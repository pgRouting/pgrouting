# SOME DESCRIPTIVE TITLE.
# Copyright (C) pgRouting Contributors - Version v4.1
# This file is distributed under the same license as the pgRouting package.
# Regina Obe <regina@arrival3d.com>, 2023.
# Wangdapeng <wangdapeng20191008@gmail.com>, 2023, 2025.
# Zuochenwei <zuochenwei5@gmail.com>, 2023, 2024, 2025.
# Celia Virginia Vergara Castillo <vicky@erosion.dev>, 2023, 2024, 2025.
# Wang Dapeng <wangdapeng20191008@gmail.com>, 2023.
# DeepL <noreply-mt-deepl@weblate.org>, 2024, 2025.
# Dapeng Wang <wangdapeng20191008@gmail.com>, 2025.
msgid ""
msgstr ""
"Project-Id-Version: pgRouting v4.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-10 19:55+0000\n"
"PO-Revision-Date: 2025-09-22 16:28+0000\n"
"Last-Translator: Celia Virginia Vergara Castillo <vicky@erosion.dev>\n"
"Language-Team: Chinese (Simplified) <https://weblate.osgeo.org/projects/pgrouting/pgrouting-develop/zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.4.3\n"

msgid "BFS - Category"
msgstr "BFS - 类别"

msgid ":doc:`pgr_kruskalBFS`"
msgstr ":doc:`pgr_kruskalBFS`"

msgid ":doc:`pgr_primBFS`"
msgstr ":doc:`pgr_primBFS`"

msgid "Traversal using breadth first search."
msgstr "使用广度优先搜索进行遍历。"

msgid "It's implementation is only on **undirected** graph."
msgstr "它的实现仅在 **无向** 图上。"

msgid "Process is done only on edges with positive costs."
msgstr "仅在具有正成本的边进行处理。"

msgid "When the graph is connected"
msgstr "当图连通时"

msgid "The resulting edges make up a tree"
msgstr "由此产生的边组成一棵树"

msgid "When the graph is not connected,"
msgstr "当图不连通时"

msgid "Finds a minimum spanning tree for each connected component."
msgstr "为每个连通分量找到最小生成树。"

msgid "The resulting edges make up a forest."
msgstr "由此产生的边构成了一片森林。"

msgid "Parameters"
msgstr "参数"

msgid "Parameter"
msgstr "参数"

msgid "Type"
msgstr "类型"

msgid "Description"
msgstr "描述"

msgid "`Edges SQL`_"
msgstr "`Edges SQL`_"

msgid "``TEXT``"
msgstr "``TEXT``"

msgid "`Edges SQL`_ as described below."
msgstr "`Edges SQL`_ 如下所述。"

msgid "**root vid**"
msgstr "**root vid**"

msgid "``BIGINT``"
msgstr "``BIGINT``"

msgid "Identifier of the root vertex of the tree."
msgstr "树的根顶点的标识符。"

msgid "When value is :math:`0` then gets the spanning forest starting in aleatory nodes for each tree in the forest."
msgstr "当值为 :math:`0` 时，则获取从森林中每棵树的随机节点开始的生成森林。"

msgid "**root vids**"
msgstr "**root vids**"

msgid "``ARRAY`` [ **ANY-INTEGER** ]"
msgstr "``ARRAY`` [ **ANY-INTEGER** ]"

msgid "Array of identifiers of the root vertices."
msgstr "根顶点的标识符数组。"

msgid ":math:`0` values are ignored"
msgstr ":math:`0` 值被忽略"

msgid "For optimization purposes, any duplicated value is ignored."
msgstr "出于优化目的，任何重复的值都将被忽略。"

msgid "Where:"
msgstr "其中："

msgid "ANY-INTEGER"
msgstr "ANY-INTEGER"

msgid "SMALLINT, INTEGER, BIGINT"
msgstr "SMALLINT, INTEGER, BIGINT"

msgid "ANY-NUMERIC"
msgstr "ANY-NUMERIC"

msgid "SMALLINT, INTEGER, BIGINT, REAL, FLOAT, NUMERIC"
msgstr "SMALLINT, INTEGER, BIGINT, REAL, FLOAT, NUMERIC"

msgid "BFS optional parameters"
msgstr "BFS可选参数"

msgid "Default"
msgstr "默认"

msgid "``max_depth``"
msgstr "``max_depth``"

msgid ":math:`9223372036854775807`"
msgstr ":math:`9223372036854775807`"

msgid "Upper limit of the depth of the tree."
msgstr "树深度的上限。"

msgid "When negative throws an error."
msgstr "为负数时抛出错误。"

msgid "Inner Queries"
msgstr "内部查询"

msgid "Edges SQL"
msgstr "Edges SQL"

msgid "Column"
msgstr "列"

msgid "``id``"
msgstr "``id``"

msgid "**ANY-INTEGER**"
msgstr "**ANY-INTEGER**"

msgid "Identifier of the edge."
msgstr "边的标识符。"

msgid "``source``"
msgstr "``source``"

msgid "Identifier of the first end point vertex of the edge."
msgstr "边的第一个端点顶点的标识符。"

msgid "``target``"
msgstr "``target``"

msgid "Identifier of the second end point vertex of the edge."
msgstr "边的第二个端点顶点的标识符。"

msgid "``cost``"
msgstr "``cost``"

msgid "**ANY-NUMERICAL**"
msgstr "**ANY-NUMERICAL**"

msgid "Weight of the edge (``source``, ``target``)"
msgstr "edge (``source``, ``target``)的权重"

msgid "``reverse_cost``"
msgstr "``reverse_cost``"

msgid "-1"
msgstr "-1"

msgid "Weight of the edge (``target``, ``source``)"
msgstr "边(``target``, ``source``)的权重"

msgid "When negative: edge (``target``, ``source``) does not exist, therefore it's not part of the graph."
msgstr "当为负时：edge (``target``, ``source``) 不存在，因此它不是图的一部分。"

msgid "``SMALLINT``, ``INTEGER``, ``BIGINT``"
msgstr "``SMALLINT``, ``INTEGER``, ``BIGINT``"

msgid "ANY-NUMERICAL"
msgstr "ANY-NUMERICAL"

msgid "``SMALLINT``, ``INTEGER``, ``BIGINT``, ``REAL``, ``FLOAT``"
msgstr "``SMALLINT``, ``INTEGER``, ``BIGINT``, ``REAL``, ``FLOAT``"

msgid "Result columns"
msgstr "结果列"

msgid "Returns set of ``(seq, depth, start_vid, node, edge, cost, agg_cost)``"
msgstr "返回一组 ``(seq, depth, start_vid, node, edge, cost, agg_cost)``"

msgid "``seq``"
msgstr "``seq``"

msgid "Sequential value starting from :math:`1`."
msgstr "从 :math:`1` 开始的顺序值。"

msgid "``depth``"
msgstr "``depth``"

msgid "Depth of the ``node``."
msgstr "``node`` 的深度。"

msgid ":math:`0` when ``node`` = ``start_vid``."
msgstr ":math:`0` 当 ``node`` = ``start_vid`` 。"

msgid "``start_vid``"
msgstr "``start_vid``"

msgid "Identifier of the root vertex."
msgstr "根顶点的标识符。"

msgid "``node``"
msgstr "``node``"

msgid "Identifier of ``node`` reached using ``edge``."
msgstr "使用 ``edge`` 到达的``node`` 的标识符。"

msgid "``edge``"
msgstr "``edge``"

msgid "Identifier of the ``edge`` used to arrive to ``node``."
msgstr "用于到达 ``node`` 的 ``edge`` 的标识符。"

msgid ":math:`-1` when ``node`` = ``start_vid``."
msgstr ":math:`-1` 当 ``node`` = ``start_vid`` 。"

msgid "``FLOAT``"
msgstr "``FLOAT``"

msgid "Cost to traverse ``edge``."
msgstr "遍历 ``edge`` 的成本。"

msgid "``agg_cost``"
msgstr "``agg_cost``"

msgid "Aggregate cost from ``start_vid`` to ``node``."
msgstr "从 ``start_vid`` 到 ``node`` 的总成本。"

msgid "See Also"
msgstr "另请参阅"

msgid "`Boost: Prim's algorithm <https://www.boost.org/libs/graph/doc/prim_minimum_spanning_tree.html>`__"
msgstr "`Boost: Prim算法 <https://www.boost.org/libs/graph/doc/prim_minimum_spanning_tree.html>`__"

msgid "`Boost: Kruskal's algorithm <https://www.boost.org/libs/graph/doc/kruskal_min_spanning_tree.html>`__"
msgstr "`Boost: Kruskal算法 <https://www.boost.org/libs/graph/doc/kruskal_min_spanning_tree.html>`__"

msgid "`Wikipedia: Prim's algorithm <https://en.wikipedia.org/wiki/Prim%27s_algorithm>`__"
msgstr "`维基百科: Prim算法 <https://en.wikipedia.org/wiki/Prim%27s_algorithm>`__"

msgid "`Wikipedia: Kruskal's algorithm <https://en.wikipedia.org/wiki/Kruskal's_algorithm>`__"
msgstr "`维基百科: Kruskal算法 <https://en.wikipedia.org/wiki/Kruskal's_algorithm>`__"

msgid "Indices and tables"
msgstr "索引和表格"

msgid ":ref:`genindex`"
msgstr ":ref:`genindex`"

msgid ":ref:`search`"
msgstr ":ref:`search`"

msgid "DFS - Category"
msgstr "DFS - 类别"

msgid "Traversal using Depth First Search."
msgstr "使用深度优先搜索进行遍历。"

msgid ":doc:`pgr_kruskalDFS`"
msgstr ":doc:`pgr_kruskalDFS`"

msgid ":doc:`pgr_primDFS`"
msgstr ":doc:`pgr_primDFS`"

#, fuzzy
msgid "Proposed"
msgstr "提议的函数。"

msgid "Proposed functions for next mayor release."
msgstr "下一版本的提议功能。"

msgid "They are not officially in the current release."
msgstr "它们并未正式出现在当前版本中。"

msgid "Code has been reviewed therefore is not experimental."
msgstr ""

#, fuzzy
msgid "Name, signature and functionality might not change."
msgstr "功能可能会改变。"

msgid "pgTap tests have being done. But might need more."
msgstr "pgTap 测试已经完成。 但可能需要更多。"

msgid "Documentation might need refinement."
msgstr "文档可能需要完善。"

msgid ":doc:`pgr_depthFirstSearch` - Depth first search traversal of the graph."
msgstr ":doc:`pgr_depthFirstSearch` - 图的深度优先搜索遍历。"

msgid "In general:"
msgstr "一般来说："

msgid "K shortest paths - Category"
msgstr "K最短路径 - 类别"

msgid ":doc:`pgr_KSP` - Yen's algorithm based on pgr_dijkstra"
msgstr ":doc:`pgr_KSP` - 基于 pgr_dijkstra 的 Yen 算法"

msgid ":doc:`pgr_withPointsKSP` - Yen's algorithm based on pgr_withPoints"
msgstr ":doc:`pgr_withPointsKSP` - 基于 pgr_withPoints 的 Yen 算法"

msgid "TRSP - Family of functions"
msgstr "TRSP - 函数族"

msgid "When points are also given as input:"
msgstr "当点也作为输入给出时："

#, fuzzy
msgid ":doc:`pgr_trsp` - Routing with restrictions."
msgstr ":doc:`pgr_turnRestrictedPath` - 有限制的路由。"

msgid ":doc:`pgr_trspVia` - Via Vertices routing with restrictions."
msgstr ":doc:`pgr_trspVia` - 有限制的通过顶点路由。"

msgid ":doc:`pgr_trsp_withPoints` - Vertex/Point routing with restrictions."
msgstr ":doc:`pgr_trsp_withPoints` - 有限制的顶点/点路由。"

msgid ":doc:`pgr_trspVia_withPoints` - Via Vertex/point routing with restrictions."
msgstr ":doc:`pgr_trspVia_withPoints` - 通过有限制的顶点/点路由。"

#, fuzzy
msgid "Experimental"
msgstr ":doc:`experimental`"

msgid "Experimental functions"
msgstr "实验性函数"

msgid "They are not officially of the current release."
msgstr "它们不是当前版本的正式版本。"

msgid "They likely will not be officially be part of the next release:"
msgstr "它们可能不会正式成为下一个版本的一部分："

msgid "The functions might not make use of ANY-INTEGER and ANY-NUMERICAL"
msgstr "这些函数可能不使用 ANY-INTEGER 和 ANY-NUMERICAL"

msgid "Name might change."
msgstr "名称可能会改变。"

msgid "Signature might change."
msgstr "签名可能会改变。"

msgid "Functionality might change."
msgstr "功能可能会改变。"

msgid "pgTap tests might be missing."
msgstr "pgTap 测试可能丢失。"

#, fuzzy
msgid "Might need c/c++ review."
msgstr "可能需要 c/c++编码。"

msgid "Documentation if any might need to be rewritten."
msgstr "文档可能需要重写。"

msgid "Might need a lot of feedback from the community."
msgstr "需要从社区获取大量反馈意见。"

msgid ":doc:`pgr_turnRestrictedPath` - Routing with restrictions."
msgstr ":doc:`pgr_turnRestrictedPath` - 有限制的路由。"

msgid "Introduction"
msgstr "介绍"

msgid "Road restrictions are a sequence of road segments that can not be taken in a sequential manner. Some restrictions are implicit on a directed graph, for example, one way roads where the wrong way edge is not even inserted on the graph. But normally on turns like no left turn or no right turn, hence the name turn restrictions, there are sometimes restrictions."
msgstr "道路限制是一系列不能按顺序采取的路段。 有向图上隐含了一些限制，例如单向道路，其中错误的边甚至不会插入到图上。 但通常在转弯时如不许左转或不许右转，因此得名转弯限制，这儿是一些常见限制。"

msgid "TRSP algorithm"
msgstr "TRSP算法"

msgid "The internal TRSP algorithm performs a lookahead over the dijkstra algorithm in order to find out if the attempted path has a restriction. This allows the algorithm to pass twice on the same vertex."
msgstr "内部 TRSP 算法对 dijkstra 算法执行前瞻，以查明尝试的路径是否有限制。 这允许算法在同一顶点上传递两次。"

msgid "`Edges SQL`_ query as described."
msgstr "`Edges SQL`_ 按描述查询。"

msgid "`Restrictions SQL`_"
msgstr "`Restrictions SQL`_"

msgid "`Restrictions SQL`_ query as described."
msgstr "`Restrictions SQL`_ 按描述查询。"

msgid "**via vertices**"
msgstr "**via vertices**"

msgid "``ARRAY[`` **ANY-INTEGER** ``]``"
msgstr "``ARRAY[`` **ANY-INTEGER** ``]``"

msgid "Array of ordered vertices identifiers that are going to be visited."
msgstr "将要访问的有序顶点标识符数组。"

msgid "Restrictions"
msgstr "限制"

msgid "On road networks, there are restrictions such as left or right turn restrictions, no U turn restrictions."
msgstr "在道路网络上，有左转或右转限制等限制，没有掉头限制。"

msgid "A restriction is a sequence of edges, called path and that path is to be avoided."
msgstr "限制是一系列边，称为路径，并且要避免该路径。"

msgid "**Restrictions on the road network**"
msgstr "**道路网络的限制**"

msgid "These restrictions are represented on a table as follows:"
msgstr "这些限制在表格中表示如下："

msgid "The table has an identifier, which maybe is needed for the administration of the restrictions, but the algorithms do not need that information. If given it will be ignored."
msgstr "该表有一个标识符，这可能是管理限制所需要的，但算法不需要该信息。 如果给出，它将被忽略。"

msgid "Restrictions SQL"
msgstr "Restrictions SQL"

msgid "``path``"
msgstr "``path``"

msgid "``ARRAY`` [**ANY-INTEGER**]"
msgstr "``ARRAY`` [**ANY-INTEGER**]"

msgid "Sequence of edge identifiers that form a path that is not allowed to be taken. - Empty arrays or ``NULL`` arrays are ignored. - Arrays that have a ``NULL`` element will raise an exception."
msgstr "形成不允许采用的路径的边缘标识符序列。 - 空数组或 ``NULL`` 数组将被忽略。 - 具有 ``NULL`` 元素的数组将引发异常。"

msgid "``Cost``"
msgstr "``Cost``"

msgid "Cost of taking the forbidden path."
msgstr "走禁路的成本。"

msgid "Traveling Sales Person - Family of functions"
msgstr "Traveling Sales Person - 函数族"

msgid ":doc:`pgr_TSP` - When input is given as matrix cell information."
msgstr ":doc:`pgr_TSP`- 当输入作为矩阵单元信息给出时。"

msgid ":doc:`pgr_TSPeuclidean` - When input are coordinates."
msgstr ":doc:`pgr_TSPeuclidean` - 当输入是坐标时。"

msgid "Table of Contents"
msgstr "目录"

msgid "General Information"
msgstr "一般信息"

msgid "Problem Definition"
msgstr "问题定义"

msgid "The travelling salesperson problem (TSP) asks the following question:"
msgstr "旅行推销员问题 (TSP) 提出以下问题："

msgid "*Given a list of cities and the distances between each pair of cities, which is the shortest possible route that visits each city exactly once and returns to the origin city?*"
msgstr "*给定一个城市列表以及每对城市之间的距离，哪条是访问每个城市一次并返回出发城市的最短路线？*"

msgid "Origin"
msgstr "起源"

msgid "The traveling sales person problem was studied in the 18th century by mathematicians **Sir William Rowam Hamilton** and **Thomas Penyngton Kirkman**."
msgstr "旅行推销员问题由数学家 **William Rowam Hamilton 爵士** 和 **Thomas Penyngton Kirkman** 于 18 世纪研究。"

msgid "A discussion about the work of Hamilton & Kirkman can be found in the book **Graph Theory (Biggs et al. 1976)**."
msgstr "关于 Hamilton 和 Kirkman 工作的讨论，可以在 **《图论》（Biggs 等，1976年）** 一书中找到。"

msgid "ISBN-13: 978-0198539162"
msgstr "ISBN-13: 978-0198539162"

msgid "ISBN-10: 0198539169"
msgstr "ISBN-10: 0198539169"

msgid "It is believed that the general form of the TSP have been first studied by Kalr Menger in Vienna and Harvard. The problem was later promoted by Hassler, Whitney & Merrill at Princeton. A detailed description about the connection between Menger & Whitney, and the development of the TSP can be found in `On the history of combinatorial optimization (till 1960) <https://homepages.cwi.nl/~lex/files/histco.ps>`__"
msgstr "人们认为旅行推销员问题（TSP）的一般形式最早由维也纳和哈佛的卡尔·门格尔（Karl Menger）研究。后来，普林斯顿的哈斯勒、惠特尼和梅里尔（Hassler, Whitney & Merrill）进一步推动了这个问题。关于门格尔和惠特尼之间的联系以及TSP的发展，可以在 `组合优化的历史(直到1960年) <https://homepages.cwi.nl/~lex/files/histco.ps>`__"

msgid "To calculate the number of different tours through :math:`n` cities:"
msgstr "计算经过 : math:`n` 城市的不同旅行次数："

msgid "Given a starting city,"
msgstr "给定一个起始城市，"

msgid "There are :math:`n-1` choices for the second city,"
msgstr "第二个城市还有 :math:`n-1` 个选择，"

msgid "And :math:`n-2` choices for the third city, etc."
msgstr "第三个城市的 :math:`n-2` 选项等。"

msgid "Multiplying these together we get :math:`(n-1)! = (n-1) (n-2) . . 1`."
msgstr "相乘得到 :math:`(n-1)！= (n-1) (n-2) ..1`."

msgid "Now since the travel costs do not depend on the direction taken around the tour:"
msgstr "现在，由于旅行成本不取决于旅行的方向："

msgid "this number by 2"
msgstr "这个数字乘2"

msgid ":math:`(n-1)!/2`."
msgstr ":math:`(n-1)!/2`."

msgid "Characteristics"
msgstr "特征"

msgid "This problem is an NP-hard optimization problem."
msgstr "该问题是一个NP-hard优化问题。"

msgid "Metric Algorithm is used"
msgstr "使用度量算法"

#, fuzzy
msgid "Implementation generates solutions that *are twice as long as the optimal tour in the worst case*:"
msgstr "*在最坏的情况下，实施产生的解决方案的时间是最佳旅行的两倍* ："

msgid "Graph characteristics for best performance:"
msgstr ""

msgid "Graph is undirected"
msgstr "图是无向的"

msgid "Graph is fully connected"
msgstr "图是全连通的"

msgid "Graph where traveling costs on edges obey the triangle inequality."
msgstr "图中，边上的旅行成本服从三角不等式。"

msgid "The traveling costs are symmetric:"
msgstr "旅行费用是对称的："

msgid "Traveling costs from ``u`` to ``v`` are just as much as traveling from ``v`` to ``u``"
msgstr "从 ``u`` 到 ``v`` 的旅行费用与从 ``v`` 到 ``u`` 的旅行费用相同"

msgid "TSP optional parameters"
msgstr "TSP 可选参数"

msgid "``start_id``"
msgstr "``start_id``"

msgid "``0``"
msgstr "``0``"

msgid "The first visiting vertex"
msgstr "第一个访问顶点"

msgid "When `0` any vertex can become the first visiting vertex."
msgstr "当 `0` 时，任何顶点都可以成为第一个访问顶点。"

msgid "``end_id``"
msgstr "``end_id``"

msgid "Last visiting vertex before returning to ``start_vid``."
msgstr "返回 ``start_vid`` 之前最后访问的顶点。"

msgid "When ``0`` any vertex can become the last visiting vertex before returning to ``start_id``."
msgstr "当为 ``0`` 时，任何顶点都可以成为返回 ``start_id`` 之前最后访问的顶点。"

msgid "When ``NOT 0`` and ``start_id = 0`` then it is the first and last vertex"
msgstr "当 ``NOT 0`` 且 ``start_id = 0`` 时，它是第一个和最后一个顶点"

msgid "References"
msgstr "参考"

msgid "`Boost: metric TSP approx <https://www.boost.org/libs/graph/doc/metric_tsp_approx.html>`__"
msgstr "`Boost: 度量旅行商问题近似算法 <https://www.boost.org/libs/graph/doc/metric_tsp_approx.html>`__"

msgid "`University of Waterloo TSP <https://www.math.uwaterloo.ca/tsp/>`__"
msgstr "`滑铁卢大学TSP研究 <https://www.math.uwaterloo.ca/tsp/>`__"

msgid "`Wikipedia: Traveling Salesman Problem <https://en.wikipedia.org/wiki/Traveling_salesman_problem>`__"
msgstr "`维基百科：旅行商问题 <https://en.wikipedia.org/wiki/Traveling_salesman_problem>`__"

msgid "Vehicle Routing Functions - Category"
msgstr "车辆路径规划函数 - 分类"

msgid "Pickup and delivery problem"
msgstr "取货和送货问题"

msgid ":doc:`pgr_pickDeliver` - Pickup & Delivery using a Cost Matrix"
msgstr ":doc:`pgr_pickDeliver` - 使用成本矩阵的取货&送货"

msgid ":doc:`pgr_pickDeliverEuclidean` - Pickup & Delivery with Euclidean distances"
msgstr ":doc:`pgr_pickDeliverEuclidean` - 使用欧几里得距离的取货&送货"

msgid "Distribution problem"
msgstr "分配问题"

msgid ":doc:`pgr_vrpOneDepot` - From a single depot, distributes orders"
msgstr ":doc:`pgr_vrpOneDepot` - 从单个仓库分发订单"

msgid "Contents"
msgstr "内容"

msgid "Vehicle Routing Problems `VRP` are **NP-hard** optimization problem, it generalises the travelling salesman problem (TSP)."
msgstr "车辆路径问题 `VRP` 是 **NP-hard** 优化问题，它推广了旅行商问题 (TSP)。"

msgid "The objective of the VRP is to minimize the total route cost."
msgstr "VRP 的目标是最小化总路由成本。"

msgid "There are several variants of the VRP problem,"
msgstr "VRP 问题有多种变体，"

msgid "**pgRouting does not try to implement all variants.**"
msgstr "**pgRouting 并不尝试实现所有变体。**"

msgid "Capacitated Vehicle Routing Problem `CVRP` where The vehicles have limited carrying capacity of the goods."
msgstr "容量车辆路径问题 `CVRP` 其中车辆的货物承载能力有限。"

msgid "Vehicle Routing Problem with Time Windows `VRPTW` where the locations have time windows within which the vehicle's visits must be made."
msgstr "具有时间窗口的车辆路由问题 `VRPTW`，其中位置具有车辆必须访问的时间窗口。"

msgid "Vehicle Routing Problem with Pickup and Delivery `VRPPD` where a number of goods need to be moved from certain pickup locations to other delivery locations."
msgstr "取货和送货的车辆路径问题 `VRPPD` ，其中大量货物需要从某些取货地点移动到其他送货地点。"

msgid "Limitations"
msgstr "局限性"

msgid "No multiple time windows for a location."
msgstr "一个位置没有多个时间窗口。"

msgid "Less vehicle used is considered better."
msgstr "使用的车辆越少越好。"

msgid "Less total duration is better."
msgstr "总持续时间越短越好。"

msgid "Less wait time is better."
msgstr "等待时间越短越好。"

msgid "Pick & Delivery"
msgstr "取货 & 送货"

msgid "Problem: `CVRPPDTW` Capacitated Pick and Delivery Vehicle Routing problem with Time Windows"
msgstr "问题： `CVRPPDTW` 具有时间窗口的有能力分拣和送货车辆路径问题"

msgid "Times are relative to `0`"
msgstr "时间是相对于 `0` 的"

msgid "The vehicles"
msgstr "车辆"

msgid "have start and ending service duration times."
msgstr "有开始和结束服务持续时间。"

msgid "have opening and closing times for the start and ending locations."
msgstr "有开始和结束地点的开放和关闭时间。"

msgid "have a capacity."
msgstr "具有容量。"

msgid "The orders"
msgstr "订单"

msgid "Have pick up and delivery locations."
msgstr "有提货和送货地点。"

msgid "Have opening and closing times for the pickup and delivery locations."
msgstr "有提货和送货地点的开放和关闭时间。"

msgid "Have pickup and delivery duration service times."
msgstr "有取货和送货持续时间的服务时间。"

msgid "have a demand request for moving goods from the pickup location to the delivery location."
msgstr "有将货物从取货地点移动到交货地点的需求请求。"

msgid "Time based calculations:"
msgstr "基于时间的计算："

msgid "Travel time between customers is :math:`distance / speed`"
msgstr "客户之间的旅行时间为 :math:`distance / speed`"

msgid "Pickup and delivery order pair is done by the same vehicle."
msgstr "取货和送货订单对由同一辆车完成。"

msgid "A pickup is done before the delivery."
msgstr "送货前会进行取货。"

msgid "Pick & deliver"
msgstr "取货 & 送货"

msgid "Used in :doc:`pgr_pickDeliverEuclidean`"
msgstr "用于 :doc:`pgr_pickDeliverEuclidean`"

msgid "`Orders SQL`_"
msgstr "`Orders SQL`_"

msgid "`Orders SQL`_ as described below."
msgstr "`Orders SQL`_ 如下所述。"

msgid "`Vehicles SQL`_"
msgstr "`Vehicles SQL`_"

msgid "`Vehicles SQL`_ as described below."
msgstr "`Vehicles SQL`_ 如下所述。"

msgid "Used in :doc:`pgr_pickDeliver`"
msgstr "用于 :doc:`pgr_pickDeliver`"

msgid "`Matrix SQL`_"
msgstr "`Matrix SQL`_"

msgid "`Matrix SQL`_ as described below."
msgstr "`Matrix SQL`_ 如下所述。"

msgid "Pick-Deliver optional parameters"
msgstr "取货-送货可选参数"

msgid "``factor``"
msgstr "``factor``"

msgid "``NUMERIC``"
msgstr "``NUMERIC``"

msgid "1"
msgstr "1"

msgid "Travel time multiplier. See :ref:`pd_factor`"
msgstr "旅行时间乘数。 请参阅 :ref:`pd_factor`"

msgid "``max_cycles``"
msgstr "``max_cycles``"

msgid "``INTEGER``"
msgstr "``INTEGER``"

msgid "10"
msgstr "10"

msgid "Maximum number of cycles to perform on the optimization."
msgstr "执行优化的最大周期数。"

msgid "``initial_sol``"
msgstr "``initial_sol``"

msgid "4"
msgstr "4"

msgid "Initial solution to be used."
msgstr "要使用的初始解决方案。"

msgid "``1`` One order per truck"
msgstr "``1`` 每辆卡车一份订单"

msgid "``2`` Push front order."
msgstr "``2`` 提前订单。"

msgid "``3`` Push back order."
msgstr "``3`` 推迟订单。"

msgid "``4`` Optimize insert."
msgstr "``4`` 优化插入。"

msgid "``5`` Push back order that allows more orders to be inserted at the back"
msgstr "``5`` 推迟订单，允许在后面插入更多订单"

msgid "``6`` Push front order that allows more orders to be inserted at the front"
msgstr "``6`` 提前订单，允许在前面插入更多订单"

msgid "Orders SQL"
msgstr "订单 SQL"

msgid "Common columns for the orders SQL in both implementations:"
msgstr "两种实现中订单 SQL 的公共列："

msgid "|ANY-INTEGER|"
msgstr "|ANY-INTEGER|"

msgid "Identifier of the pick-delivery order pair."
msgstr "提货-交货订单对的标识符。"

msgid "``demand``"
msgstr "``demand``"

msgid "|ANY-NUMERICAL|"
msgstr "|ANY-NUMERICAL|"

msgid "Number of units in the order"
msgstr "订单中的单位数量"

msgid "``p_open``"
msgstr "``p_open``"

msgid "The time, relative to 0, when the pickup location opens."
msgstr "相对于0的时间，提货地点开放。"

msgid "``p_close``"
msgstr "``p_close``"

msgid "The time, relative to 0, when the pickup location closes."
msgstr "提货地点关闭的时间（相对于 0）。"

msgid "[``p_service``]"
msgstr "[``p_service``]"

msgid "The duration of the loading at the pickup location."
msgstr "在取货地点装载的持续时间。"

msgid "When missing: 0 time units are used"
msgstr "缺失时：使用 0 个时间单位"

msgid "``d_open``"
msgstr "``d_open``"

msgid "The time, relative to 0, when the delivery location opens."
msgstr "交货地点开放的时间（相对于 0）。"

msgid "``d_close``"
msgstr "``d_close``"

msgid "The time, relative to 0, when the delivery location closes."
msgstr "交货地点关闭的时间（相对于 0）。"

msgid "[``d_service``]"
msgstr "[``d_service``]"

msgid "The duration of the unloading at the delivery location."
msgstr "在交货地点卸货的持续时间。"

msgid "For :doc:`pgr_pickDeliver` the pickup and delivery identifiers of the locations are needed:"
msgstr "对于 :doc:`pgr_pickDeliver` ，需要位置的取货和送货标识符："

msgid "``p_node_id``"
msgstr "``p_node_id``"

msgid "The node identifier of the pickup, must match a vertex identifier in the `Matrix SQL`_."
msgstr "取货的节点标识符必须与 `Matrix SQL`_ 中的顶点标识符匹配。"

msgid "``d_node_id``"
msgstr "``d_node_id``"

msgid "The node identifier of the delivery, must match a vertex identifier in the `Matrix SQL`_."
msgstr "送货的节点标识符必须与 `Matrix SQL`_ 中的顶点标识符匹配。"

msgid "For :doc:`pgr_pickDeliverEuclidean` the :math:`(x, y)` values of the locations are needed:"
msgstr "对于 :doc:`pgr_pickDeliverEuclidean` ，这需要位置的 :math:`(x, y)` 值："

msgid "``p_x``"
msgstr "``p_x``"

msgid ":math:`x` value of the pick up location"
msgstr "取货地点的 :math:`x` 值"

msgid "``p_y``"
msgstr "``p_y``"

msgid ":math:`y` value of the pick up location"
msgstr "取货地点的 :math:`y` 值"

msgid "``d_x``"
msgstr "``d_x``"

msgid ":math:`x` value of the delivery location"
msgstr "送货地点的 :math:`x` 值"

msgid "``d_y``"
msgstr "``d_y``"

msgid ":math:`y` value of the delivery location"
msgstr "送货地点的 :math:`y` 值"

msgid "Vehicles SQL"
msgstr "车辆 SQL"

msgid "Common columns for the vehicles SQL in both implementations:"
msgstr "两种实现中车辆 SQL 的公共列："

msgid "Identifier of the vehicle."
msgstr "车辆的标识符。"

msgid "``capacity``"
msgstr "``capacity``"

msgid "Maiximum capacity units"
msgstr "最大容量单位"

msgid "``start_open``"
msgstr "``start_open``"

msgid "The time, relative to 0, when the starting location opens."
msgstr "起始位置打开的时间（相对于 0）。"

msgid "``start_close``"
msgstr "``start_close``"

msgid "The time, relative to 0, when the starting location closes."
msgstr "起始位置关闭的时间（相对于 0）。"

msgid "[``start_service``]"
msgstr "[``start_service``]"

msgid "The duration of the loading at the starting location."
msgstr "在起始位置加载的持续时间。"

msgid "When missing: A duration of :math:`0` time units is used."
msgstr "缺失时：使用 :math:`0` 个时间单位的持续时间。"

msgid "[``end_open``]"
msgstr "[``end_open``]"

msgid "The time, relative to 0, when the ending location opens."
msgstr "结束位置打开的时间（相对于 0）。"

msgid "When missing: The value of ``start_open`` is used"
msgstr "缺失时：使用 ``start_open`` 的值"

msgid "[``end_close``]"
msgstr "[``end_close``]"

msgid "The time, relative to 0, when the ending location closes."
msgstr "结束位置关闭的时间（相对于 0）。"

msgid "When missing: The value of ``start_close`` is used"
msgstr "缺失时：使用 ``start_close`` 的值"

msgid "[``end_service``]"
msgstr "[``end_service``]"

msgid "The duration of the loading at the ending location."
msgstr "在结束位置加载的持续时间。"

msgid "When missing: A duration in ``start_service`` is used."
msgstr "缺失时：使用 ``start_service`` 中的持续时间。"

msgid "For :doc:`pgr_pickDeliver` the starting and ending identifiers of the locations are needed:"
msgstr "对于 :doc:`pgr_pickDeliver` ，需要位置的开始和结束标识符："

msgid "``start_node_id``"
msgstr "``start_node_id``"

msgid "The node identifier of the start location, must match a vertex identifier in the `Matrix SQL`_."
msgstr "起始位置的节点标识符必须与 `Matrix SQL`_ 中的顶点标识符匹配。"

msgid "[``end_node_id``]"
msgstr "[``end_node_id``]"

msgid "The node identifier of the end location, must match a vertex identifier in the `Matrix SQL`_."
msgstr "结束位置的节点标识符必须与 `Matrix SQL`_ 中的顶点标识符匹配。"

msgid "When missing: ``end_node_id`` is used."
msgstr "缺少时：使用 ``end_node_id`` 。"

msgid "``start_x``"
msgstr "``start_x``"

msgid ":math:`x` value of the starting location"
msgstr "起始位置的 :math:`x` 值"

msgid "``start_y``"
msgstr "``start_y``"

msgid ":math:`y` value of the starting location"
msgstr "起始位置的 :math:`y` 值"

msgid "[``end_x``]"
msgstr "[``end_x``]"

msgid ":math:`x` value of the ending location"
msgstr "结束位置的 :math:`x` 值"

msgid "When missing: ``start_x`` is used."
msgstr "缺失时：使用 ``start_x`` 值。"

msgid "[``end_y``]"
msgstr "[``end_y``]"

msgid ":math:`y` value of the ending location"
msgstr "结束位置的 :math:`y` 值"

msgid "When missing: ``start_y`` is used."
msgstr "缺失时：使用 ``start_y`` 值。"

msgid "Matrix SQL"
msgstr "矩阵SQL"

msgid "Set of |matrix-result|"
msgstr "|matrix-result| 的集合"

msgid "Identifier of the starting vertex."
msgstr "起始顶点的标识符。"

msgid "``end_vid``"
msgstr "``end_vid``"

msgid "Identifier of the ending vertex."
msgstr "结束顶点的标识符。"

msgid "Aggregate cost from ``start_vid`` to ``end_vid``."
msgstr "从 ``start_vid`` 到 ``end_vid`` 的总成本。"

msgid "Sequential value starting from **1**."
msgstr "从 **1** 开始的顺序值。"

msgid "``vehicle_seq``"
msgstr "``vehicle_seq``"

msgid "Sequential value starting from **1** for current vehicles. The :math:`n_{th}` vehicle in the solution."
msgstr "当前车辆从 **1** 开始的顺序值。 解决方案中的第 :math:`n_{th}` 辆车。"

msgid "Value :math:`-2` indicates it is the summary row."
msgstr "值 :math:`-2` 表示它是汇总行。"

msgid "``vehicle_id``"
msgstr "``vehicle_id``"

msgid "BIGINT"
msgstr "BIGINT"

msgid "Current vehicle identifier."
msgstr "当前车辆标识符。"

msgid "Summary row has the **total capacity violations**."
msgstr "摘要行显示 **违规数总容量** 。"

msgid "A capacity violation happens when overloading or underloading a vehicle."
msgstr "当车辆超载或欠载时，就会发生容量违规。"

msgid "``stop_seq``"
msgstr "``stop_seq``"

msgid "INTEGER"
msgstr "INTEGER"

msgid "Sequential value starting from **1** for the stops made by the current vehicle. The :math:`m_{th}` stop of the current vehicle."
msgstr "当前车辆停止的顺序值，从 **1** 开始。 当前第 :math:`m_{th}` 车辆的停止。"

msgid "Summary row has the **total time windows violations**."
msgstr "摘要行有 **违规时间窗口总数** 。"

msgid "A time window violation happens when arriving after the location has closed."
msgstr "在该地点关闭后到达时，会发生时间窗口违规。"

msgid "``stop_type``"
msgstr "``stop_type``"

msgid "Kind of stop location the vehicle is at"
msgstr "车辆所在的停车位置类型"

msgid ":math:`-1`: at the solution summary row"
msgstr ":math:`-1`: 在解决方案摘要行"

msgid ":math:`1`: Starting location"
msgstr ":math:`1`: 起始位置"

msgid ":math:`2`: Pickup location"
msgstr ":math:`2`: 取货位置"

msgid ":math:`3`: Delivery location"
msgstr ":math:`3`: 送货位置"

msgid ":math:`6`: Ending location and indicates the vehicle's summary row"
msgstr ":math:`6`: 结束位置并指示车辆的摘要行"

msgid "``order_id``"
msgstr "``order_id``"

msgid "Pickup-Delivery order pair identifier."
msgstr "取货-送货订单对标识符。"

msgid "Value :math:`-1`: When no order is involved on the current stop location."
msgstr "值 :math:`-1`: 当前停留位置没有订单参与。"

msgid "``cargo``"
msgstr "``cargo``"

msgid "Cargo units of the vehicle when leaving the stop."
msgstr "车辆离开停车点时的货物单位。"

msgid "Value :math:`-1` on solution summary row."
msgstr "值 :math:`-1` 在解决方案摘要行。"

msgid "``travel_time``"
msgstr "``travel_time``"

msgid "Travel time from previous ``stop_seq`` to current ``stop_seq``."
msgstr "从前一个 ``stop_seq`` 到当前 ``stop_seq`` 的行程时间。"

msgid "Summary has the **total traveling time**:"
msgstr "总结一下 **总的行程时间** ："

msgid "The sum of all the ``travel_time``."
msgstr "所有 ``travel_time`` 的总和。"

msgid "``arrival_time``"
msgstr "``arrival_time``"

msgid "Time spent waiting for current location to open."
msgstr "等待当前位置打开所花费的时间。"

msgid ":math:`-1`: at the solution summary row."
msgstr ":math:`-1`: 在解决方案摘要行。"

msgid ":math:`0`: at the starting location."
msgstr ":math:`0`: 在起始位置。"

msgid "``wait_time``"
msgstr "``wait_time``"

msgid "Summary row has the **total waiting time**:"
msgstr "摘要行包含 **总等待时间** ："

msgid "The sum of all the ``wait_time``."
msgstr "所有 ``wait_time`` 的总和。"

msgid "``service_time``"
msgstr "``service_time``"

msgid "Service duration at current location."
msgstr "当前位置的服务持续时间。"

msgid "Summary row has the **total service time**:"
msgstr "摘要行包含 **总服务时间** ："

msgid "The sum of all the ``service_time``."
msgstr "所有 ``service_time`` 的总和。"

msgid "``departure_time``"
msgstr "``departure_time``"

msgid "The time at which the vehicle departs from the stop."
msgstr "车辆离开车站的时间。"

msgid ":math:`arrival\\_time + wait\\_time + service\\_time`."
msgstr ":math:`arrival\\_time + wait\\_time + service\\_time`。"

msgid "The ending location has the **total time** used by the current vehicle."
msgstr "结束位置有当前车辆使用的 **总时间** 。"

msgid "Summary row has the **total solution time**:"
msgstr "摘要行包含 **总解决问题时间** ："

msgid ":math:`total\\ traveling\\ time + total\\ waiting\\ time + total\\ service\\ time`."
msgstr ":math:`total\\ traveling\\ time + total\\ waiting\\ time + total\\ service\\ time`。"

msgid "Summary Row"
msgstr "摘要行"

msgid "Continues the sequence"
msgstr "继续序列"

msgid "**total capacity violations**:"
msgstr "**总容量违规** ："

msgid "**total time windows violations**:"
msgstr "**总时间窗口违规** ："

msgid ":math:`-1`"
msgstr ":math:`-1`"

msgid "**total traveling time**:"
msgstr "**总行程时间** ："

msgid "**total waiting time**:"
msgstr "**总行程时间** ："

msgid "**total service time**:"
msgstr "**总服务时间** ："

msgid "Handling Parameters"
msgstr "处理参数"

msgid "To define a problem, several considerations have to be done, to get consistent results. This section gives an insight of how parameters are to be considered."
msgstr "要定义问题，必须考虑多种因素才能获得一致的结果。 本节深入了解如何考虑参数。"

msgid "`Capacity and Demand Units Handling`_"
msgstr "`容量和需求单位处理`_"

msgid "`Locations`_"
msgstr "`位置`_"

msgid "`Time Handling`_"
msgstr "`时间处理`_"

msgid "`Factor Handling`_"
msgstr "`因素处理`_"

msgid "Capacity and Demand Units Handling"
msgstr "容量和需求单位处理"

msgid "The `capacity` of a vehicle, can be measured in:"
msgstr "车辆的`容量`可以通过以下方式测量："

msgid "Volume units like :math:`m^3`."
msgstr "体积单位如 :math:`m^3` 。"

msgid "Area units like :math:`m^2` (when no stacking is allowed)."
msgstr "面积单位如 : math:`m^2` （不允许堆叠时）。"

msgid "Weight units like :math:`kg`."
msgstr "重量单位如 :math:`kg` 。"

msgid "Number of boxes that fit in the vehicle."
msgstr "车辆内可容纳的箱子数量。"

msgid "Number of seats in the vehicle"
msgstr "车内座位数"

msgid "The `demand` request of the pickup-deliver orders must use the same units as the units used in the vehicle's `capacity`."
msgstr "取货-送货订单的 `需求` 请求必须使用与车辆 `容量` 中使用的单位相同的单位。"

msgid "To handle problems like: 10 (equal dimension) boxes of apples and 5 kg of feathers that are to be transported (not packed in boxes)."
msgstr "处理以下问题：10 箱（尺寸相等）苹果和 5 千克羽毛的运输（不装箱）。"

msgid "If the vehicle's **capacity** is measured in `boxes`, a conversion of `kg of feathers` to `number of boxes` is needed."
msgstr "如果车辆的 **容量** 以 `箱子` 来衡量，则需要将 `羽毛的千克` 换算为 `箱子的数量`。"

msgid "If the vehicle's **capacity** is measured in `kg`, a conversion of `box of apples` to `kg` is needed."
msgstr "如果车辆的 **容量** 以 `kg` 为单位，则需要将 `一箱苹果` 换算为 `kg` 。"

msgid "Showing how the 2 possible conversions can be done"
msgstr "显示如何完成两种可能的转换"

msgid "Let: - :math:`f\\_boxes`: number of boxes needed for `1` kg of feathers. - :math:`a\\_weight`: weight of `1` box of apples."
msgstr "设：- :math:`f\\_boxes`： `1` 公斤羽毛所需的箱子数量。- :math:`a\\_weight`： `1` 箱子苹果的重量。"

msgid "Capacity Units"
msgstr "容量单位"

msgid "apples"
msgstr "苹果"

msgid "feathers"
msgstr "羽毛"

msgid "boxes"
msgstr "箱子"

msgid ":math:`5 * f\\_boxes`"
msgstr ":math:`5 * f\\_boxes`"

msgid "kg"
msgstr "千克"

msgid ":math:`10 * a\\_weight`"
msgstr ":math:`10 * a\\_weight`"

msgid "5"
msgstr "5"

msgid "Locations"
msgstr "位置"

msgid "When using :doc:`pgr_pickDeliverEuclidean`:"
msgstr "当使用 :doc:`pgr_pickDeliverEuclidean` ："

msgid "The vehicles have :math:`(x, y)` pairs for start and ending locations."
msgstr "车辆有起点和终点 :math:`(x, y)` 对。"

msgid "The orders Have :math:`(x, y)` pairs for pickup and delivery locations."
msgstr "订单有取货和送货地点 :math:`(x, y)` 对。"

msgid "When using :doc:`pgr_pickDeliver`:"
msgstr "当使用 :doc:`pgr_pickDeliver`:"

msgid "The vehicles have identifiers for the start and ending locations."
msgstr "车辆具有起始位置和结束位置的标识符。"

msgid "The orders have identifiers for the pickup and delivery locations."
msgstr "订单具有取货和送货地点的标识符。"

msgid "All the identifiers are indices to the given matrix."
msgstr "所有标识符都是给定矩阵的索引。"

msgid "Time Handling"
msgstr "时间处理"

msgid "The times are relative to **0**. All time units have to be converted to a **0** reference and the same time units."
msgstr "时间是相对于 **0** 的。所有时间单位都必须转换为 **0** 参考和相同的时间单位。"

msgid "Suppose that a vehicle's driver starts the shift at 9:00 am and ends the shift at 4:30 pm and the service time duration is 10 minutes with 30 seconds."
msgstr "假设车辆驾驶员上午 9:00 开始换班，下午 4:30 结束换班，服务时间为 10 分钟 30 秒。"

msgid "Meaning of 0"
msgstr "0的含义"

msgid "time units"
msgstr "时间单位"

msgid "9:00 am"
msgstr "9:00 am"

msgid "4:30 pm"
msgstr "4:30 pm"

msgid "10 min 30 secs"
msgstr "10 min 30 secs"

msgid "0:00 am"
msgstr "0:00 am"

msgid "hours"
msgstr "小时"

msgid "9"
msgstr "9"

msgid "16.5"
msgstr "16.5"

msgid ":math:`10.5 / 60 = 0.175`"
msgstr ":math:`10.5 / 60 = 0.175`"

msgid "minutes"
msgstr "分钟"

msgid ":math:`9*60 = 54`"
msgstr ":math:`9*60 = 54`"

msgid ":math:`16.5*60 = 990`"
msgstr ":math:`16.5*60 = 990`"

msgid "10.5"
msgstr "10.5"

msgid "0"
msgstr "0"

msgid "7.5"
msgstr "7.5"

msgid ":math:`7.5*60 = 540`"
msgstr ":math:`7.5*60 = 540`"

msgid "Factor handling"
msgstr "因素处理"

msgid "``factor`` acts as a multiplier to convert from distance values to time units the matrix values or the euclidean values."
msgstr "``因子`` 充当乘数，将距离值转换为时间单位、矩阵值或欧几里得值。"

msgid "When the values are already in the desired time units"
msgstr "当值已处于所需时间单位时"

msgid "``factor`` should be **1**"
msgstr "``因数`` 应为 **1**"

msgid "When ``factor`` > 1 the travel times are faster"
msgstr "当 ``因子`` > 1 时，行程时间更快"

msgid "When ``factor`` < 1 the travel times are slower"
msgstr "当 ``因子`` < 1 时，行程时间会变慢"

msgid "For the :doc:`pgr_pickDeliverEuclidean`:"
msgstr "用于 :doc:`pgr_pickDeliverEuclidean`:"

msgid "Working with time units in seconds, and x/y in lat/lon: Factor: would depend on the location of the points and on the average velocity say 25m/s is the velocity."
msgstr "使用以秒为单位的时间单位，以及以纬度/经度为单位的 x/y： 因子：取决于点的位置和平均速度，例如 25m/s 是速度。"

msgid "Latitude"
msgstr "纬度"

msgid "Conversion"
msgstr "转换"

msgid "Factor"
msgstr "因素"

msgid "45"
msgstr "45"

msgid "1 longitude degree is (78846.81m)/(25m/s)"
msgstr "1经度为(78846.81m)/(25m/s)"

msgid "3153 s"
msgstr "3153 s"

msgid "1 longitude degree is (111319.46 m)/(25m/s)"
msgstr "1经度为(111319.46 m)/(25m/s)"

msgid "4452 s"
msgstr "4452 s"

msgid "For the :doc:`pgr_pickDeliver`:"
msgstr "用于 :doc:`pgr_pickDeliver`:"

msgid "Given :math:`v = d / t` therefore :math:`t = d / v` And the ``factor`` becomes :math:`1 / v`"
msgstr "给定 :math:`v = d / t` 因此 :math:`t = d / v` 并且 ``因子`` 变为 :math:`1 / v`"

msgid "v"
msgstr "v"

msgid "Velocity"
msgstr "速度"

msgid "d"
msgstr "d"

msgid "Distance"
msgstr "距离"

msgid "t"
msgstr "t"

msgid "Time"
msgstr "时间"

msgid "For the following equivalences :math:`10m/s \\approx 600m/min \\approx 36 km/hr`"
msgstr "对于以下等价 :math:`10m/s \\approx 600m/min \\approx 36 km/hr`"

msgid "Working with time units in seconds and the matrix been in meters: For a 1000m length value on the matrix:"
msgstr "处理时间单位（秒）与距离矩阵（米）的换算：当矩阵中长度为 1000 米时："

msgid "Units"
msgstr "单位"

msgid "velocity"
msgstr "速度"

msgid "Result"
msgstr "结果"

msgid "seconds"
msgstr "秒"

msgid ":math:`10 m/s`"
msgstr ":math:`10 m/s`"

msgid ":math:`\\frac{1}{10m/s}`"
msgstr ":math:`\\frac{1}{10m/s}`"

msgid ":math:`0.1s/m`"
msgstr ":math:`0.1s/m`"

msgid ":math:`1000m * 0.1s/m = 100s`"
msgstr ":math:`1000m * 0.1s/m = 100s`"

msgid ":math:`600 m/min`"
msgstr ":math:`600 m/min`"

msgid ":math:`\\frac{1}{600m/min}`"
msgstr ":math:`\\frac{1}{600m/min}`"

msgid ":math:`0.0016min/m`"
msgstr ":math:`0.0016min/m`"

msgid ":math:`1000m * 0.0016min/m = 1.6min`"
msgstr ":math:`1000m * 0.0016min/m = 1.6min`"

msgid "Hours"
msgstr "小时"

msgid ":math:`36 km/hr`"
msgstr ":math:`36 km/hr`"

msgid ":math:`\\frac{1}{36 km/hr}`"
msgstr ":math:`\\frac{1}{36 km/hr}`"

msgid ":math:`0.0277hr/km`"
msgstr ":math:`0.0277hr/km`"

msgid ":math:`1km * 0.0277hr/km = 0.0277hr`"
msgstr ":math:`1km * 0.0277hr/km = 0.0277hr`"

msgid "https://en.wikipedia.org/wiki/Vehicle_routing_problem"
msgstr "https://en.wikipedia.org/wiki/Vehicle_routing_problem"

msgid ":doc:`sampledata`"
msgstr ":doc:`sampledata`"

msgid "A* - Family of functions"
msgstr "A* - 函数族"

msgid "The A* (pronounced \"A Star\") algorithm is based on Dijkstra's algorithm with a heuristic that allow it to solve most shortest path problems by evaluation only a sub-set of the overall graph."
msgstr "A*（发音为“A星”）算法基于 Dijkstra 算法，其启发式算法使其能够通过仅评估整个图的子集来解决大多数最短路径问题。"

msgid ":doc:`pgr_aStar` - A* algorithm for the shortest path."
msgstr ":doc:`pgr_aStar` - A* 最短路径算法。"

msgid ":doc:`pgr_aStarCost` - Get the aggregate cost of the shortest paths."
msgstr ":doc:`pgr_aStarCost` - 获取最短路径的总成本。"

msgid ":doc:`pgr_aStarCostMatrix` - Get the cost matrix of the shortest paths."
msgstr ":doc:`pgr_aStarCostMatrix` - 获取最短路径的成本矩阵。"

msgid "The main Characteristics are:"
msgstr "主要特点是："

msgid "Process works for directed and undirected graphs."
msgstr "流程适用于有向图和无向图。"

msgid "Ordering is:"
msgstr "顺序是："

msgid "first by ``start_vid`` (if exists)"
msgstr "首先按 ``start_vid`` （如果存在）"

msgid "then by ``end_vid``"
msgstr "然后按 ``end_vid``"

msgid "Values are returned when there is a path."
msgstr "当存在路径时返回值。"

msgid "Let :math:`v` and :math:`u` be nodes on the graph:"
msgstr "设 :math:`v` 和 :math:`u` 为图上的节点："

msgid "If there is no path from :math:`v` to :math:`u`:"
msgstr "如果没有从 :math:`v` 到 :math:`u` 的路径："

msgid "no corresponding row is returned"
msgstr "没有返回对应的行"

msgid "``agg_cost`` from :math:`v` to :math:`u` is :math:`\\infty`"
msgstr "从 :math:`v` 到 :math:`u` 的 ``agg_cost`` 是 :math:`\\infty`"

msgid "There is no path when :math:`v = u` therefore"
msgstr "当 :math:`v = u` 没有路径，因此"

msgid "``agg_cost`` from `v` to `u` is :math:`0`"
msgstr "从 `v` 到 `u` 的 ``agg_cost`` 是 :math:`0`"

msgid "When :math:`(x,y)` coordinates for the same vertex identifier differ:"
msgstr "当同一顶点标识符的 :math:`(x,y)` 坐标不同时："

msgid "A random selection of the vertex's :math:`(x,y)` coordinates is used."
msgstr "使用随机选择的顶点的 :math:`(x,y)` 坐标。"

msgid "Running time: :math:`O((E + V) * \\log V)`"
msgstr "运行时间： :math:`O((E + V) * \\log V)`"

msgid "aStar optional parameters"
msgstr "aStar 可选参数"

msgid "``heuristic``"
msgstr "``heuristic``"

msgid "Heuristic number. Current valid values 0~5."
msgstr "Heuristic 数字。当前有效值0~5。"

msgid "0: :math:`h(v) = 0` (Use this value to compare with pgr_dijkstra)"
msgstr "0: :math:`h(v) = 0` (使用该值与 pgr_dijkstra 进行比较)"

msgid "1: :math:`h(v) = abs(max(\\Delta x, \\Delta y))`"
msgstr "1: :math:`h(v) = abs(max(\\Delta x, \\Delta y))`"

msgid "2: :math:`h(v) = abs(min(\\Delta x, \\Delta y))`"
msgstr "2: :math:`h(v) = abs(min(\\Delta x, \\Delta y))`"

msgid "3: :math:`h(v) = \\Delta x * \\Delta x + \\Delta y * \\Delta y`"
msgstr "3: :math:`h(v) = \\Delta x * \\Delta x + \\Delta y * \\Delta y`"

msgid "4: :math:`h(v) = sqrt(\\Delta x * \\Delta x + \\Delta y * \\Delta y)`"
msgstr "4: :math:`h(v) = sqrt(\\Delta x * \\Delta x + \\Delta y * \\Delta y)`"

msgid "5: :math:`h(v) = abs(\\Delta x) + abs(\\Delta y)`"
msgstr "5: :math:`h(v) = abs(\\Delta x) + abs(\\Delta y)`"

msgid "``1``"
msgstr "``1``"

msgid "For units manipulation. :math:`factor > 0`."
msgstr "对于单位操作。 :math:`factor > 0`。"

msgid "``epsilon``"
msgstr "``epsilon``"

msgid "For less restricted results. :math:`epsilon >= 1`."
msgstr "对于限制较少的结果。 :math:`epsilon >= 1` 。"

msgid "See :ref:`heuristics <astar_heuristics>` available and :ref:`factor <astar_factor>` handling."
msgstr "查看可用的 :ref:`heuristics <astar_heuristics>` 和 :ref:`factor <astar_factor>` 处理。"

msgid "Advanced documentation"
msgstr "高级文档"

msgid "Heuristic"
msgstr "Heuristic"

msgid "Currently the heuristic functions available are:"
msgstr "目前可用的heuristic函数有："

msgid "where :math:`\\Delta x = x_1 - x_0` and :math:`\\Delta y = y_1 - y_0`"
msgstr "其中 :math:`\\Delta x = x_1 - x_0` 和 :math:`\\Delta y = y_1 - y_0`"

msgid "Analysis 1"
msgstr "分析1"

msgid "Working with cost/reverse_cost as length in degrees, x/y in lat/lon: Factor = 1 (no need to change units)"
msgstr "使用 cost/reverse_cost 作为长度（以度为单位），x/y 以纬度/经度为单位：因子 = 1（无需更改单位）"

msgid "Analysis 2"
msgstr "分析2"

msgid "Working with cost/reverse_cost as length in meters, x/y in lat/lon: Factor = would depend on the location of the points:"
msgstr "使用 cost/reverse_cost 作为以米为单位的长度，以纬度/经度为单位的 x/y： Factor = 将取决于点的位置："

msgid "1 longitude degree is 78846.81 m"
msgstr "1 经度为 78846.81 米"

msgid "78846"
msgstr "78846"

msgid "1 longitude degree is 111319.46 m"
msgstr "1经度为111319.46 m"

msgid "111319"
msgstr "111319"

msgid "Analysis 3"
msgstr "分析3"

msgid "Working with cost/reverse_cost as time in seconds, x/y in lat/lon: Factor: would depend on the location of the points and on the average speed say 25m/s is the speed."
msgstr "使用 cost/reverse_cost 作为以秒为单位的时间，以 lat/lon 为单位的 x/y： 因子：取决于点的位置和平均速度，例如 25m/s 是速度。"

msgid ":doc:`bdAstar-family`"
msgstr ":doc:`bdAstar-family`"

msgid "`Boost: A* search <https://www.boost.org/libs/graph/doc/astar_search.html>`__"
msgstr "`Boost: A* search <https://www.boost.org/libs/graph/doc/astar_search.html>`__"

msgid "https://en.wikipedia.org/wiki/A*_search_algorithm"
msgstr "https://en.wikipedia.org/wiki/A*_search_algorithm"

msgid "All Pairs - Family of Functions"
msgstr "All Pairs - 函数族"

msgid "The following functions work on all vertices pair combinations"
msgstr "以下函数适用于所有顶点对组合"

msgid ":doc:`pgr_floydWarshall` - Floyd-Warshall's algorithm."
msgstr ":doc:`pgr_floydWarshall` - Floyd-Warshall 算法。"

msgid ":doc:`pgr_johnson` - Johnson's algorithm"
msgstr ":doc:`pgr_johnson` - Johnson算法"

msgid "The main characteristics are:"
msgstr "主要特点是："

msgid "It does not return a path."
msgstr "它不返回路径。"

msgid "Returns the sum of the costs of the shortest path for each pair of nodes in the graph."
msgstr "返回图中每对节点的最短路径成本之和。"

msgid "Boost returns a :math:`V \\times V` matrix, where the infinity values. Represent the distance between vertices for which there is no path."
msgstr "Boost 返回一个 :math:`V \\times V` 矩阵，其中无穷大值。 表示没有路径的顶点之间的距离。"

msgid "We return only the non infinity values in form of a set of `(start_vid, end_vid, agg_cost)`."
msgstr "我们仅以一组 `(start_vid, end_vid, agg_cost)` 的形式返回非无穷大值。"

msgid "Let be the case the values returned are stored in a table, so the unique index would be the pair: `(start_vid, end_vid)`."
msgstr "假设返回的值存储在表中，因此唯一索引将是一对：`(start_vid, end_vid)`。"

msgid "For the undirected graph, the results are symmetric."
msgstr "对于无向图，结果是对称的。"

msgid "The `agg_cost` of `(u, v)` is the same as for `(v, u)`."
msgstr "`(u, v)` 的 `agg_cost` 与 `(v, u)` 相同。"

msgid "When `start_vid` = `end_vid`, the `agg_cost` = 0."
msgstr "当 `start_vid` = `end_vid` 时，`agg_cost` = 0。"

msgid "**Recommended, use a bounding box of no more than 3500 edges.**"
msgstr "**建议使用不超过 3500 条边的边界框。**"

msgid "Optional parameters"
msgstr "可选参数"

msgid "``directed``"
msgstr "``directed``"

msgid "``BOOLEAN``"
msgstr "``BOOLEAN``"

msgid "``true``"
msgstr "``true``"

msgid "When ``true`` the graph is considered `Directed`"
msgstr "当 ``true`` 时，该图被视为有 `有向`"

msgid "When ``false`` the graph is considered as `Undirected`."
msgstr "如果为 ``false`` ，则该图被视为 `无向` 。"

msgid "Performance"
msgstr "表现"

msgid "The following tests:"
msgstr "以下测试："

msgid "non server computer"
msgstr "非服务器"

msgid "with AMD 64 CPU"
msgstr "AMD 64 CPU"

msgid "4G memory"
msgstr "4G内存"

msgid "trusty"
msgstr "Ubuntu Trusty"

msgid "PostgreSQL version 9.3"
msgstr "PostgreSQL version 9.3"

msgid "Data"
msgstr "数据"

msgid "The following data was used"
msgstr "使用了以下数据"

msgid "Data processing was done with osm2pgrouting-alpha"
msgstr "数据处理是使用 osm2pgrouting-alpha 完成的"

msgid "Results"
msgstr "结果"

msgid "Test"
msgstr "测试"

msgid "One"
msgstr "1"

msgid "This test is not with a bounding box The density of the passed graph is extremely low. For each <SIZE> 30 tests were executed to get the average The tested query is:"
msgstr "该测试没有使用边界框，通过的图形密度极低。 对于每个 <SIZE> 执行 30 次测试以获得平均值， 测试的查询是："

msgid "The results of this tests are presented as:"
msgstr "该测试的结果如下："

msgid "SIZE"
msgstr "SIZE"

msgid "is the number of edges given as input."
msgstr "是作为输入给出的边数。"

msgid "EDGES"
msgstr "EDGES"

msgid "is the total number of records in the query."
msgstr "是查询中的记录总数。"

msgid "DENSITY"
msgstr "DENSITY"

msgid "is the density of the data :math:`\\dfrac{E}{V \\times (V-1)}`."
msgstr "是数据 :math:`\\dfrac{E}{V \\times (V-1)}` 的密度。"

msgid "OUT ROWS"
msgstr "OUT ROWS"

msgid "is the number of records returned by the queries."
msgstr "是查询返回的记录数。"

msgid "Floyd-Warshall"
msgstr "Floyd-Warshall"

msgid "is the average execution time in seconds of pgr_floydWarshall."
msgstr "是 pgr_floydWarshall 的平均执行时间（以秒为单位）。"

msgid "Johnson"
msgstr "Johnson"

msgid "is the average execution time in seconds of pgr_johnson."
msgstr "是 pgr_johnson 的平均执行时间（以秒为单位）。"

msgid "500"
msgstr "500"

msgid "0.18E-7"
msgstr "0.18E-7"

msgid "1346"
msgstr "1346"

msgid "0.14"
msgstr "0.14"

msgid "0.13"
msgstr "0.13"

msgid "1000"
msgstr "1000"

msgid "0.36E-7"
msgstr "0.36E-7"

msgid "2655"
msgstr "2655"

msgid "0.23"
msgstr "0.23"

msgid "0.18"
msgstr "0.18"

msgid "1500"
msgstr "1500"

msgid "0.55E-7"
msgstr "0.55E-7"

msgid "4110"
msgstr "4110"

msgid "0.37"
msgstr "0.37"

msgid "0.34"
msgstr "0.34"

msgid "2000"
msgstr "2000"

msgid "0.73E-7"
msgstr "0.73E-7"

msgid "5676"
msgstr "5676"

msgid "0.56"
msgstr "0.56"

msgid "2500"
msgstr "2500"

msgid "0.89E-7"
msgstr "0.89E-7"

msgid "7177"
msgstr "7177"

msgid "0.84"
msgstr "0.84"

msgid "0.51"
msgstr "0.51"

msgid "3000"
msgstr "3000"

msgid "1.07E-7"
msgstr "1.07E-7"

msgid "8778"
msgstr "8778"

msgid "1.28"
msgstr "1.28"

msgid "0.68"
msgstr "0.68"

msgid "3500"
msgstr "3500"

msgid "1.24E-7"
msgstr "1.24E-7"

msgid "10526"
msgstr "10526"

msgid "2.08"
msgstr "2.08"

msgid "0.95"
msgstr "0.95"

msgid "4000"
msgstr "4000"

msgid "1.41E-7"
msgstr "1.41E-7"

msgid "12484"
msgstr "12484"

msgid "3.16"
msgstr "3.16"

msgid "1.24"
msgstr "1.24"

msgid "4500"
msgstr "4500"

msgid "1.58E-7"
msgstr "1.58E-7"

msgid "14354"
msgstr "14354"

msgid "4.49"
msgstr "4.49"

msgid "1.47"
msgstr "1.47"

msgid "5000"
msgstr "5000"

msgid "1.76E-7"
msgstr "1.76E-7"

msgid "16503"
msgstr "16503"

msgid "6.05"
msgstr "6.05"

msgid "1.78"
msgstr "1.78"

msgid "5500"
msgstr "5500"

msgid "1.93E-7"
msgstr "1.93E-7"

msgid "18623"
msgstr "18623"

msgid "7.53"
msgstr "7.53"

msgid "2.03"
msgstr "2.03"

msgid "6000"
msgstr "6000"

msgid "2.11E-7"
msgstr "2.11E-7"

msgid "20710"
msgstr "20710"

msgid "8.47"
msgstr "8.47"

msgid "2.37"
msgstr "2.37"

msgid "6500"
msgstr "6500"

msgid "2.28E-7"
msgstr "2.28E-7"

msgid "22752"
msgstr "22752"

msgid "9.99"
msgstr "9.99"

msgid "2.68"
msgstr "2.68"

msgid "7000"
msgstr "7000"

msgid "2.46E-7"
msgstr "2.46E-7"

msgid "24687"
msgstr "24687"

msgid "11.82"
msgstr "11.82"

msgid "3.12"
msgstr "3.12"

msgid "7500"
msgstr "7500"

msgid "2.64E-7"
msgstr "2.64E-7"

msgid "26861"
msgstr "26861"

msgid "13.94"
msgstr "13.94"

msgid "3.60"
msgstr "3.60"

msgid "8000"
msgstr "8000"

msgid "2.83E-7"
msgstr "2.83E-7"

msgid "29050"
msgstr "29050"

msgid "15.61"
msgstr "15.61"

msgid "4.09"
msgstr "4.09"

msgid "8500"
msgstr "8500"

msgid "3.01E-7"
msgstr "3.01E-7"

msgid "31693"
msgstr "31693"

msgid "17.43"
msgstr "17.43"

msgid "4.63"
msgstr "4.63"

msgid "9000"
msgstr "9000"

msgid "3.17E-7"
msgstr "3.17E-7"

msgid "33879"
msgstr "33879"

msgid "19.19"
msgstr "19.19"

msgid "5.34"
msgstr "5.34"

msgid "9500"
msgstr "9500"

msgid "3.35E-7"
msgstr "3.35E-7"

msgid "36287"
msgstr "36287"

msgid "20.77"
msgstr "20.77"

msgid "6.24"
msgstr "6.24"

msgid "10000"
msgstr "10000"

msgid "3.52E-7"
msgstr "3.52E-7"

msgid "38491"
msgstr "38491"

msgid "23.26"
msgstr "23.26"

msgid "6.51"
msgstr "6.51"

msgid "Two"
msgstr "2"

msgid "This test is with a bounding box The density of the passed graph higher than of the Test One. For each <SIZE> 30 tests were executed to get the average The tested edge query is:"
msgstr "该测试带有边界框。通过的图形的密度高于测试一的密度。 对于每个 <SIZE> 执行 30 次测试以获得平均值，测试的边缘查询为："

msgid "The tested queries"
msgstr "测试的查询"

msgid "is the size of the bounding box."
msgstr "是边界框的大小。"

msgid "0.001"
msgstr "0.001"

msgid "44"
msgstr "44"

msgid "0.0608"
msgstr "0.0608"

msgid "1197"
msgstr "1197"

msgid "0.10"
msgstr "0.10"

msgid "0.002"
msgstr "0.002"

msgid "99"
msgstr "99"

msgid "0.0251"
msgstr "0.0251"

msgid "4330"
msgstr "4330"

msgid "0.003"
msgstr "0.003"

msgid "223"
msgstr "223"

msgid "0.0122"
msgstr "0.0122"

msgid "18849"
msgstr "18849"

msgid "0.12"
msgstr "0.12"

msgid "0.004"
msgstr "0.004"

msgid "358"
msgstr "358"

msgid "0.0085"
msgstr "0.0085"

msgid "71834"
msgstr "71834"

msgid "0.16"
msgstr "0.16"

msgid "0.005"
msgstr "0.005"

msgid "470"
msgstr "470"

msgid "0.0070"
msgstr "0.0070"

msgid "116290"
msgstr "116290"

msgid "0.22"
msgstr "0.22"

msgid "0.19"
msgstr "0.19"

msgid "0.006"
msgstr "0.006"

msgid "639"
msgstr "639"

msgid "0.0055"
msgstr "0.0055"

msgid "207030"
msgstr "207030"

msgid "0.27"
msgstr "0.27"

msgid "0.007"
msgstr "0.007"

msgid "843"
msgstr "843"

msgid "0.0043"
msgstr "0.0043"

msgid "346930"
msgstr "346930"

msgid "0.64"
msgstr "0.64"

msgid "0.38"
msgstr "0.38"

msgid "0.008"
msgstr "0.008"

msgid "996"
msgstr "996"

msgid "0.0037"
msgstr "0.0037"

msgid "469936"
msgstr "469936"

msgid "0.90"
msgstr "0.90"

msgid "0.49"
msgstr "0.49"

msgid "0.009"
msgstr "0.009"

msgid "1146"
msgstr "1146"

msgid "0.0032"
msgstr "0.0032"

msgid "613135"
msgstr "613135"

msgid "1.26"
msgstr "1.26"

msgid "0.62"
msgstr "0.62"

msgid "0.010"
msgstr "0.010"

msgid "1360"
msgstr "1360"

msgid "0.0027"
msgstr "0.0027"

msgid "849304"
msgstr "849304"

msgid "1.87"
msgstr "1.87"

msgid "0.82"
msgstr "0.82"

msgid "0.011"
msgstr "0.011"

msgid "1573"
msgstr "1573"

msgid "0.0024"
msgstr "0.0024"

msgid "1147101"
msgstr "1147101"

msgid "2.65"
msgstr "2.65"

msgid "1.04"
msgstr "1.04"

msgid "0.012"
msgstr "0.012"

msgid "1789"
msgstr "1789"

msgid "0.0021"
msgstr "0.0021"

msgid "1483629"
msgstr "1483629"

msgid "3.72"
msgstr "3.72"

msgid "1.35"
msgstr "1.35"

msgid "0.013"
msgstr "0.013"

msgid "1975"
msgstr "1975"

msgid "0.0019"
msgstr "0.0019"

msgid "1846897"
msgstr "1846897"

msgid "4.86"
msgstr "4.86"

msgid "1.68"
msgstr "1.68"

msgid "0.014"
msgstr "0.014"

msgid "2281"
msgstr "2281"

msgid "0.0017"
msgstr "0.0017"

msgid "2438298"
msgstr "2438298"

msgid "7.08"
msgstr "7.08"

msgid "2.28"
msgstr "2.28"

msgid "0.015"
msgstr "0.015"

msgid "2588"
msgstr "2588"

msgid "0.0015"
msgstr "0.0015"

msgid "3156007"
msgstr "3156007"

msgid "10.28"
msgstr "10.28"

msgid "2.80"
msgstr "2.80"

msgid "0.016"
msgstr "0.016"

msgid "2958"
msgstr "2958"

msgid "0.0013"
msgstr "0.0013"

msgid "4090618"
msgstr "4090618"

msgid "14.67"
msgstr "14.67"

msgid "3.76"
msgstr "3.76"

msgid "0.017"
msgstr "0.017"

msgid "3247"
msgstr "3247"

msgid "0.0012"
msgstr "0.0012"

msgid "4868919"
msgstr "4868919"

msgid "18.12"
msgstr "18.12"

msgid "4.48"
msgstr "4.48"

msgid ":doc:`pgr_johnson`"
msgstr ":doc:`pgr_johnson`"

msgid ":doc:`pgr_floydWarshall`"
msgstr ":doc:`pgr_floydWarshall`"

msgid "Boost `floyd-Warshall <https://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html>`__"
msgstr "Boost `弗洛伊德算法 <https://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html>`__"

msgid "Bidirectional A* - Family of functions"
msgstr "双向A* - 函数族"

msgid "The bidirectional A* (pronounced \"A Star\") algorithm is based on the A* algorithm."
msgstr "双向A*（发音为\"A星\"）算法基于A*算法。"

msgid ":doc:`pgr_bdAstar` - Bidirectional A* algorithm for obtaining paths."
msgstr ":doc:`pgr_bdAstar` - 获取路径的双向A*算法。"

msgid ":doc:`pgr_bdAstarCost` - Bidirectional A* algorithm to calculate the cost of the paths."
msgstr ":doc:`pgr_bdAstarCost` - 双向 A* 算法计算路径成本。"

msgid ":doc:`pgr_bdAstarCostMatrix` - Bidirectional A* algorithm to calculate a cost matrix of paths."
msgstr ":doc:`pgr_bdAstarCostMatrix` - 用于计算路径成本矩阵的双向 A* 算法。"

msgid "Based on A* algorithm, the bidirectional search finds a shortest path from a starting vertex (``start_vid``) to an ending vertex (``end_vid``). It runs two simultaneous searches: one forward from the ``start_vid``, and one backward from the ``end_vid``, stopping when the two meet in the middle. This implementation can be used with a directed graph and an undirected graph."
msgstr "基于A*算法，双向搜索找到从起始顶点(``start_vid``)到结束顶点(``end_vid``)的最短路径。 它同时运行两项搜索：一项从 ``start_vid`` 向前搜索，一项从 ``end_vid`` 向后搜索，当两者在中间相遇时停止。 该实现可以与有向图和无向图一起使用。"

#, fuzzy
msgid "For large graphs where there is a path between the starting vertex and ending vertex:"
msgstr "对于起始顶点和结束顶点之间存在路径的大型图:"

#, fuzzy
msgid "It is expected to terminate faster than :doc:`pgr_aStar`"
msgstr "预计其执行速度将快于 pgr_aStar 函数"

msgid ":doc:`aStar-family`"
msgstr ":doc:`aStar-family`"

msgid "Bidirectional Dijkstra - Family of functions"
msgstr "双向 Dijkstra - 函数族"

msgid ":doc:`pgr_bdDijkstra` - Bidirectional Dijkstra algorithm for the shortest paths."
msgstr ":doc:`pgr_bdDijkstra` - 最短路径的双向 Dijkstra 算法。"

msgid ":doc:`pgr_bdDijkstraCost` - Bidirectional Dijkstra to calculate the cost of the shortest paths"
msgstr ":doc:`pgr_bdDijkstraCost` - 双向 Dijkstra 计算最短路径的成本"

msgid ":doc:`pgr_bdDijkstraCostMatrix` - Bidirectional Dijkstra algorithm to create a matrix of costs of the shortest paths."
msgstr ":doc:`pgr_bdDijkstraCostMatrix` - 创建最短路径成本矩阵的双向 Dijkstra 算法。"

msgid "Synopsis"
msgstr "概要"

msgid "Based on Dijkstra's algorithm, the bidirectional search finds a shortest path a starting vertex to an ending vertex."
msgstr "基于 Dijkstra 算法，双向搜索找到起始顶点到结束顶点的最短路径。"

msgid "It runs two simultaneous searches: one forward from the source, and one backward from the target, stopping when the two meet in the middle."
msgstr "它同时运行两项搜索：一项从源向前搜索，一项从目标向后搜索，当两者在中间相遇时停止。"

msgid "This implementation can be used with a directed graph and an undirected graph."
msgstr "该实现可以与有向图和无向图一起使用。"

msgid "A negative value on a cost column is interpreted as the edge does not exist."
msgstr "成本列上的负值被解释为边不存在。"

msgid "When there is no path:"
msgstr "当没有路径时："

msgid "When the starting vertex and ending vertex are the same."
msgstr "当起始顶点和结束顶点相同时。"

msgid "The **aggregate cost** of the non included values :math:`(v, v)` is :math:`0`"
msgstr "未包含值 :math:`(v, v)` 的 **aggregate cost** 为 :math:`0`"

msgid "When the starting vertex and ending vertex are the different and there is no path:"
msgstr "当起始顶点和结束顶点不同且不存在路径时："

msgid "The **aggregate cost** the non included values :math:`(u, v)` is :math:`\\infty`"
msgstr "未包含值 :math:`(u, v)` 的 **aggregate cost** 是 :math:`\\infty`"

msgid "For optimization purposes, any duplicated value in the starting vertices or on the ending vertices are ignored."
msgstr "出于优化目的，起始顶点或结束顶点中的任何重复值都将被忽略。"

msgid "Running time (worse case scenario): :math:`O((V \\log V + E))`"
msgstr "运行时间（最坏情况）： :math:`O((V \\log V + E))`"

msgid "For large graphs where there is a path bewtween the starting vertex and ending vertex:"
msgstr "对于起始顶点和结束顶点之间存在路径的大型图:"

#, fuzzy
msgid "It is expected to terminate faster than :doc:`pgr_dijkstra`"
msgstr "预计终止速度比 pgr_dijkstra 更快"

#, fuzzy
msgid "`Boost  <https://www.boost.org/libs/graph/doc>`__"
msgstr "`Boost: <https://www.boost.org/libs/graph/doc/table_of_contents.html>`__"

#, fuzzy
msgid "Chinese Postman Problem - Family of functions"
msgstr "中国邮递员问题 - 函数族（实验性）"

msgid ":doc:`pgr_chinesePostman`"
msgstr ":doc:`pgr_chinesePostman`"

msgid ":doc:`pgr_chinesePostmanCost`"
msgstr ":doc:`pgr_chinesePostmanCost`"

msgid "**The main characteristics are:**"
msgstr "**主要特点是：**"

msgid "Process is done only on edges with **positive** costs."
msgstr "仅在具有 **正** 成本的边缘进行处理。"

msgid "Running time: :math:`O(E * (E + V * logV))`"
msgstr "运行时间： :math:`O(E * (E + V * logV))`"

msgid "Graph must be connected."
msgstr "图必须是连通的。"

msgid "An Edges SQL that represents a **directed** graph with the following columns"
msgstr "表示具有以下列的有向图的 Edges SQL"

msgid "Coloring - Family of functions"
msgstr "着色 - 函数族"

msgid ":doc:`pgr_sequentialVertexColoring` - Vertex coloring algorithm using greedy approach."
msgstr ":doc:`pgr_sequentialVertexColoring` - 顶点着色算法采用贪心法。"

msgid ":doc:`pgr_bipartite` - Bipartite graph algorithm using a DFS-based coloring approach."
msgstr ":doc:`pgr_bipartite` - 使用基于 DFS 的着色方法的二分图算法。"

msgid ":doc:`pgr_edgeColoring` - Edge Coloring algorithm using Vizing's theorem."
msgstr ":doc:`pgr_edgeColoring` - 使用 Vizing 定理的边缘着色算法。"

#, fuzzy
msgid "Returns set of |result_edge_color|"
msgstr "返回集合 |result-edge-color|"

msgid "``color``"
msgstr "``color``"

#, fuzzy
msgid "Color of the edge."
msgstr "边的几何形状。"

msgid "The minimum value of color is 1."
msgstr "颜色的最小值为 1。"

#, fuzzy
msgid "Returns set of |result_node_color|"
msgstr "返回集合 |result-node-color|"

#, fuzzy
msgid "Identifier of the node."
msgstr "边的标识符。"

#, fuzzy
msgid "Color of the node."
msgstr "边的几何形状。"

msgid "`Boost: <https://www.boost.org/libs/graph/doc/table_of_contents.html>`__"
msgstr "`Boost: <https://www.boost.org/libs/graph/doc/table_of_contents.html>`__"

msgid "Components - Family of functions"
msgstr "分量 - 函数族"

msgid ":doc:`pgr_connectedComponents` - Connected components of an undirected graph."
msgstr ":doc:`pgr_connectedComponents` - 无向图的连通分量。"

msgid ":doc:`pgr_strongComponents` - Strongly connected components of a directed graph."
msgstr ":doc:`pgr_strongComponents` - 有向图的强连通分量。"

msgid ":doc:`pgr_biconnectedComponents` - Biconnected components of an undirected graph."
msgstr ":doc:`pgr_biconnectedComponents` - 无向图的双连通分量。"

msgid ":doc:`pgr_articulationPoints` - Articulation points of an undirected graph."
msgstr ":doc:`pgr_articulationPoints` - 无向图的铰接点。"

msgid ":doc:`pgr_bridges` - Bridges of an undirected graph."
msgstr ":doc:`pgr_bridges` - 无向图的桥。"

msgid ":doc:`pgr_makeConnected` - Details of edges to make graph connected."
msgstr ":doc:`pgr_makeConnected` - 使图形连接的边的详细信息。"

msgid "Contraction - Family of functions"
msgstr "收缩 - 函数族"

msgid ":doc:`pgr_contraction`"
msgstr ":doc:`pgr_contraction`"

msgid ":doc:`pgr_contractionDeadEnd`"
msgstr ":doc:`pgr_contractionDeadEnd`"

msgid ":doc:`pgr_contractionLinear`"
msgstr ":doc:`pgr_contractionLinear`"

msgid ":doc:`pgr_contractionHierarchies`"
msgstr ":doc:`pgr_contractionHierarchies`"

msgid "In large graphs, like road graphs or electric networks, graph contraction can be used to speed up some graph algorithms. Contraction can reduce the size of the graph by removing some of the vertices and edges and adding edges that represent a sequence of original edges (the original ones can be kept in some methods). In this way, it decreases the total time and space used by graph algorithms, particularly those searching for an optimal path."
msgstr "在大型图中，如道路图或电力网络，图收缩可以用来加速一些图算法。收缩通过移除部分顶点和边，并添加表示原始边序列的边来减小图的大小（在某些方法中可以保留原始边）。通过这种方式，它减少了图算法使用的总时间和空间，特别是那些寻找最优路径的算法。"

msgid "This implementation gives a flexible framework for adding contraction algorithms in the future. Currently, it supports three algorithms."
msgstr "这种实现方式提供了一个灵活的框架，以便将来添加收缩算法。目前，它支持三种算法。"

msgid "Dead end contraction"
msgstr "死端收缩"

msgid "Linear contraction"
msgstr "线性收缩"

msgid "Contraction hierarchies"
msgstr "收缩等级"

msgid "The two first ones can be combined through a iterative procedure, via the ``pgr_contraction`` method. The third one is implemented on its own."
msgstr "前两项可以通过 ``pgr_contraction`` 方法，通过迭代程序进行组合。第三种方法是独立实现的。"

msgid "All functions allow the user to forbid contraction on a set of nodes."
msgstr "所有函数都允许用户禁止对一组节点进行收缩。"

msgid "https://www.cs.cmu.edu/afs/cs/academic/class/15210-f12/www/lectures/lecture16.pdf"
msgstr "https://www.cs.cmu.edu/afs/cs/academic/class/15210-f12/www/lectures/lecture16.pdf"

msgid "https://ae.iti.kit.edu/download/diploma_thesis_geisberger.pdf"
msgstr "https://ae.iti.kit.edu/download/diploma_thesis_geisberger.pdf"

msgid "https://jlazarsfeld.github.io/ch.150.project/contents/"
msgstr "https://jlazarsfeld.github.io/ch.150.project/contents/"

msgid "Cost - Category"
msgstr "成本 - 类别"

msgid ":doc:`pgr_aStarCost`"
msgstr ":doc:`pgr_aStarCost`"

msgid ":doc:`pgr_bdAstarCost`"
msgstr ":doc:`pgr_bdAstarCost`"

msgid ":doc:`pgr_dijkstraCost`"
msgstr ":doc:`pgr_dijkstraCost`"

msgid ":doc:`pgr_dijkstraNearCost`"
msgstr ":doc:`pgr_dijkstraNearCost`"

msgid ":doc:`pgr_bdDijkstraCost`"
msgstr ":doc:`pgr_bdDijkstraCost`"

msgid ":doc:`pgr_withPointsCost`"
msgstr ":doc:`pgr_withPointsCost`"

msgid "Each function works as part of the family it belongs to."
msgstr "每个函数都是其所属家族的一部分。"

msgid "Returns the sum of the costs of the shortest path of each pair combination of nodes requested."
msgstr "返回所请求的每对节点组合的最短路径的成本总和。"

msgid "Let be the case the values returned are stored in a table, so the unique index would be the pair: ``(start_vid, end_vid)``."
msgstr "假设返回的值存储在表中，因此唯一索引将是一对： ``(start_vid, end_vid)`` 。"

msgid "Depending on the function and its parameters, the results can be symmetric."
msgstr "根据函数及其参数，结果可能是对称的。"

msgid "The **aggregate cost** of :math:`(u, v)` is the same as for :math:`(v, u)`."
msgstr ":math:`(u, v)` 的 **总成本** 与 :math:`(v, u)` 的相同。"

msgid "Any duplicated value in the start or end vertex identifiers are ignored."
msgstr "起始或结束顶点标识符中的任何重复值都将被忽略。"

msgid "The returned values are ordered:"
msgstr "返回值是有序的："

msgid "``start_vid`` ascending"
msgstr "``start_vid`` 升序"

msgid "``end_vid`` ascending"
msgstr "``end_vid`` 升序"

msgid "Cost Matrix - Category"
msgstr "成本矩阵 - 类别"

msgid ":doc:`pgr_aStarCostMatrix`"
msgstr ":doc:`pgr_aStarCostMatrix`"

msgid ":doc:`pgr_dijkstraCostMatrix`"
msgstr ":doc:`pgr_dijkstraCostMatrix`"

msgid ":doc:`pgr_bdAstarCostMatrix`"
msgstr ":doc:`pgr_bdAstarCostMatrix`"

msgid ":doc:`pgr_bdDijkstraCostMatrix`"
msgstr ":doc:`pgr_bdDijkstraCostMatrix`"

msgid ":doc:`pgr_withPointsCostMatrix`"
msgstr ":doc:`pgr_withPointsCostMatrix`"

msgid ":doc:`TSP-family` needs as input a symmetric cost matrix and no edge `(u, v)` must value :math:`\\infty`."
msgstr ":doc:`TSP-family` 需要一个对称成本矩阵作为输入，并且没有边 `(u, v)` 必须值为 :math:`\\infty`。"

msgid "This collection of functions will return a cost matrix in form of a table."
msgstr "该函数集合将以表格形式返回成本矩阵。"

msgid "Can be used as input to :doc:`pgr_TSP`."
msgstr "可用作 :doc:`pgr_TSP` 的输入。"

msgid "Use directly when the resulting matrix is symmetric and there is no :math:`\\infty` value."
msgstr "当得到的矩阵是对称且没有 :math:`\\infty` 值时直接使用。"

msgid "It will be the users responsibility to make the matrix symmetric."
msgstr "用户有责任使矩阵对称。"

msgid "By using geometric or harmonic average of the non symmetric values."
msgstr "通过使用非对称值的几何平均或调和平均。"

msgid "By using max or min the non symmetric values."
msgstr "通过使用 max 或 min 非对称值。"

msgid "By setting the upper triangle to be the mirror image of the lower triangle."
msgstr "通过将上三角形设置为下三角形的镜像。"

msgid "By setting the lower triangle to be the mirror image of the upper triangle."
msgstr "通过将下三角形设置为上三角形的镜像。"

msgid "It is also the users responsibility to fix an :math:`\\infty` value."
msgstr "确定 :math:`\\infty` 值也是用户的责任。"

msgid "Returns the sum of the costs of the shortest path for pair combination of nodes in the graph."
msgstr "返回图中节点对组合的最短路径的成本总和。"

msgid "When the starting vertex and ending vertex are the same, there is no path."
msgstr "当起始顶点和结束顶点相同时，就没有路径。"

msgid "The aggregate cost in the non included values `(v, v)` is `0`."
msgstr "未包含值 `(v, v)` 中的总成本为 `0` 。"

msgid "When the starting vertex and ending vertex are the different and there is no path."
msgstr "当起始顶点和结束顶点不同且不存在路径时。"

msgid "The aggregate cost in the non included values `(u, v)` is :math:`\\infty`."
msgstr "未包含值 `(u, v)` 中的总成本为 :math:`\\infty` 。"

msgid "Let be the case the values returned are stored in a table:"
msgstr "假设返回的值存储在表中："

msgid "The unique index would be the pair: ``(start_vid, end_vid)``."
msgstr "唯一索引将是一对： ``(start_vid, end_vid)`` 。"

msgid "The aggregate cost of `(u, v)` is the same as for `(v, u)`."
msgstr "`(u, v)` 的总成本与 `(v, u)` 相同。"

msgid "Any duplicated value in the **start vids** are ignored."
msgstr "**start vids** 中的任何重复值都会被忽略。"

msgid "Used in:"
msgstr "用于："

msgid "`Edges SQL`_ as described below"
msgstr "`Edges SQL`_ 如下所述"

msgid "**start vids**"
msgstr "**start vids**"

msgid "``ARRAY[BIGINT]``"
msgstr "``ARRAY[BIGINT]``"

msgid "Array of identifiers of starting vertices."
msgstr "起始顶点的标识符数组。"

msgid "`Points SQL`_"
msgstr "`Points SQL`_"

msgid "`Points SQL`_ as described below"
msgstr "`Points SQL`_ 如下所述"

msgid "Points SQL"
msgstr "Points SQL"

msgid "``pid``"
msgstr "``pid``"

msgid "**value**"
msgstr "**value**"

msgid "Identifier of the point."
msgstr "点的标识符。"

msgid "Use with positive value, as internally will be converted to negative value"
msgstr "使用正值，因为内部将转换为负值"

msgid "If column is present, it can not be NULL."
msgstr "如果列存在，则它不能为 NULL。"

msgid "If column is not present, a sequential negative **value** will be given automatically."
msgstr "如果列不存在，将自动给出连续的负 **值** 。"

msgid "``edge_id``"
msgstr "``edge_id``"

msgid "Identifier of the \"closest\" edge to the point."
msgstr "距离该点“最近”的边的标识符。"

msgid "``fraction``"
msgstr "``fraction``"

#, fuzzy
msgid "Value in <0,1> that indicates the relative position from the first end point of the edge."
msgstr "<0,1> 中的值指示距边缘第一个端点的相对位置。"

msgid "``side``"
msgstr "``side``"

msgid "``CHAR``"
msgstr "``CHAR``"

msgid "``b``"
msgstr "``b``"

msgid "Value in [``b``, ``r``, ``l``, ``NULL``] indicating if the point is:"
msgstr "[``b``, ``r``, ``l``, ``NULL``] 中的值指示该点是否为："

msgid "In the right ``r``,"
msgstr "``r`` 在右边，"

msgid "In the left ``l``,"
msgstr "``l`` 在左边，"

msgid "In both sides ``b``, ``NULL``"
msgstr "``b``, ``NULL`` 在两边"

msgid ":doc:`TSP-family`"
msgstr ":doc:`TSP-family`"

msgid "Dijkstra - Family of functions"
msgstr "Dijkstra - 函数族"

msgid ":doc:`pgr_dijkstra` - Dijkstra's algorithm for the shortest paths."
msgstr ":doc:`pgr_dijkstra` - Dijkstra 最短路径算法。"

msgid ":doc:`pgr_dijkstraCost` - Get the aggregate cost of the shortest paths."
msgstr ":doc:`pgr_dijkstraCost` - 获取最短路径的总成本。"

msgid ":doc:`pgr_dijkstraCostMatrix` - Use pgr_dijkstra to create a costs matrix."
msgstr ":doc:`pgr_dijkstraCostMatrix` - 使用 pgr_dijkstra 创建成本矩阵。"

msgid ":doc:`pgr_drivingDistance` - Use pgr_dijkstra to calculate catchament information."
msgstr ":doc:`pgr_drivingDistance` - 使用 pgr_dijkstra 计算流域信息。"

msgid ":doc:`pgr_KSP` - Use Yen algorithm with pgr_dijkstra to get the K shortest paths."
msgstr ":doc:`pgr_KSP` - 使用 Yen 算法和 pgr_dijkstra 来获得 K 条最短路径。"

msgid ":doc:`pgr_dijkstraVia` - Get a route of a sequence of vertices."
msgstr ":doc:`pgr_dijkstraVia` - 获取经过一系列顶点的路径。"

msgid ":doc:`pgr_dijkstraNear` - Get the route to the nearest vertex."
msgstr ":doc:`pgr_dijkstraNear` - 获取到最近顶点的路线。"

msgid ":doc:`pgr_dijkstraNearCost` - Get the cost to the nearest vertex."
msgstr ":doc:`pgr_dijkstraNearCost` - 获取最近顶点的成本。"

msgid "Dijkstra's algorithm, conceived by Dutch computer scientist Edsger Dijkstra in 1956. It is a graph search algorithm that solves the shortest path problem for a graph with non-negative edge path costs, producing a shortest path from a starting vertex to an ending vertex. This implementation can be used with a directed graph and an undirected graph."
msgstr "Dijkstra算法，由荷兰计算机科学家Edsger Dijkstra于1956年提出。它是一种图搜索算法，解决具有非负边路径成本的图的最短路径问题，产生从起始顶点到结束顶点的最短路径。 该实现可以与有向图和无向图一起使用。"

msgid "Running time: :math:`O(| start\\ vids | * (V \\log V + E))`"
msgstr "运行时间： :math:`O(| start\\ vids | * (V \\log V + E))`"

msgid "The Dijkstra family functions are based on the Dijkstra algorithm."
msgstr "Dijkstra 系列函数基于 Dijkstra 算法。"

msgid "`Combinations SQL`_"
msgstr "`Combinations SQL`_"

msgid "`Combinations SQL`_ as described below"
msgstr "`Combinations SQL`_ 如下所述"

msgid "**start vid**"
msgstr "**start vid**"

msgid "Identifier of the starting vertex of the path."
msgstr "路径起始顶点的标识符。"

msgid "**end vid**"
msgstr "**end vid**"

msgid "Identifier of the ending vertex of the path."
msgstr "路径结束顶点的标识符。"

msgid "**end vids**"
msgstr "**end vids**"

msgid "Array of identifiers of ending vertices."
msgstr "结束顶点的标识符数组。"

msgid "Combinations SQL"
msgstr "分量 SQL"

msgid "Identifier of the departure vertex."
msgstr "出发顶点的标识符。"

msgid "Identifier of the arrival vertex."
msgstr "到达顶点的标识符。"

msgid "The problem definition (Advanced documentation)"
msgstr "问题定义（高级文档）"

msgid "Given the following query:"
msgstr "给出以下查询："

msgid "pgr_dijkstra(:math:`sql, start_{vid}, end_{vid}, directed`)"
msgstr "pgr_dijkstra(:math:`sql, start_{vid}, end_{vid}, directed`)"

msgid "where :math:`sql = \\{(id_i, source_i, target_i, cost_i, reverse\\_cost_i)\\}`"
msgstr "其中 :math:`sql =\\{(id_i, source_i, target_i, cost_i, reverse\\_cost_i)\\}`"

msgid "and"
msgstr "和"

msgid ":math:`source = \\bigcup source_i`,"
msgstr ":math:`source = \\bigcup source_i`,"

msgid ":math:`target = \\bigcup target_i`,"
msgstr ":math:`target = \\bigcup target_i`,"

msgid "The graphs are defined as follows:"
msgstr "图定义如下："

msgid "Directed graph"
msgstr "有向图"

msgid "The weighted directed graph, :math:`G_d(V,E)`, is defined by:"
msgstr "加权有向图， :math:`G_d(V,E)` ， 定义如下："

msgid "the set of vertices :math:`V`"
msgstr "顶点集 :math:`V`"

msgid ":math:`V = source \\cup target \\cup {start_{vid}} \\cup  {end_{vid}}`"
msgstr ":math:`V = source \\cup target \\cup {start_v{vid}} \\cup {end_{vid}}`"

msgid "the set of edges :math:`E`"
msgstr "边集 :math:`E`"

msgid ":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\} & \\quad \\text{if } reverse\\_cost = \\varnothing \\\\ \\text{ } \\text{ }  & \\quad \\text{ } \\\\ \\text{ } \\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\} &  \\quad \\text{ } \\\\ \\cup \\{(target_i, source_i, reverse\\_cost_i) \\text{ when } reverse\\_cost_i>=0 \\} & \\quad \\text{if } reverse\\_cost \\neq \\varnothing \\\\ \\end{cases}`"
msgstr ":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\} & \\quad \\text{if } reverse\\_cost = \\varnothing \\\\ \\text{ } \\text{ }  & \\quad \\text{ } \\\\ \\text{ } \\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\} & \\quad \\text{ } \\\\ \\cup \\{(target_i, source_i, reverse\\_cost_i) \\text{ when } reverse\\_cost_i>=0 \\} & \\quad \\text{if } reverse\\_cost \\neq \\varnothing \\\\ \\end{cases}`"

msgid "Undirected graph"
msgstr "无向图"

msgid "The weighted undirected graph, :math:`G_u(V,E)`, is defined by:"
msgstr "加权无向图 :math:`G_u(V,E)` 的定义如下："

msgid ":math:`V = source \\cup target \\cup {start_v{vid}} \\cup  {end_{vid}}`"
msgstr ":math:`V = source \\cup target \\cup {start_v{vid}} \\cup  {end_{vid}}`"

msgid ":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\}  & \\quad \\text{ } \\\\ \\cup \\{(target_i, source_i, cost_i) \\text{ when } cost >=0 \\}  & \\quad \\text{ if } reverse\\_cost = \\varnothing \\\\ \\text{ } \\text{ }  & \\text{ } \\\\ \\text{ } \\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\} & \\text{ } \\\\ \\cup \\{(target_i, source_i, cost_i) \\text{ when } cost >=0 \\} & \\text{ } \\\\ \\cup \\{(target_i, source_i, reverse\\_cost_i) \\text{ when } reverse\\_cost_i >=0)\\} & \\text{ } \\\\ \\cup \\{(source_i, target_i, reverse\\_cost_i) \\text{ when } reverse\\_cost_i >=0)\\} & \\quad \\text{ if } reverse\\_cost \\neq \\varnothing \\\\ \\end{cases}`"
msgstr ":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\}  & \\quad \\text{ } \\\\ \\cup \\{(target_i, source_i, cost_i) \\text{ when } cost >=0 \\} & \\quad \\text{ if } reverse\\_cost = \\varnothing \\\\ \\text{ } \\text{ } & \\text{ } \\\\ \\text{ } \\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\} & \\text{ } \\\\ \\cup \\{(target_i, source_i, cost_i) \\text{ when } cost >=0 \\} & \\text{ } \\\\ \\cup \\{(target_i, source_i, reverse\\_cost_i) \\text{ when } reverse\\_cost_i >=0)\\} & \\text{ } \\\\ \\cup \\{(source_i, target_i, reverse\\_cost_i) \\text{ when } reverse\\_cost_i >=0)\\} & \\quad \\text{ if } reverse\\_cost \\neq \\varnothing \\\\ \\end{cases}`"

msgid "The problem"
msgstr "问题"

msgid "Given:"
msgstr "给定："

msgid ":math:`start_{vid} \\in V` a starting vertex"
msgstr ":math:`start_{vid} \\in V` a starting vertex"

msgid ":math:`end_{vid} \\in V` an ending vertex"
msgstr ":math:`end_{vid} \\in V` an ending vertex"

msgid ":math:`G(V,E) = \\begin{cases} G_d(V,E) & \\quad \\text{ if6 } directed = true \\\\ G_u(V,E) & \\quad \\text{ if5 } directed = false \\\\ \\end{cases}`"
msgstr ":math:`G(V,E) = \\begin{cases} G_d(V,E) & \\quad \\text{ if6 } directed = true \\\\ G_u(V,E) & \\quad \\text{ if5 } directed = false \\\\ \\end{cases}`"

msgid "Then:"
msgstr "然后："

msgid ":math:`\\boldsymbol{\\pi} = \\{(path\\_seq_i, node_i, edge_i, cost_i, agg\\_cost_i)\\}`"
msgstr ":math:`\\boldsymbol{\\pi} = \\{(path\\_seq_i, node_i, edge_i, cost_i, agg\\_cost_i)\\}`"

msgid "where:"
msgstr "其中："

msgid ":math:`path\\_seq_i = i`"
msgstr ":math:`path\\_seq_i = i`"

msgid ":math:`path\\_seq_{| \\pi |} = | \\pi |`"
msgstr ":math:`path\\_seq_{| \\pi |} = | \\pi |`"

msgid ":math:`node_i \\in V`"
msgstr ":math:`node_i \\in V`"

msgid ":math:`node_1 = start_{vid}`"
msgstr ":math:`node_1 = start_{vid}`"

msgid ":math:`node_{| \\pi |}  = end_{vid}`"
msgstr ":math:`node_{| \\pi |}  = end_{vid}`"

msgid ":math:`\\forall i \\neq | \\pi |, \\quad (node_i, node_{i+1}, cost_i) \\in E`"
msgstr ":math:`\\forall i \\neq | \\pi |, \\quad (node_i, node_{i+1}, cost_i) \\in E`"

msgid ":math:`edge_i  = \\begin{cases}  id_{(node_i, node_{i+1},cost_i)}  &\\quad  \\text{when } i \\neq | \\pi | \\\\ -1 &\\quad  \\text{when } i = | \\pi | \\\\ \\end{cases}`"
msgstr ":math:`edge_i  = \\begin{cases}  id_{(node_i, node_{i+1},cost_i)}  &\\quad  \\text{when } i \\neq | \\pi | \\\\ -1 &\\quad  \\text{when } i = | \\pi | \\\\ \\end{cases}`"

msgid ":math:`cost_i = cost_{(node_i, node_{i+1})}`"
msgstr ":math:`cost_i = cost_{(node_i, node_{i+1})}`"

msgid ":math:`agg\\_cost_i  = \\begin{cases}  0   &\\quad  \\text{when } i = 1  \\\\ \\displaystyle\\sum_{k=1}^{i}  cost_{(node_{k-1}, node_k)}  &\\quad  \\text{when } i \\neq 1 \\\\ \\end{cases}`"
msgstr ":math:`agg\\_cost_i  = \\begin{cases}  0   &\\quad  \\text{when } i = 1  \\\\ \\displaystyle\\sum_{k=1}^{i}  cost_{(node_{k-1}, node_k)}  &\\quad  \\text{when } i \\neq 1 \\\\ \\end{cases}`"

msgid "In other words: The algorithm returns a the shortest path between :math:`start_{vid}` and :math:`end_{vid}`, if it exists, in terms of a sequence of nodes and of edges,"
msgstr "换句话说：如果 :math:`start_{vid}` 和 :math:`end_{vid}` 之间存在最短路径，算法会根据节点和边的序列返回该路径、"

msgid ":math:`path\\_seq` indicates the relative position in the path of the :math:`node` or :math:`edge`."
msgstr ":math:`path\\_seq` 表示 :math:`node` 或 :math:`edge` 的路径中的相对位置。"

msgid ":math:`cost` is the cost of the edge to be used to go to the next node."
msgstr ":math:`cost` 是用于转到下一个节点的边的成本。"

msgid ":math:`agg\\_cost` is the cost from the :math:`start_{vid}` up to the node."
msgstr ":math:`agg\\_cost` 是从 :math:`start_{vid}` 到节点的成本。"

msgid "If there is no path, the resulting set is empty."
msgstr "如果没有路径，则结果集为空。"

msgid "Driving Distance - Category"
msgstr "驾驶距离 - 类别"

msgid ":doc:`pgr_drivingDistance` - Driving Distance based on Dijkstra's algorithm"
msgstr ":doc:`pgr_drivingDistance` - 基于 Dijkstra 算法的行驶距离"

msgid ":doc:`pgr_primDD` - Driving Distance based on Prim's algorithm"
msgstr ":doc:`pgr_primDD` - 基于Prim算法的行驶距离"

msgid ":doc:`pgr_kruskalDD` - Driving Distance based on Kruskal's algorithm"
msgstr ":doc:`pgr_kruskalDD` - 基于Kruskal算法的行驶距离"

msgid ":doc:`pgr_withPointsDD` - Driving Distance based on pgr_withPoints"
msgstr ":doc:`pgr_withPointsDD` - 基于 pgr_withPoints 的行驶距离"

msgid "Calculate nodes that are within a distance."
msgstr "计算一定距离内的节点。"

msgid "Extracts all the nodes that have costs less than or equal to the value distance."
msgstr "提取成本小于或等于距离值的所有节点。"

msgid "The edges extracted will conform to the corresponding spanning tree."
msgstr "提取的边将符合相应的生成树。"

msgid "Edge :math:`(u, v)` will not be included when:"
msgstr "在以下情况下，边 :math:`(u, v)` 将不包括在内："

msgid "The distance from the **root** to :math:`u` > limit distance."
msgstr "从 **root** 到 :math:`u` 的距离>限制距离。"

msgid "The distance from the **root** to :math:`v` > limit distance."
msgstr "从 **root** 到 :math:`v` 的距离>限制距离。"

msgid "No new nodes are created on the graph, so when is within the limit and is not within the limit, the edge is not included."
msgstr "图上不会创建新的节点，因此当 位于限制内和不在限制内时，不包含边。"

msgid "Edges SQL as described below."
msgstr "Edges SQL如下所述。"

msgid "**Root vid**"
msgstr "**Root vid**"

msgid "**Root vids**"
msgstr "**Root vids**"

msgid "``ARRAY[ANY-INTEGER]``"
msgstr "``ARRAY[ANY-INTEGER]``"

msgid "**distance**"
msgstr "**distance**"

msgid "Upper limit for the inclusion of a node in the result."
msgstr "结果中包含节点的上限。"

msgid "Returns set of |result-spantree|"
msgstr "返回集合 |result-spantree|"

msgid ":math:`depth-1` is the depth of ``pred``"
msgstr ":math:`depth-1` is the depth of ``pred``"

msgid "``pred``"
msgstr "``pred``"

msgid "Predecessor of ``node``."
msgstr "``node`` 的前驱。"

msgid "When ``node`` = ``start_vid`` then has the value ``node``."
msgstr "当 `node` 等于 `start_vid` 时，它的值就是 `node` 。"

msgid "Identifier of the ``edge`` used to arrive from ``pred`` to ``node``."
msgstr "从 ``pred`` 到达 ``node`` 所使用的 ``edge`` 的标识符。"

msgid "Experimental Functions"
msgstr "实验性函数"

msgid "Families"
msgstr "族"

msgid ":doc:`flow-family`"
msgstr ":doc:`flow-family`"

msgid ":doc:`pgr_maxFlowMinCost` - Details of flow and cost on edges."
msgstr ":doc:`pgr_maxFlowMinCost` - 边缘上的流量和成本详细信息。"

msgid ":doc:`pgr_maxFlowMinCost_Cost` - Only the Min Cost calculation."
msgstr ":doc:`pgr_maxFlowMinCost_Cost` - 仅最小成本计算。"

msgid ":doc:`chinesePostmanProblem-family`"
msgstr ":doc:`chinesePostmanProblem-family`"

msgid ":doc:`coloring-family`"
msgstr ":doc:`coloring-family`"

msgid ":doc:`contraction-family`"
msgstr ":doc:`contraction-family`"

msgid ":doc:`transformation-family`"
msgstr ":doc:`transformation-family`"

msgid ":doc:`pgr_lineGraphFull` - Transformation algorithm for generating a Line Graph out of each vertex in the input graph."
msgstr ":doc:`pgr_lineGraphFull` - 用于从输入图中的每个顶点生成线图的变换算法。"

msgid ":doc:`traversal-family`"
msgstr ":doc:`traversal-family`"

msgid ":doc:`pgr_breadthFirstSearch` - Breath first search traversal of the graph."
msgstr ":doc:`pgr_breadthFirstSearch` - 图的广度优先搜索遍历。"

msgid ":doc:`pgr_binaryBreadthFirstSearch` - Breath first search traversal of the graph."
msgstr ":doc:`pgr_binaryBreadthFirstSearch` - 图的广度优先搜索遍历。"

msgid ":doc:`components-family`"
msgstr ":doc:`components-family`"

msgid ":doc:`ordering-family`"
msgstr ":doc:`ordering-family`"

msgid ":doc:`pgr_cuthillMckeeOrdering` - Return reverse Cuthill-McKee ordering of an undirected graph."
msgstr ":doc:`pgr_cuthillMckeeOrdering` - 返回无向图的反向 Cuthill-McKee 排序。"

msgid ":doc:`pgr_topologicalSort` - Linear ordering of the vertices for directed acyclic graph."
msgstr ":doc:`pgr_topologicalSort` - 有向无环图的顶点线性排序。"

#, fuzzy
msgid ":doc:`pgr_sloanOrdering` - Returns the sloan ordering of an undirected graph."
msgstr ":doc:`pgr_cuthillMckeeOrdering` - 返回无向图的反向 Cuthill-McKee 排序。"

#, fuzzy
msgid ":doc:`pgr_kingOrdering` - Returns the King ordering of an undirected graph."
msgstr "``pgr_cuthillMckeeOrdering`` — 返回无向图的反向 Cuthill-Mckee 排序"

msgid ":doc:`metrics-family`"
msgstr ":doc:`metrics-family`"

msgid ":doc:`pgr_betweennessCentrality` - Calculates relative betweenness centrality using Brandes Algorithm"
msgstr ":doc:`pgr_betweennessCentrality` - 使用布兰德斯算法计算相对介度中心性"

#, fuzzy
msgid ":doc:`pgr_bandwidth` - Computes the bandwidth of a graph."
msgstr ":doc:`pgr_withPoints` - 从/到图表上任意点的路线。"

msgid ":doc:`TRSP-family`"
msgstr ":doc:`TRSP-family`"

msgid "categories"
msgstr "类别"

msgid ":doc:`VRP-category`"
msgstr ":doc:`VRP-category`"

msgid "Shortest Path Category"
msgstr "最短路径算法分类"

msgid ":doc:`pgr_bellmanFord`"
msgstr ":doc:`pgr_bellmanFord`"

msgid ":doc:`pgr_dagShortestPath`"
msgstr ":doc:`pgr_dagShortestPath`"

msgid ":doc:`pgr_edwardMoore`"
msgstr ":doc:`pgr_edwardMoore`"

msgid "Planar Family"
msgstr "平面图算法族"

msgid ":doc:`pgr_isPlanar`"
msgstr ":doc:`pgr_isPlanar`"

msgid "Miscellaneous Algorithms"
msgstr "其他算法"

msgid ":doc:`pgr_lengauerTarjanDominatorTree`"
msgstr ":doc:`pgr_lengauerTarjanDominatorTree`"

msgid ":doc:`pgr_stoerWagner`"
msgstr ":doc:`pgr_stoerWagner`"

msgid ":doc:`pgr_transitiveClosure`"
msgstr ":doc:`pgr_transitiveClosure`"

msgid ":doc:`pgr_hawickCircuits`"
msgstr ":doc:`pgr_hawickCircuits`"

msgid "Flow - Family of functions"
msgstr "Flow - 函数族"

msgid ":doc:`pgr_maxFlow` - Only the Max flow calculation using Push and Relabel algorithm."
msgstr ":doc:`pgr_maxFlow` - 仅使用 Push 和 Relabel 算法进行最大流量计算。"

msgid ":doc:`pgr_boykovKolmogorov` - Boykov and Kolmogorov with details of flow on edges."
msgstr ":doc:`pgr_boykovKolmogorov` - Boykov 和 Kolmogorov 的边流动细节。"

msgid ":doc:`pgr_edmondsKarp` - Edmonds and Karp algorithm with details of flow on edges."
msgstr ":doc:`pgr_edmondsKarp` - 带有边流量详细信息的 Edmonds 和 Karp 算法。"

msgid ":doc:`pgr_pushRelabel` - Push and relabel algorithm with details of flow on edges."
msgstr ":doc:`pgr_pushRelabel` - 推送和重新标记算法以及边流量的详细信息。"

msgid "Applications"
msgstr "Applications"

msgid ":doc:`pgr_edgeDisjointPaths` - Calculates edge disjoint paths between two groups of vertices."
msgstr ":doc:`pgr_edgeDisjointPaths` - 计算两组顶点之间的边不相交路径。"

msgid ":doc:`pgr_maxCardinalityMatch` - Calculates a maximum cardinality matching in a graph."
msgstr ":doc:`pgr_maxCardinalityMatch` - 计算图中的最大基数匹配。"

msgid "Flow Functions General Information"
msgstr "流函数一般信息"

msgid "The graph is **directed**."
msgstr "该图是 **有向** 的。"

msgid "Process is done only on edges with positive capacities."
msgstr "仅在具有正容量的边缘上进行处理。"

msgid "When the maximum flow is 0 then there is no flow and **EMPTY SET** is returned."
msgstr "当最大流量为0时则没有流量并返回 **EMPTY SET** 。"

msgid "There is no flow when source has the same value as target."
msgstr "源点与目标点相同时无流通过。"

msgid "Any duplicated values in source or target are ignored."
msgstr "source或target 中的任何重复值都将被忽略。"

msgid "Calculates the flow/residual capacity for each edge. In the output"
msgstr "计算每条边的流量/剩余容量。 在输出中"

msgid "Edges with zero flow are omitted."
msgstr "流量为零的边被忽略。"

msgid "Creates"
msgstr "创建"

msgid "a **super source** and edges from it to all the sources,"
msgstr "一个 **超级源** 和从它到所有源的边，"

msgid "a **super target** and edges from it to all the targetss."
msgstr "一个 **超级目标** 和从它到所有目标的边。"

msgid "The maximum flow through the graph is guaranteed to be the value returned by :doc:`pgr_maxFlow <pgr_maxFlow>` when executed with the same parameters and can be calculated:"
msgstr "当使用相同参数执行时，通过图表的最大流量保证是 :doc:`pgr_maxFlow <pgr_maxFlow>` 返回的值，并且可以计算："

msgid "By aggregation of the outgoing flow from the sources"
msgstr "通过聚合来自源的传出流量"

msgid "By aggregation of the incoming flow to the targets"
msgstr "通过聚合到达目标的传入流量"

msgid ":doc:`pgr_maxFlow` is the maximum Flow and that maximum is guaranteed to be the same on the functions :doc:`pgr_pushRelabel`, :doc:`pgr_edmondsKarp`, :doc:`pgr_boykovKolmogorov`, but the actual flow through each edge may vary."
msgstr ":doc:`pgr_maxFlow` 是最大流量，并且该最大值保证在函数 :doc:`pgr_pushRelabel`, :doc:`pgr_edmondsKarp`, :doc:`pgr_boykovKolmogorov`, 上相同，但通过每条边的实际流量可能会有所不同。"

msgid "Capacity edges"
msgstr "容量边缘"

msgid ":doc:`pgr_pushRelabel`"
msgstr ":doc:`pgr_pushRelabel`"

msgid ":doc:`pgr_edmondsKarp`"
msgstr ":doc:`pgr_edmondsKarp`"

msgid ":doc:`pgr_boykovKolmogorov`"
msgstr ":doc:`pgr_boykovKolmogorov`"

msgid "``reverse_capacity``"
msgstr "``reverse_capacity``"

msgid "Capacity-Cost edges"
msgstr "容量-成本边"

msgid ":doc:`pgr_maxFlowMinCost`"
msgstr ":doc:`pgr_maxFlowMinCost`"

msgid ":doc:`pgr_maxFlowMinCost_Cost`"
msgstr ":doc:`pgr_maxFlowMinCost_Cost`"

msgid "Capacity of the edge (``source``, ``target``)"
msgstr "边 (``source``, ``target``)的容量"

msgid "Capacity of the edge (``target``, ``source``)"
msgstr "边 (``target``, ``source``)的容量"

msgid "Weight of the edge (``source``, ``target``) if it exist"
msgstr "边 (``source``, ``target``)的权重（如果存在）"

msgid "Weight of the edge (``target``, ``source``) if it exist"
msgstr "边(``target``, ``source``)的权重（如果存在）"

msgid "Cost edges"
msgstr "成本边"

msgid ":doc:`pgr_edgeDisjointPaths`"
msgstr ":doc:`pgr_edgeDisjointPaths`"

msgid "Used in"
msgstr "用于"

msgid "**seq**"
msgstr "**seq**"

msgid "``INT``"
msgstr "``INT``"

msgid "**edge**"
msgstr "**edge**"

msgid "Identifier of the edge in the original query (edges_sql)."
msgstr "原始查询中边的标识符 (edges_sql)。"

msgid "**start_vid**"
msgstr "**start_vid**"

msgid "**end_vid**"
msgstr "**end_vid**"

msgid "**flow**"
msgstr "**flow**"

msgid "Flow through the edge in the direction (``start_vid``, ``end_vid``)."
msgstr "沿 (``start_vid``, ``end_vid``)方向流经边缘。"

msgid "**residual_capacity**"
msgstr "**residual_capacity**"

msgid "Residual capacity of the edge in the direction (``start_vid``, ``end_vid``)."
msgstr "(``start_vid``, ``end_vid``)方向上边缘的剩余容量。"

msgid "For :doc:`pgr_maxFlowMinCost`"
msgstr "对于 :doc:`pgr_maxFlowMinCost`"

msgid "**source**"
msgstr "**source**"

msgid "**target**"
msgstr "**target**"

msgid "Flow through the edge in the direction (source, target)."
msgstr "沿方向 (source, target)流经边缘。"

msgid "Residual capacity of the edge in the direction (source, target)."
msgstr "方向 (source, target)上边缘的剩余容量。"

msgid "**cost**"
msgstr "**cost**"

msgid "The cost of sending this flow through the edge in the direction (source, target)."
msgstr "在方向 (source, target)上通过边缘发送此流的成本。"

msgid "**agg_cost**"
msgstr "**agg_cost**"

msgid "The aggregate cost."
msgstr "总成本。"

msgid "Advanced Documentation"
msgstr "高级文档"

msgid "A flow network is a directed graph where each edge has a capacity and a flow. The flow through an edge must not exceed the capacity of the edge. Additionally, the incoming and outgoing flow of a node must be equal except for source which only has outgoing flow, and the destination(sink) which only has incoming flow."
msgstr "流网络是一个有向图，其中每条边都有容量和流量。通过一条边的流量不能超过边的容量。此外，节点的流入流出必须相等，除了源节点只有流出流量，以及目标（汇点）节点只有流入流量。"

msgid "Maximum flow algorithms calculate the maximum flow through the graph and the flow of each edge."
msgstr "最大流量算法计算通过图的最大流量以及每条边的流量。"

msgid "The maximum flow through the graph is guaranteed to be the same with all implementations, but the actual flow through each edge may vary."
msgstr "所有实现中通过图表的最大流量保证相同，但通过每条边的实际流量可能会有所不同。"

msgid "pgr_maxFlow :math:`(edges\\_sql, source\\_vertex, sink\\_vertex)`"
msgstr "pgr_maxFlow :math:`(edges\\_sql, source\\_vertex, sink\\_vertex)`"

msgid "where :math:`edges\\_sql = \\{(id_i, source_i, target_i, capacity_i, reverse\\_capacity_i)\\}`"
msgstr "其中 :math:`edges\\_sql = \\{(id_i, source_i, target_i, capacity_i, reverse\\_capacity_i)\\}`"

msgid "Graph definition"
msgstr "图定义"

msgid "The weighted directed graph, :math:`G(V,E)`, is defined as:"
msgstr "加权有向图， :math:`G(V,E)` 定义为："

msgid "the set of vertices  :math:`V`"
msgstr "顶点集 :math:`V`"

msgid ":math:`source\\_vertex  \\cup  sink\\_vertex  \\bigcup  source_i  \\bigcup  target_i`"
msgstr ":math:`source\\_vertex  \\cup  sink\\_vertex  \\bigcup  source_i  \\bigcup  target_i`"

msgid ":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, capacity_i) \\text{ when } capacity > 0 \\} & \\quad  \\text{ if } reverse\\_capacity = \\varnothing \\\\ \\text{ } & \\quad \\text{ } \\\\ \\{(source_i, target_i, capacity_i) \\text{ when } capacity > 0 \\} & \\text{ } \\\\ \\cup \\{(target_i, source_i, reverse\\_capacity_i) \\text{ when } reverse\\_capacity_i > 0)\\} & \\quad \\text{ if } reverse\\_capacity \\neq \\varnothing \\\\ \\end{cases}`"
msgstr ":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, capacity_i) \\text{ when } capacity > 0 \\} & \\quad  \\text{ if } reverse\\_capacity = \\varnothing \\\\ \\text{ } & \\quad \\text{ } \\\\ \\{(source_i, target_i, capacity_i) \\text{ when } capacity > 0 \\} & \\text{ } \\\\ \\cup \\{(target_i, source_i, reverse\\_capacity_i) \\text{ when } reverse\\_capacity_i > 0)\\} & \\quad \\text{ if } reverse\\_capacity \\neq \\varnothing \\\\ \\end{cases}`"

msgid "Maximum flow problem"
msgstr "最大流量问题"

msgid ":math:`G(V,E)`"
msgstr ":math:`G(V,E)`"

msgid ":math:`source\\_vertex \\in V` the source vertex"
msgstr ":math:`source\\_vertex \\in V` the source vertex"

msgid ":math:`sink\\_vertex \\in V` the sink vertex"
msgstr ":math:`sink\\_vertex \\in V` the sink vertex"

msgid ":math:`pgr\\_maxFlow(edges\\_sql, source, sink) = \\boldsymbol{\\Phi}`"
msgstr ":math:`pgr\\_maxFlow(edges\\_sql, source, sink) = \\boldsymbol{\\Phi}`"

msgid ":math:`\\boldsymbol{\\Phi} = {(id_i, edge\\_id_i, source_i, target_i, flow_i, residual\\_capacity_i)}`"
msgstr ":math:`\\boldsymbol{\\Phi} = {(id_i, edge\\_id_i, source_i, target_i, flow_i, residual\\_capacity_i)}`"

msgid ":math:`\\boldsymbol{\\Phi}` is a subset of the original edges with their residual capacity and flow. The maximum flow through the graph can be obtained by aggregating on the source or sink and summing the flow from/to it. In particular:"
msgstr ":math:`\\boldsymbol{\\Phi}` 是原始边及其剩余容量和流量的子集。 通过图的最大流量可以通过在源或汇上聚合并对来自/到它的流量求和来获得。 尤其："

msgid ":math:`id_i = i`"
msgstr ":math:`id_i = i`"

msgid ":math:`edge\\_id = id_i` in edges_sql"
msgstr ":math:`edge\\_id = id_i` 在edges_sql中"

msgid ":math:`residual\\_capacity_i = capacity_i - flow_i`"
msgstr ":math:`residual\\_capacity_i = capacity_i - flow_i`"

msgid "https://en.wikipedia.org/wiki/Maximum_flow_problem"
msgstr "https://en.wikipedia.org/wiki/Maximum_flow_problem"

msgid "pgRouting extends the `PostGIS <https://postgis.net>`__/`PostgreSQL <https://www.postgresql.org>`__ geospatial database to provide geospatial routing and other network analysis functionality."
msgstr "pgRouting 扩展了 `PostGIS <https://postgis.net>`__/`PostgreSQL <https://www.postgresql.org>`__ 地理空间数据库，以提供地理空间路由和其他网络分析功能。"

msgid "This is the manual for pgRouting |release|."
msgstr "这是pgRouting |release| 手册 。"

msgid "Creative Commons Attribution-Share Alike 3.0 License"
msgstr "知识共享署名 - 相同方式共享 3.0 许可证"

msgid "The pgRouting Manual is licensed under a `Creative Commons Attribution-Share Alike 3.0 License <https://creativecommons.org/licenses/by-sa/3.0/>`_. Feel free to use this material any way you like, but we ask that you attribute credit to the pgRouting Project and wherever possible, a link back to https://pgrouting.org. For other licenses used in pgRouting see the :ref:`license` page."
msgstr "pgRouting 手册根据 `Creative Commons Attribution-Share Alike 3.0 License <https://creativecommons.org/licenses/by-sa/3.0/>`_ 。 您可以随意使用本材料，但我们要求您将功劳归功于 pgRouting 项目，并尽可能提供返回 https://pgrouting.org 的链接。 有关 pgRouting 中使用的其他许可证，请参阅 :ref:`license` 。"

msgid "General"
msgstr "常规"

msgid ":doc:`sampledata` that is used in the examples of this manual."
msgstr "本手册示例中使用的 :doc:`sampledata` 。"

msgid "Pgrouting Concepts"
msgstr "Pgrouting 概念"

msgid ":doc:`routingFunctions`"
msgstr ":doc:`routingFunctions`"

msgid ":doc:`allpairs-family`"
msgstr ":doc:`allpairs-family`"

msgid ":doc:`bdDijkstra-family`"
msgstr ":doc:`bdDijkstra-family`"

msgid ":doc:`dijkstra-family`"
msgstr ":doc:`dijkstra-family`"

msgid ":doc:`kruskal-family`"
msgstr ":doc:`kruskal-family`"

msgid ":doc:`pgr_kruskal`"
msgstr ":doc:`pgr_kruskal`"

msgid ":doc:`pgr_kruskalDD`"
msgstr ":doc:`pgr_kruskalDD`"

msgid ":doc:`pgr_degree` - Returns a set of vertices and corresponding count of incident edges to the vertex."
msgstr ":doc:`pgr_degree` - 返回顶点集及其关联边数统计。"

msgid ":doc:`prim-family`"
msgstr ":doc:`prim-family`"

msgid ":doc:`pgr_prim`"
msgstr ":doc:`pgr_prim`"

msgid ":doc:`pgr_primDD`"
msgstr ":doc:`pgr_primDD`"

msgid ":doc:`reference`"
msgstr ":doc:`reference`"

msgid ":doc:`pgr_version`"
msgstr ":doc:`pgr_version`"

msgid ":doc:`pgr_full_version`"
msgstr ":doc:`pgr_full_version`"

#, fuzzy
msgid ":doc:`utilities-family`"
msgstr ":doc:`metrics-family`"

msgid ":doc:`pgr_extractVertices` - Extracts vertex information based on the edge table information."
msgstr ":doc:`pgr_extractVertices` - 根据边表信息提取顶点信息。"

msgid ":doc:`pgr_findCloseEdges` - Finds close edges of points on the fly"
msgstr ":doc:`pgr_findCloseEdges` - 动态查找最近道路边线"

msgid ":doc:`pgr_separateCrossing` - Breaks geometries that cross each other."
msgstr ":doc:`pgr_separateCrossing` - 断开相互交叉的几何图形。"

msgid ":doc:`pgr_separateTouching` - Breaks geometries that (almost) touch each other."
msgstr ":doc:`pgr_separateTouching` - 断开相互（接近）接触的几何图形。"

msgid ":doc:`withPoints-family`"
msgstr ":doc:`withPoints-family`"

msgid ":doc:`pgr_withPoints` - Route from/to points anywhere on the graph."
msgstr ":doc:`pgr_withPoints` - 从/到图表上任意点的路线。"

msgid ":doc:`pgr_withPointsCost` - Costs of the shortest paths."
msgstr ":doc:`pgr_withPointsCost` - 最短路径的成本。"

msgid ":doc:`pgr_withPointsCostMatrix` - Costs of the shortest paths."
msgstr ":doc:`pgr_withPointsCostMatrix` - 最短路径的成本。"

msgid ":doc:`pgr_withPointsKSP` - K shortest paths."
msgstr ":doc:`pgr_withPointsKSP` -K 最短路径。"

msgid ":doc:`pgr_withPointsDD` - Driving distance."
msgstr ":doc:`pgr_withPointsDD` -行驶距离。"

msgid ":doc:`pgr_withPointsVia` - Via routing"
msgstr ":doc:`pgr_withPointsVia` - 通过路由"

msgid "Functions by categories"
msgstr "按类别划分的函数"

msgid ":doc:`cost-category`"
msgstr ":doc:`cost-category`"

msgid ":doc:`costMatrix-category`"
msgstr ":doc:`costMatrix-category`"

msgid ":doc:`drivingDistance-category`"
msgstr ":doc:`drivingDistance-category`"

msgid ":doc:`KSP-category`"
msgstr ":doc:`KSP-category`"

msgid ":doc:`spanningTree-category`"
msgstr ":doc:`spanningTree-category`"

msgid ":doc:`BFS-category`"
msgstr ":doc:`BFS-category`"

msgid ":doc:`DFS-category`"
msgstr ":doc:`DFS-category`"

msgid ":doc:`withPoints-category`"
msgstr ":doc:`withPoints-category`"

msgid ":doc:`withPoints-family` - Functions based on Dijkstra algorithm."
msgstr ":doc:`withPoints-family` - 基于 Dijkstra 算法的函数。"

msgid "From the :doc:`TRSP-family`:"
msgstr "来自 :doc:`TRSP-family`:"

msgid "Available Functions but not official pgRouting functions"
msgstr "可用函数，但不是官方 pgRouting 函数"

msgid ":doc:`proposed`"
msgstr ":doc:`proposed`"

msgid ":doc:`experimental`"
msgstr ":doc:`experimental`"

msgid ":doc:`release_notes`"
msgstr ":doc:`release_notes`"

msgid "pgRouting 4.0"
msgstr "pgRouting 4.0"

#, fuzzy
msgid "pgRouting 4.0.0-alpha1 Release Notes"
msgstr "pgRouting 4.0.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 4.0.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%204.0.0%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求,请访问： `GitHub 4.0.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%204.0.0%22>`__"

msgid "Build"
msgstr "构建"

msgid "C++ standard is std17"
msgstr ""

msgid "Using this standard, all supported toolchains across our CI matrix will work."
msgstr ""

msgid "The code is not yet modified to use std17:"
msgstr ""

msgid "If needed: ``-DCMAKE_CXX_STANDARD=14`` to lower the standard."
msgstr ""

#, fuzzy
msgid "The user's documentation is built by default."
msgstr "用于用户文档"

#, fuzzy
msgid "The doxygen documentation is built by default."
msgstr "用于用户文档"

#, fuzzy
msgid "For developers:"
msgstr "对于开发者文档"

msgid "Set `-DUSE_CLANG_TIDY=ON` for clang tidy checks."
msgstr ""

msgid "Tidy checks are done on CI."
msgstr ""

#, fuzzy
msgid "Documentation build"
msgstr "文档"

#, fuzzy
msgid "The doxygen documentation is built by default"
msgstr "用于用户文档"

#, fuzzy
msgid "The HTML documentation is built by default"
msgstr "用于用户文档"

#, fuzzy
msgid "The translated languages (en, es, sv, zh_Hans) HTML documentation are built by default"
msgstr "用于用户文档"

msgid "`WITH-DOC` is not used anymore"
msgstr ""

#, fuzzy
msgid "User Documentation is not built when"
msgstr "对于开发者文档"

msgid "Sphinx is not found"
msgstr ""

msgid "When all Sphinx formats are OFF"
msgstr ""

msgid "To not build HTML default format: `-DBUILD_HTML=OFF`"
msgstr ""

msgid "When all languages are OFF"
msgstr ""

msgid "To build only English: `-DES=OFF -DSV=OFF -DZH_HANS=OFF`"
msgstr ""

msgid "Documentation output location: ``build/doc/_build/<format>``"
msgstr ""

msgid "For example: for HTML output is on `build/doc/_build/html` directory"
msgstr ""

#, fuzzy
msgid "Developers' Documentation is not built when"
msgstr "对于开发者文档"

msgid "Doxygen is not found"
msgstr ""

msgid "To not build Doxygen documentation: `-DBUILD_DOXY=OFF`"
msgstr ""

msgid "Summary of changes by function"
msgstr ""

msgid "pgr_aStar"
msgstr "pgr_aStar"

msgid "Combinations signature promoted to official."
msgstr "组合签名已升级为正式版本。"

msgid "pgr_aStarCost"
msgstr "pgr_aStarCost"

msgid "pgr_bandwidth"
msgstr "pgr_bandwidth"

msgid "New experimental function."
msgstr "新实验性功能。"

msgid "pgr_bdAstar"
msgstr "pgr_bdAstar"

msgid "pgr_bdAstarCost"
msgstr "pgr_bdAstarCost"

msgid "pgr_bdDijkstra"
msgstr "pgr_bdDijkstra"

#, fuzzy
msgid "Output columns standardized to |short-generic-result|"
msgstr "输出列是 |old-generic-result|"

msgid "pgr_bdDijkstraCost"
msgstr "pgr_bdDijkstraCost"

msgid "pgr_bellmanFord"
msgstr "pgr_bellmanFord"

msgid "pgr_binaryBreadthFirstSearch"
msgstr "pgr_binaryBreadthFirstSearch"

msgid "pgr_bipartite"
msgstr "pgr_bipartite"

#, fuzzy
msgid "Output columns standardized to |result_node_color|"
msgstr "输出列是 |ksp-result|"

msgid "pgr_boykovKolmogorov"
msgstr "pgr_boykovKolmogorov"

msgid "pgr_breadthFirstSearch"
msgstr "pgr_breadthFirstSearch"

msgid ":"
msgstr ""

msgid "Standardizing output columns to |result-spantree|"
msgstr "将输出列标准化为 |result-spantree|"

msgid "pgr_contraction"
msgstr "pgr_contraction"

msgid "Breaking change, signatures no longer available:"
msgstr ""

msgid "pgr_contraction(text,bigint[],integer,bigint[],boolean)"
msgstr "pgr_contraction(text,bigint[],integer,bigint[],boolean)"

msgid "pgr_dagShortestPath"
msgstr "pgr_dagShortestPath"

msgid "pgr_depthFirstSearch"
msgstr "pgr_depthFirstSearch"

msgid "pgr_dijkstra"
msgstr "pgr_dijkstra"

msgid "pgr_dijkstraCost"
msgstr "pgr_dijkstraCost"

msgid "pgr_dijkstraNear"
msgstr "pgr_dijkstraNear"

msgid "Function promoted to official."
msgstr "函数正式发布。"

msgid "pgr_dijkstraNearCost"
msgstr "pgr_dijkstraNearCost"

msgid "pgr_dijkstraVia"
msgstr "pgr_dijkstraVia"

msgid "pgr_edgeColoring"
msgstr "pgr_edgeColoring"

#, fuzzy
msgid "Output columns standardized to |result_edge_color|"
msgstr "输出列是 |ksp-result|"

msgid "pgr_edgeDisjointPaths"
msgstr "pgr_edgeDisjointPaths"

#, fuzzy
msgid "Output columns standardized to |generic-result|"
msgstr "输出列是 |old-generic-result|"

msgid "pgr_edmondsKarp"
msgstr "pgr_edmondsKarp"

msgid "pgr_edwardMoore"
msgstr "pgr_edwardMoore"

msgid "Version 3.2.0"
msgstr "版本3.2.0"

msgid "New experimental signature:"
msgstr "新实验性签名："

msgid "pgr_edwardMoore(Combinations)"
msgstr "pgr_edwardMoore(组合)"

msgid "Version 3.0.0"
msgstr "版本3.0.0"

msgid "pgr_kingOrdering"
msgstr "pgr_kingOrdering"

msgid "pgr_KSP"
msgstr "pgr_KSP"

msgid "All signatures promoted to official."
msgstr "所有签名均已升级为正式版本。"

msgid "pgr_maxCardinalityMatch"
msgstr "pgr_maxCardinalityMatch"

msgid "pgr_maxCardinalityMatch(text,boolean)"
msgstr "pgr_maxCardinalityMatch(text,boolean)"

msgid "pgr_maxFlow"
msgstr "pgr_maxFlow"

msgid "pgr_pushRelabel"
msgstr "pgr_pushRelabel"

msgid "pgr_sequentialVertexColoring"
msgstr "pgr_sequentialVertexColoring"

msgid "pgr_sloanOrdering"
msgstr "pgr_sloanOrdering"

msgid "pgr_topologicalSort"
msgstr "pgr_topologicalSort"

#, fuzzy
msgid "Standardize output to |result_node_order|"
msgstr "返回集合 |result-node-color|"

msgid "pgr_transitiveClosure"
msgstr "pgr_transitiveClosure"

#, fuzzy
msgid "Standardized output to |result-closure|"
msgstr "将输出列标准化为 |result-spantree|"

msgid "pgr_trsp"
msgstr "pgr_trsp"

msgid "pgr_trsp(text,integer,integer,boolean,boolean,text)"
msgstr "pgr_trsp(text,integer,integer,boolean,boolean,text)"

msgid "pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"
msgstr "pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"

msgid "pgr_trspVia"
msgstr "pgr_trspVia"

#, fuzzy
msgid "pgr_trspviavertices(text,anyarray,boolean,boolean,text)"
msgstr "pgr_trspViaVertices(text,anyarray,boolean,boolean,text)"

msgid "pgr_trspVia_withPoints"
msgstr "pgr_trspVia_withPoints"

#, fuzzy
msgid "**Driving side** parameter is positional unnamed."
msgstr "``driving_side`` 参数以前被命名为可选，现在是强制性的未命名参数。"

#, fuzzy
msgid "Valid values depend on kind of graph"
msgstr "有效值因有向图和无向图而异："

#, fuzzy
msgid "pgr_trspvia_withpoints(text,text,text,anyarray,boolean,boolean,boolean,character,boolean)"
msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

msgid "pgr_trspviaedges(text,integer[],double precision[],boolean,boolean,text)"
msgstr "pgr_trspviaedges(text,integer[],double precision[],boolean,boolean,text)"

msgid "pgr_trsp_withPoints"
msgstr "pgr_trsp_withPoints"

#, fuzzy
msgid "**Driving side** parameter is positional unnamed and compulsory."
msgstr "``driving_side`` 参数以前被命名为可选，现在是强制性的未命名参数。"

#, fuzzy
msgid "pgr_trsp_withpoints(text,text,text,anyarray,anyarray,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "pgr_trsp_withpoints(text,text,text,anyarray,bigint,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "pgr_trsp_withpoints(text,text,text,bigint,anyarray,boolean,character,boolean)"
msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
msgid "pgr_trsp_withpoints(text,text,text,bigint,bigint,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

#, fuzzy
msgid "pgr_trsp_withpoints(text,text,text,text,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

msgid "pgr_TSP"
msgstr "pgr_TSP"

#, fuzzy
msgid "Results change depending on input order"
msgstr "结果按以下顺序递增排序："

#, fuzzy
msgid "Only for undirected graphs"
msgstr "在无向图上："

#, fuzzy
msgid "pgr_tsp(text,bigint,bigint,double precision,integer,integer,integer,double precision,double precision,double precision,boolean)"
msgstr "pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"

msgid "pgr_TSPeuclidean"
msgstr "pgr_TSPeuclidean"

#, fuzzy
msgid "pgr_tspeuclidean(text,bigint,bigint,double precision,integer,integer, integer,double precision,double precision,double precision,boolean)"
msgstr "pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"

msgid "pgr_turnRestrictedPath"
msgstr "pgr_turnRestrictedPath"

#, fuzzy
msgid "Output columns standardized to |nksp-result|"
msgstr "输出列是 |ksp-result|"

msgid "pgr_withPoints"
msgstr "pgr_withPoints"

#, fuzzy
msgid "pgr_withpoints(text,text,anyarray,anyarray,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "pgr_withpoints(text,text,anyarray,bigint,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "pgr_withpoints(text,text,bigint,anyarray,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

#, fuzzy
msgid "pgr_withpoints(text,text,bigint,bigint,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

#, fuzzy
msgid "pgr_withpoints(text,text,text,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

msgid "pgr_withPointsCost"
msgstr "pgr_withPointsCost"

#, fuzzy
msgid "**Driving side** parameter is unnamed and compulsory."
msgstr "``driving_side`` 参数以前被命名为可选，现在是强制性的未命名参数。"

#, fuzzy
msgid "Output columns standardized to |matrix-result|"
msgstr "输出列是 |ksp-result|"

#, fuzzy
msgid "pgr_withpointscost(text,text,anyarray,anyarray,boolean,character)"
msgstr "_pgr_trsp(text,text,anyarray,anyarray,boolean)"

#, fuzzy
msgid "pgr_withpointscost(text,text,anyarray,bigint,boolean,character)"
msgstr "_pgr_trsp(text,text,anyarray,bigint,boolean)"

#, fuzzy
msgid "pgr_withpointscost(text,text,bigint,anyarray,boolean,character)"
msgstr "_pgr_trsp(text,text,bigint,anyarray,boolean)"

#, fuzzy
msgid "pgr_withpointscost(text,text,bigint,bigint,boolean,character)"
msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
msgid "pgr_withpointscost(text,text,text,boolean,character)"
msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

msgid "pgr_withPointsCostMatrix"
msgstr "pgr_withPointsCostMatrix"

#, fuzzy
msgid "pgr_withpointscostmatrix(text,text,anyarray,boolean,character)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

msgid "pgr_withPointsDD"
msgstr "pgr_withPointsDD"

msgid "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

msgid "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

msgid "pgr_withPointsKSP"
msgstr "pgr_withPointsKSP"

#, fuzzy
msgid "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,character,boolean)"
msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

msgid "pgr_withPointsVia"
msgstr "pgr_withPointsVia"

#, fuzzy
msgid "pgr_withpointsvia(text,text,anyarray,boolean,boolean,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

msgid "Functions promoted to official"
msgstr "正式版功能函数"

#, fuzzy
msgid "`#2701 <https://github.com/pgRouting/pgrouting/issues/2701>`__: pgr_trsp"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2701 <https://github.com/pgRouting/pgrouting/issues/2701>`__: pgr_trspVia"
msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
msgid "`#2701 <https://github.com/pgRouting/pgrouting/issues/2701>`__: pgr_trspVia_withPoints"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2701 <https://github.com/pgRouting/pgrouting/issues/2701>`__: pgr_trsp_withPoints"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2700 <https://github.com/pgRouting/pgrouting/issues/2700>`__: pgr_withPoints"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2700 <https://github.com/pgRouting/pgrouting/issues/2700>`__: pgr_withPointsCost"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2700 <https://github.com/pgRouting/pgrouting/issues/2700>`__: pgr_withPointsCostMatrix"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2700 <https://github.com/pgRouting/pgrouting/issues/2700>`__: pgr_withPointsDD"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2700 <https://github.com/pgRouting/pgrouting/issues/2700>`__: pgr_withPointsKSP"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2700 <https://github.com/pgRouting/pgrouting/issues/2700>`__: pgr_withPointsVia"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2983 <https://github.com/pgRouting/pgrouting/issues/2983>`__: pgr_dijkstraNear"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2983 <https://github.com/pgRouting/pgrouting/issues/2983>`__: pgr_dijkstraNearCost"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2983 <https://github.com/pgRouting/pgrouting/issues/2983>`__: pgr_dijkstraVia"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

msgid "Signatures promoted to official"
msgstr "正式版函数签名"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_aStar(Combinations)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_aStarCost(Combinations)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_bdAstar(Combinations)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_bdAstarCost(Combinations)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_bdDijkstra(Combinations)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_bdDijkstraCost(Combinations)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_dijkstra(Combinations)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_dijkstraCost(Combinations)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_KSP(All signatures)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_boykovKolmogorov(Combinations)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_edmondsKarp(Combinations)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_maxFlow(Combinations)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: pgr_pushRelabel(Combinations)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "New experimental functions."
msgstr "新实验性函数"

msgid "Metrics"
msgstr "Metrics"

#, fuzzy
msgid "`#2951 <https://github.com/pgRouting/pgrouting/issues/2951>`__: pgr_bandwidth"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

msgid "Ordering"
msgstr "排序"

#, fuzzy
msgid "`#2954 <https://github.com/pgRouting/pgrouting/issues/2954>`__: pgr_kingOrdering"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2955 <https://github.com/pgRouting/pgrouting/issues/2955>`__: pgr_sloanOrdering"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

msgid "SQL signatures and output standardization"
msgstr ""

#, fuzzy
msgid "`#2904 <https://github.com/pgRouting/pgrouting/issues/2904>`__: Standardize output columns of functions with different output"
msgstr "`#2057 <https://github.com/pgRouting/pgrouting/issues/2057>`__: trspViaEdges 列的顺序不同"

#, fuzzy
msgid "columns within overloads"
msgstr "函数的重载"

#, fuzzy
msgid "Standardized to |short-generic-result|"
msgstr "将输出列标准化为 |short-generic-result|"

#, fuzzy
msgid "`#2905 <https://github.com/pgRouting/pgrouting/issues/2905>`__: pgr_withPoints"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2906 <https://github.com/pgRouting/pgrouting/issues/2906>`__: pgr_bdDijkstra"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2907 <https://github.com/pgRouting/pgrouting/issues/2907>`__: pgr_bellmanFord"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2908 <https://github.com/pgRouting/pgrouting/issues/2908>`__: pgr_binaryBreadthFirstSearch"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2910 <https://github.com/pgRouting/pgrouting/issues/2910>`__: pgr_edwardMoore"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__: pgr_dagShortestPath"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "Standardized to |matrix-result|"
msgstr "输出列是 |ksp-result|"

#, fuzzy
msgid "`#2905 <https://github.com/pgRouting/pgrouting/issues/2905>`__: pgr_withPointsCost"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2905 <https://github.com/pgRouting/pgrouting/issues/2905>`__: pgr_withPointsCostMatrix"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "Standardized to |generic-result|"
msgstr "将输出列标准化为 |short-generic-result|"

#, fuzzy
msgid "`#2909 <https://github.com/pgRouting/pgrouting/issues/2909>`__: pgr_edgeDisjointPaths"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2909 <https://github.com/pgRouting/pgrouting/issues/2909>`__: pgr_turnRestrictedPath"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "Standardized to |result_edge_color|"
msgstr "返回集合 |result-edge-color|"

#, fuzzy
msgid "`#2924 <https://github.com/pgRouting/pgrouting/issues/2924>`__: pgr_edgeColoring"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "Standardized to |result_node_color|"
msgstr "返回集合 |result-node-color|"

#, fuzzy
msgid "`#2924 <https://github.com/pgRouting/pgrouting/issues/2924>`__: pgr_bipartite"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2927 <https://github.com/pgRouting/pgrouting/issues/2927>`__: pgr_sequentialVertexColoring"
msgstr "`#2202 <https://github.com/pgRouting/pgrouting/issues/2202>`__: pgr_sequentialVertexColoring 变为提议状态"

#, fuzzy
msgid "Standardized to |result-spantree|"
msgstr "将输出列标准化为 |result-spantree|"

#, fuzzy
msgid "`#2931 <https://github.com/pgRouting/pgrouting/issues/2931>`__: pgr_breadthFirstSearch"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2931 <https://github.com/pgRouting/pgrouting/issues/2931>`__: pgr_depthFirstSearch"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "Standardized to |result_node_order|"
msgstr "返回集合 |result-node-color|"

#, fuzzy
msgid "`#2934 <https://github.com/pgRouting/pgrouting/issues/2934>`__: pgr_topologicalSort"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "Standardized to |result-closure|"
msgstr "将输出列标准化为 |result-spantree|"

#, fuzzy
msgid "`#2934 <https://github.com/pgRouting/pgrouting/issues/2934>`__: pgr_transitiveClosure"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

msgid "Removal of SQL deprecated signatures"
msgstr "移除已弃用的 SQL 函数签名"

msgid "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trspVia"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2888 <https://github.com/pgRouting/pgrouting/issues/2888>`__: pgr_findCloseEdges"
msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

#, fuzzy
msgid "pgr_findcloseedges(text,geometry,double precision,integer,boolean,boolean)"
msgstr "pgr_trspviaedges(text,integer[],double precision[],boolean,boolean,text)"

#, fuzzy
msgid "pgr_findcloseedges(text,geometry[],double precision,integer,boolean,boolean)"
msgstr "pgr_trspviaedges(text,integer[],double precision[],boolean,boolean,text)"

#, fuzzy
msgid "`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__: pgr_withPointsDD"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__: pgr_withPointsKSP"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2899 <https://github.com/pgRouting/pgrouting/issues/2899>`__: pgr_maxCardinalityMatch"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__: pgr_TSP"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__: pgr_TSPeuclidean"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

msgid "Removal of SQL deprecated functions"
msgstr "移除已弃用的SQL函数"

#, fuzzy
msgid "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspViaedges"
msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
msgid "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__: pgr_trspViaVertices"
msgstr "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__: pgr_trspviavertices"

msgid "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__: pgr_alphaShape"
msgstr "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__: pgr_alphaShape"

#, fuzzy
msgid "`#2751 <https://github.com/pgRouting/pgrouting/issues/2751>`__: pgr_createTopology"
msgstr "`#2751 <https://github.com/pgRouting/pgrouting/issues/2851>`__: pgr_createTopology"

msgid "`#2752 <https://github.com/pgRouting/pgrouting/issues/2752>`__: pgr_analyzeGraph"
msgstr "`#2752 <https://github.com/pgRouting/pgrouting/issues/2752>`__: pgr_analyzeGraph"

msgid "`#2755 <https://github.com/pgRouting/pgrouting/issues/2755>`__: pgr_analyzeOneWay"
msgstr "`#2755 <https://github.com/pgRouting/pgrouting/issues/2755>`__: pgr_analyzeOneWay"

msgid "`#2827 <https://github.com/pgRouting/pgrouting/issues/2827>`__: pgr_createVerticesTable"
msgstr "`#2827 <https://github.com/pgRouting/pgrouting/issues/2827>`__: pgr_createVerticesTable"

#, fuzzy
msgid "`#2886 <https://github.com/pgRouting/pgrouting/issues/2886>`__: pgr_nodeNetwork"
msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

#, fuzzy
msgid "Removal of SQL deprecated internal functions"
msgstr "移除已弃用的SQL内部函数"

#, fuzzy
msgid "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__ _pgr_alphaShape(text,double precision)"
msgstr "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__: pgr_alphaShape"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_checkVertTab(text,text[],integer,text)"
msgstr "`#2827 <https://github.com/pgRouting/pgrouting/issues/2827>`__: pgr_createVerticesTable"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_createIndex(text,text,text,integer,text)"
msgstr "`#2786 <https://github.com/pgRouting/pgrouting/issues/2786>`__:pgr_contraction(edges) 新签名"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_createIndex(text,text,text,text,integer,text)"
msgstr "`#2786 <https://github.com/pgRouting/pgrouting/issues/2786>`__:pgr_contraction(edges) 新签名"

#, fuzzy
msgid "`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__ _pgr_dagShortestPath(text,anyarray,anyarray,boolean,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__ _pgr_dagShortestPath(text,text,boolean,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ _pgr_dijkstraNear(text,anyarray,anyarray,bigint,boolean)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ _pgr_dijkstraNear(text,anyarray,bigint,bigint,boolean)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ _pgr_dijkstraNear(text,bigint,anyarray,bigint,boolean)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ _pgr_dijkstra(text,anyarray,anyarray,boolean,boolean,boolean,bigint)"
msgstr "_pgr_dijkstra(text,anyarray,anyarray,boolean,boolean,boolean,bigint)"

#, fuzzy
msgid "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ _pgr_dijkstra(text,anyarray,anyarray,boolean,boolean,boolean,bigint,boolean)"
msgstr "_pgr_dijkstra(text,anyarray,anyarray,boolean,boolean,boolean,bigint)"

#, fuzzy
msgid "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ _pgr_dijkstra(text,text,boolean,boolean,bigint,boolean)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ _pgr_dijkstra(text,text,boolean,boolean,boolean)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2735 <https://github.com/pgRouting/pgrouting/issues/2735>`__ _pgr_drivingDistance(text,anyarray,double precision,boolean,boolean)"
msgstr "_pgr_drivingdistance(text,anyarray,double precision,boolean,boolean)"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_endPoint(geometry)"
msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ __pgr_getColumnName(text,text,integer,text)"
msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ __pgr_getColumnName(text,text,text,integer,text)"
msgstr "`#2786 <https://github.com/pgRouting/pgrouting/issues/2786>`__:pgr_contraction(edges) 新签名"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ __pgr_getColumnType(text,text,integer,text)"
msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ __pgr_getColumnType(text,text,text,integer,text)"
msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ __pgr_getTableName(text,integer,text)"
msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_isColumnIndexed(text,text,integer,text)"
msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_isColumnIndexed(text,text,text,integer,text)"
msgstr "`#2786 <https://github.com/pgRouting/pgrouting/issues/2786>`__:pgr_contraction(edges) 新签名"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_isColumnIntable(text,text)"
msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
msgid "`#2745 <https://github.com/pgRouting/pgrouting/issues/2745>`__ _pgr_kruskal(text,anyarray,text,bigint,double precision)"
msgstr "`#2087 <https://github.com/pgRouting/pgrouting/issues/2087>`__: pgr_extractVertices 变为提议状态"

#, fuzzy
msgid "`#2897 <https://github.com/pgRouting/pgrouting/issues/2897>`__ _pgr_ksp(text,anyarray,anyarray,integer,boolean,boolean,boolean)"
msgstr "_pgr_dijkstra(text,anyarray,anyarray,boolean,boolean,boolean,bigint)"

#, fuzzy
msgid "`#2897 <https://github.com/pgRouting/pgrouting/issues/2897>`__ _pgr_ksp(text,bigint,bigint,integer,boolean,boolean)"
msgstr "`#2827 <https://github.com/pgRouting/pgrouting/issues/2827>`__: pgr_createVerticesTable"

#, fuzzy
msgid "`#2897 <https://github.com/pgRouting/pgrouting/issues/2897>`__ _pgr_ksp(text,text,integer,boolean,boolean)"
msgstr "`#2827 <https://github.com/pgRouting/pgrouting/issues/2827>`__: pgr_createVerticesTable"

#, fuzzy
msgid "`#2899 <https://github.com/pgRouting/pgrouting/issues/2899>`__ _pgr_maxCardinalityMatch(text,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_msg(integer,text,text)"
msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_onerror(boolean,integer,text,text,text,text)"
msgstr "`#2827 <https://github.com/pgRouting/pgrouting/issues/2827>`__: pgr_createVerticesTable"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_pointtoid(geometry,double precision,text,integer)"
msgstr "`#2786 <https://github.com/pgRouting/pgrouting/issues/2786>`__:pgr_contraction(edges) 新签名"

#, fuzzy
msgid "`#2743 <https://github.com/pgRouting/pgrouting/issues/2743>`__ _pgr_prim(text,anyarray,text,bigint,double precision)"
msgstr "`#2087 <https://github.com/pgRouting/pgrouting/issues/2087>`__: pgr_extractVertices 变为提议状态"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_quote_ident(text)"
msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_startPoint(geometry)"
msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ _pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"
msgstr "_pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ _pgr_trsp(text,text,anyarray,anyarray,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ _pgr_trsp(text,text,anyarray,bigint,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ _pgr_trsp(text,text,bigint,anyarray,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ _pgr_trsp(text,text,bigint,bigint,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__ _pgr_trspViaVertices(text,integer[],boolean,boolean,text)"
msgstr "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__: pgr_trspviavertices"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ _pgr_trspVia_withPoints(text,text,text,anyarray,boolean,boolean,boolean,character,boolean)"
msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ _pgr_trsp_withPoints(text,text,text,anyarray,anyarray,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ _pgr_trsp_withPoints(text,text,text,text,boolean,character,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__ _pgr_tspEuclidean(text,bigint,bigint,double precision,integer,integer,integer,double precision,double precision,double precision,boolean)"
msgstr "_pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"

#, fuzzy
msgid "`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__ _pgr_tsp(text,bigint,bigint,double precision,integer,integer,integer,double precision,double precision,double precision,boolean)"
msgstr "_pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"

#, fuzzy
msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_versionLess(text,text)"
msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
msgid "`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__ _pgr_withPointsDD(text,text,anyarray,double precision,boolean,character,boolean,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__ _pgr_withPointsKSP(text,text,anyarray,anyarray,integer,character,boolean,boolean,boolean,boolean)"
msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
msgid "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__ _pgr_withPointsKSP(text,text,bigint,bigint,integer,boolean,boolean,character,boolean)"
msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
msgid "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__ _pgr_withPointsKSP(text,text,text,integer,character,boolean,boolean,boolean)"
msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
msgid "`#2741 <https://github.com/pgRouting/pgrouting/issues/2741>`__ _pgr_withPointsVia(text,bigint[],double precision[],boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2741 <https://github.com/pgRouting/pgrouting/issues/2741>`__ _pgr_withPointsVia(text,text,anyarray,boolean,boolean,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ _trsp(text,text,anyarray,anyarray,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ _v4trsp(text,text,anyarray,anyarray,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ _v4trsp(text,text,text,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "Summary of functions and signatures no longer on pgrouting"
msgstr "为 pgRouting 添加功能"

#, fuzzy
msgid "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__ pgr_alphashape(geometry,double precision)"
msgstr "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__: pgr_alphaShape"

#, fuzzy
msgid "`#2752 <https://github.com/pgRouting/pgrouting/issues/2752>`__ pgr_analyzegraph(text,double precision,text,text,text,text,text)"
msgstr "`#2752 <https://github.com/pgRouting/pgrouting/issues/2752>`__: pgr_analyzeGraph"

#, fuzzy
msgid "`#2755 <https://github.com/pgRouting/pgrouting/issues/2755>`__ pgr_analyzeoneway(text,text[],text[],text[],text[],boolean,text,text,text)"
msgstr "_pgr_createindex(text,text,text,text,integer,text)"

#, fuzzy
msgid "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__ pgr_contraction(text,bigint[],integer,bigint[],boolean)"
msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
msgid "`#2751 <https://github.com/pgRouting/pgrouting/issues/2751>`__ pgr_createtopology(text,double precision,text,text,text,text,text,boolean)"
msgstr "_pgr_createindex(text,text,text,text,integer,text)"

#, fuzzy
msgid "`#2827 <https://github.com/pgRouting/pgrouting/issues/2827>`__ pgr_createverticestable(text,text,text,text,text)"
msgstr "`#2827 <https://github.com/pgRouting/pgrouting/issues/2827>`__: pgr_createVerticesTable"

#, fuzzy
msgid "`#2888 <https://github.com/pgRouting/pgrouting/issues/2888>`__ pgr_findcloseedges(text,geometry,double precision,integer,boolean,boolean)"
msgstr "pgr_trspviaedges(text,integer[],double precision[],boolean,boolean,text)"

#, fuzzy
msgid "`#2888 <https://github.com/pgRouting/pgrouting/issues/2888>`__ pgr_findcloseedges(text,geometry[],double precision,integer,boolean,boolean)"
msgstr "pgr_trspviaedges(text,integer[],double precision[],boolean,boolean,text)"

#, fuzzy
msgid "`#2899 <https://github.com/pgRouting/pgrouting/issues/2899>`__ pgr_maxCardinalityMatch(text,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2886 <https://github.com/pgRouting/pgrouting/issues/2886>`__ pgr_nodenetwork(text,double precision,text,text,text,text,boolean)"
msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"
msgstr "_pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ pgr_trsp(text,integer,integer,boolean,boolean,text)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__ pgr_trspViaedges(text,integer[],double precision[],boolean,boolean,text)"
msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
msgid "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__ pgr_trspViaVertices(text,anyarray,boolean,boolean,text)"
msgstr "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__: pgr_trspviavertices"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_trspVia_withPoints(text,text,text,anyarray,boolean,boolean,boolean,character,boolean)"
msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_trsp_withPoints(text,text,text,anyarray,anyarray,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_trsp_withPoints(text,text,text,anyarray,bigint,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_trsp_withPoints(text,text,text,bigint,anyarray,boolean,character,boolean)"
msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_trsp_withPoints(text,text,text,bigint,bigint,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_trsp_withPoints(text,text,text,text,boolean,character,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__ pgr_tspEuclidean(text,bigint,bigint,double precision,integer,integer,integer,double precision,double precision,double precision,boolean)"
msgstr "_pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"

#, fuzzy
msgid "`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__ pgr_tsp(text,bigint,bigint,double precision,integer,integer,integer,double precision,double precision,double precision,boolean)"
msgstr "_pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withPointsCostMatrix(text,text,anyarray,boolean,character)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withPointsCost(text,text,anyarray,anyarray,boolean,character)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withPointsCost(text,text,anyarray,bigint,boolean,character)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withPointsCost(text,text,bigint,anyarray,boolean,character)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withPointsCost(text,text,bigint,bigint,boolean,character)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withPointsCost(text,text,text,boolean,character)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__ pgr_withPointsDD(text,text,anyarray,double precision,boolean,character,boolean,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__ pgr_withPointsDD(text,text,bigint,double precision,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

#, fuzzy
msgid "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__ pgr_withPointsKSP(text,text,bigint,bigint,integer,boolean,boolean,character,boolean)"
msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withPoints(text,text,anyarray,anyarray,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withPoints(text,text,anyarray,bigint,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withPoints(text,text,bigint,anyarray,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withPoints(text,text,bigint,bigint,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withPoints(text,text,text,boolean,character,boolean)"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withPointsVia(text,text,anyarray,boolean,boolean,boolean,character,boolean)"
msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
msgid "Code enhancements"
msgstr "代码改进"

msgid "Removal of unused C/C++ code"
msgstr "移除未使用的C/C++代码"

msgid "Refactor the Script to build the update PostgreSQL file."
msgstr ""

msgid "One process & driver for:"
msgstr ""

msgid "allpairs: johnson and Floyd-Warshall"
msgstr ""

msgid "Shortest path: Dijkstra and withPoints using Dijkstra"
msgstr ""

msgid "Deprecation of internal C/C++ functions"
msgstr "弃用内部C/C++函数"

msgid "Deprecated functions are substituted by new function."
msgstr ""

#, fuzzy
msgid "_pgr_drivingDistance => _pgr_drivingDistancev4"
msgstr "``pgr_drivingDistance`` - 返回起始节点的行驶距离。"

#, fuzzy
msgid "_pgr_withPointsDD => _pgr_withPointsddv4"
msgstr "pgr_withPointsKSP 是 **带有点** 的 pgr_ksp"

msgid "_pgr_kruskal => _pgr_kruskalv4"
msgstr ""

msgid "_pgr_prim => _pgr_primv4"
msgstr ""

#, fuzzy
msgid "_pgr_dijkstra => _pgr_dijkstra_v4"
msgstr "pgr_bddijkstra - 使用 pgr_bdDijkstra代替"

#, fuzzy
msgid "_pgr_withPointsKSP => _pgr_withPointsKSP_v4"
msgstr "pgr_withPointsKSP 是 **带有点** 的 pgr_ksp"

#, fuzzy
msgid "_pgr_trspVia_withPoints => _pgr_trspVia_withPoints_v4"
msgstr "pgr_withPoints 是 **带有点** 的 pgr_dijkstra"

#, fuzzy
msgid "_pgr_trsp_withPoints => _pgr_trsp_withPoints_v4"
msgstr "pgr_withPointsKSP 是 **带有点** 的 pgr_ksp"

#, fuzzy
msgid "_pgr_withPointsVia => _pgr_withPointsvia_v4"
msgstr "pgr_withPointsvia 是 pgr_dijkstraVia **with points** 的版本"

msgid "Internal C/C++ functions in legacy"
msgstr "遗留代码中内部 C/C++ 函数"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ _trsp"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ _v4trsp"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
msgid "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__ _pgr_alphaShape"
msgstr "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__: pgr_alphaShape"

#, fuzzy
msgid "`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__ _pgr_dagShortestPath"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

msgid "All releases"
msgstr "所有版本"

msgid "Kruskal - Family of functions"
msgstr "Kruskal - 函数族"

msgid "Kruskal's algorithm is a greedy minimum spanning tree algorithm that in each cycle finds and adds the edge of the least possible weight that connects any two trees in the forest."
msgstr "克鲁斯卡尔算法是一种贪婪的最小生成树算法，它在每个循环中查找并添加连接森林中任意两棵树的最小可能权重的边。"

msgid "**The main Characteristics are:**"
msgstr "**主要特点是：**"

msgid "The total weight of all the edges in the tree or forest is minimized."
msgstr "树或森林中所有边的总权重最小化。"

msgid "Kruskal's running time: :math:`O(E * log E)`"
msgstr "克鲁斯卡尔的运行时间： :math:`O(E * log E)`"

msgid "Metrics - Family of functions"
msgstr "Metrics - 功能系列"

msgid "Migration guide"
msgstr "迁移指南"

msgid "Several functions are having changes on the signatures, and/or have been replaced by new functions."
msgstr "多个函数的签名发生了变化，和/或已被新函数取代。"

msgid "Results can be different because of the changes."
msgstr "结果可能会因变化而不同。"

msgid "All deprecated functions will be removed on next major version 4.0.0"
msgstr "所有已弃用函数将在下一个主版本 4.0.0 中被移除"

#, fuzzy
msgid "Migration to standardized columns"
msgstr "限制迁移"

msgid "There has been an effort to standardize function output columns names and types."
msgstr ""

msgid ":ref:`pgRouting-concepts:Result columns for cost functions`"
msgstr ":ref:`pgRouting-concepts:Result columns for cost functions`"

#, fuzzy
msgid "|matrix-result|"
msgstr "|matrix-result| 的集合"

msgid ":ref:`pgRouting-concepts:Result columns for single path functions`"
msgstr ":ref:`pgRouting-concepts:Result columns for single path functions`"

#, fuzzy
msgid "|short-generic-result|"
msgstr "返回集合 |short-generic-result|"

msgid ":ref:`pgRouting-concepts:Result columns for spanning tree functions`"
msgstr ":ref:`pgRouting-concepts:Result columns for spanning tree functions`"

msgid "|result-spantree|"
msgstr "|result-spantree|"

#, fuzzy
msgid "Function"
msgstr "新函数:"

msgid ":doc:`pgr_dijkstra`"
msgstr ":doc:`pgr_dijkstra`"

#, fuzzy
msgid "`Migration of single path functions`_"
msgstr "`迁移限制`_"

#, fuzzy
msgid ":doc:`pgr_aStar`"
msgstr ":doc:`pgr_aStarCost`"

#, fuzzy
msgid ":doc:`pgr_bdAstar`"
msgstr ":doc:`pgr_bdAstarCost`"

msgid ":doc:`pgr_drivingDistance`"
msgstr ":doc:`pgr_drivingDistance`"

#, fuzzy
msgid "`Migration of spanning tree functions`_"
msgstr "`迁移限制`_"

#, fuzzy
msgid ":doc:`pgr_withPointsDD`"
msgstr ":doc:`pgr_withPoints`"

#, fuzzy
msgid ":doc:`pgr_bdDijkstra`"
msgstr ":doc:`pgr_dijkstra`"

#, fuzzy
msgid ":doc:`pgr_binaryBreadthFirstSearch`"
msgstr "pgr_binaryBreadthFirstSearch"

#, fuzzy
msgid ":doc:`pgr_bipartite`"
msgstr ":doc:`pgr_prim`"

#, fuzzy
msgid "`Migration of output column name change`_"
msgstr "`迁移限制`_"

#, fuzzy
msgid ":doc:`pgr_breadthFirstSearch`"
msgstr "pgr_binaryBreadthFirstSearch"

#, fuzzy
msgid ":doc:`pgr_depthFirstSearch`"
msgstr "pgr_depthFirstSearch"

#, fuzzy
msgid ":doc:`pgr_edgeColoring`"
msgstr "pgr_edgeColoring"

#, fuzzy
msgid "`Migration of multiple paths functions`_"
msgstr "`迁移限制`_"

#, fuzzy
msgid ":doc:`pgr_sequentialVertexColoring`"
msgstr "pgr_sequentialVertexColoring"

#, fuzzy
msgid ":doc:`pgr_topologicalSort`"
msgstr "pgr_topologicalSort"

msgid ":doc:`pgr_withPoints`"
msgstr ":doc:`pgr_withPoints`"

#, fuzzy
msgid "`Migration of cost functions`_"
msgstr "`迁移限制`_"

#, fuzzy
msgid "Migration of cost functions"
msgstr "限制迁移"

msgid "The standardized :ref:`pgRouting-concepts:Result columns for cost functions` are |matrix-result|"
msgstr ""

msgid "The following functions need to be migrated when they are being used in an application."
msgstr ""

#, fuzzy
msgid "Version"
msgstr "版本3.0"

msgid "From"
msgstr ""

msgid "``pgr_withPointsCost``"
msgstr "``pgr_withPointsCost``"

msgid "v < 4.0"
msgstr ""

#, fuzzy
msgid "|matrix-pid|"
msgstr "返回 |matrix-pid| 的集合"

msgid "``pgr_withPointsCostMatrix``"
msgstr "``pgr_withPointsCostMatrix``"

#, fuzzy
msgid "**to** |matrix-result|"
msgstr "|matrix-result| 的集合"

#, fuzzy
msgid "Migration of |matrix-pid|"
msgstr "限制迁移"

msgid "Signatures to be migrated:"
msgstr "要迁移的签名："

msgid "One to One"
msgstr "One to One"

msgid "One to Many"
msgstr "One to Many"

msgid "Many to One"
msgstr "Many to One"

msgid "Many to Many"
msgstr "Many to Many"

msgid "Combinations"
msgstr "组合"

#, fuzzy
msgid "Breaking change"
msgstr "重大变更："

msgid "If using ``pgr_withPointsCost``: column names must be changed after updating pgRouting"
msgstr ""

#, fuzzy
msgid "New output columns are |matrix-result|"
msgstr "输出列是 |ksp-result|"

msgid "To get the old version column names: rename ``start_vid`` to ``start_pid`` and ``end_vid`` to ``end_pid``."
msgstr ""

msgid "Examples"
msgstr "示例"

#, fuzzy
msgid "Examples for One to One for cost functions"
msgstr "成本函数结果列"

#, fuzzy
msgid "Using ``pgr_withPointsCost``"
msgstr "``pgr_withPointsCost``"

#, fuzzy
msgid "Migrating `this v3.8 <https://docs.pgrouting.org/3.8/en/pgr_withPointsCost.html#one-to-one>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

msgid "from"
msgstr "从"

msgid "to"
msgstr "到"

#, fuzzy
msgid "Examples for One to Many for cost functions"
msgstr "成本函数结果列"

#, fuzzy
msgid "Migrating `this v3.8 <https://docs.pgrouting.org/3.8/en/pgr_withPointsCost.html#one-to-many>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

#, fuzzy
msgid "Examples for Many to One for cost functions"
msgstr "成本函数结果列"

#, fuzzy
msgid "Migrating `this v3.8 <https://docs.pgrouting.org/3.8/en/pgr_withPointsCost.html#many-to-one>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

#, fuzzy
msgid "Examples for Many to Many for cost functions"
msgstr "成本函数结果列"

#, fuzzy
msgid "Migrating `this v3.8 <https://docs.pgrouting.org/3.8/en/pgr_withPointsCost.html#many-to-many>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

#, fuzzy
msgid "Examples for Combinations for cost functions"
msgstr "成本函数结果列"

#, fuzzy
msgid "Migrating `this v3.8 <https://docs.pgrouting.org/3.8/en/pgr_withPointsCost.html#combinations>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsKSP.html#signatures>`__ 示例。"

#, fuzzy
msgid "Migration of multiple paths functions"
msgstr "限制迁移"

#, fuzzy
msgid "The standardized :ref:`pgRouting-concepts:Result columns for single path functions` are |nksp-result|"
msgstr "将输出列标准化为 |short-generic-result|"

msgid "``pgr_KSP``"
msgstr "``pgr_KSP``"

msgid "v < 3.6"
msgstr ""

msgid ":ref:`from_ksp_result`"
msgstr ":ref:`from_ksp_result`"

msgid "``pgr_edgeDisjointPaths``"
msgstr "``pgr_edgeDisjointPaths``"

msgid ":ref:`from_result_disjoint`"
msgstr ":ref:`from_result_disjoint`"

#, fuzzy
msgid "Migration of |ksp-result|"
msgstr "返回 |old-pid-result| 的集合"

#, fuzzy
msgid "|nksp-result|"
msgstr "|ksp-result|"

#, fuzzy
msgid "Before updating pgRouting, enumerate the |ksp-result|"
msgstr "结果列的重大变化"

msgid "One to One example using ``pgr_KSP``"
msgstr ""

msgid "Using `this <https://docs.pgrouting.org/3.5/en/pgr_KSP.html#signatures>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_KSP.html#signatures>`__ 示例。"

#, fuzzy
msgid "Migration of |result-disjoint|"
msgstr "|result-dij-dd|"

#, fuzzy
msgid "Before updating pgRouting, enumerate the |result-disjoint|"
msgstr "结果列的重大变化"

msgid "Skip when applicable, ``start_vid``"
msgstr ""

#, fuzzy
msgid "Skip when applicable, ``end_vid``"
msgstr "然后按 ``end_vid``"

#, fuzzy
msgid "One to One example using ``pgr_edgeDisjointPaths``"
msgstr "``pgr_edgeDisjointPaths``"

#, fuzzy
msgid "Migrating `this v3.8 <https://docs.pgrouting.org/3.6/en/pgr_edgeDisjointPaths.html#one-to-one>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

#, fuzzy
msgid "Before updating pgRouting enumerate the columns: |ksp-result|"
msgstr "结果列的重大变化"

#, fuzzy
msgid "Migration of single path functions"
msgstr "限制迁移"

#, fuzzy
msgid "The standardized :ref:`pgRouting-concepts:Result columns for single path functions` are |short-generic-result|"
msgstr "将输出列标准化为 |short-generic-result|"

msgid "``pgr_dijkstra``"
msgstr "``pgr_dijkstra``"

msgid "v < 3.5"
msgstr ""

#, fuzzy
msgid "|old-generic-result|"
msgstr "|nksp-result|"

msgid "``pgr_aStar``"
msgstr "``pgr_aStar``"

msgid "``pgr_bdDijkstra``"
msgstr "``pgr_bdDijkstra``"

msgid "``pgr_bellmanFord``"
msgstr "``pgr_bellmanFord``"

msgid "``pgr_dagShortestPath``"
msgstr "``pgr_dagShortestPath``"

#, fuzzy
msgid "|result-1-1|"
msgstr "|result-bfs|"

msgid "``pgr_edwardMoore``"
msgstr "``pgr_edwardMoore``"

msgid "``pgr_withPoints``"
msgstr "``pgr_withPoints``"

#, fuzzy
msgid "|old-pid-result|"
msgstr "|ksp-result|"

#, fuzzy
msgid "Migration of |old-generic-result|"
msgstr "返回 |old-generic-result| 的集合"

msgid "Before updating pgRouting, enumerate the corresponding columns of the signature"
msgstr ""

#, fuzzy
msgid "Migration of |old-pid-result|"
msgstr "返回 |old-pid-result| 的集合"

msgid "To get the old version column names, depending on the signature:"
msgstr ""

#, fuzzy
msgid "Filter out the columns: ``start_vid`` and/or ``end_vid``"
msgstr "``start_vid`` 和 ``end_vid`` 列不存在。"

#, fuzzy
msgid "Rename the columns:"
msgstr "结果列"

#, fuzzy
msgid "``start_vid`` to ``start_pid``"
msgstr "从 ``start_vid`` 到 ``end_vid`` 的总成本。"

#, fuzzy
msgid "``end_vid`` to ``end_pid``"
msgstr "``end_vid`` 升序"

msgid "If using ``pgr_withPoints``: column names must be changed after updating pgRouting"
msgstr ""

#, fuzzy
msgid "Migration of |result-1-1|"
msgstr "返回 |result-1-1| 的集合"

#, fuzzy
msgid "To get the old version column names:"
msgstr "获取原始列名："

#, fuzzy
msgid "Filter out the columns: ``start_vid`` and ``end_vid``"
msgstr "``start_vid`` 和 ``end_vid`` 列不存在。"

#, fuzzy
msgid "Examples with One to One with one route result"
msgstr "使用示例（无结果输出）"

#, fuzzy
msgid "Using ``pgr_aStar``"
msgstr "``pgr_aStar``"

#, fuzzy
msgid "Migrating `this v3.5 <https://docs.pgrouting.org/3.5/en/pgr_aStar.html#one-to-one>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

msgid "Before updating pgRouting enumerate the columns: |result-1-1|"
msgstr ""

#, fuzzy
msgid "Using ``pgr_bdDijkstra``"
msgstr "``pgr_bdDijkstra``"

#, fuzzy
msgid "Migrating `this v3.8 <https://docs.pgrouting.org/3.8/en/pgr_bdDijkstra.html#one-to-one>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

#, fuzzy
msgid "Using ``pgr_DAGshortestPath``"
msgstr "``pgr_bdAstar``"

#, fuzzy
msgid "Migrating `this v3.8 <https://docs.pgrouting.org/3.8/en/pgr_dagShortestPath.html#one-to-one>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

msgid "This applies to all signatures of ``pgr_DAGshortestPath``"
msgstr ""

#, fuzzy
msgid "Examples for One to Many with one route result"
msgstr "使用示例（无结果输出）"

#, fuzzy
msgid "Using ``pgr_bdAstar``"
msgstr "``pgr_bdAstar``"

#, fuzzy
msgid "Migrating `this v3.5 <https://docs.pgrouting.org/3.5/en/pgr_bdAstar.html#one-to-many>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

msgid "Before updating pgRouting enumerate the columns: |result-1-m|"
msgstr ""

#, fuzzy
msgid "Using ``pgr_withPoints``"
msgstr "使用 :doc:`pgr_withPoints`"

#, fuzzy
msgid "Migrating `this v3.8 <https://docs.pgrouting.org/3.8/en/pgr_withPoints.html#one-to-many>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

msgid "|pid-1-m|"
msgstr ""

#, fuzzy
msgid "To get the old signature column names: filter out the column ``start_vid`` and rename ``end_vid`` to ``end_pid``."
msgstr "``start_vid`` 和 ``end_vid`` 列不存在。"

#, fuzzy
msgid "Examples for Many to One with one route result"
msgstr "使用示例（无结果输出）"

#, fuzzy
msgid "Migrating `this v3.8 <https://docs.pgrouting.org/3.8/en/pgr_bdDijkstra.html#many-to-one>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

msgid "Before updating pgRouting enumerate the columns: |result-m-1|"
msgstr ""

#, fuzzy
msgid "Using ``pgr_dijkstra``"
msgstr "``pgr_dijkstra``"

#, fuzzy
msgid "Migrating `this v3.4 <https://docs.pgrouting.org/3.4/en/pgr_dijkstra.html#many-to-one>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

msgid "Examples for Many to Many with one route result"
msgstr ""

#, fuzzy
msgid "Migrating `this v3.8 <https://docs.pgrouting.org/3.8/en/pgr_withPoints.html#many-to-many>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

msgid "|pid-m-m|"
msgstr ""

msgid "Examples for combinations with one route result"
msgstr ""

#, fuzzy
msgid "Migrating `this v3.8 `this <https://docs.pgrouting.org/3.8/en/pgr_withPoints.html#combinations>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsKSP.html#signatures>`__ 示例。"

#, fuzzy
msgid "Migration of spanning tree functions"
msgstr "生成树函数的结果列"

msgid "The standardized :ref:`pgRouting-concepts:Result columns for spanning tree functions` are |result-spantree|"
msgstr ""

msgid "``pgr_drivingDistance``"
msgstr "``pgr_drivingDistance``"

msgid ":ref:`from_result_dij_dd`"
msgstr ":ref:`from_result_dij_dd`"

msgid "``pgr_withPointsDD``"
msgstr "``pgr_withPointsDD``"

msgid ":ref:`from_result_generic_no_seq`"
msgstr ":ref:`from_result_generic_no_seq`"

msgid "``pgr_kruskalDD``"
msgstr "``pgr_kruskalDD``"

msgid "v < 3.7"
msgstr ""

msgid ":ref:`from_result_bfs`"
msgstr ":ref:`from_result_bfs`"

msgid "``pgr_kruskalBFS``"
msgstr "``pgr_kruskalBFS``"

msgid "``pgr_kruskalDFS``"
msgstr "``pgr_kruskalDFS``"

msgid "``pgr_primDD``"
msgstr "``pgr_primDD``"

msgid "``pgr_primBFS``"
msgstr "``pgr_primBFS``"

msgid "``pgr_primDFS``"
msgstr "``pgr_primDFS``"

msgid "``pgr_breadthFisrtSearch``"
msgstr "``pgr_breadthFisrtSearch``"

msgid "v < 4.0.0"
msgstr ""

msgid "``pgr_depthFisrtSearch``"
msgstr "``pgr_depthFisrtSearch``"

#, fuzzy
msgid "to |result-spantree|"
msgstr "|result-spantree|"

#, fuzzy
msgid "Migration from |result-bfs|."
msgstr "限制迁移"

msgid "Single vertex"
msgstr "单个顶点"

msgid "Multiple vertices"
msgstr "多个顶点"

msgid "Before updating pgRouting enumerate the columns: |result-bfs|"
msgstr ""

#, fuzzy
msgid "Single vertex example using ``pgr_kruskalDD``"
msgstr "``pgr_kruskalDD``"

#, fuzzy
msgid "Migrating `this v3.6 <https://docs.pgrouting.org/3.6/en/pgr_kruskalDD.html#single-vertex>`__ example."
msgstr "与 `this <https://docs.pgrouting.org/3.6/en/pgr_kruskalDD.html#single-vertex>`__ 示例比较。"

msgid "Before updating pgRouting enumerate the columns: |result-bfs|."
msgstr ""

#, fuzzy
msgid "Multiple vertices example using ``pgr_kruskalDFS``"
msgstr "``pgr_kruskalDFS``"

#, fuzzy
msgid "Migrating `this v3.6 <https://docs.pgrouting.org/3.6/en/pgr_kruskalDFS.html#multiple-vertices>`__ example."
msgstr "与 `this <https://docs.pgrouting.org/3.6/en/pgr_kruskalDD.html#multiple-vertex>`__ 示例比较。"

#, fuzzy
msgid "Migration from |result-dij-dd|"
msgstr "|result-dij-dd|"

msgid "Migration depends on the signature."
msgstr ""

#, fuzzy
msgid "For single vertex:"
msgstr "Prim 单个节点"

#, fuzzy
msgid "Before updating pgRouting, enumerate |result-1-1| columns"
msgstr "结果列的重大变化"

#, fuzzy
msgid "For multiple vertices:"
msgstr "Prim 多个顶点"

msgid "Changes must be done after updating pgRouting."
msgstr ""

#, fuzzy
msgid "To get the old version column names |result-dij-dd-m|:"
msgstr "获取原始列名："

#, fuzzy
msgid "filter out the column ``pred`` and ``depth`` and"
msgstr "``start_vid`` 和 ``end_vid`` 列不存在。"

#, fuzzy
msgid "rename ``start_vid`` to ``from_v``."
msgstr "从 ``start_vid`` 到 ``end_vid`` 的总成本。"

#, fuzzy
msgid "Single vertex example using ``pgr_drivingDistance``"
msgstr "``pgr_drivingDistance``"

#, fuzzy
msgid "Migrating `this v3.5 <https://docs.pgrouting.org/3.5/en/pgr_drivingDistance.html#single-vertex>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_drivingDistance.html#single-vertex>`__ 示例。"

#, fuzzy
msgid "Before updating pgRouting, enumerate |result-1-1-no-seq| columns"
msgstr "输出列为 |result-1-1-no-seq|"

#, fuzzy
msgid "Multiple vertices example using ``pgr_drivingDistance``"
msgstr "``pgr_drivingDistance``"

#, fuzzy
msgid "Migrating `this v3.5 <https://docs.pgrouting.org/3.5/en/pgr_drivingDistance.html#multiple-vertices>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_drivingDistance.html#multiple-vertices>`__ 示例。"

msgid "To get the old version column names |result-dij-dd-m|: filter out the column ``pred`` and ``depth`` and rename ``start_vid`` to ``from_v``."
msgstr ""

#, fuzzy
msgid "Migration of |result-generic-no-seq|"
msgstr "|result-generic-no-seq|"

msgid "After updating pgRouting:"
msgstr ""

#, fuzzy
msgid "Enumerate |result-1-1-no-seq| columns"
msgstr "输出列为 |result-1-1-no-seq|"

#, fuzzy
msgid "Use an unnamed valid value for **driving side** after the **distance** parameter."
msgstr "要进行迁移，请在 **distance** 参数之后使用一个未命名的有效值作为 **行驶方向** ："

#, fuzzy
msgid "Enumerate |result-m-1-no-seq| columns"
msgstr "输出列为 |result-1-1-no-seq|"

#, fuzzy
msgid "Default value of **driving side** parameter"
msgstr "右驾驶侧"

#, fuzzy
msgid "**driving side** parameter is unnamed, and valid values differ for directed and undirected graphs."
msgstr "**driving side** 参数是未命名的强制参数，有向图和无向图的有效值不同。"

msgid "In directed graph: valid values are [``r``, ``R``, ``l``, ``L``]"
msgstr "在有向图中：有效值为 [``r``, ``R``, ``l``, ``L``]"

#, fuzzy
msgid "Default value = 'r';"
msgstr "有默认值"

msgid "In undirected graph: valid values are [``b``, ``B``]"
msgstr "在无向图中：有效值为 [``b``, ``B``]"

#, fuzzy
msgid "Default value = 'b';"
msgstr "有默认值"

#, fuzzy
msgid "Single vertex example using ``pgr_withPointsDD``"
msgstr "``pgr_withPointsDD``"

#, fuzzy
msgid "Migrating `this v3.5 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

#, fuzzy
msgid "Multiple vertices example using ``pgr_withPointsDD``"
msgstr "``pgr_withPointsDD``"

#, fuzzy
msgid "Migrating `this v3.5 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#multiple-vertex>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-vertex>`__ 示例。"

#, fuzzy
msgid "Migration of output column name change"
msgstr "限制迁移"

#, fuzzy
msgid "The standardized result columns:"
msgstr "成本函数结果列"

#, fuzzy
msgid "|result_edge_color|"
msgstr "返回集合 |result-edge-color|"

#, fuzzy
msgid "|result_node_color|"
msgstr "返回集合 |result-node-color|"

#, fuzzy
msgid "|result_node_order|"
msgstr "返回集合 |result-node-color|"

msgid "Changes on column names must be done after updating pgRouting."
msgstr ""

msgid "``pgr_edgeColoring``"
msgstr "``pgr_edgeColoring``"

msgid ":ref:`from_old_edge_color`"
msgstr ":ref:`from_old_edge_color`"

msgid "``pgr_bipartite``"
msgstr "``pgr_bipartite``"

msgid ":ref:`from_old_node_color`"
msgstr ":ref:`from_old_node_color`"

msgid "``pgr_sequentialVertexColoring``"
msgstr "``pgr_sequentialVertexColoring``"

msgid "``pgr_topologicalSort``"
msgstr "``pgr_topologicalSort``"

msgid ":ref:`from_toposort`"
msgstr ":ref:`from_toposort`"

msgid "``pgr_transitiveClosure``"
msgstr "``pgr_transitiveClosure``"

msgid ":ref:`from_old_closure`"
msgstr ":ref:`from_old_closure`"

#, fuzzy
msgid "Migration from |result-old-closure|"
msgstr "|result-dij-dd|"

#, fuzzy
msgid "Migration to: |result-old-closure|"
msgstr "|result-generic-no-seq|"

msgid "After update:"
msgstr ""

#, fuzzy
msgid "Remove column ``seq``"
msgstr "删除了不必要的列 seq"

msgid "Rename ``vid`` to ``node`` and ``target_array`` to ``targets``"
msgstr ""

#, fuzzy
msgid "Migration from |result-toposort|"
msgstr "限制迁移"

#, fuzzy
msgid "Migration to: |result_node_order|"
msgstr "|result-generic-no-seq|"

#, fuzzy
msgid "Rename ``sorted_v`` to ``node``"
msgstr "从 ``start_vid`` 到 ``end_vid`` 的总成本。"

#, fuzzy
msgid "Migration from |old-edge-color|"
msgstr "返回 |old-pid-result| 的集合"

#, fuzzy
msgid "Migration to: |result_edge_color|"
msgstr "|result-generic-no-seq|"

msgid "Rename ``edge_id`` to ``edge`` and ``color_id`` to ``color``."
msgstr ""

#, fuzzy
msgid "Migration from |old-node-color|"
msgstr "返回 |old-pid-result| 的集合"

#, fuzzy
msgid "Migration to: |result_node_color|"
msgstr "|result-generic-no-seq|"

msgid "Rename ``vertex_id`` to ``node`` and ``color_id`` to ``color``."
msgstr ""

#, fuzzy
msgid "Migration of deleted functions"
msgstr "限制迁移"

#, fuzzy
msgid "Functions no longer on pgRouting"
msgstr "为 pgRouting 添加功能"

msgid "Migration of ``pgr_alphaShape``"
msgstr "迁移 ``pgr_alphaShape``"

msgid "Deprecated"
msgstr "已停用"

#, fuzzy
msgid "`v3.8.0 <https://docs.pgrouting.org/3.8>`__"
msgstr "`v3.4.0 <https://docs.pgrouting.org/3.4>`__"

msgid "Removed"
msgstr "已删除的功能"

msgid "`v4.0.0 <https://docs.pgrouting.org/4.0>`__"
msgstr "`v4.0.0 <https://docs.pgrouting.org/4.0>`__"

msgid "**Before Deprecation:** The following was calculated:"
msgstr "** 弃用前：** 原计算方式如下："

msgid "An alphaShape was calculated"
msgstr "已计算 alphaShape"

msgid "**After Deprecation:**"
msgstr "**停用后：**"

msgid "PostGIS has two ways of generating alphaShape."
msgstr "PostGIS 提供两种生成 alphaShape 的方法。"

msgid "If you have SFCGAL, which you can install using"
msgstr "如果你有 SFCGAL，可以通过以下方式安装"

msgid "Since PostGIS 3.5+ use `CG_AlphaShape <https://postgis.net/docs/CG_AlphaShape.html>`__"
msgstr "自 PostGIS 3.5 起，请使用 `CG_AlphaShape <https://postgis.net/docs/CG_AlphaShape.html>`__ 函数"

msgid "For PostGIS 3.5+ use the old name ``ST_AlphaShape``"
msgstr "对于 PostGIS 3.5+ 版本，请继续使用旧函数名 ``ST_AlphaShape``"

msgid "Other PostGIS options are"
msgstr ""

msgid "`ST_ConvexHull <https://postgis.net/docs/ST_ConvexHull.html>`__"
msgstr ""

msgid "`ST_ConcaveHull <https://postgis.net/docs/ST_ConcaveHull.html>`__"
msgstr ""

#, fuzzy
msgid "Migration of ``pgr_nodeNetwork``"
msgstr "迁移 ``pgr_bdAstar``"

msgid "**Before Deprecation:** A table with `<edges>_nodded` was created. with split edges."
msgstr ""

#, fuzzy
msgid "**Migration**"
msgstr "迁移"

#, fuzzy
msgid "Use :doc:`pgr_separateTouching` and/or use :doc:`pgr_separateCrossing`"
msgstr "使用 ``pgr_separateTouching`` 和 ``pgr_separateCrossing`` 。"

msgid "Migration of ``pgr_createTopology``"
msgstr "迁移 ``pgr_createTopology``"

msgid "A table with `<edges>_vertices_pgr` was created."
msgstr "创建了一个包含 `<edges>_vertices_pgr` 的表。"

msgid "**After Deprecation:** The user is responsible to create the complete topology."
msgstr "**弃用后：** 用户需自行构建完整拓扑。"

msgid "Build a routing topology"
msgstr "构建路由拓扑"

msgid "The basic information to use the majority of the pgRouting functions ``id, source, target, cost, [reverse_cost]`` is what in pgRouting is called the routing topology."
msgstr "使用大多数 pgRouting 函数的基本信息 ``id, source, target, cost, [reverse_cost]`` 在 pgRouting 中被称为路由拓扑。"

msgid "``reverse_cost`` is optional but strongly recommended to have in order to reduce the size of the database due to the size of the geometry columns. Having said that, in this documentation ``reverse_cost`` is used in this documentation."
msgstr "``reverse_cost`` 是可选的，但强烈建议使用，以便由于几何列的大小而减小数据库的大小。 话虽如此，在本文档中使用了 ``reverse_cost`` 。"

msgid "When the data comes with geometries and there is no routing topology, then this step is needed."
msgstr "当数据带有几何图形并且没有路由拓扑时，则需要此步骤。"

msgid "All the start and end vertices of the geometries need an identifier that is to be stored in a ``source`` and ``target`` columns of the table of the data. Likewise, ``cost`` and ``reverse_cost`` need to have the value of traversing the edge in both directions."
msgstr "几何图的所有开始和结束顶点都需要一个标识符，该标识符将存储在数据表的 ``source`` 列和 ``target`` 列中。 同样， ``cost`` 和 ``reverse_cost`` 需要具有在两个方向上遍历边的值。"

msgid "If the columns do not exist they need to be added to the table in question. (see `ALTER TABLE <https://www.postgresql.org/docs/current/sql-altertable.html>`__)"
msgstr "如果这些列不存在，则需要将它们添加到相关表中。 （参见 `ALTER TABLE <https://www.postgresql.org/docs/current/sql-altertable.html>`__ ）"

msgid "The function :doc:`pgr_extractVertices` is used to create a vertices table based on the edge identifier and the geometry of the edge of the graph."
msgstr "函数 :doc:`pgr_extractVertices` 用于根据边标识符和图边的几何形状创建顶点表。"

msgid "Finally using the data stored on the vertices tables the ``source`` and ``target`` are filled up."
msgstr "最后使用存储在顶点表上的数据填充 ``source`` 和 ``target`` 。"

msgid "Migration of ``pgr_createVerticesTable``"
msgstr "迁移 ``pgr_createVerticesTable``"

msgid "**After Deprecation:** The user is responsible to create the vertices table, indexes, etc. They may use :doc:`pgr_extractVertices` for that purpose."
msgstr "**弃用后：** 用户需自行创建顶点表、索引等结构，可调用 :doc:`pgr_extractVertices` 函数实现该功能。"

msgid "Migration of ``pgr_analyzeOneWay``"
msgstr "迁移 ``pgr_analyzeOneWay``"

msgid "Number of potential problems in directionality"
msgstr "方向性潜在问题数量分析"

msgid "WHERE"
msgstr "WHERE"

msgid "Directionality problems were calculated based on codes."
msgstr "方向性问题已根据预设规则代码完成计算。"

msgid "Dead ends."
msgstr "死胡同。"

msgid "A routing problem can arise when from a vertex there is only a way on or a way out but not both:"
msgstr "当某个节点仅存在单向通行路径（仅有进入或仅有离开的边线）时，将导致路由问题："

msgid "Either saving or using directly :doc:`pgr_extractVertices` get the dead ends information and determine if the adjacent edge is one way or not."
msgstr "通过保存或直接调用 :doc:`pgr_extractVertices` 获取断头路信息，并判断相邻边线是否为单行道。"

msgid "In this example :doc:`pgr_extractVertices` has already been applied."
msgstr "在本例中 :doc:`pgr_extractVertices` 已经应用。"

msgid "Bridges."
msgstr "桥梁。"

msgid "Another routing problem can arise when there is an edge of an undirected graph whose deletion increases its number of connected components, and the bridge is only one way."
msgstr "另一个路由问题可能出现在以下情况：当无向图中存在这样一条边——删除该边会增加图的连通分量数量（即该边是桥接边），而该桥接边却是单向通行的。"

msgid "To determine if the bridges are or not one way."
msgstr "判断桥梁是否为单行道。"

msgid "Migration of ``pgr_analyzeGraph``"
msgstr "迁移 ``pgr_analyzeGraph``"

msgid "Number of isolated segments."
msgstr "隔离段的数量。"

msgid "Number of dead ends."
msgstr "死胡同数量。"

msgid "Number of potential gaps found near dead ends."
msgstr "在断头路附近发现的潜在缺口数量。"

msgid "Number of intersections. (between 2 edges)"
msgstr "交叉点数量。(两条边之间）"

msgid "Graph component"
msgstr "图形组件"

msgid "A connected subgraph that is not part of any larger connected subgraph."
msgstr "不属于任何较大连通子图的连通子图。"

msgid "Isolated segment"
msgstr "隔离段"

msgid "A graph component with only one segment."
msgstr "单一孤立路段组成的网络组件。"

msgid "Dead ends"
msgstr "死端"

msgid "A vertex that participates in only one edge."
msgstr "仅关联单条边线的顶点。"

msgid "gaps"
msgstr "差距"

msgid "Space between two geometries."
msgstr "两个几何对象之间的空间。"

msgid "Intersection"
msgstr "交叉路口"

msgid "Is a topological relationship between two geometries."
msgstr "是两个几何体之间的拓扑关系。"

msgid "Migration."
msgstr "迁移。"

msgid "Components."
msgstr "组件。"

msgid "Instead of counting only isolated segments, determine all the components of the graph."
msgstr "不仅统计孤立线段，还要识别图中的所有连通子图（组件）。"

msgid "Depending of the final application requirements use:"
msgstr "根据最终应用需求选择："

msgid ":doc:`pgr_connectedComponents`"
msgstr ":doc:`pgr_connectedComponents`"

msgid ":doc:`pgr_strongComponents`"
msgstr ":doc:`pgr_strongComponents`"

msgid ":doc:`pgr_biconnectedComponents`"
msgstr ":doc:`pgr_biconnectedComponents`"

msgid "For example:"
msgstr "示例："

msgid "Instead of counting the dead ends, determine all the dead ends of the graph using :doc:`pgr_degree`."
msgstr "使用 :doc:`pgr_degree` 确定图形的所有死角，而不是计算死角。"

msgid "Potential gaps near dead ends."
msgstr "断头路附近的潜在缺口。"

msgid "Instead of counting potential gaps between geometries, determine the geometric gaps in the graph using :doc:`pgr_findCloseEdges`."
msgstr "使用 :doc:`pgr_findCloseEdges` 来确定图形中的几何间隙，而不是计算几何图形之间的潜在间隙。"

msgid "Topological relationships."
msgstr "拓扑关系。"

msgid "Instead of counting intersections, determine topological relationships between geometries."
msgstr "确定几何图形之间的拓扑关系，而不是计算交叉点。"

msgid "Several PostGIS functions can be used: `ST_Intersects <https://postgis.net/docs/ST_Intersects.html>`__, `ST_Crosses <https://postgis.net/docs/ST_Crosses.html>`__, `ST_Overlaps <https://postgis.net/docs/ST_Overlaps.html>`__, etc."
msgstr "可以使用几个 PostGIS 函数： `ST_Intersects <https://postgis.net/docs/ST_Intersects.html>`__, `ST_Crosses <https://postgis.net/docs/ST_Crosses.html>`__, `ST_Overlaps <https://postgis.net/docs/ST_Overlaps.html>`__, 等。"

msgid "Migration of ``pgr_trsp`` (Vertices)"
msgstr "迁移 ``pgr_trsp`` (顶点）"

msgid "Signature:"
msgstr "签名："

msgid "`v3.4.0 <https://docs.pgrouting.org/3.4>`__"
msgstr "`v3.4.0 <https://docs.pgrouting.org/3.4>`__"

msgid ":doc:`pgr_trsp`"
msgstr ":doc:`pgr_trsp`"

msgid "`Migration of restrictions`_"
msgstr "`迁移限制`_"

msgid "Use ``pgr_dijkstra`` when there are no restrictions."
msgstr "当没有限制条件时，使用 ``pgr_dijkstra`` 。"

msgid "Use :doc:`pgr_dijkstra` instead."
msgstr "使用 :doc:`pgr_dijkstra` 替代。"

msgid "To get the original column names:"
msgstr "获取原始列名："

msgid "``id1`` is the node"
msgstr "``id1`` 是节点"

msgid "``id2`` is the edge"
msgstr "``id2`` 是边"

msgid "Use ``pgr_trsp`` when there are restrictions."
msgstr "当存在限制条件时，使用 ``pgr_trsp`` 。"

msgid "Use :doc:`pgr_trsp` (One to One) instead."
msgstr "使用 :doc:`pgr_trsp` (One to One) 替代。"

msgid "Migration of ``pgr_trsp`` (Edges)"
msgstr "迁移 ``pgr_trsp`` (边)"

msgid ":doc:`pgr_trsp_withPoints`"
msgstr ":doc:`pgr_trsp_withPoints`"

msgid "Migration of ``pgr_trspViaVertices``"
msgstr "迁移 ``pgr_trspViaVertices``"

msgid ":doc:`pgr_dijkstraVia`"
msgstr ":doc:`pgr_dijkstraVia`"

msgid ":doc:`pgr_trspVia`"
msgstr ":doc:`pgr_trspVia`"

msgid "Use ``pgr_dijkstraVia`` when there are no restrictions"
msgstr "无限制条件时，使用 ``pgr_dijkstraVia``"

msgid "Use :doc:`pgr_dijkstraVia` instead."
msgstr "使用 :doc:`pgr_dijkstraVia` 替代。"

msgid "``id1`` is the path identifier"
msgstr "``id1`` 是路径标识符"

msgid "``id2`` is the node"
msgstr "``id2`` 是节点"

msgid "``id3`` is the edge"
msgstr "``id3`` 是边"

msgid "Use ``pgr_trspVia`` when there are restrictions"
msgstr "当存在限制条件时，使用 ``pgr_trspVia``"

msgid "Use :doc:`pgr_trspVia` instead."
msgstr "使用 :doc:`pgr_trspVia` 替代。"

msgid "Migration of ``pgr_trspViaEdges``"
msgstr "迁移 ``pgr_trspViaEdges``"

msgid ":doc:`pgr_withPointsVia`"
msgstr ":doc:`pgr_withPointsVia`"

msgid ":doc:`pgr_trspVia_withPoints`"
msgstr ":doc:`pgr_trspVia_withPoints`"

msgid "Use ``pgr_withPointsVia`` when there are no restrictions"
msgstr "无限制条件时，使用 ``pgr_withPointsVia``"

msgid "Use :doc:`pgr_withPointsVia` instead."
msgstr "使用 :doc:`pgr_withPointsVia` 替代。"

msgid "Use ``pgr_trspVia_withPoints`` when there are restrictions"
msgstr "当存在限制条件时，使用 ``pgr_trspVia_withPoints``"

msgid "Use :doc:`pgr_trspVia_withPoints` instead."
msgstr "使用 :doc:`pgr_trspVia_withPoints` 替代。"

msgid "Not yet classified migrations"
msgstr ""

msgid "Migration of ``pgr_withPointsKSP``"
msgstr "迁移 ``pgr_withPointsKSP``"

msgid "Starting from `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__ :doc:`pgr_withPointsKSP` result columns are being standardized."
msgstr "从 `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__ :doc:`pgr_withPointsKSP` 开始对结果列进行标准化。"

msgid "|ksp-result|"
msgstr "|ksp-result|"

#, fuzzy
msgid "|generic-result|"
msgstr "|nksp-result|"

#, fuzzy
msgid "And ``driving side`` parameter changed from named optional to unnamed **driving side** and its validity differ for directed and undirected graphs."
msgstr "而且 ``driving side`` 参数从命名的可选参数变为未命名的必选参数 **行驶方向**，其有效性对于有向图和无向图有所不同。"

msgid "``pgr_withPointsKSP`` (`One to One`)"
msgstr "``pgr_withPointsKSP`` (`One to One`)"

msgid "Before Migration"
msgstr "迁移前"

msgid "Output columns were |old-pid-result|"
msgstr "输出列是 |old-pid-result|"

msgid "the columns ``start_vid`` and ``end_vid`` do not exist."
msgstr "``start_vid`` 和 ``end_vid`` 列不存在。"

msgid "Migration"
msgstr "迁移"

msgid "Be aware of the existence of the additional result Columns."
msgstr "注意附加结果列的存在。"

#, fuzzy
msgid "New output columns are |generic-result|"
msgstr "新的输出列是 |nksp-result|"

msgid "Using `this <https://docs.pgrouting.org/3.5/en/pgr_withPointsKSP.html#signatures>`__ example."
msgstr "使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsKSP.html#signatures>`__ 示例。"

msgid "``start_vid`` contains the **start vid** parameter value."
msgstr "``start_vid`` 包含 **起始 vid** 参数值。"

msgid "``end_vid`` contains the **end vid** parameter value."
msgstr "``end_vid`` 包含 **结束 vid** 参数值。"

msgid "If needed filter out the additional columns, for example, to return the original columns:"
msgstr "如果需要，过滤掉附加列，例如，返回原始列："

msgid "Use ``pgr_withPoints`` when there are no restrictions."
msgstr "无限制条件时，使用 ``pgr_withPoints`` 。"

msgid "Use :doc:`pgr_withPoints` (One to One) instead."
msgstr "使用 :doc:`pgr_withPoints` (One to One) 替代。"

msgid "Use ``pgr_trsp_withPoints`` when there are restrictions."
msgstr "当存在限制条件时，使用 ``pgr_trsp_withPoints`` 。"

msgid "Use :doc:`pgr_trsp_withPoints` instead."
msgstr "使用 :doc:`pgr_trsp_withPoints` 替代。"

msgid "Migration of ``pgr_maxCardinalityMatch``"
msgstr "迁移 ``pgr_maxCardinalityMatch``"

msgid ":doc:`pgr_maxCardinalityMatch` works only for undirected graphs, therefore the ``directed`` flag has been removed."
msgstr ":doc:`pgr_maxCardinalityMatch` 仅适用于无向图，因此 ``有向`` 标志已被删除。"

msgid "Starting from `v3.4.0 <https://docs.pgrouting.org/3.4/en/migration.html>`__"
msgstr "开始于 `v3.4.0 <https://docs.pgrouting.org/3.4/en/migration.html>`__"

msgid "Signature to be migrated:"
msgstr "待迁移签名："

msgid "Migration is needed, because:"
msgstr "需要迁移，因为："

msgid "Use ``cost`` and ``reverse_cost`` on the inner query"
msgstr "在内部查询上使用 ``cost`` 和 ``reverse_cost``"

msgid "Results are ordered"
msgstr "结果已排序"

msgid "Works for undirected graphs."
msgstr "适用于无向图。"

msgid "New signature"
msgstr "新签名"

msgid "``pgr_maxCardinalityMatch(text)`` returns only ``edge`` column."
msgstr "``pgr_maxCardinalityMatch(text)`` 仅仅返回 ``边`` 列."

msgid "The optional flag ``directed`` is removed."
msgstr "可选的 ``directed`` 标志被删除。"

msgid "Before migration"
msgstr "迁移前"

msgid "Columns used are ``going`` and ``coming`` to represent the existence of an edge."
msgstr "所使用的列是 ``going`` 和 ``coming`` ，用于表示边的存在。"

msgid "Flag ``directed`` was used to indicate if it was for a **directed** or **undirected** graph."
msgstr "``directed`` 标志用于指示是 **有向** 图还是 **无向** 图。"

msgid "The flag ``directed`` is ignored."
msgstr "``directed`` 标志被忽略。"

msgid "Regardless of it's value it gives the result considering the graph as **undirected**."
msgstr "无论它的值如何，它都会给出将图视为 **无向** 的结果。"

msgid "Use the columns ``cost`` and ``reverse_cost`` to represent the existence of an edge."
msgstr "使用 ``cost`` 和 ``reverse_cost`` 列来表示边的存在。"

msgid "Do not use the flag ``directed``."
msgstr "不要使用 ``directed`` 标志。"

msgid "In the query returns only ``edge`` column."
msgstr "查询中仅返回 ``edge`` 列。"

msgid "Migration of restrictions"
msgstr "限制迁移"

msgid "The structure of the restrictions have changed:"
msgstr "限制的结构发生了变化："

msgid "Old restrictions structure"
msgstr "旧的限制结构"

msgid "On the deprecated signatures:"
msgstr "关于已弃用的签名："

msgid "Column ``rid`` is ignored"
msgstr "列 ``rid`` 被忽略"

msgid "``via_path``"
msgstr "``via_path``"

msgid "Must be in reverse order."
msgstr "必须是相反的顺序。"

msgid "Is of type ``TEXT``."
msgstr "属于 ``TEXT`` 类型。"

msgid "When more than one via edge must be separated with ``,``."
msgstr "当多个过孔边必须用 ``,`` 分隔时。"

msgid "``target_id``"
msgstr "``target_id``"

msgid "Is the last edge of the forbidden path."
msgstr "是禁止路径的最后一条边。"

msgid "Is of type ``INTEGER``."
msgstr "类型为 ``INTEGER`` 。"

msgid "``to_cost``"
msgstr "``to_cost``"

msgid "Is of type ``FLOAT``."
msgstr "类型为 ``FLOAT`` 。"

msgid "Creation of the old restrictions table"
msgstr "创建旧限制表"

msgid "Old restrictions fill up"
msgstr "旧限制已满"

msgid "Old restrictions contents"
msgstr "旧限制内容"

msgid "The restriction with ``rid = 2`` is representing :math:`3 \\rightarrow 5 \\rightarrow9`"
msgstr "``rid = 2`` 的限制表示的是路径 :math:`3 \\rightarrow 5 \\rightarrow9`"

msgid ":math:`3\\rightarrow5`"
msgstr ":math:`3\\rightarrow5`"

msgid "is on column ``via_path`` in reverse order"
msgstr "以相反的顺序位于 ``via_path`` 列上"

msgid "is of type ``TEXT``"
msgstr "类型为 ``TEXT``"

msgid ":math:`9`"
msgstr ":math:`9`"

msgid "is on column ``target_id``"
msgstr "位于列 ``target_id``"

msgid "is of type ``INTEGER``"
msgstr "类型为 ``INTEGER``"

msgid "New restrictions structure"
msgstr "新的限制结构"

msgid "Column ``id`` is ignored"
msgstr "列 ``id`` 被忽略"

msgid "Column ``path``"
msgstr "列 ``path``"

msgid "Is of type ``ARRAY[ANY-INTEGER]``."
msgstr "类型为 ``ARRAY[ANY-INTEGER]`` 。"

msgid "Contains all the edges involved on the restriction."
msgstr "包含限制所涉及的所有边。"

msgid "The array has the ordered edges of the restriction."
msgstr "该数组具有限制的有序边。"

msgid "Column ``cost``"
msgstr "列 ``cost``"

msgid "Is of type ``ANY-NUMERICAL``"
msgstr "类型为 ``ANY-NUMERICAL``"

msgid "The creation of the restrictions table"
msgstr "限制表的创建"

msgid "Adding the restrictions"
msgstr "添加限制"

msgid "Restrictions data"
msgstr "限制数据"

msgid "The restriction with ``rid = 2`` represents the path :math:`3 \\rightarrow5 \\rightarrow9`."
msgstr "``rid = 2`` 的限制表示的是路径 :math:`3 \\rightarrow5 \\rightarrow9` 。"

msgid "By inspection the path is clear."
msgstr "通过检查，路径是清晰的。"

msgid "To transform the old restrictions table to the new restrictions structure,"
msgstr "要将旧的限制表转换为新的限制结构，"

msgid "Create a new table with the new restrictions structure."
msgstr "使用新的限制结构创建一个新表。"

msgid "In this migration guide ``new_restrictions`` is been used."
msgstr "在此迁移指南中使用了 ``new_restrictions`` 。"

msgid "For this migration pgRouting supplies an auxiliary function for reversal of an array ``_pgr_array_reverse`` needed for the migration."
msgstr "为了进行这次迁移，pgRouting 提供了一个用于反转数组的辅助函数 ``_ pgr_array_reverse`` ，这在迁移过程中是必需的。"

msgid "``_pgr_array_reverse``:"
msgstr "``_pgr_array_reverse``:"

msgid "Was created temporally for this migration"
msgstr "是为此迁移临时创建的"

msgid "Is not documented."
msgstr "没有记录。"

msgid "Will be removed on the next mayor version 4.0.0"
msgstr "将在下一个正式版本 4.0.0 中删除"

msgid "The migrated table contents:"
msgstr "迁移后的表内容："

#, fuzzy
msgid ":doc:`pgRouting-concepts`"
msgstr "pgRouting 概念"

msgid "Ordering - Family of functions"
msgstr "排序 - 函数族"

msgid "pgRouting Concepts"
msgstr "pgRouting 概念"

msgid "This is a simple guide that go through some of the steps for getting started with pgRouting. This guide covers:"
msgstr "这是一个简单的指南，介绍了 pgRouting 入门的一些步骤。 本指南涵盖："

msgid "Graphs"
msgstr "图"

msgid "A graph is an ordered pair :math:`G = (V ,E)` where:"
msgstr "图是一个有序对 :math:`G = (V ,E)` ，其中："

msgid ":math:`V` is a set of vertices, also called nodes."
msgstr ":math:`V` 是一组顶点，也称为节点。"

msgid ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V \\}`"
msgstr ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V \\}`"

msgid "There are different kinds of graphs:"
msgstr "有不同类型的图："

msgid ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V\\}`"
msgstr ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V\\}`"

msgid "Undirected simple graph"
msgstr "无向simple图"

msgid ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V, u \\neq v\\}`"
msgstr ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V, u \\neq v\\}`"

msgid ":math:`E \\subseteq \\{( u, v ) \\mid (u , v) \\in (V X V) \\}`"
msgstr ":math:`E \\subseteq \\{( u, v ) \\mid (u , v) \\in (V X V) \\}`"

msgid "Directed simple graph"
msgstr "有向simple图"

msgid ":math:`E \\subseteq \\{( u, v ) \\mid (u , v) \\in (V X V), u \\neq v\\}`"
msgstr ":math:`E \\subseteq \\{( u, v ) \\mid (u , v) \\in (V X V), u \\neq v\\}`"

msgid "Graphs:"
msgstr "图："

msgid "Do not have geometries."
msgstr "没有几何图形。"

msgid "Some graph theory problems require graphs to have weights, called **cost** in pgRouting."
msgstr "一些图论问题需要图具有权重，在 pgRouting 中称为 **成本** 。"

msgid "In pgRouting there are several ways to represent a graph on the database:"
msgstr "在 pgRouting 中，有多种方法来表示数据库上的图："

msgid "With ``cost``"
msgstr "使用 ``cost``"

msgid "(``id``, ``source``, ``target``, ``cost``)"
msgstr "(``id``, ``source``, ``target``, ``cost``)"

msgid "With ``cost`` and ``reverse_cost``"
msgstr "使用 ``cost`` 和 ``reverse_cost``"

msgid "(``id``, ``source``, ``target``, ``cost``, ``reverse_cost``)"
msgstr "(``id``, ``source``, ``target``, ``cost``, ``reverse_cost``)"

msgid "Identifier of the edge. Requirement to use the database in a consistent. manner."
msgstr "边的标识符。要求在数据库中以一致的方式使用。"

msgid "Identifier of a vertex."
msgstr "顶点的标识符。"

msgid "Weight of the edge (``source``, ``target``):"
msgstr "边 (``source``, ``target``)的权重："

msgid "When negative the edge (``source``, ``target``) do not exist on the graph."
msgstr "当为负时，图上不存在edge (``source``, ``target``)。"

msgid "``cost`` must exist in the query."
msgstr "查询中必须存在 ``cost`` 。"

msgid "When negative the edge (``target``, ``source``) do not exist on the graph."
msgstr "当为负时，图上不存在边(``target``, ``source``)。"

msgid "The decision of the graph to be **directed** or **undirected** is done when executing a pgRouting algorithm."
msgstr "图是 **有向** 图还是 **无向** 图的决定是在执行 pgRouting 算法时完成的。"

msgid "Graph with ``cost``"
msgstr "``cost`` 图"

msgid "The weighted directed graph, :math:`G_d(V,E)`:"
msgstr "加权有向图， :math:`G_d(V,E)`:"

msgid "Graph data is obtained with a query"
msgstr "通过查询获取图数据"

msgid "``SELECT id, source, target, cost FROM edges``"
msgstr "``SELECT id, source, target, cost FROM edges``"

msgid ":math:`E = \\{(source_{id}, target_{id}, cost_{id}) \\text{ when } cost_{id} \\ge 0 \\}`"
msgstr ":math:`E = \\{(source_{id}, target_{id}, cost_{id}) \\text{ when } cost_{id} \\ge 0 \\}`"

msgid "Edges where ``cost`` is non negative are part of the graph."
msgstr "``cost`` 非负的边是图的一部分。"

msgid ":math:`V = \\{source_{id} \\cup target_{id}\\}`"
msgstr ":math:`V = \\{source_{id} \\cup target_{id}\\}`"

msgid "All vertices in ``source`` and ``target`` are part of the graph."
msgstr "``source`` 和 ``target`` 中的所有顶点都是图的一部分。"

msgid "In a directed graph the edge :math:`(source_{id}, target_{id}, cost_{id})` has directionality: :math:`source_{id} \\rightarrow target_{id}`"
msgstr "在有向图中，边 :math:`(source_{id}, target_{id}, cost_{id})` 具有方向性：:math:`source_{id} \\rightarrow target_{id}`"

msgid "For the following data:"
msgstr "对于以下数据："

msgid "Edge :math:`2` (:math:`1 \\rightarrow 3`) is not part of the graph."
msgstr "边 :math:`2` (:math:`1 \\rightarrow 3`) 不是图的一部分。"

msgid "The data is representing the following graph:"
msgstr "数据代表下图："

msgid "In an undirected graph the edge :math:`(source_{id}, target_{id}, cost_{id})` does not have directionality: :math:`source_{id} \\frac{\\;\\;\\;\\;\\;}{} target_{id}`"
msgstr "在无向图中，边 :math:`(source_{id}, target_{id}, cost_{id})` 没有方向性：:math:`source_{id} \\frac{\\;\\;\\;\\;\\;}{} target_{id}`"

msgid "In terms of a directed graph is like having two edges: :math:`source_{id} \\leftrightarrow target_{id}`"
msgstr "在有向图的术语中，这相当于有两条边： :math:`source_{id} \\leftrightarrow target_{id}`"

msgid "Edge :math:`2` (:math:`1 \\frac{\\;\\;\\;\\;\\;}{} 3`) is not part of the graph."
msgstr "边 :math:`2` (:math:`1 \\frac{\\;\\;\\;\\;\\;}{} 3`) 不是图的一部分。"

msgid "Graph with ``cost`` and ``reverse_cost``"
msgstr "带有 ``cost`` 和 ``reverse_cost`` 的图"

msgid "``SELECT id, source, target, cost, reverse_cost FROM edges``"
msgstr "``SELECT id, source, target, cost, reverse_cost FROM edges``"

msgid "The set of edges :math:`E`:"
msgstr "边的集合 :math:`E` ："

msgid ":math:`E = \\begin{split} \\begin{align} & {\\{(source_{id}, target_{id}, cost_{id}) \\text{ when } cost_{id} >=0 \\}} \\\\ & \\cup \\\\ & {\\{(target_{id}, source_{id}, reverse\\_cost_{id}) \\text{ when } reverse\\_cost_{id} >=0 \\}} \\end{align} \\end{split}`"
msgstr ":math:`E = \\begin{split} \\begin{align} & {\\{(source_{id}, target_{id}, cost_{id}) \\text{ when } cost_{id} >=0 \\}} \\\\ & \\cup \\\\ & {\\{(target_{id}, source_{id}, reverse\\_cost_{id}) \\text{ when } reverse\\_cost_{id} >=0 \\}} \\end{align} \\end{split}`"

msgid "Edges :math:`(source \\rightarrow target)` where ``cost`` is non negative are part of the graph."
msgstr "边 :math:`(source \\rightarrow target)` 中的 ``cost`` 是非负数的都属于图的一部分。"

msgid "Edges :math:`(target \\rightarrow source)` where ``reverse_cost`` is non negative are part of the graph."
msgstr "边 :math:`(target \\rightarrow source)` 中的 ``reverse_cost`` 是非负数的都属于图的一部分。"

msgid "The set of vertices :math:`V`:"
msgstr "顶点集 :math:`V` ："

msgid "In a directed graph both edges have directionality"
msgstr "在有向图中，两条边都有方向性"

msgid "edge :math:`(source_{id}, target_{id}, cost_{id})` has directionality: :math:`source_{id} \\rightarrow target_{id}`"
msgstr "边 :math:`(source_{id}, target_{id}, cost_{id})` 具有方向性： :math:`source_{id} \\rightarrow target_{id}`"

msgid "edge :math:`(target_{id}, source_{id}, reverse\\_cost_{id})` has directionality: :math:`target_{id} \\rightarrow source_{id}`"
msgstr "边 :math:`(target_{id}, source_{id}, reverse\\_cost_{id})` 具有方向性： :math:`target_{id} \\rightarrow source_{id}`"

msgid "Edges not part of the graph:"
msgstr "边不是图的一部分："

msgid ":math:`2` (:math:`1 \\rightarrow 3`)"
msgstr ":math:`2` (:math:`1\\rightarrow 3`)"

msgid ":math:`3` (:math:`3 \\rightarrow 2`)"
msgstr ":math:`3` (:math:`3\\rightarrow 2`)"

msgid "In a directed graph both edges do not have directionality"
msgstr "在有向图中，两条边都没有方向性"

msgid "Edge :math:`(source_{id}, target_{id}, cost_{id})` is :math:`source_{id} \\frac{\\;\\;\\;\\;\\;}{} target_{id}`"
msgstr "边 :math:`(source_{id}, target_{id}, cost_{id})` 是 :math:`source_{id} \\frac{\\;\\;\\;\\;\\;}{} target_{id}`"

msgid "Edge :math:`(target_{id}, source_{id}, reverse\\_cost_{id})` is :math:`target_{id} \\frac{\\;\\;\\;\\;\\;}{} source_{id}`"
msgstr "边 :math:`(target_{id}, source_{id}, reverse\\_cost_{id})`是 :math:`target_{id} \\frac{\\;\\;\\;\\;\\;}{} source_{id}`"

msgid "In terms of a directed graph is like having four edges:"
msgstr "就有向图而言，就像有四个边："

msgid ":math:`source_i \\leftrightarrow target_i`"
msgstr ":math:`source_i \\leftrightarrow target_i`"

msgid ":math:`target_i \\leftrightarrow source_i`"
msgstr ":math:`target_i \\leftrightarrow source_i`"

msgid ":math:`2` (:math:`1 \\frac{\\;\\;\\;\\;\\;}{} 3`)"
msgstr ":math:`2` (:math:`1 \\frac{\\;\\;\\;\\;\\;}{} 3`)"

msgid ":math:`3` (:math:`3 \\frac{\\;\\;\\;\\;\\;}{} 2`)"
msgstr ":math:`3` (:math:`3 \\frac{\\;\\;\\;\\;\\;}{} 2`)"

msgid "Graphs without geometries"
msgstr "没有几何信息的图"

msgid "Personal relationships, genealogy, file dependency problems can be solved using pgRouting. Those problems, normally, do not come with geometries associated with the graph."
msgstr "使用 pgRouting 可以解决个人关系、家谱和文件依赖性问题。这些问题通常不会与图形相关的几何图形一起出现。"

msgid "Wiki example"
msgstr "维基示例"

msgid "Solve the example problem taken from `wikipedia <https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm>`__):"
msgstr "解决来自 `维基百科 <https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm>`__):"

msgid "Problem is to find the shortest path from :math:`1` to :math:`5`."
msgstr "问题是找到从 :math:`1` 到 :math:`5` 的最短路径。"

msgid "Is an undirected graph."
msgstr "是一个无向图。"

msgid "Although visually looks like to have geometries, the drawing is not to scale."
msgstr "虽然视觉上看起来有几何形状，但该图并不是按比例绘制的。"

msgid "No geometries associated to the vertices or edges"
msgstr "没有与顶点或边关联的几何图形"

msgid "Has 6 vertices :math:`\\{1,2,3,4,5,6\\}`"
msgstr "有6个顶点 :math:`\\{1,2,3,4,5,6\\}`"

msgid "Has 9 edges:"
msgstr "有九个边："

msgid ":math:`\\begin{split} \\begin{align} E = & \\{(1,2,7), (1,3,9), (1,6,14), \\\\ & (2,3,10), (2,4,13), \\\\ & (3,4,11), (3,6,2), \\\\ & (4,5,6), \\\\ & (5,6,9) \\} \\end{align} \\end{split}`"
msgstr ":math:`\\begin{split} \\begin{align} E = & \\{(1,2,7), (1,3,9), (1,6,14), \\\\ & (2,3,10), (2,4,13), \\\\ & (3,4,11), (3,6,2), \\\\ & (4,5,6), \\\\ & (5,6,9) \\} \\end{align} \\end{split}`"

msgid "The graph can be represented in many ways for example:"
msgstr "该图可以用多种方式表示，例如："

msgid "Prepare the database"
msgstr "准备数据库"

msgid "Create a database for the example, access the database and install pgRouting: ::"
msgstr "为示例创建一个数据库，访问数据库并安装 pgRouting： ::"

msgid "Create a table"
msgstr "创建表"

msgid "The basic elements needed to perform basic routing on an undirected graph are:"
msgstr "在无向图上执行基本路由所需的基本元素是："

msgid "SMALLINT, INTEGER, BIGINT, REAL, FLOAT"
msgstr "SMALLINT, INTEGER, BIGINT, REAL, FLOAT"

msgid "Using this table design for this example:"
msgstr "本示例使用此表设计："

msgid "Insert the data"
msgstr "插入数据"

msgid "Find the shortest path"
msgstr "寻找最短路径"

msgid "To solve this example :doc:`pgr_dijkstra` is used:"
msgstr "为了解决这个例子，使用了 :doc:`pgr_dijkstra`："

msgid "To go from :math:`1` to :math:`5` the path goes thru the following vertices: :math:`1 \\rightarrow 3 \\rightarrow 6 \\rightarrow 5`"
msgstr "从 :math:`1` 到 :math:`5` 的路径要经过以下顶点： :math:`1 \\rightarrow 3 \\rightarrow 6 \\rightarrow 5`"

msgid "Vertex information"
msgstr "顶点信息"

msgid "To obtain the vertices information, use :doc:`pgr_extractVertices`"
msgstr "要获取顶点信息，请使用 :doc:`pgr_extractVertices`"

msgid "Graphs with geometries"
msgstr "具有几何图形的图"

msgid "Create a routing Database"
msgstr "创建路由数据库"

msgid "The first step is to create a database and load pgRouting in the database."
msgstr "第一步是创建数据库并在数据库中加载 pgRouting。"

msgid "Typically create a database for each project."
msgstr "通常为每个项目创建一个数据库。"

msgid "Once having the database to work in, load your data and build the routing application in that database."
msgstr "一旦数据库可以工作，加载数据并在该数据库中构建路由应用程序。"

msgid "Load Data"
msgstr "加载数据"

msgid "There are several ways to load your data into pgRouting."
msgstr "有多种方法可以将数据加载到 pgRouting 中。"

msgid "Manually creating a database."
msgstr "手动创建数据库。"

msgid "`Graphs without geometries`_"
msgstr "`没有几何形状的图`_"

msgid ":doc:`sampledata`: a small graph used in the documentation examples"
msgstr ":doc:`sampledata`: 文档示例中使用的小图形"

msgid "Using `osm2pgrouting <https://workshop.pgrouting.org/latest/en/basic/data.html>`__"
msgstr "使用 `osm2pgrouting <https://workshop.pgrouting.org/latest/en/basic/data.html>`__"

msgid "There are various open source tools that can help, like:"
msgstr "有多种开源工具可以提供帮助，例如："

msgid "shp2pgsql"
msgstr "shp2pgsql"

msgid "postgresql shapefile loader"
msgstr "postgresql shapefile 加载器"

msgid "ogr2ogr"
msgstr "ogr2ogr"

msgid "vector data conversion utility"
msgstr "矢量数据转换实用程序"

msgid "osm2pgsql"
msgstr "osm2pgsql"

msgid "load OSM data into postgresql"
msgstr "将OSM数据加载到postgresql中"

msgid "Please note that these tools will **not** import the data in a structure compatible with pgRouting and when this happens the topology needs to be adjusted."
msgstr "请注意，这些工具 **不会** 导入与 pgRouting 兼容的结构中的数据，当发生这种情况时，需要调整拓扑。"

msgid "Breakup a segments on each segment-segment intersection"
msgstr "在每个线段-线段交叉点上分解线段"

msgid "When missing, add columns and assign values to ``source``, ``target``, ``cost``, ``reverse_cost``."
msgstr "如果缺少，请添加列并为 ``source``, ``target``, ``cost``, ``reverse_cost`` 分配值。"

msgid "Connect a disconnected graph."
msgstr "连接断开的图。"

msgid "Create the complete graph topology"
msgstr "创建完整的图拓扑"

msgid "Create one or more graphs based on the application to be developed."
msgstr "根据要开发的应用程序创建一个或多个图。"

msgid "Create a contracted graph for the high speed roads"
msgstr "为高速道路创建收缩图"

msgid "Create graphs per state/country"
msgstr "创建每个州/国家的图"

msgid "In few words:"
msgstr "简而言之："

msgid "Prepare the graph"
msgstr "准备图"

msgid "What and how to prepare the graph, will depend on the application and/or on the quality of the data and/or on how close the information is to have a topology usable by pgRouting and/or some other factors not mentioned."
msgstr "准备什么以及如何准备图将取决于应用程序和/或数据质量和/或信息与 pgRouting 可用的拓扑的接近程度和/或未提及的一些其他因素。"

msgid "The steps to prepare the graph involve geometry operations using `PostGIS <https://postgis.net/>`__ and some others involve graph operations like :doc:`pgr_contraction` to contract a graph."
msgstr "准备图的步骤涉及使用 `PostGIS <https://postgis.net/>`__ 进行几何操作，其他一些步骤涉及诸如 :doc:`pgr_contraction` 之类的图操作来收缩图。"

msgid "The `workshop <https://workshop.pgrouting.org/latest>`__ has a step by step on how to prepare a graph using Open Street Map data, for a small application."
msgstr "该 `workshop <https://workshop.pgrouting.org/latest>`__ 逐步介绍了如何使用开放街道地图数据为小型应用程序准备图。"

msgid "The use of indexes on the database design in general:"
msgstr "数据库设计上索引的使用一般："

msgid "Have the geometries indexed."
msgstr "对几何图形进行索引。"

msgid "Have the identifiers columns indexed."
msgstr "对标识符列建立索引。"

msgid "Please consult the `PostgreSQL <https://www.postgresql.org/docs/>`__ documentation and the `PostGIS <https://postgis.net/>`__ documentation."
msgstr "请查阅 `PostgreSQL <https://www.postgresql.org/docs/>`__ 文档和 `PostGIS <https://postgis.net/>`__ 文档。"

msgid "Data coming from OSM and using `osm2pgrouting <https://github.com/pgRouting/osm2pgrouting>`__ as an import tool, comes with the routing topology. See an example of using ``osm2pgrouting`` on the `workshop <https://workshop.pgrouting.org/latest/en/basic/data.html>`__."
msgstr "来自 OSM 并使用 `osm2pgrouting <https://github.com/pgRouting/osm2pgrouting>`__ 作为导入工具的数据附带路由拓扑。 请参阅 `workshop <https://workshop.pgrouting.org/latest/en/basic/data.html>`__ 上使用 ``osm2pgrouting`` 的示例。"

msgid "Adjust costs"
msgstr "调整成本"

msgid "For this example the ``cost`` and ``reverse_cost`` values are going to be the double of the length of the geometry."
msgstr "对于本示例， ``cost`` 和 ``reverse_cost`` 值将是几何体长度的两倍。"

msgid "Update costs to length of geometry"
msgstr "将成本更新为几何形状的长度"

msgid "Suppose that ``cost`` and ``reverse_cost`` columns in the sample data represent:"
msgstr "假设样本数据中的 ``cost`` 和 ``reverse_cost`` 列表示："

msgid ":math:`1` when the edge exists in the graph"
msgstr "当边存在于图中时为 :math:`1`"

msgid ":math:`-1` when the edge does not exist in the graph"
msgstr "当图中不存在边时为 :math:`-1`"

msgid "Using that information updating to the length of the geometries:"
msgstr "使用该信息更新几何形状的长度："

msgid "Which gives the following results:"
msgstr "给出以下结果："

msgid "Note that to be able to follow the documentation examples, everything is based on the original graph."
msgstr "请注意，为了能够遵循文档示例，一切都基于原始图。"

msgid "Returning to the original data:"
msgstr "回到原始数据："

msgid "Update costs based on codes"
msgstr "根据代码更新成本"

msgid "Other datasets, can have a column with values like"
msgstr "其他数据集可以有一列包含如下值"

msgid "``FT`` vehicle flow on the direction of the geometry"
msgstr "``FT`` 几何方向上的车流"

msgid "``TF`` vehicle flow opposite of the direction of the geometry"
msgstr "``TF`` 车流与几何方向相反"

msgid "``B`` vehicle flow on both directions"
msgstr "``B`` 双向车流"

msgid "Preparing a code column for the example:"
msgstr "为示例准备代码列："

msgid "Adjusting the costs based on the codes:"
msgstr "根据代码调整成本："

msgid "Check the Routing Topology"
msgstr "检查路由拓扑"

msgid "There are lots of possible problems in a graph."
msgstr "图中可能存在很多问题。"

msgid "The data used may not have been designed with routing in mind."
msgstr "使用的数据在设计时可能没有考虑路由。"

msgid "A graph has some very specific requirements."
msgstr "图有一些非常具体的要求。"

msgid "The graph is disconnected."
msgstr "该图已断开连接。"

msgid "There are unwanted intersections."
msgstr "存在不需要的交叉点。"

msgid "The graph is too large and needs to be contracted."
msgstr "图太大，需要收缩。"

msgid "A sub graph is needed for the application."
msgstr "该应用程序需要一个子图。"

msgid "and many other problems that the pgRouting user, that is the application developer might encounter."
msgstr "以及 pgRouting 用户（即应用程序开发人员）可能遇到的许多其他问题。"

msgid "Crossing edges"
msgstr "交叉边"

msgid "To get the crossing edges:"
msgstr "要获取交叉边："

msgid "That information is correct, for example, when in terms of vehicles, is it a tunnel or bridge crossing over another road."
msgstr "这些信息是正确的，例如，就车辆而言，是隧道还是横跨另一条道路的桥梁。"

msgid "It might be incorrect, for example:"
msgstr "它可能是不正确的，例如："

msgid "When it is actually an intersection of roads, where vehicles can make turns."
msgstr "当它实际上是道路交叉口时，车辆可以转弯。"

msgid "When in terms of electrical lines, the electrical line is able to switch roads even on a tunnel or bridge."
msgstr "在电力线路方面，电力线能够在隧道或桥梁上甚至切换道路。"

msgid "When it is incorrect, it needs fixing:"
msgstr "当不正确时，需要修复："

msgid "For vehicles and pedestrians"
msgstr "对于车辆和行人"

msgid "If the data comes from OSM and was imported to the database using ``osm2pgrouting``, the fix needs to be done in the `OSM portal <https://www.openstreetmap.org>`__ and the data imported again."
msgstr "如果数据来自 OSM 并使用 ``osm2pgrouting`` 导入到数据库，则需要在 `OSM portal <https://www.openstreetmap.org>`__ 中完成修复并再次导入数据。"

msgid "In general when the data comes from a supplier that has the data prepared for routing vehicles, and there is a problem, the data is to be fixed from the supplier"
msgstr "一般来说，当数据来自为车辆路线准备数据的供应商时，并且出现问题时，需要从供应商处修复数据"

msgid "For very specific applications"
msgstr "对于非常具体的应用"

msgid "The data is correct when from the point of view of routing vehicles or pedestrians."
msgstr "从路线车辆或行人的角度来看，数据是正确的。"

msgid "The data needs a local fix for the specific application."
msgstr "数据需要针对特定应用程序进行本地修复。"

msgid "Once analyzed one by one the crossings, for the ones that need a local fix, the edges need to be `split <https://postgis.net/docs/ST_Split.html>`__."
msgstr "对交叉点进行一一分析后，对于需要局部修复的交叉点，需要 `分割 <https://postgis.net/docs/ST_Split.html>`__ 边。"

msgid "The new edges need to be added to the edges table, the rest of the attributes need to be updated in the new edges, the old edges need to be removed and the routing topology needs to be updated."
msgstr "需要将新边添加到边表中，需要更新新边中的其余属性，需要删除旧边并需要更新路由拓扑。"

msgid "Fixing an intersection"
msgstr "修复交叉路口"

msgid "In this example the original edge table will be used to store the additional geometries."
msgstr "在此示例中，原始边线表将用于存储新增的几何图形。"

msgid "An example use without results"
msgstr "使用示例（无结果输出）"

msgid "Routing from :math:`1` to :math:`18` gives no solution."
msgstr "从 :math:`1` 到 :math:`18` 的路由无解。"

msgid "Analyze the network for intersections."
msgstr "分析路网的相交情况。"

msgid "The analysis tell us that the network has an intersection."
msgstr "分析结果表明该路网存在交叉点。"

msgid "Prepare tables"
msgstr "准备数据表"

msgid "Additional columns to control the origin of the segments."
msgstr "用于控制路段来源的附加列。"

msgid "Adding new segments."
msgstr "添加新线段。"

msgid "Calling :doc:`pgr_separateCrossing` and adding the new segments to the edges table."
msgstr "调用 :doc:`pgr_separateCrossing` 并将新的线段添加到边缘表中。"

msgid "Update other values"
msgstr "更新其他数值"

msgid "In this example only ``cost`` and ``reverse_cost`` are updated, where they are based on the length of the geometry and the directionality is kept using the ``sign`` function."
msgstr "在此示例中，仅更新了 ``cost`` 和 ``reverse_cost`` 列，其值基于几何长度并通过 ``sign`` 函数保持方向性。"

msgid "Update the topology"
msgstr "更新拓扑结构"

msgid "Insert the new vertices if any."
msgstr "如有新顶点，则插入。"

msgid "Update source and target information on the edges table."
msgstr "更新边缘表中的源信息和目标信息。"

msgid "The example has results"
msgstr "示例结果"

msgid "Routing from :math:`1` to :math:`18` gives a solution."
msgstr "从 :math:`1` 到 :math:`18` 的路径给出了解决方案。"

msgid "Touching edges"
msgstr "相邻边线"

msgid "Visually the edges seem to be connected, but internally they are not."
msgstr "从视觉上看，这些边缘似乎是相连的，但从内部看却并非如此。"

msgid "The validity of the information is application dependent."
msgstr "信息的有效性取决于应用情况。"

msgid "Maybe there is a small barrier for vehicles but not for pedestrians."
msgstr "也许对车辆有一个小障碍，但对行人却没有。"

msgid "Once analyzed one by one the touchings, for the ones that need a local fix, the edges need to be `split <https://postgis.net/docs/ST_Split.html>`__."
msgstr "逐条分析接触边后，需局部修复的边线应通过 `split <https://postgis.net/docs/ST_Split.html>`__ 。"

msgid "Fixing a gap"
msgstr "弥补差距"

msgid "Routing from :math:`1` to :math:`2` gives no solution."
msgstr "从 :math:`1` 到 :math:`2` 的路由无解。"

msgid "Analyze the network for gaps."
msgstr "分析路网的断点情况。"

msgid "The analysis tell us that the network has a gap."
msgstr "分析表明该路网存在断点。"

msgid "Calling :doc:`pgr_separateTouching` and adding the new segments to the edges table."
msgstr "调用 :doc:`pgr_separateTouching` 并将新的线段添加到边缘表中。"

msgid "Routing from :math:`1` to :math:`2` gives a solution."
msgstr "从 :math:`1` 到 :math:`2` 的路径给出了解决方案。"

msgid "Connecting components"
msgstr "连接组件"

msgid "To get the graph connectivity:"
msgstr "要获取图的连通性："

msgid "There are three basic ways to connect components:"
msgstr "连接组件有三种基本方法："

msgid "From the vertex to the starting point of the edge"
msgstr "从顶点到边的起点"

msgid "From the vertex to the ending point of the edge"
msgstr "从顶点到边的终点"

msgid "From the vertex to the closest vertex on the edge"
msgstr "从边上的顶点到最近的顶点"

msgid "This solution requires the edge to be split."
msgstr "该解决方案需要将边缘分割。"

msgid "In this example :doc:`pgr_separateCrossing` and :doc:`pgr_separateTouching` will be used."
msgstr "在这个例子中，将使用 :doc:`pgr_separateCrossing` 和 :doc:`pgr_separateTouching` 。"

msgid "Get the connectivity"
msgstr "获取连接性"

msgid "In this example: the edges table will need an additional column and the vertex table will be rebuilt completely."
msgstr "在本例中：边表需要增加一列，顶点表将完全重建。"

msgid "Insert new edges"
msgstr "插入新边线"

msgid "Using :doc:`pgr_separateCrossing` and :doc:`pgr_separateTouching` insert the results into the edges table."
msgstr "使用 :doc:`pgr_separateCrossing` 和 :doc:`pgr_separateTouching` 将结果插入边缘表。"

msgid "Create the vertices table"
msgstr "创建顶点表"

msgid "Using :doc:`pgr_extractVertices` create the table."
msgstr "使用 :doc:`pgr_extractVertices` 创建该表。"

msgid "Contraction of a graph"
msgstr "图的收缩"

msgid "The graph can be reduced in size using :doc:`contraction-family`"
msgstr "可以使用 :doc:`contraction-family` 来减小图形的大小"

msgid "When to contract will depend on the size of the graph, processing times, correctness of the data, on the final application, or any other factor not mentioned."
msgstr "何时收缩将取决于图的大小、处理时间、数据的正确性、最终应用程序或任何其他未提及的因素。"

msgid "A fairly good method of finding out if contraction can be useful is because of the number of dead ends and/or the number of linear edges."
msgstr "确定收缩是否有用的一个相当好的方法是根据死端的数量和/或线性边的数量。"

msgid "A complete method on how to contract and how to use the contracted graph is described on :doc:`contraction-family`"
msgstr "有关如何收缩以及如何使用收缩图的完整方法在 :doc:`contraction-family` 中进行了描述"

msgid "To get the dead ends:"
msgstr "获取死端："

msgid "A dead end happens when"
msgstr "死端（Dead End）的形成条件"

msgid "The vertex is the limit of a cul-de-sac, a no-through road or a no-exit road."
msgstr "死端顶点（Dead End Vertex）的拓扑定义。"

msgid "The vertex is on the limit of the imported graph."
msgstr "该顶点位于导入图形的边界处。"

msgid "If a larger graph is imported then the vertex might not be a dead end"
msgstr "如果导入了更大的图，则该顶点可能不会是死端"

msgid "Node :math:`4`, is a dead end on the query, even that it visually looks like an end point of 3 edges."
msgstr "节点 :math:`4` 在查询中是一个死端，即使从视觉上看它是三条边的终点。"

msgid "Is node :math:`4` a dead end or not?"
msgstr "节点 :math:`4` 是死端还是非死端？"

msgid "The answer to that question will depend on the application."
msgstr "这个问题的答案将取决于应用情况。"

msgid "Is there such a small curb:"
msgstr "有这么小的路边吗："

msgid "That does not allow a vehicle to use that visual intersection?"
msgstr "这不允许车辆使用该视觉交叉路口？"

msgid "Is the application for pedestrians and therefore the pedestrian can easily walk on the small curb?"
msgstr "是否适用于行人，因此行人可以轻松地在小路边行走？"

msgid "Is the application for the electricity and the electrical lines than can easily be extended on top of the small curb?"
msgstr "电力和电线的应用是否可以轻松地延伸到小路边顶部？"

msgid "Is there a big cliff and from eagles view look like the dead end is close to the segment?"
msgstr "是否有一个大悬崖，从鹰的角度看，死胡同靠近该路段？"

msgid "Depending on the answer, modification of the data might be needed."
msgstr "根据分析结果，可能需要对数据进行修改。"

msgid "When there are many dead ends, to speed up processing, the :doc:`contraction-family` functions can be used to contract the graph."
msgstr "当存在大量断头节点时，可调用 :doc:`contraction-family` 函数族收缩图形结构以加速处理。"

msgid "Linear edges"
msgstr "线性边"

msgid "To get the linear edges:"
msgstr "要获得线性边："

msgid "These linear vertices are correct, for example, when those the vertices are speed bumps, stop signals and the application is taking them into account."
msgstr "当这些顶点表示减速带、停止信号，并且应用程序将其纳入考虑时，这些线性顶点是正确的。"

msgid "When there are many linear vertices, that need not to be taken into account, to speed up the processing, the :doc:`contraction-family` functions can be used to contract the problem."
msgstr "当图中存在许多不需要考虑的线性顶点时，为了加速处理，可以使用 :doc:`contraction-family` 函数来简化问题。"

msgid "Function's structure"
msgstr "函数的结构"

msgid "Once the graph preparation work has been done above, it is time to use a"
msgstr "完成上述图准备工作后，就可以使用"

msgid "The general form of a pgRouting function call is:"
msgstr "pgRouting 函数调用的一般形式是："

msgid "\\ \\"
msgstr "\\ \\"

msgid "pgr_<name>(`Inner queries`_, **parameters**, [ ``Optional parameters``)"
msgstr "pgr_<name>(`Inner queries`_ , **parameters**, [``Optional parameters``)"

msgid "`Inner queries`_: Are compulsory parameters that are ``TEXT`` strings containing SQL queries."
msgstr "`Inner queries`_ ：是强制参数，是包含 SQL 查询的 ``TEXT`` 字符串。"

msgid "**parameters**: Additional compulsory parameters needed by the function."
msgstr "**parameters**：函数需要的附加强制参数。"

msgid "``Optional parameters``: Are non compulsory **named** parameters that have a default value when omitted."
msgstr "``Optional parameters`` ：是非强制命名参数，省略时具有默认值。"

msgid "The compulsory parameters are positional parameters, the optional parameters are named parameters."
msgstr "强制参数是位置参数，可选参数是命名参数。"

msgid "For example, for this :doc:`pgr_dijkstra` signature:"
msgstr "例如，对于这个 :doc:`pgr_dijkstra` 签名："

msgid "pgr_dijkstra(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr "pgr_dijkstra(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "`Edges SQL`_:"
msgstr "`Edges SQL`_:"

msgid "Is the first parameter."
msgstr "是第一个参数。"

msgid "It is compulsory."
msgstr "这是强制性的。"

msgid "It is an inner query."
msgstr "这是一个内部查询。"

msgid "It has no name, so **Edges SQL** gives an idea of what kind of inner query needs to be used"
msgstr "它没有名称，因此 **Edges SQL** 给出了需要使用哪种内部查询的想法"

msgid "**start vid**:"
msgstr "**start vid**:"

msgid "Is the second parameter."
msgstr "是第二个参数。"

msgid "It has no name, so **start vid** gives an idea of what the second parameter's value should contain."
msgstr "它没有名称，因此 **start vid** 给出了第二个参数的值应包含的内容。"

msgid "Is the third parameter."
msgstr "是第三个参数。"

msgid "It has no name, so **end vid** gives an idea of what the third parameter's value should contain"
msgstr "它没有名称，因此 **end vid** 给出了第三个参数的值应包含的内容"

msgid "Is the fourth parameter."
msgstr "是第四个参数。"

msgid "It is optional."
msgstr "是可选的。"

msgid "It has a name."
msgstr "它有一个名字。"

msgid "The full description of the parameters are found on the `Parameters`_ section of each function."
msgstr "参数的完整描述可以在每个函数的 `Parameters`_ 部分找到。"

msgid "Function's overloads"
msgstr "函数的重载"

msgid "A function might have different overloads. The most common are called:"
msgstr "一个函数可能有不同的重载。 最常见的是："

msgid "`One to One`_"
msgstr "`One to One`_"

msgid "`One to Many`_"
msgstr "`One to Many`_"

msgid "`Many to One`_"
msgstr "`Many to One`_"

msgid "`Many to Many`_"
msgstr "`Many to Many`_"

msgid "`Combinations`_"
msgstr "`组合`_"

msgid "Depending on the overload the parameters types change."
msgstr "根据过载，参数类型会发生变化。"

msgid "**One**: **ANY-INTEGER**"
msgstr "**一**: **ANY-INTEGER**"

msgid "**Many**: ``ARRAY`` [**ANY-INTEGER**]"
msgstr "**Many**: ``ARRAY`` [**ANY-INTEGER**]"

msgid "Depending of the function the overloads may vary. But the concept of parameter type change remains the same."
msgstr "根据函数的不同，重载可能会有所不同。 但参数类型改变的概念保持不变。"

msgid "When routing from:"
msgstr "当路由来自："

msgid "From **one** starting vertex"
msgstr "从 **一** 起始顶点"

msgid "to **one** ending vertex"
msgstr "到 **一** 结束顶点"

msgid "to **many** ending vertices"
msgstr "到 **多** 结束顶点"

msgid "From **many** starting vertices"
msgstr "从 **多** 起始顶点"

msgid "From **many** different starting vertices"
msgstr "从 **多个** 不同的起始顶点"

msgid "to **many** different ending vertices"
msgstr "到 **多个** 不同的结束顶点"

msgid "Every tuple specifies a pair of a start vertex and an end vertex"
msgstr "每个元组指定一对起始顶点和结束顶点"

msgid "Users can define the combinations as desired."
msgstr "用户可以根据需要定义组合。"

msgid "Needs a `Combinations SQL`_"
msgstr "需要 `Combinations SQL`_"

msgid "There are several kinds of valid inner queries and also the columns returned are depending of the function. Which kind of inner query will depend on the function's requirements. To simplify the variety of types, **ANY-INTEGER** and **ANY-NUMERICAL** is used."
msgstr "有几种有效的内部查询类型，返回的列也取决于函数。哪种类型的内部查询将取决于函数的要求。为了简化类型的种类，使用了 **ANY-INTEGER** 和 **ANY-NUMERICAL** 。"

msgid "Edges SQL for"
msgstr "边 SQL"

msgid "Some uncategorised functions"
msgstr "一些未分类的函数"

msgid "General without ``id``"
msgstr "一般没有 ``id``"

msgid "General with (X,Y)"
msgstr "通常带有（X,Y)"

msgid "When negative: edge (``source``, ``target``) does not exist, therefore it's not part of the graph."
msgstr "当为负时：edge (``source``, ``target``)不存在，因此它不是图的一部分。"

msgid "Weight of the edge (``target``, ``source``),"
msgstr "边 (``target``, ``source``)的权重，"

msgid "``x1``"
msgstr "``x1``"

msgid "X coordinate of ``source`` vertex."
msgstr "``source`` 顶点的X坐标。"

msgid "``y1``"
msgstr "``y1``"

msgid "Y coordinate of ``source`` vertex."
msgstr "``source`` 顶点的Y坐标。"

msgid "``x2``"
msgstr "``x2``"

msgid "X coordinate of ``target`` vertex."
msgstr "``target`` 顶点的X坐标。"

msgid "``y2``"
msgstr "``y2``"

msgid "Y coordinate of ``target`` vertex."
msgstr "``target`` 顶点的Y坐标。"

msgid "Flow"
msgstr "流"

msgid "Edges SQL for :doc:`flow-family`"
msgstr "用于流数据系列 ( :doc:`flow-family`) 的Edges SQL"

msgid "Edges SQL for the following functions of :doc:`flow-family`"
msgstr "Edges SQL 适用于 :doc:`flow-family` 的以下函数"

msgid "Used in combination signatures"
msgstr "结合签名使用"

msgid "Points SQL for"
msgstr "用于Points SQL"

msgid "The main parameter of the majority of the pgRouting functions is a query that selects the edges of the graph."
msgstr "大多数 pgRouting 函数的主要参数是选择图的边的查询。"

msgid "Depending on the family or category of a function it will have additional parameters, some of them are compulsory and some are optional."
msgstr "根据函数的族或类别，它将具有附加参数，其中一些是强制性的，一些是可选的。"

msgid "The compulsory parameters are nameless and must be given in the required order. The optional parameters are named parameters and will have a default value."
msgstr "强制参数是无名的，并且必须按要求的顺序给出。 可选参数是命名参数，并且具有默认值。"

msgid "Parameters for the Via functions"
msgstr "Via 函数的参数"

msgid "SQL query as described."
msgstr "如所述的 SQL 查询。"

msgid "When ``true`` Graph is considered `Directed`"
msgstr "当为 ``true`` 时，图被视为 `有向` 图"

msgid "When ``false`` the graph is considered as Undirected."
msgstr "当为 ``false`` 时，图被视为无向图。"

msgid "``strict``"
msgstr "``strict``"

msgid "``false``"
msgstr "``false``"

msgid "When ``true`` if a path is missing stops and returns **EMPTY SET**"
msgstr "当为 ``true`` 时，如果路径丢失，则停止并返回 **EMPTY SET**"

msgid "When ``false`` ignores missing paths returning all paths found"
msgstr "当 ``false`` 忽略丢失的路径时，返回找到的所有路径"

msgid "``U_turn_on_edge``"
msgstr "``U_turn_on_edge``"

msgid "When ``true`` departing from a visited vertex will not try to avoid using the edge used to reach it. In other words, U turn using the edge with same identifier is allowed."
msgstr "当 为 ``true`` 时，从已访问的顶点出发，不会试图避免使用用于到达它的边。换句话说，允许使用具有相同标识符的边来进行掉头。"

msgid "When ``false`` when a departing from a visited vertex tries to avoid using the edge used to reach it. In other words, U turn using the edge with same identifier is used when no other path is found."
msgstr "当为 ``false`` 时，从已访问的顶点出发，尝试避免使用用于到达它的边。换句话说，只有在找不到其他路径时才使用具有相同标识符的边来进行掉头。"

msgid "For the TRSP functions"
msgstr "对于 TRSP 函数"

msgid "Array of identifiers of destination vertices."
msgstr "目标顶点的标识符数组。"

msgid "There are several kinds of columns returned are depending of the function."
msgstr "根据函数的不同，返回的列有多种。"

#, fuzzy
msgid "Result columns for single path functions"
msgstr "生成树函数的结果列"

#, fuzzy
msgid "Used in functions that return one path solution per departure and destination."
msgstr "在返回一个路径解的函数中使用"

msgid ":doc:`pgr_dijkstraNear`"
msgstr ":doc:`pgr_dijkstraNear`"

#, fuzzy
msgid "Returns |short-generic-result|"
msgstr "返回集合 |short-generic-result|"

msgid "``path_seq``"
msgstr "``path_seq``"

msgid "Relative position in the path. Has value **1** for the beginning of a path."
msgstr "路径中的相对位置。 路径开头的值为 **1** 。"

msgid "Identifier of the starting vertex of the current path."
msgstr "当前路径起始顶点的标识符。"

msgid "Identifier of the ending vertex of the current path."
msgstr "当前路径结束顶点的标识符。"

msgid "Identifier of the node in the path from ``start_vid`` to ``end_vid``."
msgstr "从 ``start_vid`` 到 ``end_vid`` 路径中节点的标识符。"

msgid "Identifier of the edge used to go from ``node`` to the next node in the path sequence. **-1** for the last node of the path."
msgstr "用于从路径序列中的 ``node`` 到下一个节点的边的标识符。 **-1** 表示路径的最后一个节点。"

msgid "Cost to traverse from ``node`` using ``edge`` to the next node in the path sequence."
msgstr "从使用 ``edge`` 的 ``node`` 遍历到路径序列中的下一个节点的成本。"

#, fuzzy
msgid "When ``start_vid`` or ``end_vid`` columns have negative values, the identifier is for a Point."
msgstr "当 start_vid 或 end_vid 列具有负值时，标识符用于点。"

#, fuzzy
msgid "Result columns for multiple paths functions"
msgstr "生成树函数的结果列"

#, fuzzy
msgid "Used in functions that return many paths solutions per departure and destination."
msgstr "在返回一个路径解的函数中使用"

#, fuzzy
msgid ":doc:`pgr_KSP`"
msgstr ":doc:`pgr_aStarCost`"

#, fuzzy
msgid ":doc:`pgr_withPointsKSP`"
msgstr ":doc:`pgr_withPoints`"

msgid "Returns set of |generic-result|"
msgstr "返回 |generic-result| 的集合"

msgid "``path_id``"
msgstr "``path_id``"

msgid "Path identifier."
msgstr "路径标识符。"

msgid "Has value **1** for the first of a path from ``start_vid`` to ``end_vid``."
msgstr "从 ``start_vid`` 到 ``end_vid`` 的第一个路径的值为 **1** 。"

msgid "Result columns for cost functions"
msgstr "成本函数结果列"

#, fuzzy
msgid "Used by:"
msgstr "用于："

msgid "When start_vid or end_vid columns have negative values, the identifier is for a Point."
msgstr "当 start_vid 或 end_vid 列具有负值时，标识符用于点。"

msgid "Result columns for flow functions"
msgstr "流量函数的结果列"

msgid "Result columns for spanning tree functions"
msgstr "生成树函数的结果列"

#, fuzzy
msgid "Used in functions that return a tree solution per departure."
msgstr "在返回一个路径解的函数中使用"

#, fuzzy
msgid "Result columns for simple spanning tree functions"
msgstr "生成树函数的结果列"

msgid "Returns set of ``(edge, cost)``"
msgstr "返回集合 ``(edge, cost)``"

msgid "Cost to traverse the edge."
msgstr "穿越边的成本。"

msgid "Performance Tips"
msgstr "性能技巧"

msgid "For the Routing functions"
msgstr "对于路由功能"

msgid "To get faster results bound the queries to an area of interest of routing."
msgstr "为了获得更快的结果，将查询绑定到路由感兴趣的区域。"

msgid "In this example Use an inner query SQL that does not include some edges in the routing function and is within the area of the results."
msgstr "在此示例中，使用内部查询 SQL，该 SQL 不包括路由函数中的某些边并且位于结果区域内。"

msgid "Given this area:"
msgstr "针对该区域："

msgid "Calculate a route:"
msgstr "计算路线："

msgid "How to contribute"
msgstr "如何贡献"

msgid "Wiki"
msgstr "维基"

msgid "Edit an existing `pgRouting Wiki <https://github.com/pgRouting/pgrouting/wiki>`__ page."
msgstr "编辑现有的 `pgRouting 维基 <https://github.com/pgRouting/pgrouting/wiki>`__ 页面。"

msgid "Or create a new Wiki page"
msgstr "或者创建一个新的维基 页面"

msgid "Create a page on the `pgRouting Wiki <https://github.com/pgRouting/pgrouting/wiki>`__"
msgstr "在 `pgRouting 维基 <https://github.com/pgRouting/pgrouting/wiki>`__ 上创建页面"

msgid "Give the title an appropriate name"
msgstr "给标题起一个合适的名称"

msgid "`Example <https://github.com/pgRouting/pgrouting/wiki/How-to:-Handle-parallel-edges-(KSP)>`__"
msgstr "`示例 <https://github.com/pgRouting/pgrouting/wiki/How-to:-Handle-parallel-edges-(KSP)>`__"

msgid "Adding Functionality to pgRouting"
msgstr "为 pgRouting 添加功能"

msgid "Consult the `developer's documentation <https://docs.pgrouting.org/doxy/2.4/index.html>`__"
msgstr "查阅 `开发者文档 <https://docs.pgrouting.org/doxy/2.4/index.html>`__"

msgid "Installation"
msgstr "安装"

msgid "Instructions for downloading and installing binaries for different operating systems, additional notes and corrections not included in this documentation can be found in `Installation wiki <https://github.com/pgRouting/pgrouting/wiki/Notes-on-Download%2C-Installation-and-building-pgRouting>`__"
msgstr "有关下载和安装适用于不同操作系统的二进制文件的说明、本文档中未包含的其他注释和更正，可以在 `安装维基 <https://github.com/pgRouting/pgrouting/wiki/Notes-on-Download%2C-Installation-and-building-pgRouting>`__ 中找到"

#, fuzzy
msgid "To use pgRouting, PostGIS needs to be installed, please read the information about installation in this `Install Guide <https://www.postgis.us/presentations/postgis_install_guide_22.html>`__"
msgstr "使用pgRouting需要安装PostGIS，请阅读本 `安装指南 <https://www.postgis.us/presentations/postgis_install_guide_22.html>`__ 中有关安装的信息"

msgid "Short Version"
msgstr "简洁版本"

msgid "Extracting the tar ball"
msgstr "解压 tar 压缩文件"

msgid "To compile assuming you have all the dependencies in your search path:"
msgstr "假设您的搜索路径中有所有依赖项，则进行编译："

msgid "Once pgRouting is installed, it needs to be enabled in each individual database you want to use it in."
msgstr "安装 pgRouting 后，需要在您想要使用它的每个数据库中启用它。"

msgid "Get the sources"
msgstr "获取源码"

msgid "The pgRouting latest release can be found in https://github.com/pgRouting/pgrouting/releases/latest"
msgstr "pgRouting 最新版本可以在 https://github.com/pgRouting/pgrouting/releases/latest 中找到"

msgid "To download this release:"
msgstr "要下载此版本："

msgid "Go to :ref:`install-short` for more instructions on extracting tar ball and compiling pgRouting."
msgstr "转到 :ref:`install-short` 以获取有关提取 tar 包和编译 pgRouting 的更多说明。"

msgid "git"
msgstr "git"

msgid "To download the repository"
msgstr "下载存储库"

msgid "Go to :ref:`install-short` for more instructions on compiling pgRouting (there is no tar ball involved while downloading pgRouting repository from GitHub)."
msgstr "请参阅 :ref:`install-short` 获取有关编译 pgRouting 的更多说明（从 GitHub 下载 pgRouting 存储库时不涉及 tar 文件）。"

msgid "Enabling and upgrading in the database"
msgstr "在数据库中启用和升级"

msgid "Enabling the database"
msgstr "启用数据库"

msgid "pgRouting is a PostgreSQL extension and depends on PostGIS to provide functionalities to end user. Below given code demonstrates enabling PostGIS and pgRouting in the database."
msgstr "pgRouting 是 PostgreSQL 扩展，依赖 PostGIS 向最终用户提供功能。 下面给出的代码演示了在数据库中启用 PostGIS 和 pgRouting。"

msgid "Checking PostGIS and pgRouting version after enabling them in the database."
msgstr "在数据库中启用 PostGIS 和 pgRouting 后检查它们的版本。"

msgid "Upgrading the database"
msgstr "升级数据库"

#, fuzzy
msgid "To upgrade pgRouting in the database to version 4.1.0 use the following command:"
msgstr "要将数据库中的 pgRouting 升级到 4.0.0 版本，请使用以下命令："

msgid "More information can be found in https://www.postgresql.org/docs/current/sql-createextension.html"
msgstr "更多信息可以在 https://www.postgresql.org/docs/current/sql-createextension.html 中找到"

msgid "Dependencies"
msgstr "依赖"

msgid "Compilation Dependencies"
msgstr "编译依赖"

msgid "To be able to compile pgRouting, make sure that the following dependencies are met:"
msgstr "为了能够编译 pgRouting，请确保满足以下依赖项："

msgid "C and C++0x compilers"
msgstr "C 和 C++0x编译器"

msgid "Compiling with Boost 1.56 up to Boost 1.74 requires C++ Compiler with C++03 or C++11 standard support"
msgstr "使用 Boost 1.56 到 Boost 1.74 进行编译需要具有 C++03 或 C++ 11 标准支持的 C ++编译器"

msgid "Compiling with Boost 1.75 requires C++ Compiler with C++14 standard support"
msgstr "使用 Boost 1.75 进行编译需要具有 C++ 14 标准支持的 C++ 编译器"

#, fuzzy
msgid "Postgresql version >= 13"
msgstr "PostgreSQL version 9.3"

#, fuzzy
msgid "The Boost Graph Library (BGL) >= 1.56.0"
msgstr "Boost 图库 (BGL)。 版本 >= 1.56"

#, fuzzy
msgid "CMake >= 3.12"
msgstr "CMake >= 3.2"

msgid "For user's documentation"
msgstr "用于用户文档"

#, fuzzy
msgid "Sphinx >= 4.0"
msgstr "Sphinx >= 1.1"

msgid "For developer's documentation"
msgstr "对于开发者文档"

msgid "Doxygen >= 1.7"
msgstr "Doxygen >= 1.7"

msgid "For testing"
msgstr "供测试用"

msgid "pgtap"
msgstr "pgtap"

msgid "pg_prove"
msgstr "pg_prove"

msgid "For using:"
msgstr "用于使用："

#, fuzzy
msgid "PostGIS version >= 3.0.0"
msgstr "PostGIS版本 >= 2.2"

msgid "Example: Installing dependencies on linux"
msgstr "示例：在 Linux 上安装依赖项"

msgid "Installing the compilation dependencies"
msgstr "安装编译依赖项"

msgid "Build dependencies"
msgstr "构建依赖关系"

msgid "Optional dependencies"
msgstr "可选依赖项"

#, fuzzy
msgid "For documentation"
msgstr "用于用户文档"

msgid "Configuring"
msgstr "配置"

msgid "pgRouting uses the `cmake` system to do the configuration."
msgstr "pgRouting 使用 `cmake` 系统进行配置。"

msgid "Configurable variables"
msgstr "可配置变量"

msgid "To see the variables that can be configured"
msgstr "查看可以配置的变量"

msgid "The build directory is different from the source directory"
msgstr "构建目录与源目录不同"

msgid "Configuring The Documentation"
msgstr "配置文档"

msgid "User and developers documentation are not build if prerequisites are not found."
msgstr ""

msgid "Most of the effort of the documentation has been on the HTML files. Some variables for building documentation:"
msgstr "文档的大部分工作都集中在 HTML 文件上。 构建文档的一些变量："

msgid "Variable"
msgstr "变量"

msgid "Comment"
msgstr "解释"

msgid "BUILD_HTML"
msgstr "BUILD_HTML"

msgid "BOOL=ON"
msgstr "BOOL=ON"

msgid "If ON, turn on/off building HTML for user's documentation"
msgstr "如果打开，则打开/关闭为用户文档构建 HTML"

msgid "BUILD_DOXY"
msgstr "BUILD_DOXY"

msgid "If ON, turn on/off building HTML for developer's documentation"
msgstr "如果打开，则打开/关闭为开发人员文档构建 HTML"

msgid "BUILD_LATEX"
msgstr "BUILD_LATEX"

msgid "BOOL=OFF"
msgstr "BOOL=OFF"

msgid "If ON, turn on/off building PDF"
msgstr "如果打开，则打开/关闭构建 PDF"

msgid "BUILD_MAN"
msgstr "BUILD_MAN"

msgid "If ON, turn on/off building MAN pages"
msgstr "如果为 ON，则打开/关闭构建 MAN 页面"

msgid "DOC_USE_BOOTSTRAP"
msgstr "DOC_USE_BOOTSTRAP"

msgid "If ON, use sphinx-bootstrap for HTML pages of the users documentation"
msgstr "如果打开，则对用户文档的 HTML 页面使用 sphinx-bootstrap"

msgid "EN"
msgstr ""

#, fuzzy
msgid "if OFF the English documentation will no be built"
msgstr "有关此文档何时构建的信息"

msgid "ES"
msgstr ""

#, fuzzy
msgid "if OFF the Spanish documentation will no be built"
msgstr "有关此文档何时构建的信息"

msgid "SV"
msgstr ""

#, fuzzy
msgid "if OFF the Swedish documentation will no be built"
msgstr "有关此文档何时构建的信息"

msgid "ZH_HANS"
msgstr ""

msgid "if OFF the Chinese simplified documentation will no be built"
msgstr ""

msgid "Building"
msgstr "构建"

msgid "Using ``make`` to build the code and the documentation"
msgstr "使用 ``make`` 构建代码和文档"

#, fuzzy
msgid "The following instructions start from ``path/to/pgrouting/build``"
msgstr "以下说明从 *path/to/pgrouting/build* 开始"

msgid "We have tested on several platforms, For installing or reinstalling all the steps are needed."
msgstr "我们已经在多个平台上进行了测试，安装或重新安装需要所有步骤。"

msgid "Linux"
msgstr "Linux"

#, fuzzy
msgid "The following instructions start from ``path/to/pgrouting``"
msgstr "以下说明从 *path/to/pgrouting* 开始"

msgid "Testing"
msgstr "测试"

msgid "Currently there is no :code:`make test` and testing is done as follows"
msgstr "目前没有 :code:`make test` ，测试如下"

msgid "pgRouting is an extension of `PostGIS <https://postgis.net>`__ and `PostgreSQL <https://www.postgresql.org>`__ geospatial database and adds routing and other network analysis functionality. A predecessor of pgRouting – pgDijkstra, written by Sylvain Pasche from `Camptocamp <https://camptocamp.com>`__, was later extended by Orkney and renamed to pgRouting. The project is now supported and maintained by `Georepublic <https://georepublic.info>`__, `Paragon Corporation <https://www.paragoncorporation.com/>`__ and a broad user community."
msgstr "pgRouting 是 `PostGIS <https://postgis.net>`__ 和 `PostgreSQL <https://www.postgresql.org>`__ 地理空间数据库的扩展，并添加了路由和其他网络分析功能。 pgRouting的前身 – pgDijkstra，由 `Camptocamp <https://camptocamp.com>`__ 的Sylvain Pasche编写，后来被Orkney扩展并更名为pgRouting。 该项目现在得到了 `Georepublic <https://georepublic.info>`__ 、 `Paragon Corporation <https://www.paragoncorporation.com/>`__ 和广大用户社区的支持和维护。"

msgid "pgRouting is part of `OSGeo Community Projects <https://wiki.osgeo.org/wiki/OSGeo_Community_Projects>`__ from the `OSGeo Foundation <https://www.osgeo.org>`__ and included on `OSGeoLive <http://live.osgeo.org/>`__."
msgstr "pgRouting 是 `OSGeo Community Projects <https://wiki.osgeo.org/wiki/OSGeo_Community_Projects>`__ 的一部分，隶属于 `OSGeo Foundation <https://www.osgeo.org>`__ ，并被包含在 `OSGeoLive <http://live.osgeo.org/>`__ 。"

msgid "Licensing"
msgstr "许可"

msgid "The following licenses can be found in pgRouting:"
msgstr "可以在 pgRouting 中找到以下许可证："

msgid "**License**"
msgstr "**许可**"

msgid "GNU General Public License v2.0 or later"
msgstr "GNU 通用公共许可证 v2.0 或更高版本"

msgid "Most features of pgRouting are available under `GNU General Public License v2.0 or later <https://spdx.org/licenses/GPL-2.0-or-later.html>`_."
msgstr "pgRouting 的大多数功能都可以在 `GNU General Public License v2.0 or later <https://spdx.org/licenses/GPL-2.0-or-later.html>`_ 。"

msgid "Boost Software License - Version 1.0"
msgstr "Boost 软件许可证 - 版本 1.0"

msgid "Some Boost extensions are available under `Boost Software License - Version 1.0 <https://www.boost.org/LICENSE_1_0.txt>`_."
msgstr "一些 Boost 扩展可根据 `Boost Software License - Version 1.0 <https://www.boost.org/LICENSE_1_0.txt>`_ 。"

msgid "MIT-X License"
msgstr "MIT-X License"

msgid "Some code contributed by iMaptools.com is available under MIT-X license."
msgstr "iMaptools.com 贡献的一些代码可在 MIT-X 许可证下使用。"

msgid "The pgRouting Manual is licensed under a `Creative Commons Attribution-Share Alike 3.0 License <https://creativecommons.org/licenses/by-sa/3.0/>`_."
msgstr "pgRouting 手册根据 `知识共享署名-相同方式共享 3.0 许可证获得许可 <https://creativecommons.org/licenses/by-sa/3.0/>`_ 。"

msgid "In general license information should be included in the header of each source file."
msgstr "一般来说，许可证信息应包含在每个源文件的标头中。"

msgid "Contributors"
msgstr "贡献者"

msgid "This Release Contributors"
msgstr "此版本贡献者"

#, fuzzy
msgid "Individuals in this release v4.0.0 (in alphabetical order)"
msgstr "本次 v3.8.x 版本发布的个人贡献者（按字母顺序排列）"

#, fuzzy
msgid "Bipasha Gayary, Fan Wu, Regina Obe, Saloni kumari, Vicky Vergara"
msgstr "Aurélie Bousquet, Regina Obe, Vicky Vergara"

msgid "And all the people that give us a little of their time making comments, finding issues, making pull requests etc. in any of our products: osm2pgrouting, pgRouting, pgRoutingLayer, workshop."
msgstr "还有所有为我们的产品（osm2pgrouting、pgRouting、pgRoutingLayer、workshop）提供意见、发现问题、提出拉取请求等帮助的开发者。"

msgid "Translators (in alphabetical order)"
msgstr "翻译（按字母顺序排列）"

msgid "Chinese:"
msgstr ""

msgid "Dapeng Wang"
msgstr "Dapeng Wang"

msgid "Spanish:"
msgstr ""

msgid "Vicky Vergara"
msgstr ""

msgid "Swedish:"
msgstr ""

msgid "Daniel Nylander"
msgstr ""

msgid "Corporate Sponsors in this release (in alphabetical order)"
msgstr "本次发布中的企业赞助商（按字母顺序排列）"

msgid "These are corporate entities that have contributed developer time, hosting, or direct monetary funding to the pgRouting project:"
msgstr "这些是为 pgRouting 项目贡献了开发人员时间、托管或直接提供资金的公司实体："

msgid "`OSGeo <https://www.osgeo.org>`__"
msgstr "`OSGeo <https://www.osgeo.org>`__"

msgid "`OSGeo UK <https://uk.osgeo.org>`__"
msgstr "`OSGeo UK <https://uk.osgeo.org>`__"

msgid "`Google Summer of Code <https://summerofcode.withgoogle.com>`__"
msgstr "`Google Summer of Code <https://summerofcode.withgoogle.com>`__"

msgid "`HighGo Software <https://www.highgo.com/>`__"
msgstr "`HighGo Software <https://www.highgo.com/>`__"

msgid "`Paragon Corporation <https://www.paragoncorporation.com/>`__"
msgstr "`Paragon Corporation <https://www.paragoncorporation.com/>`__"

msgid "Contributors Past & Present:"
msgstr "过去与现在的贡献者："

msgid "Individuals (in alphabetical order)"
msgstr "个人贡献者（按字母排序）"

#, fuzzy
msgid "Aasheesh Tiwari, Abhinav Jain, Aditya Pratap Singh, Adrien Berchet, Akio Takubo, Andrea Nardelli, Anthony Tasca, Anton Patrushev, Aryan Gupta, Ashraf Hossain, Ashish Kumar, Aurélie Bousquet, Bipasha Gayary, Cayetano Benavent, Christian Gonzalez, Daniel Kastl, Dapeng Wang, Dave Potts, David Techer, Denis Rykov, Ema Miyawaki, Esteban Zimanyi, Fan Wu, Florian Thurkow, Frederic Junod, Gerald Fenoy, Gudesa Venkata Sai Akhil, Hang Wu, Himanshu Raj, Imre Samu, Jay Mahadeokar, Jinfu Leng, Kai Behncke, Kishore Kumar, Ko Nagase, Mahmoud Sakr, Manikata Kondeti, Mario Basa, Martin Wiesenhaan, Maxim Dubinin, Maoguang Wang, Mohamed Bakli, Mohamed Zia, Mukul Priya, Nitish Chauhan, Rajat Shinde, Razequl Islam, Regina Obe, Rohith Reddy, Saloni Kumari, Sarthak Agarwal, Shobhit Chaurasia, Sourabh Garg, Stephen Woodbridge, Swapnil Joshi, Sylvain Housseman, Sylvain Pasche, Veenit Kumar, Vidhan Jain, Virginia Vergara, Yige Huang"
msgstr "Aasheesh Tiwari, Abhinav Jain, Aditya Pratap Singh, Adrien Berchet, Akio Takubo, Andrea Nardelli, Anthony Tasca, Anton Patrushev, Aryan Gupta, Ashraf Hossain, Ashish Kumar, Cayetano Benavent, Christian Gonzalez, Daniel Kastl, Dave Potts, David Techer, Denis Rykov, Ema Miyawaki, Esteban Zimanyi, Florian Thurkow, Frederic Junod, Gerald Fenoy, Gudesa Venkata Sai Akhil, Hang Wu, Himanshu Raj, Imre Samu, Jay Mahadeokar, Jinfu Leng, Kai Behncke, Kishore Kumar, Ko Nagase, Mahmoud Sakr, Manikata Kondeti, Mario Basa, Martin Wiesenhaan, Maxim Dubinin, Maoguang Wang, Mohamed Bakli, Mohamed Zia, Mukul Priya, Nitish Chauhan, Rajat Shinde, Razequl Islam, Regina Obe, Rohith Reddy, Sarthak Agarwal, Shobhit Chaurasia, Sourabh Garg, Stephen Woodbridge, Swapnil Joshi, Sylvain Housseman, Sylvain Pasche, Veenit Kumar, Vidhan Jain, Virginia Vergara, Yige Huang"

msgid "Corporate Sponsors (in alphabetical order)"
msgstr "企业赞助商（按字母顺序排列）"

msgid "Camptocamp"
msgstr "Camptocamp"

msgid "CSIS (University of Tokyo)"
msgstr "CSIS (University of Tokyo)"

msgid "Georepublic"
msgstr "Georepublic"

msgid "Google Summer of Code"
msgstr "Google Summer of Code"

msgid "HighGo Software"
msgstr "HighGo Software"

msgid "iMaptools"
msgstr "iMaptools"

msgid "Leopark"
msgstr "Leopark"

msgid "Orkney"
msgstr "Orkney"

msgid "OSGeo"
msgstr "OSGeo"

msgid "OSGeo UK"
msgstr "OSGeo UK"

msgid "Paragon Corporation"
msgstr "Paragon Corporation"

msgid "Versaterm Inc."
msgstr "Versaterm Inc."

msgid "More Information"
msgstr "更多信息"

msgid "The latest software, documentation and news items are available at the pgRouting web site https://pgrouting.org."
msgstr "最新的软件、文档和新闻可在 pgRouting 网站 https://pgrouting.org 上获取。"

msgid "PostgreSQL database server at the PostgreSQL main site https://www.postgresql.org."
msgstr "PostgreSQL 数据库服务器位于 PostgreSQL 主站点 https://www.postgresql.org。"

msgid "PostGIS extension at the PostGIS project web site https://postgis.net."
msgstr "PostGIS 项目网站 https://postgis.net 上的 PostGIS 扩展。"

msgid "Boost C++ source libraries at https://www.boost.org."
msgstr "Boost C++ 源库位于 https://www.boost.org。"

msgid ":doc:`migration`"
msgstr ":doc:`migration`"

msgid "``pgr_KSP`` — Yen's algorithm for K shortest paths using Dijkstra."
msgstr "``pgr_KSP`` — Yen 使用 Dijkstra 计算 K 最短路径的算法。"

msgid "Availability"
msgstr "可用性"

msgid "Version 4.0.0"
msgstr "Version 4.0.0"

msgid "Version 3.6.0"
msgstr "版本3.6.0"

msgid "Standardizing output columns to |nksp-result|"
msgstr "将输出列标准化为 |nksp-result|"

msgid "pgr_ksp(One to One)"
msgstr "pgr_ksp(One to One)"

msgid "Added ``start_vid`` and ``end_vid`` result columns."
msgstr "增加 ``start_vid`` 和 ``end_vid`` 结果列。"

msgid "New proposed signatures:"
msgstr "新提议的签名："

msgid "pgr_ksp(One to Many)"
msgstr "pgr_ksp(One to Many)"

msgid "pgr_ksp(Many to One)"
msgstr "pgr_ksp(Many to One)"

msgid "pgr_ksp(Many to Many)"
msgstr "pgr_ksp(Many to Many)"

msgid "pgr_ksp(Combinations)"
msgstr "pgr_ksp(Combinations)"

msgid "Version 2.1.0"
msgstr "版本2.1.0"

msgid "Signature change"
msgstr "签名变更"

msgid "Old signature no longer supported"
msgstr "不再支持旧签名"

msgid "Version 2.0.0"
msgstr "版本2.0.0"

msgid "Official function."
msgstr "官方函数。"

msgid "The K shortest path routing algorithm based on Yen's algorithm. \"K\" is the number of shortest paths desired."
msgstr "基于Yen算法的K最短路径路由算法。 “K”是所需的最短路径的数量。"

msgid "|Boost| Boost Graph Inside"
msgstr "|Boost| Boost 图内部"

msgid "Boost Graph inside"
msgstr "内部使用 Boost Graph"

msgid "Signatures"
msgstr "签名"

msgid "Summary"
msgstr "总结"

msgid "pgr_KSP(`Edges SQL`_, **start vid**, **end vid**, **K**, [**options**])"
msgstr "pgr_KSP(`Edges SQL`_, **start vid**, **end vid**, **K**, [**options**])"

msgid "pgr_KSP(`Edges SQL`_, **start vid**, **end vids**, **K**, [**options**])"
msgstr "pgr_KSP(`Edges SQL`_, **start vid**, **end vids**, **K**, [**options**])"

msgid "pgr_KSP(`Edges SQL`_, **start vids**, **end vid**, **K**, [**options**])"
msgstr "pgr_KSP(`Edges SQL`_, **start vids**, **end vid**, **K**, [**options**])"

msgid "pgr_KSP(`Edges SQL`_, **start vids**, **end vids**, **K**, [**options**])"
msgstr "pgr_KSP(`Edges SQL`_, **start vids**, **end vids**, **K**, [**options**])"

msgid "pgr_KSP(`Edges SQL`_, `Combinations SQL`_, **K**, [**options**])"
msgstr "pgr_KSP(`Edges SQL`_, `Combinations SQL`_, **K**, [**options**])"

msgid "**options:** ``[directed, heap_paths]``"
msgstr "**options:** ``[directed, heap_paths]``"

msgid "Returns set of |nksp-result|"
msgstr "返回集合 |nksp-result|"

msgid "OR EMPTY SET"
msgstr "OR EMPTY SET"

msgid "Example"
msgstr "示例"

msgid "Get 2 paths from :math:`6` to :math:`17` on a directed graph."
msgstr "在有向图上获取从 :math:`6` 到 :math:`17` 的 2 条路径。"

msgid "Get 2 paths from vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a directed graph."
msgstr "获取有向图上从顶点 :math:`6` 到顶点 :math:`\\{10, 17\\}` 的 2 条路径。"

msgid "Get 2 paths from vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a directed graph."
msgstr "在有向图中得到从顶点 :math:`\\{6, 1\\}` 到顶点 :math:`17` 的2条路经。"

msgid "Get 2 paths vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 17\\}` on a directed graph."
msgstr "在有向图中得到从顶点 :math:`\\{6, 1\\}` 到顶点 :math:`\\{10, 17\\}` 的2条路经。"

msgid "Using a combinations table on an directed graph"
msgstr "在有向图上使用组合表"

msgid "The combinations table:"
msgstr "组合表："

msgid "The query:"
msgstr "查询："

msgid "Identifier of the destination vertex."
msgstr "目标顶点的标识符。"

msgid "**K**"
msgstr "**K**"

msgid "Number of required paths."
msgstr "所需路径的数量。"

msgid "KSP Optional parameters"
msgstr "KSP 可选参数"

msgid "``heap_paths``"
msgstr "``heap_paths``"

msgid "When ``false`` Returns at most K paths."
msgstr "当 ``false`` 时返回最多 K 条路径。"

msgid "When ``true`` all the calculated paths while processing are returned."
msgstr "当 ``true`` 时，返回处理时的所有计算路径。"

msgid "Roughly, when the shortest path has ``N`` edges, the heap will contain about than ``N * K`` paths for small value of ``K`` and ``K > 5``."
msgstr "粗略地说，当最短路径有 ``N`` 个边时，对于 ``K`` 值较小且 ``K > 5`` ，堆将包含大约 ``N * K`` 条路径。"

msgid "Additional Examples"
msgstr "其他示例"

msgid "Get 2 paths from :math:`6` to :math:`17` on an undirected graph"
msgstr "在无向图中获取从 :math:`6` 到 :math:`17` 的2条路径"

msgid "Also get the paths in the heap."
msgstr "还获取堆中的路径。"

msgid "Get 2 paths using combinations table on an undirected graph"
msgstr "使用无向图上的组合表获取 2 条路径"

msgid "Get 2 paths from vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a undirected graph."
msgstr "在无向图中获取从顶点 :math:`\\{6, 1\\}` 到顶点 :math:`17` 的2条路径。"

msgid "https://en.wikipedia.org/wiki/K_shortest_path_routing"
msgstr "https://en.wikipedia.org/wiki/K_shortest_path_routing"

msgid "``pgr_TSP``"
msgstr "``pgr_TSP``"

msgid "``pgr_TSP`` - Approximation using *metric* algorithm."
msgstr "``pgr_TSP`` - 使用 *metric* 算法的近似计算。"

msgid "Availability:"
msgstr "可用性："

msgid "Version 3.2.1"
msgstr "版本3.2.1"

msgid "Metric Algorithm from `Boost library <https://www.boost.org/libs/graph/doc/metric_tsp_approx.html>`__"
msgstr "`Boost库 <https://www.boost.org/libs/graph/doc/metric_tsp_approx.html>`__ 中的度量算法"

msgid "Simulated Annealing Algorithm no longer supported"
msgstr "Simulated Annealing算法不再受支持"

msgid "The Simulated Annealing Algorithm related parameters are ignored: `max_processing_time`, `tries_per_temperature`, `max_changes_per_temperature`, `max_consecutive_non_changes`, `initial_temperature`, `final_temperature`, `cooling_factor`, `randomize`"
msgstr "Simulated Annealing 算法相关参数被忽略： `max_processing_time`, `tries_per_temperature`, `max_changes_per_temperature`, `max_consecutive_non_changes`, `initial_temperature`, `final_temperature`, `cooling_factor`, `randomize`"

msgid "Version 2.3.0"
msgstr "版本2.3.0"

msgid "Results change depending on input order of the `Matrix SQL`_"
msgstr ""

#, fuzzy
msgid "Negative costs are ignored."
msgstr ":math:`0` 值被忽略"

msgid "Can be Used with :doc:`costMatrix-category` functions preferably with `directed => false`."
msgstr "可以与 :doc:`costMatrix-category` 函数一起使用，最好使用 `directed => false`。"

msgid "With ``directed => false``"
msgstr "使用 ``directed => false``"

msgid "Will generate a graph that:"
msgstr "将生成一个图："

msgid "is undirected"
msgstr "是无向的"

msgid "is fully connected (As long as the graph has one component)"
msgstr "是完全连接的（只要图有一个分量）"

msgid "all traveling costs on edges obey the triangle inequality."
msgstr "所有边上的旅行成本都遵循三角不等式。"

msgid "When ``start_vid = 0 OR end_vid = 0``"
msgstr "当 ``start_vid = 0 OR end_vid = 0``"

msgid "The solutions generated are guaranteed to be *twice as long as the optimal tour in the worst case*"
msgstr "生成的解在最坏情况下保证 *不超过最优路径长度的两倍*"

msgid "When ``start_vid != 0 AND end_vid != 0 AND start_vid != end_vid``"
msgstr "当 ``start_vid != 0 AND end_vid != 0 AND start_vid != end_vid``"

msgid "It is **not guaranteed** that the solution will be, in the worst case, twice as long as the optimal tour, due to the fact that `end_vid` is forced to be in a fixed position."
msgstr "由于 `end_vid` 被限制在固定位置，因此**无法保证**在最坏情况下，生成的解长度最多为最优路线长度的两倍。"

msgid "With ``directed => true``"
msgstr "当 ``directed => true``"

msgid "It is **not guaranteed** that the solution will be, in the worst case, twice as long as the optimal tour"
msgstr "**无法保证** 该解在最坏情况下不超过最优路径长度的两倍"

msgid "is directed"
msgstr "有向"

msgid "some (or all) traveling costs on edges might not obey the triangle inequality."
msgstr "某些（或全部）边上的旅行成本可能不满足三角不等式。"

msgid "As an undirected graph is required, the directed graph is transformed as follows:"
msgstr "由于需要无向图，有向图变换如下："

msgid "edges `(u, v)` and `(v, u)` is considered to be the same edge (denoted `(u, v)`"
msgstr "边 `(u, v)` 和 `(v, u)`被认为是相同的边（表示为 `(u, v)`"

msgid "if ``agg_cost`` differs between one or more instances of edge `(u, v)`"
msgstr "如果 ``agg_cost`` 在边 `(u, v)` 的一个或多个实例之间不同"

msgid "The minimum value of the ``agg_cost`` all instances of edge `(u, v)` is going to be considered as the ``agg_cost`` of edge `(u, v)`"
msgstr "边 `(u, v)` 的所有实例的 ``agg_cost`` 最小值将被视为边 `(u, v)` 的 ``agg_cost``"

msgid "Some (or all) traveling costs on edges will still might not obey the triangle inequality."
msgstr "边上的一些（或全部）旅行成本仍然可能不遵守三角不等式。"

msgid "When the data does not come from an undirected graph or its not fully connected:"
msgstr ""

#, fuzzy
msgid "Missing values will be calculated with dijkstra algorithm."
msgstr "缺失值将使用 dijkstra 算法计算。"

#, fuzzy
msgid "When the graph has more than one component:"
msgstr "当图不连通时"

msgid "``start_vid`` or ``end_vid`` are defined and are on the same component: the TSP tour will happen on that component."
msgstr ""

msgid "``start_vid`` or ``end_vid`` are defined and are not on the same component: the TSP tour will propose a tour that has both components where connecting costs are estimated."
msgstr ""

msgid "``start_vid`` or ``end_vid`` are not defined: the starting point could be on any component and will include data only from that component."
msgstr ""

msgid "One cycle attempt to remove crossing edges is done to the TSP results."
msgstr ""

msgid "pgr_TSP(`Matrix SQL`_, ``[start_id, end_id]``)"
msgstr "pgr_TSP(`Matrix SQL`_, ``[start_id, end_id]``)"

msgid "Returns set of |tsp-result|"
msgstr "返回 |tsp-result| 的集合"

msgid "Using :doc:`pgr_dijkstraCostMatrix` to generate the matrix information"
msgstr "使用 :doc:`pgr_dijkstraCostMatrix` 生成矩阵信息"

msgid "**Line 4** Vertices :math:`\\{2, 4, 13, 14\\}` are not included because they are not connected."
msgstr "**Line 4** 顶点 :math:`\\{2, 4, 13, 14\\}` 不包括在内，因为它们未连接。"

msgid "`Matrix SQL`_ as described below"
msgstr "`Matrix SQL`_ 如下所述"

msgid "``ANY-INTEGER``"
msgstr "``ANY-INTEGER``"

msgid "``ANY-NUMERICAL``"
msgstr "``ANY-NUMERICAL``"

msgid "Cost for going from start_vid to end_vid"
msgstr "从 start_vid 到 end_vid 的成本"

msgid "Returns SET OF ``(seq, node, cost, agg_cost)``"
msgstr "返回集合 ``(seq, node, cost, agg_cost)``"

msgid "Row sequence."
msgstr "行顺序。"

msgid "**node**"
msgstr "**node**"

msgid "Identifier of the node/coordinate/point."
msgstr "节点/坐标/点的标识符。"

msgid "Cost to traverse from the current ``node`` to the next ``node`` in the path sequence."
msgstr "从路径序列中的当前 ``node`` 遍历到下一个 ``node`` 的成本。"

msgid "``0`` for the last row in the tour sequence."
msgstr "``0`` 表示游览序列中的最后一行。"

msgid "Aggregate cost from the ``node`` at ``seq = 1`` to the current node."
msgstr "从 ``seq = 1`` 的 ``node`` 到当前节点的总成本。"

msgid "``0`` for the first row in the tour sequence."
msgstr "``0`` 表示游览序列中的第一行。"

msgid "Start from vertex :math:`1`"
msgstr "从顶点 :math:`1` 开始"

msgid "**Line 6** ``start_vid => 1``"
msgstr "**Line 6** ``start_vid => 1``"

msgid "Using points of interest to generate an asymmetric matrix."
msgstr "使用兴趣点（POI）生成非对称矩阵的步骤如下。"

msgid "To generate an asymmetric matrix:"
msgstr "生成非对称矩阵："

msgid "**Line 4** The ``side`` information of ``pointsOfInterset`` is ignored by not including it in the query"
msgstr "**Line 4** 通过未在查询中包括 ``pointsOfInterset`` 中的 ``side`` 信息而被忽略"

msgid "**Line 6** Generating an asymmetric matrix with ``directed => true``"
msgstr "**Line 6** 行 生成非对称矩阵， ``directed => true``"

msgid ":math:`min(agg\\_cost(u, v), agg\\_cost(v, u))` is going to be considered as the ``agg_cost``"
msgstr ":math:`min(agg\\_cost(u, v), agg\\_cost(v, u))` 将被视为 ``agg_cost``"

msgid "The solution that can be larger than *twice as long as the optimal tour* because:"
msgstr "该解决方案的长度可能是*最佳行程的两倍以上*，因为："

msgid "Triangle inequality might not be satisfied."
msgstr "三角不等式可能不满足。"

msgid "``start_id != 0 AND end_id != 0``"
msgstr "``start_id != 0 AND end_id != 0``"

msgid "Connected incomplete data"
msgstr "连接不完整数据"

msgid "Using selected edges :math:`\\{2, 4, 5, 8, 9, 15\\}` the matrix is not complete."
msgstr "使用选定的边 :math:`\\{2, 4, 5, 8, 9, 15\\}`，矩阵不完整。"

msgid "Cost value for :math:`17 \\rightarrow 10` do not exist on the matrix, but the value used is taken from :math:`10 \\rightarrow 17`."
msgstr "对于 :math:`17 \\rightarrow 10` 的成本值在矩阵中不存在，但使用的值是从 :math:`10 \\rightarrow 17` 中获取的。"

msgid "``pgr_TSPeuclidean``"
msgstr "``pgr_TSPeuclidean``"

msgid "``pgr_TSPeuclidean`` - Approximation using *metric* algorithm."
msgstr "``pgr_TSPeuclidean`` - 使用 *metric* 算法进行近似计算。"

msgid "Using `Boost: metric TSP approx <https://www.boost.org/libs/graph/doc/metric_tsp_approx.html>`__"
msgstr "使用 `Boost: metric TSP approx <https://www.boost.org/libs/graph/doc/metric_tsp_approx.html>`__"

msgid "Name change from pgr_eucledianTSP"
msgstr "pgr_eucledianTSP 的名称更改"

msgid "New official function."
msgstr "新官方函数说明。"

msgid "Results change depending on input order of the `Coordinates SQL`_"
msgstr ""

msgid "Any duplicated identifier will be ignored. The coordinates that will be kept is arbitrarily."
msgstr "任何重复的标识符都会被忽略，保留的坐标是任意选择的。"

msgid "The coordinates are quite similar for the same identifier, for example ::"
msgstr "对于相同的标识符，坐标非常相似，例如 ::"

msgid "The coordinates are quite different for the same identifier, for example ::"
msgstr "对于相同的标识符，坐标有很大不同，例如::"

msgid "pgr_TSPeuclidean(`Coordinates SQL`_, ``[start_id, end_id]``)"
msgstr "pgr_TSPeuclidean(`Coordinates SQL`_, ``[start_id, end_id]``)"

msgid "With default values"
msgstr "有默认值"

msgid "`Coordinates SQL`_"
msgstr "`Coordinates SQL`_"

msgid "`Coordinates SQL`_ as described below"
msgstr "`Coordinates SQL`_ 如下所述"

msgid "Coordinates SQL"
msgstr "坐标SQL"

msgid "``x``"
msgstr "``x``"

msgid "X value of the coordinate."
msgstr "坐标的X值。"

msgid "``y``"
msgstr "``y``"

msgid "Y value of the coordinate."
msgstr "坐标的Y值。"

msgid "Test 29 cities of Western Sahara"
msgstr "测试西撒哈拉29个城市"

msgid "This example shows how to make performance tests using University of Waterloo's `example data <https://www.math.uwaterloo.ca/tsp/world/countries.html>`__ using the 29 cities of `Western Sahara dataset <https://www.math.uwaterloo.ca/tsp/world/wi29.tsp>`__"
msgstr "此示例展示了如何使用Waterloo大学的 `示例数据 <https://www.math.uwaterloo.ca/tsp/world/countries.html>`__ ，使用29 个城市的数据集 `Western Sahara dataset <https://www.math.uwaterloo.ca/tsp/world/wi29.tsp>`__ 进行性能测试"

msgid "Creating a table for the data and storing the data"
msgstr "创建数据表并存储数据"

msgid "Adding a geometry (for visual purposes)"
msgstr "添加几何图形（用于视觉目的）"

msgid "Total tour cost"
msgstr "旅游总费用"

msgid "Getting a total cost of the tour, compare the value with the length of an optimal tour is 27603, given on the dataset"
msgstr "获取旅行的总成本，将该值与数据集上给出的最佳旅行长度 27603 进行比较"

msgid "Getting a geometry of the tour"
msgstr "获取游览的几何形状"

msgid "Visual results"
msgstr "视觉效果"

msgid "Visually, The first image is the `optimal solution <https://www.math.uwaterloo.ca/tsp/world/witour.html>`__ and the second image is the solution obtained with ``pgr_TSPeuclidean``."
msgstr "从视觉上比较，第一个图展示了 `最优解 <https://www.math.uwaterloo.ca/tsp/world/witour.html>`__ ，而第二个图展示了使用 ``pgr_TSPeuclidean`` 所得到的解。"

msgid "``pgr_aStar`` — Shortest path using the A* algorithm."
msgstr "``pgr_aStar`` — 使用 A* 算法的最短路径。"

msgid "Standardizing output columns to |short-generic-result|"
msgstr "将输出列标准化为 |short-generic-result|"

msgid "pgr_aStar(One to One) added ``start_vid`` and ``end_vid`` columns."
msgstr "pgr_aStar(One to One) 增加了 `start_vid`` 和 ``end_vid`` 列。"

msgid "pgr_aStar(One to Many) added ``end_vid`` column."
msgstr "pgr_aStar(One to Many) 添加了 ``end_vid`` 列。"

msgid "pgr_aStar(Many to One) added ``start_vid`` column."
msgstr "pgr_aStar(Many to One) 添加了 ``start_vid`` 列。"

msgid "New proposed signature:"
msgstr "新提议的签名："

msgid "pgr_aStar(Combinations)"
msgstr "pgr_aStar(组合)"

msgid "Version 2.4.0"
msgstr "版本2.4.0"

msgid "pgr_aStar(One to Many)"
msgstr "pgr_aStar(One to Many)"

msgid "pgr_aStar(Many to One)"
msgstr "pgr_aStar(Many to One)"

msgid "pgr_aStar(Many to Many)"
msgstr "pgr_aStar(Many to Many)"

msgid "Signature change on pgr_aStar(One to One)"
msgstr "pgr_aStar(One to One) 函数签名变更"

msgid "The results are equivalent to the union of the results of the `pgr_aStar(` `One to One`_ `)` on the:"
msgstr "结果相当于 `pgr_aStar(` `One to One`_ `)` 结果的并集："

msgid "pgr_aStar(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr "pgr_aStar(`Edges SQL`_, **start vid**, **end vid**, [**options**])"

msgid "pgr_aStar(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr "pgr_aStar(`Edges SQL`_, **start vid**, **end vids**, [**options**])"

msgid "pgr_aStar(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr "pgr_aStar(`Edges SQL`_, **start vids**, **end vid**, [**options**])"

msgid "pgr_aStar(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr "pgr_aStar(`Edges SQL`_, **start vids**, **end vids**, [**options**])"

msgid "pgr_aStar(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr "pgr_aStar(`Edges SQL`_, `Combinations SQL`_, [**options**])"

msgid "**options:** ``[directed, heuristic, factor, epsilon]``"
msgstr "**options:** ``[directed, heuristic, factor, epsilon]``"

msgid "Returns set of |short-generic-result|"
msgstr "返回集合 |short-generic-result|"

msgid "Optional parameters are `named parameters` and have a default value."
msgstr "可选参数是`命名参数` 并具有默认值。"

msgid "From vertex :math:`6` to vertex :math:`12` on a **directed** graph with heuristic :math:`2`"
msgstr "在具有heuristic :math:`2` 的 **有向** 图上，从顶点 :math:`6` 到顶点 :math:`12`"

msgid "From vertex :math:`6` to vertices :math:`\\{10, 12\\}` on a **directed** graph with heuristic :math:`3` and factor :math:`3.5`"
msgstr "在具有heuristic :math:`3` 和factor :math:`3.5` 的 **有向** 图上，从顶点 :math:`6` 到顶点 :math:`\\{10, 12\\}`"

msgid "From vertices :math:`\\{6, 8\\}` to vertex :math:`10` on an **undirected** graph with heuristic :math:`4`"
msgstr "在具有heuristic :math:`4` 的 **无向** 图上，从顶点 :math:`\\{6, 8\\}` 到顶点 :math:`10`"

msgid "From vertices :math:`\\{6, 8\\}` to vertices :math:`\\{10, 12\\}` on a **directed** graph with factor :math:`0.5`"
msgstr "在具有factor :math:`0.5` 的 **有向** 图上，从顶点 :math:`\\{6, 8\\}` 到顶点 :math:`\\{10, 12\\}`"

msgid "Using a combinations table on a **directed** graph with factor :math:`0.5`."
msgstr "在 **有向** 图上使用组合表，且使用factor :math:`0.5`。"

msgid "Example 1"
msgstr "示例1"

msgid "Demonstration of repeated values are ignored, and result is sorted."
msgstr "演示中重复的值被忽略，且结果被排序。"

msgid "Example 2"
msgstr "示例2"

msgid "Making **start vids** the same as **end vids**."
msgstr "使 **start vids** 与 **end vids** 相同。"

msgid "Example 3"
msgstr "示例3"

msgid "Manually assigned vertex combinations."
msgstr "手动指定的顶点组合。"

msgid "``pgr_aStarCost``"
msgstr "``pgr_aStarCost``"

msgid "``pgr_aStarCost`` - Total cost of the shortest path using the A* algorithm."
msgstr "``pgr_aStarCost`` - 使用 A* 算法计算最短路径的总成本。"

msgid "pgr_aStarCost(Combinations)"
msgstr "pgr_aStarCost(组合)"

msgid "New proposed function."
msgstr "新提议的函数。"

#, fuzzy
msgid "The ``pgr_aStarCost`` function summarizes the cost of the shortest path using the A* algorithm."
msgstr "``pgr_aStarCost`` 函数通过 A* 算法汇总最短路径的成本。"

msgid "Let be the case the values returned are stored in a table, so the unique index would be the pair: `(start_vid, end_vid)`"
msgstr "假设返回的值存储在表中，因此唯一索引将是一对：`(start_vid, end_vid)`"

msgid "For undirected graphs, the results are symmetric."
msgstr "对于无向图，结果是对称的。"

msgid "The returned values are ordered in ascending order:"
msgstr "返回值按升序排列："

msgid "`start_vid` ascending"
msgstr "`start_vid` 升序"

msgid "`end_vid` ascending"
msgstr "`end_vid` 升序"

msgid "pgr_aStarCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr "pgr_aStarCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"

msgid "pgr_aStarCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr "pgr_aStarCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"

msgid "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"

msgid "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"

msgid "pgr_aStarCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr "pgr_aStarCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"

msgid "Returns set of |matrix-result|"
msgstr "返回 |matrix-result| 的集合"

msgid "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vids**, [options])"
msgstr "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vids**, [options])"

msgid "``pgr_aStarCostMatrix``"
msgstr "``pgr_aStarCostMatrix``"

msgid "``pgr_aStarCostMatrix`` - Calculates the a cost matrix using :doc:`pgr_aStar`."
msgstr "``pgr_aStarCostMatrix`` - 使用 :doc:`pgr_aStar` 计算成本矩阵。"

msgid "Using internally the :doc:`pgr_aStar` algorithm"
msgstr "内部通过调用 :doc:`pgr_aStar` 算法进行处理"

msgid "Returns a cost matrix."
msgstr "返回成本矩阵。"

msgid "No ordering is performed"
msgstr "不进行排序"

msgid "let `v` and `u` are nodes on the graph:"
msgstr "设`v` 和 `u` 是图上的节点："

msgid "when there is no path from `v` to `u`:"
msgstr "当没有从 `v` 到 `u` 的路径时："

msgid "cost from `v` to `u` is :math:`\\inf`"
msgstr "从 `v` 到 `u` 的成本是 :math:`\\inf`"

msgid "when :math:`v = u` then"
msgstr "当 :math:`v = u` 时"

msgid "cost from `v` to `u` is :math:`0`"
msgstr "从 `v` 到 `u` 的成本是 :math:`0`"

msgid "When the graph is **undirected** the cost matrix is symmetric"
msgstr "当图 **无向** 时，成本矩阵是对称的"

msgid "pgr_aStarCostMatrix(`Edges SQL`_, **start vids**, [**options**])"
msgstr "pgr_aStarCostMatrix(`Edges SQL`_, **start vids**, [**options**])"

msgid "Symmetric cost matrix for vertices :math:`\\{5, 6, 10, 15\\}` on an **undirected** graph using heuristic :math:`2`"
msgstr "在 **无向** 图上，使用heuristic :math:`2`，对顶点 :math:`\\{5, 6, 10, 15\\}` 创建对称的成本矩阵"

msgid "Use with :doc:`pgr_TSP`"
msgstr "使用 :doc:`pgr_TSP`"

msgid "``pgr_articulationPoints``"
msgstr "``pgr_articulationPoints``"

msgid "``pgr_articulationPoints`` - Return the articulation points of an undirected graph."
msgstr "``pgr_articulationPoints`` - 返回无向图的连接点。"

msgid "Result columns change: ``seq`` is removed"
msgstr "结果列更改：删除了 ``seq``"

msgid "Version 2.5.0"
msgstr "版本2.5.0"

msgid "Those vertices that belong to more than one biconnected component are called articulation points or, equivalently, cut vertices. Articulation points are vertices whose removal would increase the number of connected components in the graph. This implementation can only be used with an undirected graph."
msgstr "那些属于多于一个双连通分量的顶点被称为关节点，或者等效地称为割点。关节点是指那些如果被移除，会增加图中连接分量数量的顶点。这个实现仅适用于无向图。"

msgid "Works for **undirected** graphs."
msgstr "适用于 **无向** 图。"

msgid "``node`` ascending"
msgstr "``node`` 升序"

msgid "Running time: :math:`O(V + E)`"
msgstr "运行时间： :math:`O(V + E)`"

msgid "pgr_articulationPoints(`Edges SQL`_)"
msgstr "pgr_articulationPoints(`Edges SQL`_)"

msgid "Returns set of |result-node|"
msgstr "返回集合 |result-node|"

msgid "The articulation points of the graph"
msgstr "图表的连接点"

msgid "Nodes in red are the articulation points."
msgstr "红色节点是关节点。"

msgid "Identifier of the vertex."
msgstr "顶点的标识符。"

msgid "`Boost: Biconnected components & articulation points <https://www.boost.org/libs/graph/doc/biconnected_components.html>`__"
msgstr "`Boost: 双连通分量与割点 <https://www.boost.org/libs/graph/doc/biconnected_components.html>`__"

msgid "wikipedia: `Biconnected component <https://en.wikipedia.org/wiki/Biconnected_component>`__"
msgstr "维基百科: `双连通分量 <https://en.wikipedia.org/wiki/Biconnected_component>`__"

#, fuzzy
msgid "``pgr_bandwidth`` - Experimental"
msgstr "``pgr_bipartite`` - 实验性"

msgid "``pgr_bandwidth`` - Calculates the bandwidth of the graph"
msgstr ""

msgid "Bandwidth measures how \"spread out\" the connections are in a graph when vertices are arranged in a linear order (like numbering them 1, 2, 3, etc.)."
msgstr ""

msgid "For each edge in the graph, calculate the distance between the vertex numbers it connects"
msgstr ""

msgid "The bandwidth is the maximum of all these distances"
msgstr ""

#, fuzzy
msgid "The implementation is for undirected graphs"
msgstr "该实现适用于 **无向** 图。"

msgid "Run time is 0.160789 seconds"
msgstr ""

#, fuzzy
msgid "pgr_bandwidth(`Edges SQL`_)"
msgstr "pgr_bipartite(`Edges SQL`_)"

#, fuzzy
msgid "Returns ``BIGINT``"
msgstr "``BIGINT``"

#, fuzzy
msgid "For an undirected graph with edges."
msgstr "对于一个undirected graph(无向图)，其边为 :math:'{2,4,5,8}'"

#, fuzzy
msgid "Returns a bigint ``(pgr_bandwidth)``"
msgstr "返回一个布尔值 ``(pgr_isplanar)``"

msgid "``pgr_bandwidth``"
msgstr "``pgr_bandwidth``"

#, fuzzy
msgid "gives the bandwidth of the graph."
msgstr "边不是图的一部分："

#, fuzzy
msgid "Undirected graph with edges before optimization."
msgstr "在有向图中，两条边都有方向性"

#, fuzzy
msgid "Undirected graph with edges after optimization."
msgstr "在有向图中，两条边都有方向性"

#, fuzzy
msgid "`Boost: bandwidth <https://www.boost.org/libs/graph/doc/bandwidth.html>`_"
msgstr "`Boost: 是否为二分图 <https://www.boost.org/libs/graph/doc/is_bipartite.html>`__"

msgid "``pgr_bdAstar``"
msgstr "``pgr_bdAstar``"

msgid "``pgr_bdAstar`` — Shortest path using the bidirectional A* algorithm."
msgstr "``pgr_bdAstar`` — 使用双向 A* 算法的最短路径。"

msgid "pgr_bdAstar(One to One) added ``start_vid`` and ``end_vid`` columns."
msgstr "pgr_bdAstar(One to One) 增加了 ``start_vid`` 和 ``end_vid`` 列。"

msgid "pgr_bdAstar(One to Many) added ``end_vid`` column."
msgstr "pgr_bdAstar(One to Many) 添加了 ``end_vid`` 列。"

msgid "pgr_bdAstar(Many to One) added ``start_vid`` column."
msgstr "pgr_bdAstar(Many to One) 添加了 ``start_vid`` 列。"

msgid "pgr_bdAstar(Combinations)"
msgstr "pgr_bdAstar(组合)"

msgid "pgr_bdAstar(One to Many)"
msgstr "pgr_bdAstar(One to Many)"

msgid "pgr_bdAstar(Many to One)"
msgstr "pgr_bdAstar(Many to One)"

msgid "pgr_bdAstar(Many to Many)"
msgstr "pgr_bdAstar(Many to Many)"

msgid "Signature change on pgr_bdAstar(One to One)"
msgstr "pgr_bdAstar(One to One) 函数签名变更"

#, fuzzy
msgid "The results are equivalent to the union of the results of pgr_bdAStar(One to One) on the:"
msgstr "结果等效于以下情形中 pgr_bdAStar(One to One) 结果的并集："

msgid "pgr_bdAstar(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr "pgr_bdAstar(`Edges SQL`_, **start vid**, **end vid**, [**options**])"

msgid "pgr_bdAstar(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr "pgr_bdAstar(`Edges SQL`_, **start vid**, **end vids**, [**options**])"

msgid "pgr_bdAstar(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr "pgr_bdAstar(`Edges SQL`_, **start vids**, **end vid**, [**options**])"

msgid "pgr_bdAstar(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr "pgr_bdAstar(`Edges SQL`_, **start vids**, **end vids**, [**options**])"

msgid "pgr_bdAstar(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr "pgr_bdAstar(`Edges SQL`_, `Combinations SQL`_, [**options**])"

msgid "``pgr_bdAstarCost``"
msgstr "``pgr_bdAstarCost``"

msgid "``pgr_bdAstarCost`` - Total cost of the shortest path using the bidirectional A* algorithm."
msgstr "``pgr_bdAstarCost`` - 使用双向 A* 算法计算的最短路径的总成本。"

msgid "pgr_bdAstarCost(Combinations)"
msgstr "pgr_bdAstarCost(组合)"

#, fuzzy
msgid "The ``pgr_bdAstarCost`` function summarizes the cost of the shortest path using the bidirectional A* algorithm."
msgstr "``pgr_bdAstarCost`` 函数通过双向 A* 算法汇总最短路径的成本。"

msgid "pgr_bdAstarCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr "pgr_bdAstarCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"

msgid "pgr_bdAstarCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr "pgr_bdAstarCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"

msgid "pgr_bdAstarCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr "pgr_bdAstarCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"

msgid "pgr_bdAstarCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr "pgr_bdAstarCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"

msgid "pgr_bdAstarCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr "pgr_bdAstarCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"

msgid "``pgr_bdAstarCostMatrix``"
msgstr "``pgr_bdAstarCostMatrix``"

#, fuzzy
msgid "``pgr_bdAstarCostMatrix`` - Calculates the cost matrix using :doc:`pgr_bdAstar`."
msgstr "``pgr_bdAstarCostMatrix`` - 使用 :doc:`pgr_aStar` 计算成本矩阵。"

#, fuzzy
msgid "Internally uses the :doc:`pgr_bdAstar` algorithm."
msgstr "内部使用 :doc:`pgr_bdAstar` 算法"

msgid "pgr_bdAstarCostMatrix(`Edges SQL`_, **start vids**, [**options**])"
msgstr "pgr_bdAstarCostMatrix(`Edges SQL`_, **start vids**, [**options**])"

msgid "``pgr_bdDijkstra`` — Returns the shortest path using Bidirectional Dijkstra algorithm."
msgstr "``pgr_bdDijkstra`` — 返回使用双向 Dijkstra 算法计算的最短路径。"

msgid "pgr_bdDijkstra(Combinations)"
msgstr "pgr_bdDijkstra(组合)"

msgid "pgr_bdDijkstra(One to Many)"
msgstr "pgr_bdDijkstra(One to Many)"

msgid "pgr_bdDijkstra(Many to One)"
msgstr "pgr_bdDijkstra(Many to One)"

msgid "pgr_bdDijkstra(Many to Many)"
msgstr "pgr_bdDijkstra(Many to Many)"

#, fuzzy
msgid "Signature change on pgr_bdDijkstra(One to One)"
msgstr "函数的签名变更 pgr_bdDijsktra(One to One)"

msgid "pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr "pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid "pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr "pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid "pgr_bdDijkstra(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr "pgr_bdDijkstra(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"

msgid "pgr_bdDijkstra(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr "pgr_bdDijkstra(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_bdDijkstra(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_bdDijkstra(`Edges SQL`_, `Combinations SQL`_, [``directed``])"

msgid "From vertex :math:`6` to vertex :math:`10` on a **directed** graph"
msgstr "在 **有向** 图上从顶点 :math:`6` 到顶点 :math:`10`"

msgid "From vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a **directed** graph"
msgstr "在 **有向** 图上从顶点 :math:`6` 到顶点 :math:`\\{10, 17\\}`"

msgid "From vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a **directed** graph"
msgstr "在 **有向** 图上从顶点 :math:`\\{6, 1\\}` 到顶点 :math:`17`"

msgid "From vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 17\\}` on an **undirected** graph"
msgstr "在 **无向** 图上从顶点 :math:`\\{6, 1\\}` 到顶点 :math:`\\{10, 17\\}`"

msgid "Using a combinations table on an **undirected** graph"
msgstr "在 **无向** 图上使用组合表"

msgid "https://en.wikipedia.org/wiki/Bidirectional_search"
msgstr "https://en.wikipedia.org/wiki/Bidirectional_search"

msgid "``pgr_bdDijkstraCost``"
msgstr "``pgr_bdDijkstraCost``"

msgid "``pgr_bdDijkstraCost`` — Returns the shortest path's cost using Bidirectional Dijkstra algorithm."
msgstr "``pgr_bdDijkstraCost`` — 返回使用双向 Dijkstra 算法计算最短路径的成本。"

msgid "pgr_bdDijkstraCost(Combinations)"
msgstr "pgr_bdDijkstraCost(组合)"

#, fuzzy
msgid "The ``pgr_bdDijkstraCost`` function summarizes the cost of the shortest path using the bidirectional Dijkstra Algorithm."
msgstr "``pgr_bdDijkstraCost`` 函数通过双向 Dijkstra 算法汇总最短路径的成本值。"

msgid "pgr_bdDijkstraCost(`Edges SQL`_, **start vid**, **end vid** , [``directed``])"
msgstr "pgr_bdDijkstraCost(`Edges SQL`_, **start vid**, **end vid** , [``directed``])"

msgid "pgr_bdDijkstraCost(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr "pgr_bdDijkstraCost(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid "pgr_bdDijkstraCost(`Edges SQL`_, **start vids**, **end vid** , [``directed``])"
msgstr "pgr_bdDijkstraCost(`Edges SQL`_, **start vids**, **end vid** , [``directed``])"

msgid "pgr_bdDijkstraCost(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr "pgr_bdDijkstraCost(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_bdDijkstraCost(`Edges SQL`_, `Combinations SQL`_, [ ``directed``])"
msgstr "pgr_bdDijkstraCost(`Edges SQL`_, `Combinations SQL`_, [ ``directed``])"

msgid "pgr_bdDijkstraCost(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_bdDijkstraCost(`Edges SQL`_, `Combinations SQL`_, [``directed``])"

msgid "``pgr_bdDijkstraCostMatrix``"
msgstr "``pgr_bdDijkstraCostMatrix``"

msgid "``pgr_bdDijkstraCostMatrix`` - Calculates a cost matrix using :doc:`pgr_bdDijkstra`."
msgstr "``pgr_bdDijkstraCostMatrix`` - 使用 :doc:`pgr_bdDijkstra` 计算成本矩阵。"

msgid "Using bidirectional Dijkstra algorithm, calculate and return a cost matrix."
msgstr "使用双向Dijkstra算法，计算并返回成本矩阵。"

msgid "pgr_bdDijkstraCostMatrix(`Edges SQL`_, **start vids**, [``directed``])"
msgstr "pgr_bdDijkstraCostMatrix(`Edges SQL`_, **start vids**, [``directed``])"

msgid "Symmetric cost matrix for vertices :math:`\\{5, 6, 10, 15\\}` on an **undirected** graph"
msgstr "在一个 **无向** 图上的顶点集合 :math:`\\{5, 6, 10, 15\\}` 的对称成本矩阵"

msgid "Use with :doc:`pgr_TSP`."
msgstr "与 :doc:`pgr_TSP` 一起使用。"

#, fuzzy
msgid "``pgr_bellmanFord`` - Experimental"
msgstr "``pgr_bellmanFord - 实验性``"

msgid "``pgr_bellmanFord`` — Shortest path using Bellman-Ford algorithm."
msgstr "``pgr_bellmanFord`` — 使用 Bellman-Ford 算法计算的最短路径。"

msgid "pgr_bellmanFord(Combinations)"
msgstr "pgr_bellmanFord(组合)"

msgid "Bellman-Ford's algorithm, is named after Richard Bellman and Lester Ford, who first published it in 1958 and 1956, respectively.It is a graph search algorithm that computes shortest paths from a starting vertex (``start_vid``) to an ending vertex (``end_vid``) in a graph where some of the edge weights may be negative. Though it is more versatile, it is slower than Dijkstra's algorithm.This implementation can be used with a directed graph and an undirected graph."
msgstr "Bellman-Ford算法以Richard Bellman和Lester Ford的名字命名，他们分别于1958年和1956年首次发表了这个算法。它是一种图搜索算法，用于计算从起始顶点 (``start_vid``) 到终点顶点 (``end_vid``) 的最短路径，其中一些边的权重可以为负数。尽管它更加通用，但比Dijkstra算法更慢。这个实现可以用于有向图和无向图。"

msgid "Process is valid for edges with both positive and negative edge weights."
msgstr "该过程对于具有正边权重和负边权重的边都有效。"

msgid "When the start vertex and the end vertex are the same, there is no path. The agg_cost would be :math:`0`."
msgstr "当起始顶点和结束顶点相同时，不存在路径。聚合成本（agg_cost）将为 :math:`0`。"

msgid "When the start vertex and the end vertex are different, and there exists a path between them without having a *negative cycle*. The agg_cost would be some finite value denoting the shortest distance between them."
msgstr "当起始顶点和结束顶点不同，并且它们之间存在路径且不存在*负循环*时。 agg_cost 将是某个有限值，表示它们之间的最短距离。"

msgid "When the start vertex and the end vertex are different, and there exists a path between them, but it contains a *negative cycle*. In such case, agg_cost for those vertices keep on decreasing furthermore, Hence agg_cost can’t be defined for them."
msgstr "当起始顶点和结束顶点不同，并且它们之间存在路径，但包含*负循环*时。 在这种情况下，这些顶点的 agg_cost 继续减少，因此无法为它们定义 agg_cost 。"

msgid "When the start vertex and the end vertex are different, and there is no path. The agg_cost is :math:`\\infty`."
msgstr "当起始顶点和结束顶点不同且不存在路径时，聚合成本（agg_cost）为 :math:`\\infty`。"

msgid "For optimization purposes, any duplicated value in the `start_vids` or `end_vids` are ignored."
msgstr "出于优化目的，`start_vids`或 `end_vids` 中的任何重复值都将被忽略。"

msgid "Running time: :math:`O(| start\\_vids | * ( V * E))`"
msgstr "运行时间： :math:`O(| start\\_vids | * ( V * E))`"

msgid "pgr_bellmanFord(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr "pgr_bellmanFord(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid "pgr_bellmanFord(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr "pgr_bellmanFord(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid "pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr "pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"

msgid "pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr "pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_bellmanFord(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_bellmanFord(`Edges SQL`_, `Combinations SQL`_, [``directed``])"

#, fuzzy
msgid "From vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a directed graph"
msgstr "在 **有向** 图上从顶点 :math:`6` 到顶点 :math:`\\{10, 17\\}`"

#, fuzzy
msgid "From vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a directed graph"
msgstr "在 **有向** 图上从顶点 :math:`\\{6, 1\\}` 到顶点 :math:`17`"

#, fuzzy
msgid "From vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 17\\}` on an undirected graph"
msgstr "在 **无向** 图上从顶点 :math:`\\{6, 1\\}` 到顶点 :math:`\\{10, 17\\}`"

#, fuzzy
msgid "Using a combinations table on an undirected graph"
msgstr "在无向图上使用组合表。"

msgid "`Boost: Bellman Ford <https://www.boost.org/libs/graph/doc/bellman_ford_shortest.html>`__"
msgstr "`Boost: Belman Ford <https://www.boost.org/libs/graph/doc/bellman_ford_shortest.html>`__"

msgid "https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm"
msgstr "https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm"

msgid "``pgr_betweennessCentrality`` - Experimental"
msgstr "``pgr_betweennessCentrality`` - 实验性"

msgid "``pgr_betweennessCentrality`` - Calculates the relative betweenness centrality using Brandes Algorithm"
msgstr "``pgr_betweennessCentrality`` - 使用布兰德斯算法计算相对中心度"

msgid "Version 3.7.0"
msgstr "版本 3.7.0"

msgid "The Brandes Algorithm takes advantage of the sparse graphs for evaluating the betweenness centrality score of all vertices."
msgstr "Brandes 算法利用稀疏图来评估所有顶点的中心度得分。"

msgid "Betweenness centrality measures the extent to which a vertex lies on the shortest paths between all other pairs of vertices. Vertices with a high betweenness centrality score may have considerable influence in a network by the virtue of their control over the shortest paths passing between them."
msgstr "Betweenness centrality（介数中心性）衡量的是一个顶点在所有其他顶点对之间的最短路径中的重要性。具有较高介数中心性得分的顶点，通常能够对网络产生显著的影响，因为它们控制了通过它们的最短路径。"

msgid "The removal of these vertices will affect the network by disrupting the it, as most of the shortest paths between vertices pass through them."
msgstr "这些顶点的移除会影响网络，因为大多数顶点之间的最短路径都经过它们，从而破坏了网络的连接性。"

msgid "This implementation work for both directed and undirected graphs."
msgstr "该实现适用于directed 和undirected。"

msgid "Running time:  :math:`\\Theta(VE)`"
msgstr "运行时间: :math:`Theta(VE)`"

msgid "Running space: :math:`\\Theta(VE)`"
msgstr "运行空间: :math:`\\Theta(VE)`"

msgid "Throws when there are no edges in the graph"
msgstr "当图形中没有边时抛出"

msgid "pgr_betweennessCentrality(`Edges SQL`_, [``directed``])"
msgstr "pgr_betweennessCentrality(`Edges SQL`_, [``directed``])"

msgid "Returns set of ``(vid, centrality)``"
msgstr "返回 ``(vid, centrality)`` 的集合"

msgid "For a directed graph with edges :math:`\\{1, 2, 3, 4\\}`."
msgstr "对于带边的directed graph:math:`\\{1, 2, 3, 4\\}`."

msgid "Explanation"
msgstr "说明"

msgid "The betweenness centrality are between parenthesis."
msgstr "介数中心性值位于括号内。"

msgid "The leaf vertices have betweenness centrality :math:`0`."
msgstr "叶子节点的介数中心性为 :math:`0`。"

msgid "Betweenness centrality of vertex :math:`6` is higher than of vertex :math:`10`."
msgstr "顶点 :math:`6` 的间隔中心度高于顶点 :math:`10` 的间隔中心度。"

msgid "Removing vertex :math:`6` will create three graph components."
msgstr "移除顶点 :math:`6` 将创建三个图形组件。"

msgid "Removing vertex :math:`10` will create two graph components."
msgstr "移除节点 :math:`10` 将会产生两个图形组件。"

msgid "``vid``"
msgstr "``vid``"

msgid "``centrality``"
msgstr "``centrality``"

msgid "Relative betweenness centrality score of the vertex (will be in range [0,1])"
msgstr "该节点的相对介数中心性得分（范围为 [0,1]）"

msgid "`Boost: betweenness centrality <https://www.boost.org/libs/graph/doc/betweenness_centrality.html>`_"
msgstr "`Boost: 介数中心性 <https://www.boost.org/libs/graph/doc/betweenness_centrality.html>`_"

msgid "``pgr_biconnectedComponents``"
msgstr "``pgr_biconnectedComponents``"

msgid "``pgr_biconnectedComponents`` — Biconnected components of an undirected graph."
msgstr "``pgr_biconnectedComponents`` — 无向图的双连通分量。"

msgid "Result columns change:"
msgstr "结果列发生变化："

msgid "``n_seq`` is removed"
msgstr "``n_seq`` 被删除"

msgid "``seq`` changed type to ``BIGINT``"
msgstr "``seq`` 将类型更改为 ``BIGINT``"

msgid "The biconnected components of an undirected graph are the maximal subsets of vertices such that the removal of a vertex from particular component will not disconnect the component. Unlike connected components, vertices may belong to multiple biconnected components. Vertices can be present in multiple biconnected components, but each edge can only be contained in a single biconnected component."
msgstr "无向图的双连通分量是顶点的最大子集，因此从特定分量中删除顶点不会断开该分量。 与连接组件不同，顶点可以属于多个双连接组件。 顶点可以存在于多个双连通分量中，但每条边只能包含在单个双连通分量中。"

msgid "Components are described by edges."
msgstr "组件由边描述。"

msgid "``component`` ascending."
msgstr "``component`` 升序。"

msgid "``edge`` ascending."
msgstr "``edge`` 升序。"

msgid "pgr_biconnectedComponents(`Edges SQL`_)"
msgstr "pgr_biconnectedComponents(`Edges SQL`_)"

msgid "Returns set of |result-component-E|"
msgstr "返回集合 |result-component-E|"

msgid "The biconnected components of the graph"
msgstr "图的双连通分量"

msgid "``component``"
msgstr "``component``"

msgid "Component identifier."
msgstr "分量标识符。"

msgid "Has the value of the minimum edge identifier in the component."
msgstr "具有组件中最小边标识符的值。"

msgid "Identifier of the edge that belongs to the ``component``."
msgstr "属于该 ``component`` 的边的标识符。"

msgid "``pgr_binaryBreadthFirstSearch`` - Experimental"
msgstr "``pgr_binaryBreadthFirstSearch`` - 实验性"

msgid "``pgr_binaryBreadthFirstSearch`` — Returns the shortest path in a binary graph."
msgstr "``pgr_binaryBreadthFirstSearch`` — 返回二进制图中的最短路径。"

msgid "Any graph whose edge-weights belongs to the set {0,X}, where 'X' is any non-negative integer, is termed as a 'binary graph'."
msgstr "任何边权属于集合 {0,X} 的图（其中“X”是任何非负整数）都被称为“二元图”。"

msgid "pgr_binaryBreadthFirstSearch(Combinations)"
msgstr "pgr_binaryBreadthFirstSearch(组合)"

#, fuzzy
msgid "It is well-known that the shortest paths between a single source and all other vertices can be found using Breadth First Search in :math:`O(|E|)` in an unweighted graph, i.e. the distance is the minimal number of edges that you need to traverse from the source to another vertex. We can interpret such a graph also as a weighted graph, where every edge has the weight :math:`1`. If not all edges in graph have the same weight, then we a more general algorithm is needed, like Dijkstra's Algorithm which runs in :math:`O(|E|log|V|)` time."
msgstr "众所周知，在无权重图中，使用广度优先搜索（Breadth First Search）可以在 :math:`O(|E|)` 内找到单个源点与所有其他顶点之间的最短路径，也就是说，距离是指从源点到另一个顶点所需的最少边数。我们也可以把这样的图解释为加权图，其中每条边的权重为 :math:`1`。如果图中不是所有边的权重都相同，我们就需要一种更通用的算法，比如 Dijkstra 算法，它的运行时间为 :math:`O(|E|log|V||)`。"

msgid "However if the weights are more constrained, we can use a faster algorithm. This algorithm, termed as 'Binary Breadth First Search' as well as '0-1 BFS', is a variation of the standard Breadth First Search problem to solve the SSSP (single-source shortest path) problem in :math:`O(|E|)`, if the weights of each edge belongs to the set {0,X}, where 'X' is any non-negative real integer."
msgstr "然而，如果权重受到更多限制，我们可以使用一种更快的算法。这个算法被称为'二进制广度优先搜索'，也称为'0-1 BFS'，它是标准广度优先搜索问题的一种变体，用于解决单源最短路径（SSSP）问题，当每条边的权重属于集合{0，X}，其中'X'是任意非负实数时，其时间复杂度为 :math:`O(|E|)`。"

msgid "Process is done only on 'binary graphs'. ('Binary Graph': Any graph whose edge-weights belongs to the set {0,X}, where 'X' is any non-negative real integer.)"
msgstr "过程仅在“二元图”上完成。 （“二元图”：边权重属于集合 {0,X} 的任何图，其中“X”是任何非负实整数。）"

msgid "Running time: :math:`O(| start\\_vids | * |E|)`"
msgstr "运行时间： :math:`O(| start\\_vids | * |E|)`"

msgid "pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr "pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid "pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr "pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid "pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr "pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"

msgid "pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr "pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_binaryBreadthFirstSearch(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_binaryBreadthFirstSearch(`Edges SQL`_, `Combinations SQL`_, [``directed``])"

msgid "**Note:** Using the :doc:`sampledata` Network as all weights are same (i.e :math:`1``)"
msgstr "**注意:** 使用 :doc:`sampledata` 网络，因为所有权重都相同 (即为 :math:`1`)"

msgid "`Boost: Breadth First Search <https://www.boost.org/libs/graph/doc/breadth_first_search.html>`__"
msgstr "`Boost: 广度优先搜索 <https://www.boost.org/libs/graph/doc/breadth_first_search.html>`__"

msgid "https://cp-algorithms.com/graph/01_bfs.html"
msgstr "https://cp-algorithms.com/graph/01_bfs.html"

msgid "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Specialized_variants"
msgstr "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Specialized_variants"

msgid "``pgr_bipartite`` - Experimental"
msgstr "``pgr_bipartite`` - 实验性"

msgid "``pgr_bipartite`` — Disjoint sets of vertices such that no two vertices within the same set are adjacent."
msgstr "``pgr_bipartite`` - 不相邻的顶点集合，同一集合中没有两个顶点相邻。"

msgid "A bipartite graph is a graph with two sets of vertices which are connected to each other, but not within themselves. A bipartite graph is possible if the graph coloring is possible using two colors such that vertices in a set are colored with the same color."
msgstr "二方图是指有两组顶点的图，这两组顶点相互连接，但内部没有连接。如果可以使用两种颜色对图形着色，从而使一个集合中的顶点着色为相同的颜色，那么就可能是一个二方图。"

msgid "The algorithm works in undirected graph only."
msgstr "该算法只适用于无向图。"

msgid "The returned values are not ordered."
msgstr "返回值没有排序。"

msgid "The algorithm checks graph is bipartite or not. If it is bipartite then it returns the node along with two colors `0` and `1` which represents two different sets."
msgstr "该算法检查图是否是二分图。 如果它是二分的，那么它返回节点以及代表两个不同集合的两种颜色 `0` 和`1`。"

msgid "If graph is not bipartite then algorithm returns empty set."
msgstr "如果图不是两部分的，那么算法会返回空集。"

msgid "pgr_bipartite(`Edges SQL`_)"
msgstr "pgr_bipartite(`Edges SQL`_)"

msgid "When the graph is bipartite"
msgstr "当图形为两方时"

msgid "Additional Example"
msgstr "附加示例"

msgid "The odd length cyclic graph can not be bipartite."
msgstr "奇长循环图不可能是两部分的。"

msgid "The edge :math:`5 \\rightarrow 1` will make subgraph with vertices :math:`\\{1, 3, 7, 6, 5\\}` an odd length cyclic graph, as the cycle has 5 vertices."
msgstr "边 :math:`5 \\rightarrow 1` 将使顶点为 :math:`\\{1, 3, 7, 6, 5\\}` 的子图成为奇数长度的循环图，因为循环有 5 个顶点。"

msgid "Edges in blue represent odd length cycle subgraph."
msgstr "蓝色边代表奇数长度循环子图。"

msgid "`Boost: is_bipartite <https://www.boost.org/libs/graph/doc/is_bipartite.html>`__"
msgstr "`Boost: 是否为二分图 <https://www.boost.org/libs/graph/doc/is_bipartite.html>`__"

msgid "`Wikipedia: bipartite graph <https://en.wikipedia.org/wiki/Bipartite_graph>`__"
msgstr "`维基百科：二分图 <https://en.wikipedia.org/wiki/Bipartite_graph>`__"

msgid "``pgr_boykovKolmogorov``"
msgstr "``pgr_boykovKolmogorov``"

msgid "``pgr_boykovKolmogorov`` — Calculates the flow on the graph edges that maximizes the flow from the sources to the targets using Boykov Kolmogorov algorithm."
msgstr "`pgr_boykovKolmogorov`` - 使用 Boykov Kolmogorov 算法计算图边的流量，使从源到目标的流量最大。"

msgid "pgr_boykovKolmogorov(Combinations)"
msgstr "pgr_boykovKolmogorov (组合)"

msgid "Renamed from ``pgr_maxFlowBoykovKolmogorov``"
msgstr "从 ``pgr_maxFlowBoykovKolmogorov`` 更名而来"

msgid "Function promoted to proposed."
msgstr "函数已升级为提议。"

msgid "Running time: Polynomial"
msgstr "运行时间：多项式时间"

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_boykovKolmogorov(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_boykovKolmogorov(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_boykovKolmogorov(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_boykovKolmogorov(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_boykovKolmogorov(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_boykovKolmogorov(`Edges SQL`_, `Combinations SQL`_)"

msgid "Returns set of |result-flow|"
msgstr "返回集合 |result-flow|"

msgid "From vertex :math:`11` to vertex :math:`12`"
msgstr "从顶点 :math:`11` 到顶点 :math:`12`"

msgid "From vertex :math:`11` to vertices :math:`\\{5, 10, 12\\}`"
msgstr "从顶点 :math:`11` 到顶点 :math:`\\{5, 10, 12\\}`"

msgid "From vertices :math:`\\{11, 3, 17\\}` to vertex :math:`12`"
msgstr "从顶点 :math:`\\{11, 3, 17\\}` 到顶点 :math:`12`"

msgid "From vertices :math:`\\{11, 3, 17\\}` to vertices :math:`\\{5, 10, 12\\}`"
msgstr "从顶点 :math:`\\{11, 3, 17\\}` 到顶点 :math:`\\{5, 10, 12\\}`"

msgid "Using a combinations table, equivalent to calculating result from vertices :math:`\\{5, 6\\}` to vertices :math:`\\{10, 15, 14\\}`."
msgstr "使用组合表，相当于计算从顶点 :math:`\\{5, 6\\}` 到顶点 :math:`{\\10, 15, 14\\}` 的结果。"

msgid "`Boost: Boykov Kolmogorov max flow <https://www.boost.org/libs/graph/doc/boykov_kolmogorov_max_flow.html>`__"
msgstr "`Boost: Boykov-Kolmogorov 最大流算法 <https://www.boost.org/libs/graph/doc/boykov_kolmogorov_max_flow.html>`__"

msgid "``pgr_breadthFirstSearch`` - Experimental"
msgstr "``pgr_breadthFirstSearch`` - 实验性"

msgid "``pgr_breadthFirstSearch`` — Returns the traversal order(s) using Breadth First Search algorithm."
msgstr "``pgr_breadthFirstSearch`` — 使用广度优先搜索算法返回遍历顺序。"

#, fuzzy
msgid "Version 4.0.0:"
msgstr "Version 4.0.0"

msgid "Provides the Breadth First Search traversal order from a root vertex to a particular depth."
msgstr "提供从根顶点到特定深度的广度优先搜索遍历顺序。"

msgid "The implementation will work on any type of graph."
msgstr "该实现适用于任何类型的图。"

msgid "Provides the Breadth First Search traversal order from a source node to a target depth level."
msgstr "提供从源节点到目标深度级别的广度优先搜索遍历顺序。"

msgid "Running time: :math:`O(E + V)`"
msgstr "运行时间： :math:`O(E + V)`"

msgid "pgr_breadthFirstSearch(`Edges SQL`_, **root vid**, [**options**])"
msgstr "pgr_breadthFirstSearch(`Edges SQL`_, **root vid**, [**options**])"

msgid "pgr_breadthFirstSearch(`Edges SQL`_, **root vids**, [**options**])"
msgstr "pgr_breadthFirstSearch(`Edges SQL`_, **root vids**, [**options**])"

msgid "**options:** ``[max_depth, directed]``"
msgstr "**options:** ``[max_depth, directed]``"

msgid "From root vertex :math:`6` on a **directed** graph with edges in ascending order of ``id``"
msgstr "从根顶点 :math:`6` 开始，该顶点位于一个 **有向** 图中，其边按 ``id`` 升序排列"

msgid "From root vertices :math:`\\{12, 6\\}` on an **undirected** graph with **depth** :math:`<= 2` and edges in ascending order of ``id``"
msgstr "从根顶点开始 :math:`{12, 6\\}` 在一个 **无向** 图上，**depth** :math:`<=2` ，边按 ``id`` 升序排列"

msgid "DFS optional parameters"
msgstr "DFS 可选参数"

msgid "Same as `Single vertex`_ with edges in ascending order of ``id``."
msgstr "与 `单个顶点`_ 相同，边按 ``id`` 升序排列。"

msgid "Same as `Single vertex`_ with edges in descending order of ``id``."
msgstr "与 `单个顶点`_ 相同，边按 ``id`` 降序排列。"

msgid "The resulting traversal is different."
msgstr "由此产生的遍历是不同的。"

msgid "The left image shows the result with ascending order of ids and the right image shows with descending order of the edge identifiers."
msgstr "左图显示的是按 ID 升序排列的结果，右图显示的是按边缘标识符降序排列的结果。"

msgid "|ascending| |descending|"
msgstr "|ascending| |descending|"

msgid "ascending"
msgstr "升序"

msgid "descending"
msgstr "降序"

msgid "`Wikipedia: Breadth First Search algorithm <https://en.wikipedia.org/wiki/Breadth-first_search>`__"
msgstr "`维基百科：广度优先搜索算法 <https://en.wikipedia.org/wiki/Breadth-first_search>`__"

msgid "``pgr_bridges``"
msgstr "``pgr_bridges``"

msgid "``pgr_bridges`` - Return the bridges of an undirected graph."
msgstr "``pgr_bridges`` - 返回无向图的桥。"

msgid "A bridge is an edge of an undirected graph whose deletion increases its number of connected components. This implementation can only be used with an undirected graph."
msgstr "桥是指一个无向图中的边，如果删除它会增加该图的连通分量数量。此实现仅适用于无向图。"

msgid "``edge`` ascending"
msgstr "``edge`` 升序"

msgid "Running time: :math:`O(E * (V + E))`"
msgstr "运行时间： :math:`O(E * (V + E))`"

msgid "pgr_bridges(`Edges SQL`_)"
msgstr "pgr_bridges(`Edges SQL`_)"

msgid "Returns set of |result-edge|"
msgstr "返回集合 |result-edge|"

msgid "The bridges of the graph"
msgstr "图的桥"

msgid "Identifier of the edge that is a bridge."
msgstr "作为桥的边的标识符。"

msgid "https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29"
msgstr "https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29"

msgid "`Boost: Connected components <https://www.boost.org/libs/graph/doc/connected_components.html>`__"
msgstr "`Boost: 已连接的组件 <https://www.boost.org/libs/graph/doc/connected_components.html>`__"

msgid "``pgr_chinesePostman`` - Experimental"
msgstr "``pgr_chinesePostman`` - 实验性"

msgid "``pgr_chinesePostman`` — Calculates the shortest circuit path which contains every edge in a directed graph and starts and ends on the same vertex."
msgstr "``pgr_chinesePostman`` — 计算包含有向图中的每条边并从同一顶点开始和结束的最短回路路径。"

msgid "Returns ``EMPTY SET`` on a disconnected graph"
msgstr "在一个不连通的图上返回 ``EMPTY SET``"

msgid "pgr_chinesePostman(`Edges SQL`_)"
msgstr "pgr_chinesePostman(`Edges SQL`_)"

msgid "Returns set of |result-1-1-no-seq|"
msgstr "返回 |result-1-1-no-seq| 的集合"

msgid "Returns set of ``(seq, node, edge, cost, agg_cost)``"
msgstr "返回集合 ``(seq, node, edge, cost, agg_cost)``"

msgid "Sequential value starting from ``1``"
msgstr "从 ``1`` 开始的顺序值"

msgid "Identifier of the edge used to go from ``node`` to the next node in the path sequence. ``-1`` for the last node of the path."
msgstr "用于从路径序列中的 ``node`` 到下一个节点的边的标识符。 ``-1`` 表示路径的最后一个节点。"

msgid "Aggregate cost from ``start_v`` to ``node``."
msgstr "从 ``start_v`` 到 ``node`` 的总成本。"

msgid "``pgr_chinesePostmanCost`` - Experimental"
msgstr "``pgr_chinesePostmanCost`` - 实验性"

msgid "``pgr_chinesePostmanCost`` — Calculates the minimum costs of a circuit path which contains every edge in a directed graph and starts and ends on the same vertex."
msgstr "``pgr_chinesePostmanCost`` — 计算一个包含有向图中的每条边、以同一顶点为起点和终点的最短成本的回路路径。"

msgid "Return value when the graph if disconnected"
msgstr "当图是不连通的时候返回的数值"

msgid "pgr_chinesePostmanCost(`Edges SQL`_)"
msgstr "pgr_chinesePostmanCost(`Edges SQL`_)"

msgid "RETURNS ``FLOAT``"
msgstr "RETURNS ``FLOAT``"

msgid "``pgr_chinesepostmancost``"
msgstr "``pgr_chinesepostmancost``"

msgid "Minimum costs of a circuit path."
msgstr "一个回路路径的最小成本。"

msgid "``pgr_connectedComponents``"
msgstr "``pgr_connectedComponents``"

msgid "``pgr_connectedComponents`` — Connected components of an undirected graph using a DFS-based approach."
msgstr "``pgr_connectedComponents`` — 使用基于深度优先搜索（DFS）的方法计算无向图的连通分量。"

msgid "A connected component of an undirected graph is a set of vertices that are all reachable from each other."
msgstr "无向图的连通部分是指相互之间均可到达的顶点集合。"

msgid "Components are described by vertices"
msgstr "连通分量由顶点描述"

msgid "``component`` ascending"
msgstr "``component`` 升序"

msgid "pgr_connectedComponents(`Edges SQL`_)"
msgstr "pgr_connectedComponents(`Edges SQL`_)"

msgid "Returns set of |result-component-V|"
msgstr "返回集合 |result-component-V|"

msgid "The connected components of the graph"
msgstr "图的连通分量"

msgid "Has the value of the minimum node identifier in the component."
msgstr "具有组件中最小节点标识符的值。"

msgid "Identifier of the vertex that belongs to the ``component``."
msgstr "属于该 ``组件`` 的顶点的标识符。"

msgid "Connecting disconnected components"
msgstr "连接不连通的组件"

msgid "wikipedia: `Connected component <https://en.wikipedia.org/wiki/Connected_component_(graph_theory)>`__"
msgstr "维基百科: `连通分量 <https://en.wikipedia.org/wiki/Connected_component_(graph_theory)>`__"

msgid "``pgr_contraction``"
msgstr "``pgr_contraction``"

msgid "``pgr_contraction`` — Performs graph contraction and returns the contracted vertices and edges."
msgstr "``pgr_contraction`` — 执行图收缩操作并返回收缩后的顶点和边。"

msgid "Version 3.8.0"
msgstr "Version 3.8.0"

msgid "New signature:"
msgstr "新签名："

msgid "Previously compulsory parameter **Contraction order** is now optional with name ``methods``."
msgstr "之前必需的参数 **Contraction order** 现在已变为可选参数，并更名为 ``methods`` 。"

msgid "New name and order of optional parameters."
msgstr "可选参数的新名称和顺序。"

msgid "Deprecated signature pgr_contraction(text,bigint[],integer,bigint[],boolean)"
msgstr "已弃用签名 pgr_contraction(text,bigint[],integer,bigint[],boolean)"

msgid "Name change from ``pgr_contractGraph``"
msgstr "``pgr_contractGraph`` 的名称更改"

msgid "Bug fixes"
msgstr "Bug修复"

msgid "Contraction reduces the size of the graph by removing some of the vertices and edges and, for example, might add edges that represent a sequence of original edges decreasing the total time and space used in graph algorithms."
msgstr "收缩通过移除部分顶点和边来减小图的大小，例如，可以添加代表原始边序列的边，从而减少图算法所用的总时间和空间。"

msgid "Does not return the full contracted graph."
msgstr "不返回完整的收缩图。"

msgid "Only changes on the graph are returned."
msgstr "仅返回图中的变更部分。"

msgid "The returned values include:"
msgstr "返回值包括："

msgid "The new edges generated by linear contraction."
msgstr "线性收缩生成的新边线集。"

msgid "The modified vertices generated by dead end contraction."
msgstr "断头节点收缩生成的修改后顶点集。"

msgid "The returned values are ordered as follows:"
msgstr "返回值的排序如下："

msgid "column ``id`` ascending when its a modified vertex."
msgstr "列 ``id`` 升序排列。"

msgid "column ``id`` with negative numbers descending when its a new edge."
msgstr "列 ``id`` 中的负数，当它是一条新边时，负数依次递减。"

msgid "Currently there are two types of contraction methods included in this function:"
msgstr "目前，该功能包含两种收缩方法："

msgid "Dead End Contraction. See :doc:`pgr_contractionDeadEnd`."
msgstr "死角收缩。参考 :doc:`pgr_contractionDeadEnd`。"

msgid "Linear Contraction. See :doc:`pgr_contractionLinear`."
msgstr "线性收缩。参考 :doc:`pgr_contractionLinear`。"

msgid "pgr_contraction(`Edges SQL`_, [**options**])"
msgstr "pgr_contraction(`Edges SQL`_, [**options**])"

msgid "**options:** ``[directed, methods, cycles, forbidden]``"
msgstr "**options:** ``[directed, methods, cycles, forbidden]``"

msgid "Returns set of |result-contract|"
msgstr "Returns set of |result-contract|"

msgid "Dead end and linear contraction in that order on an undirected graph."
msgstr "在无向图上依次执行断头节点收缩与线性收缩。"

msgid "Contraction optional parameters"
msgstr "可选收缩参数"

msgid "``methods``"
msgstr "``methods``"

msgid "``INTEGER[]``"
msgstr "``INTEGER[]``"

msgid "``ARRAY[1,2]``"
msgstr "``ARRAY[1,2]``"

msgid "Ordered contraction operations."
msgstr "有序收缩操作。"

msgid "1 = Dead end contraction"
msgstr "1 = 死端收缩"

msgid "2 = Linear contraction"
msgstr "2 = 线性收缩"

msgid "``cycles``"
msgstr "``cycles``"

msgid ":math:`1`"
msgstr ":math:`1`"

msgid "Number of times the contraction methods will be performed."
msgstr "收缩方法的执行次数。"

msgid "``forbidden``"
msgstr "``forbidden``"

msgid "``BIGINT[]``"
msgstr "``BIGINT[]``"

msgid "``ARRAY[]::BIGINT[]``"
msgstr "``ARRAY[]::BIGINT[]``"

msgid "Identifiers of vertices forbidden for contraction."
msgstr "禁止收缩的顶点标识符。"

msgid "The function returns a single row. The columns of the row are:"
msgstr "该函数返回一行数据。该行的列包括："

msgid "``type``"
msgstr "``type``"

msgid "Type of the row."
msgstr "行的类型。"

msgid "``v`` when the row is a vertex."
msgstr "当该行表示一个顶点时，列为 ``v`` 。"

msgid "Column ``id`` has a positive value."
msgstr "列 ``id`` 为正值。"

msgid "``e`` when the row is an edge."
msgstr "当行是边时，则为 ``e`` 。"

msgid "Column ``id`` has a negative value."
msgstr "列 ``id`` 的值为负数。"

msgid "All numbers on this column are ``DISTINCT``"
msgstr "此列中的所有数字都是 ``DISTINCT``"

msgid "When ``type`` = **'v'**."
msgstr "当 ``type`` = **'v'** 时。"

msgid "Identifier of the modified vertex."
msgstr "修改顶点的标识符。"

msgid "When ``type`` = **'e'**."
msgstr "当 ``type`` = **'e'** 时。"

msgid "Decreasing sequence starting from **-1**."
msgstr "从 **-1** 开始递减序列。"

msgid "Representing a pseudo `id` as is not incorporated in the set of original edges."
msgstr "表示未包含在原始边集中的伪`id` 。"

msgid "``contracted_vertices``"
msgstr "``contracted_vertices``"

msgid "Array of contracted vertex identifiers."
msgstr "收缩顶点标识符数组。"

msgid "When ``type`` = **'v'**: :math:`-1`"
msgstr "当 ``type`` = **'v'**: :math:`-1` 时"

msgid "When ``type`` = **'e'**: Identifier of the source vertex of the current edge (``source``, ``target``)."
msgstr "当 ``type`` = **'e'** 时：当前边 (``source``, ``target``) 的source顶点标识符。"

msgid "When ``type`` = **'e'**: Identifier of the target vertex of the current edge (``source``, ``target``)."
msgstr "当 ``type`` = **'e'** 时：当前边 (``source``, ``target``) 的target 顶点标识符。"

msgid "When ``type`` = **'e'**: Weight of the current edge (``source``, ``target``)."
msgstr "当 ``type`` = **'e'** 时：当前边 (``source``, ``target``) 的权重。"

msgid "Only dead end contraction"
msgstr "仅死端收缩"

msgid "Only linear contraction"
msgstr "仅线性收缩"

msgid "The cycle"
msgstr "循环"

msgid "Contracting a graph can be done with more than one operation. The order of the operations affect the resulting contracted graph, after applying one operation, the set of vertices that can be contracted by another operation changes."
msgstr "对图进行收缩可通过多次操作实现，操作顺序会影响最终收缩图的结果——每执行一次操作后，可被后续操作收缩的顶点集合将发生变化。"

msgid "This implementation cycles ``cycles`` times through the ``methods`` ."
msgstr "这种实现方式在 ``methods`` 中循环 ``cycles`` 次。"

msgid "Contracting sample data"
msgstr "收缩示例数据"

msgid "In this section, building and using a contracted graph will be shown by example."
msgstr "在本节中，将通过示例展示构建和使用收缩图。"

msgid "The :doc:`sampledata` for an undirected graph is used"
msgstr "使用无向图的 :doc:`sampledata`"

msgid "a dead end operation first followed by a linear operation."
msgstr "首先是死端操作，然后是线性操作。"

msgid "Construction of the graph in the database"
msgstr "数据库中图的构建"

msgid "The original graph:"
msgstr "原始图："

msgid "The results do not represent the contracted graph. They represent the changes that need to be done to the graph after applying the contraction methods."
msgstr "结果数据并非表示收缩后的图，而是反映应用收缩方法后需对原图执行的变更操作。"

msgid "Observe that vertices, for example, :math:`6` do not appear in the results because it was not affected by the contraction algorithm."
msgstr "例如，观察到顶点 :math:`6` 没有出现在结果中，因为它不受收缩算法的影响。"

msgid "After doing the dead end contraction operation:"
msgstr "进行死端收缩操作后："

msgid "After doing the linear contraction operation to the graph above:"
msgstr "对上图进行线性收缩运算后："

msgid "The process to create the contraction graph on the database:"
msgstr "在数据库上创建收缩图的过程："

msgid "Add additional columns"
msgstr "添加附加列"

msgid "Adding extra columns to the edges and vertices tables. In this documentation the following will be used:"
msgstr "在边表和顶点表中添加额外列。在本文档中将使用以下内容："

msgid "Column."
msgstr "列。"

msgid "The vertices set belonging to the vertex/edge"
msgstr "属于顶点/边的顶点集"

msgid "``is_contracted``"
msgstr "``is_contracted``"

msgid "On the vertex table"
msgstr "在顶点表上"

msgid "when ``true`` the vertex is contracted, its not part of the contracted graph."
msgstr "当 ``true`` 时，顶点收缩，它不是收缩图的一部分。"

msgid "when ``false`` the vertex is not contracted, its part of the contracted graph."
msgstr "当 ``false`` 时，顶点不收缩，它是收缩图的一部分。"

msgid "``is_new``"
msgstr "``is_new``"

msgid "On the edge table"
msgstr "在边表上"

msgid "when ``true`` the edge was generated by the contraction algorithm. its part of the contracted graph."
msgstr "当 ``true`` 时，边缘由收缩算法生成。 它是收缩图的一部分。"

msgid "when ``false`` the edge is an original edge, might be or not part of the contracted graph."
msgstr "当 ``false`` 时，边是原始边，可能是也可能不是收缩图的一部分。"

msgid "Store contraction information"
msgstr "存储收缩信息"

msgid "Store the contraction results in a table."
msgstr "将收缩结果存储至数据表。"

msgid "Update the edges and vertices tables"
msgstr "更新边线与顶点表"

msgid "Use ``is_contracted`` column to indicate the vertices that are contracted."
msgstr "使用 ``is_contracted`` 列来指示收缩的顶点。"

msgid "Fill ``contracted_vertices`` with the information from the results that belong to the vertices."
msgstr "将属于顶点的结果信息填充至 ``contracted_vertices`` 表中。"

msgid "Insert the new edges generated by pgr_contraction."
msgstr "插入由 pgr_contraction 生成的新边。"

msgid "The contracted graph"
msgstr "收缩图"

msgid "Vertices that belong to the contracted graph."
msgstr "属于收缩图的顶点。"

msgid "Edges that belong to the contracted graph."
msgstr "属于收缩图的边。"

msgid "Visually:"
msgstr "视觉效果："

msgid "Using the contracted graph"
msgstr "使用收缩图"

msgid "Depending on the final application the graph is to be prepared. In this example the final application will be to calculate the cost from two vertices in the original graph by using the contracted graph with ``pgr_dijkstraCost``"
msgstr "根据最终应用的需求，图需要进行预处理。在本示例中，最终应用是使用收缩图通过 ``pgr_dijkstraCost`` 计算原始图中两个顶点之间的成本"

msgid "There are three cases when calculating the shortest path between a given source and target in a contracted graph:"
msgstr "计算收缩图中给定源和目标之间的最短路径时，存在三种情况："

msgid "Case 1: Both source and target belong to the contracted graph."
msgstr "情况1：源和目标都属于收缩图。"

msgid "Case 2: Source and/or target belong to an edge subgraph."
msgstr "情况 2：源和/或目标属于边缘子图。"

msgid "Case 3: Source and/or target belong to a vertex."
msgstr "情况 3：源和/或目标属于一个顶点。"

msgid "The final application should consider all of those cases."
msgstr "最终应用应考虑所有这些情况。"

msgid "Create a view (or table) of the contracted graph:"
msgstr "创建收缩图的视图（或表）："

msgid "Create the function that will use the contracted graph."
msgstr "创建使用收缩图的函数。"

msgid "Case 2: Source and/or target belong to an edge that has contracted vertices."
msgstr "情况 2：源点和/或目标点位于含收缩顶点的边线上。"

msgid "Case 3: Source and/or target belong to a vertex that has been contracted."
msgstr "情况 3：源点和/或目标点属于已被收缩的顶点。"

msgid "``pgr_contractionDeadEnd`` - Proposed"
msgstr "``pgr_contractionDeadEnd`` - 提议中"

msgid "``pgr_contractionDeadEnd`` — Performs graph contraction and returns the contracted vertices and edges."
msgstr "``pgr_contractionDeadEnd`` — 执行图收缩操作，并返回收缩后的顶点集与边线集。"

msgid "A node is considered a dead end node when:"
msgstr "在下列情况下，节点被视为断头节点："

msgid "On undirected graphs:"
msgstr "在无向图上："

msgid "The number of adjacent vertices is 1."
msgstr "相邻顶点的个数为1。"

msgid "On directed graphs:"
msgstr "在有向图上："

msgid "When there is only one adjacent vertex or"
msgstr "当只有一个相邻顶点或"

msgid "When all edges are incoming regardless of the number of adjacent vertices."
msgstr "无论相邻顶点的数量多少，所有边都是进入的。"

msgid "pgr_contractionDeadEnd(`Edges SQL`_, [**options**])"
msgstr "pgr_contractionDeadEnd(`Edges SQL`_, [**options**])"

msgid "**options:** ``[directed, forbidden]``"
msgstr "**options:** ``[directed, forbidden]``"

msgid "Dead end contraction on an undirected graph."
msgstr "无向图的断头节点收缩。"

msgid "The green nodes are dead end nodes."
msgstr "绿色节点为断头节点。"

msgid "Node :math:`3` is a dead end node after node :math:`1` is contracted."
msgstr "节点 :math:`3` 是节点 :math:`1` 收缩后的死结节点。"

msgid "``ARRAY[`` |ANY-INTEGER| ``]``"
msgstr "``ARRAY[`` |ANY-INTEGER| ``]``"

msgid "**Empty**"
msgstr "**Empty**"

msgid "Value = ``e`` indicating the row is an edge."
msgstr "值 = ``e`` 表示该行是一条边。"

msgid "A pseudo `id` of the edge."
msgstr "边线的伪 `id`。"

msgid "Identifier of the source vertex of the current edge."
msgstr "当前边的源顶点的标识符。"

msgid "Identifier of the target vertex of the current edge."
msgstr "当前边的目标顶点的标识符。"

msgid "Weight of the current edge."
msgstr "当前边线的权重值。"

msgid "Dead end vertex on undirected graph"
msgstr "无向图上的死端顶点"

msgid "They have only one adjacent node."
msgstr "它们只有一个相邻节点。"

msgid "Dead end vertex on directed graph"
msgstr "有向图上的死端顶点"

msgid "The green nodes are dead end nodes"
msgstr "绿色节点为断头节点"

msgid "The blue nodes have an unlimited number of incoming and/or outgoing edges."
msgstr "蓝色节点具有无限数量的传入和/或传出边缘。"

msgid "Node"
msgstr "节点"

msgid "Adjacent nodes"
msgstr "相邻节点"

msgid "Dead end"
msgstr "死端"

msgid "Reason"
msgstr "Reason"

msgid ":math:`6`"
msgstr ":math:`6`"

msgid ":math:`\\{1\\}`"
msgstr ":math:`\\{1\\}`"

msgid "Yes"
msgstr "是"

msgid "Has only one adjacent node."
msgstr "只有一个相邻节点。"

msgid ":math:`7`"
msgstr ":math:`7`"

msgid ":math:`\\{2\\}`"
msgstr ":math:`\\{2\\}`"

msgid ":math:`8`"
msgstr ":math:`8`"

msgid ":math:`\\{2, 3\\}`"
msgstr ":math:`\\{2, 3\\}`"

msgid "Has more than one adjacent node and all edges are incoming."
msgstr "有一个以上的相邻节点，且所有边都是传入的。"

msgid ":math:`\\{4\\}`"
msgstr ":math:`\\{4\\}`"

msgid ":math:`10`"
msgstr ":math:`10`"

msgid ":math:`\\{4, 5\\}`"
msgstr ":math:`\\{4, 5\\}`"

msgid "No"
msgstr "No"

msgid "Has more than one adjacent node and all edges are outgoing."
msgstr "有一个以上的相邻节点，且所有边都是向外的。"

msgid ":math:`1,2,3,4,5`"
msgstr ":math:`1,2,3,4,5`"

msgid "Many adjacent nodes."
msgstr "许多相邻节点。"

msgid "Has more than one adjacent node and some edges are incoming and some are outgoing."
msgstr "有一个以上的相邻节点，有些边是入边，有些是出边。"

msgid "From above, nodes :math:`\\{6, 7, 9\\}` are dead ends because the total number of adjacent vertices is one."
msgstr "从上面可以看出，节点 :math:`\\{6, 7, 9\\}` 是断头节点，因为其邻接顶点的数量为 1。"

msgid "When there are more than one adjacent vertex, all edges need to be all incoming edges otherwise it is not a dead end."
msgstr "当有多个相邻顶点时，所有的边都必须是所有进入的边，否则就不是死胡同。"

msgid "Step by step dead end contraction"
msgstr "逐步断头节点收缩"

msgid "The dead end contraction will stop until there are no more dead end nodes. For example, from the following graph where :math:`3` is the dead end node:"
msgstr "断头节点收缩将持续执行，直至图中不再存在断头节点。例如下图中 :math:`3` 为断头节点时的处理流程："

msgid "After contracting :math:`3`, node :math:`2` is now a dead end node and is contracted:"
msgstr "在收缩 :math:`3` 后，节点 :math:`2` 变成了断头节点，并被继续收缩："

msgid "After contracting :math:`2`, stop. Node :math:`1` has the information of nodes that were contracted."
msgstr "收缩 :math:`2` 后，停止。节点 :math:`1` 包含已收缩节点的信息。"

msgid "Creating the contracted graph"
msgstr "创建收缩图"

msgid "Steps for the creation of the contracted graph"
msgstr "创建收缩图的步骤"

msgid "Add additional columns."
msgstr "添加额外的列。"

msgid "Save results into a table."
msgstr "将结果保存到表格中。"

msgid "The contracted vertices are not part of the contracted graph."
msgstr "收缩后的顶点不包含在收缩图中。"

msgid "Using when departure and destination are in the contracted graph"
msgstr "当出发地和目的地位于收缩图中时使用"

msgid "Using when departure/destination is not in the contracted graph"
msgstr "当出发地/目的地不在收缩图中时使用"

msgid "Using when departure and destination are not in the contracted graph"
msgstr "当出发地和目的地均不在收缩图中时使用"

msgid "``pgr_contractionHierarchies`` - Experimental"
msgstr "``pgr_contractionHierarchies`` - 实验性"

msgid "``pgr_contractionHierarchies`` — Performs graph contraction according to the contraction hierarchies method and returns the contracted vertices and shortcut edges created."
msgstr "``pgr_contractionHierarchies`` — 根据收缩层级方法执行图收缩，并返回收缩后的顶点和生成的快捷边。"

msgid "The contraction hierarchies method builds, from an initial order of the vertices, a hierarchical order, giving priority to some vertices during the processing of label fixing of shortest paths algorithms. Furthermore, the contraction hierarchies algorithm adds shortcut edges in the graph, that helps the shortest paths algorithm to follow the created hierarchical graph structure."
msgstr "收缩层次法是从顶点的初始顺序出发建立层次顺序的，在最短路径算法的标签固定处理过程中优先考虑某些顶点。此外，收缩层次算法还能在图中添加捷径边，帮助最短路径算法遵循所创建的层次图结构。"

msgid "The idea of the hierarchy is to put at a high priority level vertices that belong to the long distance network (highways for example in a road network) and to a low level of priority nodes that belong to the short distance network (arterials or secondary roads for example in road networks)."
msgstr "层次结构的原理是将属于长距离网络（例如公路网络中的高速公路）的顶点置于高优先级，而将属于短距离网络（例如公路网络中的主干道或次干路）的节点置于低优先级。"

msgid "The contraction hierarchies algorithm makes the assumption that there is already a valuable vertices order that is used to initialize the contraction process. As in most cases there is no valuable initial node ordering, we use the order given by vertices ID. Then, the contraction process is made on the basis of this first order to give the final hierarchy."
msgstr "收缩层次结构算法的假设是，已经存在一个有价值的顶点顺序，用于初始化收缩过程。由于大多数情况下没有有价值的初始节点排序，因此我们使用顶点 ID 给出的顺序。然后，在这个首序的基础上进行收缩处理，得到最终的层次结构。"

msgid "The basic idea is to keep the vertices in a priority queue sorted by some estimate of how attractive is their contraction. The implemented case uses the metric called *edge difference*, which corresponds to the difference between the number of shortcuts produced by a vertex contraction and the number of incident edges in the graph before contraction (``#shortcuts - #incident edges``)."
msgstr "其基本原理是将顶点按其收缩吸引力的估计值排序，保留在优先队列中。实施案例中使用的度量称为 *边差* ，相当于顶点收缩产生的捷径数量与收缩前图中附带边的数量之差 (``#shortcuts - #incident edges``)."

msgid "Finally, the aim is to reduce the explored part of the graph, when using a bidirectional Dijkstra-like algorithm. The vertices order is used to feed the oriented search. The search is made without losing optimality."
msgstr "最后，在使用类似 Dijkstra 的双向算法时，目的是减少图中已探索的部分。顶点顺序用于为定向搜索提供信息。搜索过程不会失去最优性。"

msgid "Finding an optimal vertices ordering for contraction is a difficult problem. Nevertheless, very simple local heuristics work quite well, according to Geisberger et al. [2]. The principle here is to a priori estimate the value of the *edge difference* and to contract the node at the top of the queue only if the new value of the metric keeps it at the top of the queue. Otherwise, it is reinserted in the queue, at its right place corresponding to the new metric value."
msgstr "为收缩寻找最佳顶点排序是一个难题。然而，根据 Geisberger 等人的研究 [2]，非常简单的局部启发式方法就能很好地解决这个问题。这种方法的原理是先验地估算 *边差* 的值，只有当新的度量值使位于队列顶端的节点保持在队列顶端时，才对其进行收缩。否则，它就会被重新插入队列，位于与新度量值相对应的正确位置。"

msgid "The process is done on graphs having only edges with positive costs."
msgstr "这个过程是在只有边的成本为正值的图形上完成的。"

msgid "It is necessary to remember that there are no deleted vertices with this function. At the end, the graph keeps every vertex it had, but has some added edges, corresponding to shortcuts. The vertices which have been contracted, to build the shortcut edges, are kept and hierarchically ordered."
msgstr "需要注意的是，此函数不会删除任何顶点。最终图中保留了原有的所有顶点，但新增了一些对应于快捷边的边。为构建这些快捷边而收缩的顶点也会被保留，并按层级顺序排列。"

msgid "As for the other contraction methods, it does not return the full contracted graph, only the changes. They are here of two types:"
msgstr "至于其他收缩方法，它不会返回完整的收缩图，只会返回变化。它们有两种类型："

msgid "added shortcut edges, with negative identifiers;"
msgstr "增加了带有负标识符的快捷边;"

msgid "contracted nodes with an order."
msgstr "带有顺序的收缩节点。"

msgid "The ``pgr_contractionHierarchies`` function has the following signature:"
msgstr "``pgr_contractionHierarchies`` 函数具有以下签名："

msgid "pgr_contractionHierarchies(`Edges SQL`_, [**options**])"
msgstr "pgr_contractionHierarchies(`Edges SQL`_, [**options**])"

msgid "Returns set of |result-contraction-hierarchies|"
msgstr "返回集合 |result-contract|"

msgid "Contraction hierarchies optional parameters"
msgstr "收缩层级的可选参数"

msgid "True if the graph is directed, False otherwise."
msgstr "如果图是有向的，则为 True，否则为 False。"

msgid "The function returns many rows (one per vertex and one per shortcut edge created). The columns of the rows are:"
msgstr "该函数返回多行（每个顶点一行，每创建一条快捷边一行）。行的列数为："

msgid "Type of the ``id``."
msgstr "``id`` 的类型。"

msgid "Column ``id`` has a positive value"
msgstr "列 ``id`` 为正值"

msgid "Column ``id`` has a negative value"
msgstr "列 ``id`` 的值为负数"

msgid "``metric``"
msgstr "``metric``"

msgid "``vertex_order``"
msgstr "``vertex_order``"

msgid "On an undirected graph"
msgstr "在无向图上"

msgid "The following query shows the original data involved in the contraction operation on an undirected graph."
msgstr "下面的查询显示了在无向图上进行收缩操作所涉及的原始数据。"

msgid "building contraction hierarchies on the whole graph"
msgstr "在整个图形上建立收缩层次结构"

msgid "The results do not represent the contracted graph. They represent the changes done to the graph after applying the contraction algorithm and give the vertex order built by the algorithm, by ordering vertices according to the *edge difference* metric. As a consequence, vertices are all represented in the result (except of course forbidden ones). Only shortcut built by the algorithm are represented in the result."
msgstr "结果并不代表收缩后的图形。它们代表的是应用收缩算法后对图所做的改变，并根据 *边差* 度量对顶点进行排序，从而给出算法建立的顶点顺序。因此，结果中包含了所有顶点（当然禁止的顶点除外）。结果中只显示算法建立的捷径。"

msgid "After computing the contraction hierarchies, an order is now given to the vertices,"
msgstr "计算完收缩层次后，现在要给顶点排序，"

msgid "in order to be used with a specific Dijkstra algorithm (implementation coming in a future version), which speeds up the search."
msgstr "是为了与一种特定的 Dijkstra 算法（在未来版本中实现）配合使用，从而加快搜索速度。"

msgid "We obtain the contracted graph above:"
msgstr "我们得到了上面的收缩图："

msgid "We can see without surprise that the vertices belonging to the shortcuts have a tendency to have a high priority level in the resulting vertices order."
msgstr "我们可以毫不意外地看到，属于捷径的顶点在结果顶点顺序中往往具有较高的优先级。"

msgid "On an undirected graph with forbidden vertices"
msgstr "在有禁止顶点的无向图上"

msgid "building contraction with a set of forbidden vertices"
msgstr "带有一组禁止顶点的建筑收缩"

msgid "Contraction process steps details"
msgstr "收缩过程步骤详情"

msgid "Shortcut building process"
msgstr "快捷构建过程"

msgid "A vertex ``v`` is contracted by adding shortcuts replacing former paths of the form ``(u, v, w)`` by an edge ``(u, w)``. The shortcut ``(u, w)`` is only needed when ``(u, v, w)`` is the only shortest path between ``u`` and ``w``."
msgstr "顶点 ``v`` 通过添加快捷边来进行收缩，替换形式为 ``(u, v, w)`` 的原路径为一条边 ``(u, w)`` 。仅当 ``(u, v, w)`` 是 ``u`` 和 ``w`` 之间唯一的最短路径时，才需要快捷边 ``(u, w)`` 。"

msgid "When all shortcuts have been added for a given vertex ``v``, the incident edges of ``v`` are removed and another vertex is contracted with the remaining graph."
msgstr "当为给定顶点 ``v`` 添加完所有快捷边后， ``v`` 的相关边会被移除，接着对剩余图中的另一个顶点进行收缩。"

msgid "The procedure is destructive for the graph and a copy is made to be able to manipulate it again as a whole. The contraction process adds all discovered shortcuts to the edge set ``E`` and attributes a metric to each contracted vertex. This metric is giving what is called the *contraction hierarchy*."
msgstr "这个过程对图形是破坏性的，我们会制作一个副本，以便再次对其进行整体操作。收缩过程会将所有发现的捷径添加到边集 ``E`` 中，并为每个收缩顶点赋予一个度量值。这个度量值就是所谓的 *收缩层次* 。"

msgid "Initialize the queue with a first vertices order"
msgstr "用初始顶点顺序初始化队列"

msgid "For each vertex ``v`` of the graph, a contraction of ``v`` is built:"
msgstr "对于图中的每个顶点 ``v`` ，都会建立一个 ``v`` 的收缩："

msgid ":math:`v`"
msgstr ":math:`v`"

msgid ":math:`\\{p, r, u\\}`"
msgstr ":math:`\\{p, r, u\\}`"

msgid ":math:`p`"
msgstr ":math:`p`"

msgid ":math:`\\{u, v\\}`"
msgstr ":math:`\\{u, v\\}`"

msgid ":math:`u`"
msgstr ":math:`u`"

msgid ":math:`\\{p, v, w\\}`"
msgstr ":math:`\\{p, v, w\\}`"

msgid ":math:`r`"
msgstr ":math:`r`"

msgid ":math:`\\{v, w\\}`"
msgstr ":math:`\\{v, w\\}`"

msgid ":math:`w`"
msgstr ":math:`w`"

msgid ":math:`\\{r, u\\}`"
msgstr ":math:`\\{r, u\\}`"

msgid "Adjacent edges are removed."
msgstr "相邻边被移除。"

msgid "Shortcuts are built from predecessors of ``v`` to successors of ``v`` if and only if the path through ``v`` corresponds to the only shortest path between the predecessor and the successor of ``v`` in the graph. The *edge difference* metric here takes the value of -2."
msgstr "只有当通过 ``v`` 的路径是 ``v`` 的前驱和后继之间唯一的最短路径时，才会从 ``v`` 的前驱到后继构建快捷边。这里的 *边差* 度量值为-2。"

msgid "Then the following vertex is contracted. The process goes on until each node of the graph has been contracted. At the end, there are no more edges in the graph, which has been destroyed by the process."
msgstr "然后收缩下面的顶点。这个过程一直持续到图中的每个节点都被收缩为止。最后，图中就不再有边了，这个过程也就结束了。"

msgid "This first contraction will give a vertices order, given by ordering them in ascending order on the metric (edge difference). A total vertices order is built. If ``u < v``, then ``u`` is less important than ``v``. The algorithm keeps the vertices into a queue in this order."
msgstr "第一次收缩将给出一个顶点顺序，根据度量（边差值）按升序排列。这样就得到了一个总的顶点顺序。如果 ``u < v`` ，那么 ``u`` 就比 ``v`` 重要。算法会按此顺序将顶点保存到队列中。"

msgid "A hierarchy will now be constructed by contracting again the vertices in this order."
msgstr "现在，我们将按照这个顺序再次收缩顶点，从而构建一个层次结构。"

msgid "Build the final vertex order"
msgstr "构建最终顶点顺序"

msgid "Once the first order built, the algorithm uses it to browse the graph once again. For each vertex taken in the queue, the algorithm simulates contraction and calculates its edge difference. If the computed value is greater than the one of the next vertex to be contracted, then the algorithm puts it back in the queue (heuristic approach). Otherwise it contracts it permanently."
msgstr "一旦建立了第一顺序，算法就会利用它再次浏览图形。对于队列中的每个顶点，算法都会模拟收缩并计算其边差。如果计算出的值大于下一个要收缩的顶点的值，算法就会把它放回队列（启发式方法）。否则，该顶点将永久收缩。"

msgid "Add shortcuts to the initial graph"
msgstr "向初始图形添加快捷边"

msgid "At the end, the algorithm takes the initial graph (before edges deletions) and adds the shortcut edges to it. It gives you the contracted graph, ready to use with a specialized Dijkstra algorithm, which takes into account the order of the nodes in the hierarchy."
msgstr "最后，算法会使用初始图形（删除边之前）并添加快捷边。这样就得到了收缩后的图形，可以使用专门的 Dijkstra 算法，该算法会考虑层次结构中节点的顺序。"

msgid "Use the contraction"
msgstr "使用缩略语"

msgid "Build the contraction"
msgstr "构建收缩"

msgid "Add shortcuts and hierarchy in the existing tables"
msgstr "在现有表中添加快捷边和层级"

msgid "Add new columns in the `vertices` and `edges` tables to store the results:"
msgstr "在 `vertices` 和 `edges` 表中添加新列来存储结果："

msgid "Update and insert the results in the two tables."
msgstr "更新并插入结果到两个表中。"

msgid "Use a Dijkstra shortest path algorithm on it"
msgstr "对其使用 Dijkstra 最短路径算法"

msgid "Then you can use any Dijkstra-like algorithm, waiting for the adapted one which will take into account the built vertices hierarchy. For example:"
msgstr "然后，你可以使用任何类似Dijkstra的算法，等待适应的算法，它将考虑构建的顶点层级。例如："

msgid "``pgr_contractionLinear`` - Proposed"
msgstr "``pgr_contractionLinear`` - 提议中"

msgid "``pgr_contractionLinear`` — Performs graph contraction and returns the contracted vertices and edges."
msgstr "``pgr_contractionLinear`` — 执行图收缩并返回收缩后的顶点和边线。"

msgid "pgr_contractionLinear(`Edges SQL`_, [**options**])"
msgstr "pgr_contractionLinear(`Edges SQL`_, [**options**])"

msgid "Linear contraction on an undirected graph."
msgstr "无向图上的线性收缩。"

msgid "The green nodes are linear nodes and will not be part of the contracted graph."
msgstr "绿色节点为线性节点，不属于收缩图的一部分。"

msgid "All edges adjacent will not be part of the contracted graph."
msgstr "所有相邻边线均不纳入收缩图。"

msgid "The red lines will be new edges of the contracted graph."
msgstr "红线将成为收缩图的新边线。"

msgid "**contraction Order**"
msgstr "**contraction Order**"

msgid "Number of times the contraction operations on ``contraction_order`` will be performed."
msgstr "对 ``contraction_order`` 执行收缩操作的次数。"

msgid "A node connects two (or more) `linear` edges when"
msgstr "节点连接两条（或多条）\"线性 \"边，当"

msgid "The number of adjacent vertices is 2."
msgstr "相邻顶点的数量为2。"

msgid "In case of a directed graph, a node is considered a `linear` node when"
msgstr "在有向图的情况下，当满足以下条件时，节点被视为`线性`节点"

msgid "Linearity is symmetrical."
msgstr "线性是对称的。"

msgid "Linearity is not symmetrical"
msgstr "线性不对称"

msgid "Graph where linearity is not symmetrical."
msgstr "线性不对称的图形。"

msgid "When the graph is processed as a directed graph, linearity is not symmetrical, therefore the graph can not be contracted."
msgstr "当图形作为有向图处理时，线性并不对称，因此图形无法收缩。"

msgid "When the same graph is processed as an undirected graph, linearity is symmetrical, therefore the graph can be contracted."
msgstr "当把同一图形作为无向图处理时，线性是对称的，因此图形可以收缩。"

msgid "The three edges can be replaced by one undirected edge"
msgstr "三条边可以用一条无向边代替"

msgid "Edge :math:`1 - 3`."
msgstr "边线 :math:`1 - 3`。"

msgid "With cost: :math:`4`."
msgstr "成本： :math:`4`."

msgid "Contracted vertices in the edge: :math:`\\{2\\}`."
msgstr "边上的收缩顶点: :math:`\\{2\\}`."

msgid "Linearity is symmetrical"
msgstr "线性是对称的"

msgid "Graph where linearity is symmetrical."
msgstr "线性对称的图形。"

msgid "The four edges can be replaced by two directed edges."
msgstr "四条边可以用两条有向边代替。"

msgid "Edge :math:`3 - 1`."
msgstr "边线 :math:`3 - 1`."

msgid "With cost: :math:`6`."
msgstr "成本： :math:`6`."

msgid "The four edges can be replaced by one undirected edge."
msgstr "四条边线可替换为一条无向边。"

msgid "Step by step linear contraction"
msgstr "逐步线性收缩"

msgid "The linear contraction will stop when there are no more linear edges. For example from the following graph there are linear edges"
msgstr "线性收缩将在没有更多线性边时停止。例如，在下图中存在线性边"

msgid "Contracting vertex :math:`3`,"
msgstr "收缩顶点 :math:`3`,"

msgid "The vertex :math:`3` is removed from the graph"
msgstr "顶点 :math:`3` 已从图中移除"

msgid "The edges :math:`2 \\rightarrow 3` and :math:`w \\rightarrow z` are removed from the graph."
msgstr "边线 :math:`2 \\rightarrow 3` 和 :math:`w \\rightarrow z` 已从图中移除。"

msgid "A new edge :math:`2 \\rightarrow 4` is inserted represented with red color."
msgstr "插入一条新边 :math:`2 \\rightarrow 4` ，用红色表示。"

msgid "Contracting vertex :math:`2`:"
msgstr "收缩顶点 :math:`2`："

msgid "The vertex :math:`2` is removed from the graph"
msgstr "顶点 :math:`2` 已从图形中移除"

msgid "The edges :math:`1 \\rightarrow 2` and :math:`2 \\rightarrow 3` are removed from the graph."
msgstr "从图中删除边 :math:`1 \\rightarrow 2` 和 :math:`2 \\rightarrow 3` 。"

msgid "A new edge :math:`1 \\rightarrow 3` is inserted represented with red color."
msgstr "插入一条新边 :math:`1\\rightarrow 3` ，用红色表示。"

msgid "Edge :math:`1 \\rightarrow 3` has the information of cost and the nodes that were contracted."
msgstr "边线 :math:`1 \\rightarrow 3` 包含成本值及被收缩节点信息。"

msgid "Create the contracted graph."
msgstr "创建收缩图。"

msgid "``pgr_cuthillMckeeOrdering`` - Experimental"
msgstr "pgr_cuthillMckeeOrdering`` - 实验性"

msgid "``pgr_cuthillMckeeOrdering`` — Returns the reverse Cuthill-Mckee ordering of an undirected graphs"
msgstr "``pgr_cuthillMckeeOrdering`` — 返回无向图的反向 Cuthill-Mckee 排序"

msgid "Version 3.4.0"
msgstr "版本 3.4.0"

msgid "In numerical linear algebra, the Cuthill-McKee algorithm (CM), named after Elizabeth Cuthill and James McKee, is an algorithm to permute a sparse matrix that has a symmetric sparsity pattern into a band matrix form with a small bandwidth."
msgstr "在数值线性代数中，Cuthill-McKee 算法（CM）以 Elizabeth Cuthill 和 James McKee 的名字命名，是一种将具有对称稀疏性模式的稀疏矩阵置换为带宽较小的带状矩阵形式的算法。"

msgid "The vertices are basically assigned a breadth-first search order, except that at each step, the adjacent vertices are placed in the queue in order of increasing degree."
msgstr "顶点的搜索顺序基本上是广度优先，只不过在每一步中，相邻的顶点会按照度数递增的顺序排列在队列中。"

msgid "The implementation is for **undirected** graphs."
msgstr "该实现适用于 **无向** 图。"

msgid "The bandwidth minimization problems are considered NP-complete problems."
msgstr "带宽最小化问题被认为是NP完全问题。"

msgid "The running time complexity is: :math:`O(m log(m)|V|)`"
msgstr "运行时间复杂度为： :math:`O(m log(m)|V|)`"

msgid "where :math:`|V|` is the number of vertices,"
msgstr "其中 :math:`|V|` 是顶点数，"

msgid ":math:`m` is the maximum degree of the vertices in the graph."
msgstr ":math:`m` 是图中顶点的最大度数。"

msgid "pgr_cuthillMckeeOrdering(`Edges SQL`_)"
msgstr "pgr_cuthillMckeeOrdering(`Edges SQL`_)"

msgid "Returns set of |result_node_order|"
msgstr "返回集合 |result_node_order|"

msgid "Graph ordering of pgRouting :doc:`sampledata`"
msgstr "pgRouting :doc:`sampledata` 的图形排序"

msgid "Returns set of ``(seq, node)``"
msgstr "返回 ``(seq, node)`` 的集合"

msgid "Sequence of the order starting from 1."
msgstr "从1开始的顺序序列。"

msgid "New ordering in reverse order."
msgstr "新的逆序排列。"

msgid "`Boost: Cuthill-McKee Ordering <https://www.boost.org/libs/graph/doc/cuthill_mckee_ordering.html>`__"
msgstr "`Boost: Cuthill-McKee 排序 <https://www.boost.org/libs/graph/doc/cuthill_mckee_ordering.html>`__"

msgid "`Wikipedia: Cuthill-McKee Ordering <https://en.wikipedia.org/wiki/Cuthill%E2%80%93McKee_algorithm>`__"
msgstr "`Wikipedia: Cuthill-McKee 排序 <https://en.wikipedia.org/wiki/Cuthill%E2%80%93McKee_algorithm>`__"

msgid "``pgr_dagShortestPath`` - Experimental"
msgstr "``pgr_dagShortestPath`` - 实验性"

msgid "``pgr_dagShortestPath`` — Returns the shortest path for weighted directed acyclic graphs(DAG). In particular, the DAG shortest paths algorithm implemented by Boost.Graph."
msgstr "``pgr_dagShortestPath`` — 返回加权有向无环图（DAG）中的最短路径。特别是使用 Boost.Graph 实现的 DAG 最短路径算法。"

msgid "pgr_dagShortestPath(Combinations)"
msgstr "pgr_dagShortestPath(组合)"

msgid "Shortest Path for Directed Acyclic Graph(DAG) is a graph search algorithm that solves the shortest path problem for weighted directed acyclic graph, producing a shortest path from a starting vertex (``start_vid``) to an ending vertex (``end_vid``)."
msgstr "有向无环图（DAG）的最短路径是一种图搜索算法，用于解决加权有向无环图的最短路径问题，找到从起始顶点 (``start_vid``) 到结束顶点 (``end_vid``) 的最短路径。"

msgid "This implementation can only be used with a **directed** graph with no cycles i.e. directed acyclic graph."
msgstr "这个实现只能用于 **有向** 图，且没有循环，即有向无环图。"

msgid "The algorithm relies on topological sorting the dag to impose a linear ordering on the vertices, and thus is more efficient for DAG's than either the Dijkstra or Bellman-Ford algorithm."
msgstr "该算法依靠对 DAG 进行拓扑排序来对顶点进行线性排序，因此比 Dijkstra 或 Bellman-Ford 算法更有效率。"

msgid "Process is valid for weighted directed acyclic graphs only. otherwise it will throw warnings."
msgstr "该过程仅对加权有向无环图有效。 否则它会抛出警告。"

msgid "The `agg_cost` the non included values `(v, v)` is `0`"
msgstr "`agg_cost`中未包括的值`(v, v)` 的成本为`0`"

msgid "The `agg_cost` the non included values `(u, v)` is :math:`\\infty`"
msgstr "`agg_cost`中未包括的值 `(u, v)`是数学符号中的 :math:`\\infty`"

msgid "Running time: :math:`O(| start\\_vids | * (V + E))`"
msgstr "运行时间： :math:`O(| start\\_vids | * (V + E))`"

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_dagShortestPath(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_dagShortestPath(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_dagShortestPath(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_dagShortestPath(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_dagShortestPath(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_dagShortestPath(`Edges SQL`_, `Combinations SQL`_)"

msgid "From vertex :math:`5` to vertex :math:`11` on a **directed** graph"
msgstr "在 **有向** 图上，从顶点 :math:`5` 到顶点 :math:`11`"

msgid "From vertex :math:`5` to vertices :math:`\\{7, 11\\}`"
msgstr "从顶点 :math:`5` 到顶点 :math:`\\{7, 11\\}`"

msgid "From vertices :math:`\\{5, 10\\}` to vertex :math:`11`"
msgstr "从顶点 :math:`\\{5, 10\\}` 到顶点 :math:`11`"

msgid "From vertices :math:`\\{5, 15\\}` to vertices :math:`\\{11, 17\\}` on an **undirected** graph"
msgstr "在 **无向** 图上，从顶点 :math:`\\{5, 15\\} ` 到顶点 :math:`\\{11, 17\\}`"

msgid "Return columns"
msgstr "返回列"

msgid "Making **start_vids** the same as **end_vids**"
msgstr "使 **start_vids** 与 **end_vids** 相同"

msgid "`Boost: DAG shortest paths <https://www.boost.org/libs/graph/doc/dag_shortest_paths.html>`__"
msgstr "`Boost: DAG最短路径DAG 最短路径 <https://www.boost.org/libs/graph/doc/dag_shortest_paths.html>`__"

msgid "https://en.wikipedia.org/wiki/Topological_sorting"
msgstr "https://en.wikipedia.org/wiki/Topological_sorting"

msgid "``pgr_degree``"
msgstr "``pgr_degree``"

msgid "``pgr_degree`` — For each vertex in an undirected graph, return the count of edges incident to the vertex."
msgstr "``pgr_degree`` —对于无向图中的每个顶点，返回与该顶点关联的边的计数。"

msgid "Error messages adjustment."
msgstr "错误信息调整。"

msgid "New signature with only Edges SQL."
msgstr "只有 Edges SQL 的新签名。"

msgid "Calculates the degree of the vertices of an undirected graph"
msgstr "计算无向图顶点的度数"

msgid "The degree (or valency) of a vertex of a graph is the number of edges that are incident to the vertex."
msgstr "图中顶点的度（或称为顶点的连接度）是指与该顶点相关联的边数。"

msgid "A loop contributes 2 to a vertex's degree."
msgstr "一个循环对一个顶点的度数贡献为 2。"

msgid "A vertex with degree 0 is called an isolated vertex."
msgstr "度数为 0 的顶点称为孤立顶点。"

msgid "Isolated vertex is not part of the result"
msgstr "孤立顶点不包含在结果中"

msgid "Vertex not participating on the subgraph is considered and isolated vertex."
msgstr "未参与子图的顶点被视为孤立顶点。"

msgid "There can be a ``dryrun`` execution and the code used to get the answer will be shown in a PostgreSQL ``NOTICE``."
msgstr "可以执行 ``dryrun`` ，用于获取答案的代码将显示在 PostgreSQL 的 ``NOTICE`` 。"

msgid "The code can be used as base code for the particular application requirements."
msgstr "该代码可用作满足特定应用要求的基础代码。"

msgid "No ordering is performed."
msgstr "不执行排序操作。"

msgid "pgr_degree(`Edges SQL`_ , [``dryrun``])"
msgstr "pgr_degree(`Edges SQL`_ , [``dryrun``])"

msgid "pgr_degree(`Edges SQL`_ , `Vertex SQL`_, [``dryrun``])"
msgstr "pgr_degree(`Edges SQL`_ , `Vertex SQL`_, [``dryrun``])"

msgid "RETURNS SETOF |result-degree|"
msgstr "RETURNS SETOF |result-degree|"

msgid "Edges"
msgstr "边"

msgid "example"
msgstr "示例"

msgid "Get the degree of the vertices defined on the edges table"
msgstr "获取边线表定义的顶点度数"

msgid "Edges and Vertices"
msgstr "边和顶点"

msgid "Extracting the vertex information"
msgstr "提取顶点信息"

msgid "``pgr_degree`` can use :doc:`pgr_extractVertices` embedded in the call."
msgstr "``pgr_degree`` 可以使用 :doc:`pgr_extractVertices` 嵌入调用。"

msgid "For decent size networks, it is best to prepare your vertices table before hand and use it on ``pgr_degree`` calls. (See `Using a vertex table`_)"
msgstr "对于适当规模的网络，最好事先准备好顶点表，并在调用 ``pgr_degree`` 时使用。 (请参阅 `Using a vertex table`_)"

msgid "Calculate the degree of the nodes:"
msgstr "计算节点的度数："

msgid "`Vertex SQL`_"
msgstr "`Vertex SQL`_"

msgid "`Vertex SQL`_ as described below"
msgstr "`Vertex SQL`_ 如下所述"

msgid "``dryrun``"
msgstr "``dryrun``"

msgid "When true do not process and get in a NOTICE the resulting query."
msgstr "当为真时，不要处理查询，而是获取一个通知（NOTICE）来显示查询的结果。"

msgid "For the `Edges and Vertices`_ signature:"
msgstr "关于 `Edges and Vertices`_ 签名："

msgid "For the `Edges`_ signature:"
msgstr "关于 `Edges`_ 签名："

msgid "Vertex SQL"
msgstr "Vertex SQL"

msgid "``in_edges``"
msgstr "``in_edges``"

msgid "Array of identifiers of the edges that have the vertex ``id`` as *first end point*."
msgstr "以顶点 ``id`` 作为 *第一个端点* 的边的标识符数组。"

msgid "When missing, ``out_edges`` must exist."
msgstr "当缺失时， ``out_edges`` 必须存在。"

msgid "``out_edges``"
msgstr "``out_edges``"

msgid "Array of identifiers of the edges that have the vertex ``id`` as *second end point*."
msgstr "以顶点 ``id`` 作为 *第二个端点* 的边的标识符数组。"

msgid "When missing, ``in_edges`` must exist."
msgstr "缺失时， ``in_edges`` 必须存在。"

msgid "Vertex identifier"
msgstr "顶点标识符"

msgid "``degree``"
msgstr "``degree``"

msgid "Number of edges that are incident to the vertex ``id``"
msgstr "与顶点 ``id`` 关联的边数"

msgid "Degree of a loop"
msgstr "循环度"

msgid "Using the `Edges`_ signature."
msgstr "使用 `Edges`_ 签名。"

msgid "Using the `Edges and Vertices`_ signature."
msgstr "使用 `Edges and Vertices`_ 签名。"

msgid "Degree of a sub graph"
msgstr "子图的度数"

msgid "For the following is a subgraph of the :doc:`sampledata`:"
msgstr "下面是 :doc:`sampledata` 的子图："

msgid ":math:`E = \\{(1, 5 \\leftrightarrow 6), (1, 6 \\leftrightarrow 10)\\}`"
msgstr ":math:`E = \\{(1, 5 \\leftrightarrow 6), (1, 6 \\leftrightarrow 10)\\}`"

msgid ":math:`V = \\{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17\\}`"
msgstr ":math:`V = \\{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17\\}`"

msgid "The vertices not participating on the edge are considered isolated"
msgstr "未参与边的顶点被视为孤立顶点"

msgid "their degree is 0 in the subgraph and"
msgstr "在子图中的阶数为 0，并且"

msgid "their degree is not shown in the output."
msgstr "它们的度数不会在输出结果中显示。"

msgid "Using a vertex table"
msgstr "使用顶点表"

msgid "For decent size networks, it is best to prepare your vertices table before hand and use it on ``pgr_degree`` calls."
msgstr "对于较大规模的网络，建议预先准备顶点表并在调用 ``pgr_degree`` 时使用。"

msgid "Extract the vertex information and save into a table:"
msgstr "提取顶点信息并保存到表格中："

msgid "Dry run execution"
msgstr "模拟执行"

msgid "To get the query generated used to get the vertex information, use ``dryrun => true``."
msgstr "要获取用于生成顶点信息的查询，请使用 ``dryrun => true`` 。"

msgid "The results can be used as base code to make a refinement based on the backend development needs."
msgstr "结果可作为基础代码，根据后台开发需要进行改进。"

msgid "Finding dead ends"
msgstr "查找断头节点"

msgid "If there is a vertices table already built using ``pgr_extractVertices`` and want the degree of the whole graph rather than a subset, it can be forgo using ``pgr_degree`` and work with the ``in_edges`` and ``out_edges`` columns directly."
msgstr "如果已经使用 ``pgr_extractVertices`` 构建了顶点表，并且想要获取整个图的度数，而不是子集的度数，则可以跳过使用 ``pgr_degree`` ，直接操作 ``in_edges`` 和 ``out_edges`` 列。"

msgid "The degree of a dead end is 1."
msgstr "断头节点的度数为 1。"

msgid "Finding linear vertices"
msgstr "查找线性顶点"

msgid "The degree of a linear vertex is 2."
msgstr "线性顶点的阶数为 2。"

msgid "If there is a vertices table already built using the ``pgr_extractVertices``"
msgstr "若已使用 ``pgr_extractVertices`` 构建顶点表"

msgid ":doc:`pgr_extractVertices`"
msgstr ":doc:`pgr_extractVertices`"

msgid "``pgr_depthFirstSearch`` - Proposed"
msgstr "``pgr_depthFirstSearch`` - 提议中"

msgid "``pgr_depthFirstSearch`` — Returns a depth first search traversal of the graph. The graph can be directed or undirected."
msgstr "``pgr_depthFirstSearch`` — 返回图的深度优先搜索遍历。 该图可以是有向图或无向图。"

msgid "Version 3.3.0"
msgstr "版本 3.3.0"

msgid "Depth First Search algorithm is a traversal algorithm which starts from a root vertex, goes as deep as possible, and backtracks once a vertex is reached with no adjacent vertices or with all visited adjacent vertices. The traversal continues until all the vertices reachable from the root vertex are visited."
msgstr "深度优先搜索算法是一种遍历算法，从根顶点开始，尽可能深入探索，一旦到达一个没有相邻顶点或所有相邻顶点都已访问的顶点，就会回溯。遍历会一直持续，直到从根顶点可达的所有顶点都被访问。"

msgid "The implementation works for both **directed** and **undirected** graphs."
msgstr "该实现适用于 **有向** 图和 **无向** 图。"

msgid "Provides the Depth First Search traversal order from a root vertex or from a set of root vertices."
msgstr "提供从根顶点或一组根顶点开始的深度优先搜索遍历顺序。"

msgid "An optional non-negative maximum depth parameter to limit the results up to a particular depth."
msgstr "可选的非负最大深度参数，用于限制结果的深度到特定的深度。"

msgid "For optimization purposes, any duplicated values in the `Root vids` are ignored."
msgstr "为了优化的目的，`Root vids` 中的任何重复值都会被忽略。"

msgid "It does not produce the shortest path from a root vertex to a target vertex."
msgstr "它不会生成从根顶点到目标顶点的最短路径。"

msgid "The aggregate cost of traversal is not guaranteed to be minimal."
msgstr "不保证遍历的总成本最小。"

msgid "The returned values are ordered in ascending order of `start_vid`."
msgstr "返回值按 `start_vid` 升序排列。"

msgid "Depth First Search Running time: :math:`O(E + V)`"
msgstr "深度优先搜索运行时间： :math:`O(E + V)`"

msgid "pgr_depthFirstSearch(`Edges SQL`_, **root vid**, [**options**])"
msgstr "pgr_depthFirstSearch(`Edges SQL`_, **root vid**, [**options**])"

msgid "pgr_depthFirstSearch(`Edges SQL`_, **root vids**, [**options**])"
msgstr "pgr_depthFirstSearch(`Edges SQL`_, **root vids**, [**options**])"

msgid "**options:** ``[directed, max_depth]``"
msgstr "**options:** ``[directed, max_depth]``"

msgid "Same as `Single vertex`_ but with edges in descending order of ``id``."
msgstr "与 `单个顶点`_ 相同，但边按 ``id`` 降序排列。"

msgid "`Boost: Depth First Search <https://www.boost.org/libs/graph/doc/depth_first_search.html>`__"
msgstr "`Boost: 深度优先搜索 <https://www.boost.org/libs/graph/doc/depth_first_search.html>`__"

msgid "`Boost: Undirected DFS <https://www.boost.org/libs/graph/doc/undirected_dfs.html>`__"
msgstr "`Boost: 非定向 DFS <https://www.boost.org/libs/graph/doc/undirected_dfs.html>`__"

msgid "`Wikipedia: Depth First Search algorithm <https://en.wikipedia.org/wiki/Depth-first_search>`__"
msgstr "`维基百科：深度优先搜索算法 <https://en.wikipedia.org/wiki/Depth-first_search>`__"

msgid "``pgr_dijkstra`` — Shortest path using Dijkstra algorithm."
msgstr "``pgr_dijkstra`` - 使用 Dijkstra 算法计算的最短路径。"

msgid "Version 3.5.0"
msgstr "版本 3.5.0"

msgid "pgr_dijkstra(One to One) added ``start_vid`` and ``end_vid`` columns."
msgstr "pgr_dijkstra(One to One) 增加了 ``start_vid`` 和 ``end_vid`` 列。"

msgid "pgr_dijkstra(One to Many) added ``end_vid`` column."
msgstr "pgr_dijkstra(One to Many) 添加了 ``end_vid`` 列。"

msgid "pgr_dijkstra(Many to One) added ``start_vid`` column."
msgstr "pgr_dijkstra(Many to One) 添加了 ``start_vid`` 列。"

msgid "Version 3.1.0"
msgstr "版本 3.1.0"

msgid "pgr_dijkstra(Combinations)"
msgstr "pgr_dijkstra(Combinations)"

msgid "Version 2.2.0"
msgstr "版本 2.2.0"

msgid "pgr_dijkstra(One to Many)"
msgstr "pgr_dijkstra(One to Many)"

msgid "pgr_dijkstra(Many to One)"
msgstr "pgr_dijkstra(Many to One)"

msgid "pgr_dijkstra(Many to Many)"
msgstr "pgr_dijkstra(Many to Many)"

msgid "Signature change on pgr_dijkstra(One to One)"
msgstr "pgr_dijkstra(One to One) 函数签名变更"

msgid "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid "pgr_dijkstra(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid "pgr_dijkstra(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_dijkstra(`Edges SQL`_, `Combinations SQL`_, [``directed``])"

msgid "From vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a **directed**"
msgstr "在 **有向** 图上，从顶点 :math:`6` 到顶点 :math:`\\{10, 17\\}`"

msgid "The examples of this section are based on the :doc:`sampledata` network."
msgstr "本节的示例基于 :doc:`sampledata` 网络。"

msgid "For **directed** graphs with ``cost`` and ``reverse_cost`` columns"
msgstr "对于带有 ``cost`` 和 ``reverse_cost`` 列的 **有向** 图"

msgid "Directed graph with cost and reverse cost columns"
msgstr "带成本列和反向成本列的有向图"

msgid "1) Path from :math:`6` to :math:`10`"
msgstr "1) 从 :math:`6` 到 :math:`10` 的路径"

msgid "2) Path from :math:`6` to :math:`7`"
msgstr "2) 从 :math:`6` 到 :math:`7` 的路径"

msgid "3) Path from :math:`12` to :math:`10`"
msgstr "3) 从 :math:`12` 到 :math:`10` 的路径"

msgid "4) Path from :math:`12` to :math:`7`"
msgstr "4) 从 :math:`12` 到 :math:`7` 的路径"

msgid "5) Using `One to Many`_ to get the solution of examples 1 and 2"
msgstr "5) 使用 `One to Many`_ 来获取示例1和示例2的解决方案"

msgid "Paths :math:`\\{6\\}\\rightarrow\\{10, 7\\}`"
msgstr "路径 :math:`\\{6\\}\\rightarrow\\{10, 7\\}`"

msgid "6) Using `Many to One`_ to get the solution of examples 2 and 4"
msgstr "6) 使用 `Many to One`_ 来获取示例2和示例4的解决方案"

msgid "Paths :math:`\\{6, 12\\}\\rightarrow\\{7\\}`"
msgstr "路径 :math:`\\{6, 12\\}\\rightarrow\\{7\\}`"

msgid "7) Using `Many to Many`_ to get the solution of examples 1 to 4"
msgstr "7) 使用 `Many to Many`_ 来获取示例1到4的解决方案"

msgid "Paths :math:`\\{6, 12\\}\\rightarrow\\{10, 7\\}`"
msgstr "路径 :math:`\\{6, 12\\}\\rightarrow\\{10, 7\\}`"

msgid "8) Using `Combinations`_ to get the solution of examples 1 to 3"
msgstr "8) 使用 `组合`_ 来获取示例1到3的解决方案"

msgid "Paths :math:`\\{6\\}\\rightarrow\\{10, 7\\}\\cup\\{12\\}\\rightarrow\\{10\\}`"
msgstr "路径 :math:`\\{6\\}\\rightarrow\\{10, 7\\}\\cup\\{12\\}\\rightarrow\\{10\\}`"

msgid "For **undirected** graphs with ``cost`` and ``reverse_cost`` columns"
msgstr "对于带有 ``cost`` 和 ``reverse_cost`` 列的 **无向** 图"

msgid "Undirected graph with cost and reverse cost columns"
msgstr "带成本列和反向成本列的无向图"

msgid "9) Path from :math:`6` to :math:`10`"
msgstr "9)从 :math:`6` 到 :math:`10` 的路径"

msgid "10) Path from :math:`6` to :math:`7`"
msgstr "10) 从 :math:`6` 到 :math:`7` 的路径"

msgid "11) Path from :math:`12` to :math:`10`"
msgstr "11)从 :math:`12` 到 :math:`10` 的路径"

msgid "12) Path from :math:`12` to :math:`7`"
msgstr "12)从 :math:`12` 到 :math:`7` 的路径"

msgid "13) Using `One to Many`_ to get the solution of examples 9 and 10"
msgstr "13) 使用 `One to Many`_ 来获取示例9和10的解决方案"

msgid "14) Using `Many to One`_ to get the solution of examples 10 and 12"
msgstr "14) 使用 `Many to One`_ 来获取示例10和12的解决方案"

msgid "15) Using `Many to Many`_ to get the solution of examples 9 to 12"
msgstr "15) 使用 `Many to Many`_ 来获取示例9到12的解决方案"

msgid "16) Using `Combinations`_ to get the solution of examples 9 to 11"
msgstr "16) 使用 `组合`_ 来获取示例9到11的解决方案"

msgid "For **directed** graphs only with ``cost`` column"
msgstr "仅适用于 **有向** 图，且仅包含 ``cost`` 列"

msgid "Directed graph only with cost column"
msgstr "仅有成本列的有向图"

msgid "17) Path from :math:`6` to :math:`10`"
msgstr "17)从 :math:`6` 到 :math:`10` 的路径"

msgid "18) Path from :math:`6` to :math:`7`"
msgstr "18) 从 :math:`6` 到 :math:`7` 的路径"

msgid "19) Path from :math:`12` to :math:`10`"
msgstr "19)从 :math:`12` 到 :math:`10` 的路径"

msgid "20) Path from :math:`12` to :math:`7`"
msgstr "20) 从 :math:`12` 到 :math:`7` 的路径"

msgid "21) Using `One to Many`_ to get the solution of examples 17 and 18"
msgstr "21) 使用 `One to Many`_ 来获取示例17和18的解决方案"

msgid "22) Using `Many to One`_ to get the solution of examples 18 and 20"
msgstr "22) 使用 `Many to One`_ 来获取示例18和20的解决方案"

msgid "23) Using `Many to Many`_ to get the solution of examples 17 to 20"
msgstr "23) 使用 `Many to Many`_ 来获取示例17到20的解决方案"

msgid "24) Using `Combinations`_ to get the solution of examples 17 to 19"
msgstr "24) 使用 `组合`_ 来获取示例17到19的解决方案"

msgid "For **undirected** graphs only with ``cost`` column"
msgstr "仅适用于带有 ``cost`` 列的 **无向** 图"

msgid "Undirected graph only with cost column"
msgstr "仅有成本列的无向图"

msgid "25) Path from :math:`6` to :math:`10`"
msgstr "25) 从 :math:`6` 到 :math:`10` 的路径"

msgid "26) Path from :math:`6` to :math:`7`"
msgstr "26) 从 :math:`6` 到 :math:`7` 的路径"

msgid "27) Path from :math:`12` to :math:`10`"
msgstr "27)从 :math:`12` 到 :math:`10` 的路径"

msgid "28) Path from :math:`12` to :math:`7`"
msgstr "28) 从 :math:`12` 到 :math:`7` 的路径"

msgid "29) Using `One to Many`_ to get the solution of examples 25 and 26"
msgstr "29) 使用 `One to Many`_ 来获取示例25和26的解决方案"

msgid "30) Using `Many to One`_ to get the solution of examples 26 and 28"
msgstr "30) 使用 `Many to One`_ 来获取示例26和28的解决方案"

msgid "31) Using `Many to Many`_ to get the solution of examples 25 to 28"
msgstr "31) 使用 `Many to Many`_ 来获取示例25到28的解决方案"

msgid "32) Using `Combinations`_ to get the solution of examples 25 to 27"
msgstr "32) 使用 `组合`_ 来获取示例25到27的解决方案"

msgid "Equvalences between signatures"
msgstr "签名之间的等价性"

msgid "The following examples find the path for :math:`\\{6\\}\\rightarrow\\{10\\}`"
msgstr "下面的示例可以找到 :math:`\\{6}\\rightarrow\\{10\\}` 的路径"

msgid "33) Using `One to One`_"
msgstr "33) 使用 `One to One`_"

msgid "34) Using `One to Many`_"
msgstr "34)使用 `One to Many`_"

msgid "35) Using `Many to One`_"
msgstr "35) 使用 `Many to One`_"

msgid "36) Using `Many to Many`_"
msgstr "36) 使用 `Many to Many`_"

msgid "37) Using `Combinations`_"
msgstr "37) 使用 `组合`_"

msgid "`Boost: Dijkstra shortest paths <https://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html>`__"
msgstr "`Boost: Dijkstra最短路径Dijkstra 最短路径 <https://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html>`__"

msgid "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
msgstr "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"

msgid "``pgr_dijkstraCost``"
msgstr "``pgr_dijkstraCost``"

msgid "``pgr_dijkstraCost`` - Total cost of the shortest path using Dijkstra algorithm."
msgstr "`pgr_dijkstraCost`` - 使用 Dijkstra 算法计算最短路径的总成本。"

msgid "pgr_dijkstraCost(Combinations)"
msgstr "pgr_dijkstraCost(Combinations)"

msgid "The ``pgr_dijkstraCost`` function summarizes of the cost of the shortest path using Dijkstra Algorithm."
msgstr "``pgr_dijkstraCost`` 使用 Dijkstra 算法计算出的最短路径的代价。"

msgid "pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr "pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid "pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr "pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid "pgr_dijkstraCost(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr "pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid "pgr_dijkstraCost(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr "pgr_dijkstraCost(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_dijkstraCost(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_dijkstraCost(`Edges SQL`_, `Combinations SQL`_, [``directed``])"

msgid "``pgr_dijkstraCostMatrix``"
msgstr "``pgr_dijkstraCostMatrix``"

msgid "``pgr_dijkstraCostMatrix`` - Calculates a cost matrix using :doc:`pgr_dijkstra`."
msgstr "``pgr_dijkstraCostMatrix`` - 使用 :doc:`pgr_dijkstra` 计算成本矩阵。"

msgid "Using Dijkstra algorithm, calculate and return a cost matrix."
msgstr "使用 Dijkstra 算法，计算并返回成本矩阵。"

msgid "pgr_dijkstraCostMatrix(`Edges SQL`_, **start vids**, [``directed``])"
msgstr "pgr_dijkstraCostMatrix(`Edges SQL`_, **start vids**, [``directed``])"

msgid "``pgr_dijkstraNear``"
msgstr "``pgr_dijkstraNear``"

msgid "``pgr_dijkstraNear`` — Using Dijkstra's algorithm, finds the route that leads to the nearest vertex."
msgstr "``pgr_dijkstraNear`` - 使用 Dijkstra 算法，找到通往最近顶点的路径。"

msgid "Given a graph, a starting vertex and a set of ending vertices, this function finds the shortest path from the starting vertex to the nearest ending vertex."
msgstr "给定一个图、一个起始顶点和一组终止顶点，该函数会找出从起始顶点到最近的终止顶点的最短路径。"

msgid "Uses Dijkstra algorithm."
msgstr "使用 Dijkstra 算法。"

msgid "Works for **directed** and **undirected** graphs."
msgstr "适用于 **有向** 和 **无向** 图。"

msgid "When there are more than one path to the same vertex with same cost:"
msgstr "当有多条路径通向同一顶点且成本相同时："

msgid "The algorithm will return just one path"
msgstr "算法将只返回一条路径"

msgid "Optionally allows to find more than one path."
msgstr "可选择查找多条路径。"

msgid "When more than one path is to be returned:"
msgstr "当需要返回多条路径时："

msgid "Results are sorted in increasing order of:"
msgstr "结果按以下顺序递增排序："

msgid "aggregate cost"
msgstr "总成本"

msgid "Within the same value of aggregate costs:"
msgstr "在总成本相同值范围内："

msgid "results are sorted by (source, target)"
msgstr "结果按 (source, target)排序"

msgid "Running time: Dijkstra running time: :math:`drt = O((|E| + |V|)log|V|)`"
msgstr "运行时间：Dijkstra 运行时间： :math:`drt = O((|E| + |V|)log|V|)`"

msgid "One to Many; :math:`drt`"
msgstr "一对多； :math:`drt`"

msgid "Many to One: :math:`drt`"
msgstr "Many to One: :math:`drt`"

msgid "Many to Many: :math:`drt * |Starting vids|`"
msgstr "Many to Many: :math:`drt * |Starting vids|`"

msgid "Combinations: :math:`drt * |Starting vids|`"
msgstr "组合： :math:`drt * |Starting vids|`"

msgid "pgr_dijkstraNear(`Edges SQL`_, **start vid**, **end vids**, [**options A**])"
msgstr "pgr_dijkstraNear(`Edges SQL`_, **start vid**, **end vids**, [**options A**])"

msgid "pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vid**, [**options A**])"
msgstr "pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vid**, [**options A**])"

msgid "pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vids**, [**options B**])"
msgstr "pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vids**, [**options B**])"

msgid "pgr_dijkstraNear(`Edges SQL`_, `Combinations SQL`_, [**options B**])"
msgstr "pgr_dijkstraNear(`Edges SQL`_, `Combinations SQL`_, [**options B**])"

msgid "**options A:** ``[directed, cap]``"
msgstr "**options A:** ``[directed, cap]``"

msgid "**options B:** ``[directed, cap, global]``"
msgstr "**options B:** ``[directed, cap, global]``"

msgid "pgr_dijkstraNear(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr "pgr_dijkstraNear(`Edges SQL`_, **start vid**, **end vids**, [**options**])"

msgid "**options:** ``[directed, cap]``"
msgstr "**options:** ``[directed, cap]``"

msgid "Departing on car from vertex :math:`6` find the nearest subway station."
msgstr "从顶点 :math:`6` 乘车出发，找到最近的地铁站。"

msgid "Using a **directed** graph for car routing."
msgstr "使用 **有向** 图进行汽车路线规划。"

msgid "The subway stations are on the following vertices :math:`\\{1, 10, 11\\}`"
msgstr "地铁站位于以下顶点上 :math:`\\{1, 10, 11\\}`"

msgid "The defaults used:"
msgstr "使用的默认值："

msgid "`directed => true`"
msgstr "`directed => true`"

msgid "`cap => 1`"
msgstr "`cap => 1`"

msgid "The result shows that station at vertex :math:`11` is the nearest."
msgstr "结果显示，位于顶点 :math:`11` 的站最近。"

msgid "pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr "pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vid**, [**options**])"

msgid "Departing on a car from a subway station find the nearest **two** stations to vertex :math:`2`"
msgstr "从地铁站开车出发，找到距离顶点 :math:`2` 最近的 **两个** 车站"

msgid "On line `4`: using the positional parameter: `directed` set to ``true``"
msgstr "第 `4` 行：使用位置参数： `directed` 设置为 ``true``"

msgid "In line `5`: using named parameter `cap => 2`"
msgstr "第 `5` 行：使用命名参数 `cap => 2`"

msgid "The result shows that station at vertex :math:`10` is the nearest and the next best is :math:`11`."
msgstr "结果显示，位于顶点 :math:`10` 的站点最近，其次是 :math:`11`。"

msgid "pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr "pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vids**, [**options**])"

msgid "**options:** ``[directed, cap, global]``"
msgstr "**options:** ``[directed, cap, global]``"

msgid "Find the best pedestrian connection between two lines of buses"
msgstr "在两条公交线路之间寻找最佳的行人通道"

msgid "Using an **undirected** graph for pedestrian routing"
msgstr "采用**非定向**图进行行人路径规划"

msgid "The first subway line stations are at :math:`\\{15, 16\\}`"
msgstr "第一条地铁线的站点位于 :math:`\\{15, 16\\}`"

msgid "The second subway line stations stops are at :math:`\\{1, 10, 11\\}`"
msgstr "地铁二号线的站点是 :math:`\\{1, 10, 11\\}`"

msgid "On line `4`: using the named parameter: `directed => false`"
msgstr "第 `4` 行：使用命名参数：`directed => false`"

msgid "`global => true`"
msgstr "`global => true`"

msgid "For a pedestrian the best connection is to get on/off is at vertex :math:`15` of the first subway line and at vertex :math:`10` of the second subway line."
msgstr "对于行人来说，上下车的最佳连接点是第一条地铁线的顶点 :math:`15` 和第二条地铁线的顶点 :math:`10`。"

msgid "Only `one` route is returned because `global` is ``true`` and `cap` is ``1``"
msgstr "只返回 `一条` 路由，因为 `global` 为 ``true`` 且 `cap` 为 ``1``"

msgid "pgr_dijkstraNear(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr "pgr_dijkstraNear(`Edges SQL`_, `Combinations SQL`_, [**options**])"

msgid "Find the best car connection between all the stations of two subway lines"
msgstr "查找两条地铁线所有站点之间的最佳汽车连接线路"

msgid "The first subway line stations stops are at :math:`\\{1, 10, 11\\}`"
msgstr "第一条地铁线的站点是 :math:`\\{1, 10, 11\\}`"

msgid "The second subway line stations are at :math:`\\{15, 16\\}`"
msgstr "地铁二号线站点位于 :math:`\\{15, 16\\}`"

msgid "The combinations contents:"
msgstr "组合内容："

msgid "lines `3~4` sets the start vertices to be from the first subway line and the ending vertices to be from the second subway line"
msgstr "行 `3~4` 将起始顶点设置为第一条地铁线上的顶点，将终点顶点设置为第二条地铁线上的顶点"

msgid "lines `6~7` sets the start vertices to be from the first subway line and the ending vertices to be from the first subway line"
msgstr "行 `6~7` 将起始顶点设置为第一条地铁线上的顶点，将终点顶点设置为第一条地铁线上的顶点"

msgid "On line `8`: using the named parameter is `global => false`"
msgstr "第 `8` 行：使用名为 `global => false` 的参数"

msgid "From the results:"
msgstr "从结果来看："

msgid "making a connection from the first subway line :math:`\\{1, 10, 11\\}` to the second :math:`\\{15, 16\\}`:"
msgstr "将第一条地铁线 :math:`{1, 10, 11\\}` 连接到第二条地铁线 :math:`{15, 16\\}`："

msgid "The best connections from all the stations from the first line are: :math:`{(1 \\rightarrow 16) (10 \\rightarrow 16) (11 \\rightarrow 16)}`"
msgstr "从第一条线路的所有站点出发的最佳连接是： :math:`{(1 \\rightarrow 16) (10 \\rightarrow 16) (11 \\rightarrow 16)}`"

msgid "The best one is :math:`(11 \\rightarrow 16)` with a cost of :math:`1` (lines: `11` and `12`)"
msgstr "最好的方法是 :math:`(11/rightarrow 16)`，成本是 :math:`1` （行：`11` 和`12`）"

msgid "making a connection from the second subway line :math:`\\{15, 16\\}` to the first :math:`\\{1, 10, 11\\}`:"
msgstr "将第二条地铁线 :math:`{15, 16\\}` 连接到第一条地铁线 :math:`{1, 10, 11\\}`："

msgid "The best connections from all the stations from the second line are: :math:`{(15 \\rightarrow 10) (16 \\rightarrow 11)}`"
msgstr "从二号线所有站点出发的最佳连接是： :math:`{(15 ／rightarrow 10) (16 ／rightarrow 11)}`"

msgid "Both are equally good as they have the same cost. (lines: `13` and `14` and lines: `15` and `16`)"
msgstr "由于成本相同，两者同样好。(行：`13` 和 `14` ，行：`15` 和 `16`)"

msgid "Dijkstra optional parameters"
msgstr "Dijkstra 可选参数"

msgid "Near optional parameters"
msgstr "接近可选参数"

msgid "``cap``"
msgstr "``cap``"

msgid "Find at most ``cap`` number of nearest shortest paths"
msgstr "查找最多 ``cap`` 条最近的最短路径"

msgid "``global``"
msgstr "``global``"

msgid "When ``true``: only ``cap`` limit results will be returned"
msgstr "``true`` 时：仅返回 ``cap`` 结果"

msgid "When ``false``: ``cap`` limit per ``Start vid`` will be returned"
msgstr "当 ``false`` 时：将返回每个 ``Start vid`` 的 ``cap`` 限值"

msgid "Wikipedia: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
msgstr "维基百科：https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"

msgid "``pgr_dijkstraNearCost``"
msgstr "``pgr_dijkstraNearCost``"

msgid "``pgr_dijkstraNearCost`` — Using dijkstra algorithm, finds the route that leads to the nearest vertex."
msgstr "`pgr_dijkstraNearCost`` - 使用 dijkstra 算法，找到通往最近顶点的路径。"

msgid "pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vids**, [**options A**])"
msgstr "pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vids**, [**options A**])"

msgid "pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vid**, [**options A**])"
msgstr "pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vid**, [**options A**])"

msgid "pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vids**, [**options B**])"
msgstr "pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vids**, [**options B**])"

msgid "pgr_dijkstraNearCost(`Edges SQL`_, `Combinations SQL`_, [**options B**])"
msgstr "pgr_dijkstraNearCost(`Edges SQL`_, `Combinations SQL`_, [**options B**])"

msgid "pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr "pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"

msgid "pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr "pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"

msgid "Departing on a car from a subway station find the nearest **two** stations to vertex :math:`6`"
msgstr "从地铁站开车出发找到距离顶点 :math:`6` 最近的 **两个** 车站"

msgid "pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr "pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"

msgid "pgr_dijkstraNearCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr "pgr_dijkstraNearCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"

msgid "The best one is :math:`(11 \\rightarrow 16)` with a cost of :math:`1` (lines: `1`)"
msgstr "最好的方法是 :math:`(11/rightarrow 16)`，成本是 :math:`1` (lines: `1`)"

msgid "Both are equally good as they have the same cost. (lines: `12` and `13`)"
msgstr "由于成本相同，两者同样好。(行：`12` and `13`)"

msgid "``pgr_dijkstraVia``"
msgstr "``pgr_dijkstraVia``"

msgid "``pgr_dijkstraVia`` — Route that goes through a list of vertices."
msgstr "``pgr_dijkstraVia`` - 经过顶点列表的路径。"

msgid "Given a list of vertices and a graph, this function is equivalent to finding the shortest path between :math:`vertex_i` and :math:`vertex_{i+1}` for all :math:`i < size\\_of(via\\;vertices)`."
msgstr "给定一个顶点列表和一个图，该函数等价于为所有 :math:`i < size\\_of(via\\;vertices)`的 :math:`vertex_i` 和 :math:`vertex_{i+1}` 之间找到最短路径。"

msgid "Route"
msgstr "路线"

msgid "is a sequence of paths."
msgstr "是一个路径序列。"

msgid "Path"
msgstr "路径"

msgid "is a section of the route."
msgstr "是路线的一段。"

msgid "One Via"
msgstr "一次通过"

msgid "pgr_dijkstraVia(`Edges SQL`_, **via vertices**, [**options**])"
msgstr "pgr_dijkstraVia(`Edges SQL`_, **via vertices**, [**options**])"

msgid "**options:** ``[directed, strict, U_turn_on_edge]``"
msgstr "**options:** ``[directed, strict, U_turn_on_edge]``"

msgid "Returns set of |via-result|"
msgstr "返回 |via-result| 的集合"

msgid "Find the route that visits the vertices :math:`\\{5, 1, 8\\}` in that order on an directed graph."
msgstr "在一个directed graph中，找到按顺序访问顶点 :math:`\\ {5, 1, 8\\}` 的路径。"

msgid "Via optional parameters"
msgstr "Via可选参数"

msgid "When ``true`` departing from a visited vertex will not try to avoid"
msgstr "为 ``true`` 时，从访问过的顶点出发时不会试图避开"

msgid "Identifier of a path. Has value **1** for the first path."
msgstr "路径的标识符。 第一条路径的值为 **1**。"

msgid "Identifier of the edge used to go from ``node`` to the next node in the path sequence."
msgstr "用于从路径序列中的 ``node`` 到下一个节点的边的标识符。"

msgid "-1 for the last node of the path."
msgstr "-1，表示路径的最后一个节点。"

msgid "-2 for the last node of the route."
msgstr "路由的最后一个节点为 -2。"

msgid "``route_agg_cost``"
msgstr "``route_agg_cost``"

msgid "Total cost from ``start_vid`` of ``seq = 1`` to ``end_vid`` of the current ``seq``."
msgstr "从 ``seq = 1`` 的 ``start_vid`` 到当前 ``seq`` 的 ``end_vid`` 的总费用。"

msgid "All this examples are about the route that visits the vertices :math:`\\{5, 7, 1, 8, 15\\}` in that order on a **directed** graph."
msgstr "所有这些示例都是关于在 **有向** 图上按顺序访问顶点 :math:`\\{5, 7, 1, 8, 15\\}` 的路径。"

msgid "The main query"
msgstr "主查询"

msgid "Aggregate cost of the third path."
msgstr "第三条路径的总成本。"

msgid "Route's aggregate cost of the route at the end of the third path."
msgstr "第三条路径末端的路径总成本。"

msgid "Nodes visited in the route."
msgstr "路由中访问的节点。"

msgid "The aggregate costs of the route when the visited vertices are reached."
msgstr "到达所访问顶点时的路线总成本。"

msgid "Status of \"passes in front\" or \"visits\" of the nodes."
msgstr "节点的 \"前方通过 \"或 \"访问 \"状态。"

msgid ":doc:`via-category`."
msgstr ":doc:`via-category`。"

msgid ":doc:`dijkstra-family`."
msgstr ":doc:`dijkstra-family`。"

msgid "``pgr_drivingDistance`` - Returns the driving distance from a start node."
msgstr "``pgr_drivingDistance`` - 返回起始节点的行驶距离。"

msgid "pgr_drivingDistance(Single vertex)"
msgstr "pgr_drivingDistance(Single vertex)"

msgid "Added ``depth`` and ``start_vid`` result columns."
msgstr "添加了 ``depth`` 和 ``start_vid`` 结果列。"

msgid "pgr_drivingDistance(Multiple vertices)"
msgstr "pgr_drivingDistance(Multiple vertices)"

msgid "Result column name change: ``from_v`` to ``start_vid``."
msgstr "结果列名称更改： ``from_v`` 改为 ``start_vid`` 。"

msgid "Added ``depth`` and ``pred`` result columns."
msgstr "添加了 ``depth`` 和``pred`` 结果列。"

msgid "Signature change:"
msgstr "签名变更："

msgid "pgr_drivingDistance(single vertex)"
msgstr "pgr_drivingDistance(单个顶点)"

msgid "New official signature:"
msgstr "新签名："

msgid "pgr_drivingDistance(multiple vertices)"
msgstr "pgr_drivingDistance(多个顶点)"

msgid "Using the Dijkstra algorithm, extracts all the nodes that have costs less than or equal to the value ``distance``. The edges extracted will conform to the corresponding spanning tree."
msgstr "使用 Dijkstra 算法，提取成本小于或等于 ``distance`` 值的所有节点。提取的边将符合相应的生成树。"

msgid "pgr_drivingDistance(`Edges SQL`_, **Root vid**, **distance**, [``directed``])"
msgstr "pgr_drivingDistance(`Edges SQL`_, **Root vid**, **distance**, [``directed``])"

msgid "pgr_drivingDistance(`Edges SQL`_, **Root vids**, **distance**, [**options**])"
msgstr "pgr_drivingDistance(`Edges SQL`_, **Root vids**, **distance**, [**options**])"

msgid "**options:** [directed, equicost]"
msgstr "**options:** [directed, equicost]"

msgid "Single Vertex"
msgstr "单个顶点"

msgid "From vertex :math:`11` for a distance of :math:`3.0`"
msgstr "从顶点 :math:`11` 到 :math:`3.0` 的距离"

msgid "Multiple Vertices"
msgstr "多个顶点"

msgid "From vertices :math:`\\{11, 16\\}` for a distance of :math:`3.0` with equi-cost on a directed graph"
msgstr "从顶点 :math:`{11, 16\\}` 出发，距离为 :math:`3.0` 且有向图上的成本相等"

msgid "Driving distance optional parameters"
msgstr "行驶距离可选参数"

msgid "``equicost``"
msgstr "``equicost``"

msgid "When ``true`` the node will only appear in the closest ``start_vid`` list. Tie brakes are arbitrary."
msgstr "``true`` 时，节点只会出现在最近的 ``start_vid`` 列表中。绑定制动是任意的。"

msgid "When ``false`` which resembles several calls using the single vertex signature."
msgstr "``false`` 时，类似于使用单个顶点签名的多次调用。"

msgid "end-before"
msgstr ""

msgid "From vertices :math:`\\{11, 16\\}` for a distance of :math:`3.0` on an undirected graph"
msgstr "在无向图上，从顶点 :math:`{11, 16\\}` 开始的距离为 :math:`3.0`"

msgid "``pgr_edgeColoring`` - Experimental"
msgstr "``pgr_edgeColoring`` - 实验性"

msgid "``pgr_edgeColoring`` — Returns the edge coloring of undirected and loop-free graphs"
msgstr "``pgr_edgeColoring`` - 返回无向图和无环图的边着色"

msgid "Edge Coloring is an algorithm used for coloring of the edges for the vertices in the graph. It is an assignment of colors to the edges of the graph so that no two adjacent edges have the same color."
msgstr "边着色是一种用于为图形中顶点的边着色的算法。它为图中的边分配颜色，使相邻的两条边没有相同的颜色。"

msgid "The implementation is for **undirected** and **loop-free** graphs"
msgstr "针对 **无向** 和 **无环** 图实施"

msgid "loop free"
msgstr "无环"

msgid "no self-loops and no parallel edges."
msgstr "无自循环，无平行边。"

msgid "Provides the color to be assigned to all the edges present in the graph."
msgstr "指定要分配给图中所有边的颜色。"

msgid "At most :math:`\\Delta + 1` colors are used, where :math:`\\Delta` is the degree of the graph."
msgstr "最多使用 :math:`\\Delta + 1` 种颜色，其中 :math:`\\Delta` 是图的度数。"

msgid "This is optimal for some graphs, and by Vizing's theorem it uses at most one color more than the optimal for all others."
msgstr "这对于某些图是最优的，根据Vizing定理，对于所有其他图，它使用的颜色最多比最优解多一种。"

msgid "the chromatic number :math:`x'(G)` (minimum number of colors needed for proper edge coloring of graph) is equal to the degree :math:`\\Delta + 1` of the graph, (:math:`x'(G) = \\Delta`)"
msgstr "色数（chromatic number） :math:`x'(G)`（用于图的适当边着色所需的最小颜色数）等于图的度 :math:`\\Delta + 1`（ :math:`x'(G) = \\Delta`）"

msgid "The algorithm tries to assign the least possible color to every edge."
msgstr "该算法尝试为每条边分配尽可能少的颜色。"

msgid "Does not always produce optimal coloring."
msgstr "并不总是产生最佳的着色。"

msgid "The returned rows are ordered in ascending order of the edge identifier."
msgstr "返回的行按边标识符升序排列。"

msgid "Efficient graph coloring is an NP-Hard problem, and therefore:"
msgstr "高效图形着色是一个 NP-Hard问题，因此："

msgid "In this implelentation the running time: :math:`O(|E|*|V|)`"
msgstr "在此实现中，运行时间为： :math:`O(|E|*|V||)`"

msgid "where :math:`|E|` is the number of edges in the graph,"
msgstr "其中 :math:`|E|` 是图中的边数、"

msgid ":math:`|V|` is the number of vertices in the graph."
msgstr ":math:`|V|` 是图中的顶点数。"

msgid "pgr_edgeColoring(`Edges SQL`_)"
msgstr "pgr_edgeColoring(`Edges SQL`_)"

msgid "Graph coloring of pgRouting :doc:`sampledata`"
msgstr "pgRouting :doc:`sampledata` 的图形着色"

msgid "`Boost: Edge Coloring <https://www.boost.org/libs/graph/doc/edge_coloring.html>`__"
msgstr "`Boost: 边着色 <https://www.boost.org/libs/graph/doc/edge_coloring.html>`__"

msgid "`Wikipedia: Graph coloring <https://en.wikipedia.org/wiki/Graph_coloring>`__"
msgstr "`维基百科：图着色 <https://en.wikipedia.org/wiki/Graph_coloring>`__"

msgid "``pgr_edgeDisjointPaths`` — Calculates edge disjoint paths between two groups of vertices."
msgstr "``pgr_edgeDisjointPaths`` - 计算两组顶点之间的边不相交路径。"

msgid "pgr_edgeDisjointPaths(Combinations)"
msgstr "pgr_edgeDisjointPaths(组合)"

msgid "Calculates the edge disjoint paths between two groups of vertices. Utilizes underlying maximum flow algorithms to calculate the paths."
msgstr "计算两组顶点之间的边不相交路径。 利用底层最大流量算法来计算路径。"

msgid "The main characterics are:"
msgstr "主要特点是："

msgid "Calculates the edge disjoint paths between any two groups of vertices."
msgstr "计算任意两组顶点之间的边相交路径。"

msgid "Returns EMPTY SET when source and destination are the same, or cannot be reached."
msgstr "当源和目标相同或无法到达时，返回 EMPTY SET。"

msgid "The graph can be directed or undirected."
msgstr "图可以是有向或无向的。"

msgid "Uses :doc:`pgr_boykovKolmogorov` to calculate the paths."
msgstr "使用 :doc:`pgr_boykovKolmogorov` 计算路径。"

msgid "pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr "pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid "pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr "pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid "pgr_edgeDisjointPaths(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr "pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid "pgr_edgeDisjointPaths(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr "pgr_edgeDisjointPaths(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_edgeDisjointPaths(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_edgeDisjointPaths(`Edges SQL`_, `Combinations SQL`_, [``directed``])"

msgid "Using a combinations table, equivalent to calculating result from vertices :math:`\\{5, 6\\}` to vertices :math:`\\{10, 15, 14\\}` on an undirected graph."
msgstr "使用组合表，相当于计算无向图上从顶点 :math:`\\{5, 6\\}` 到顶点 :math:`\\{10, 15, 14\\}` 的结果。"

msgid "Manually assigned vertex combinations on an undirected graph."
msgstr "在无向图上手动分配顶点组合。"

msgid "``pgr_edmondsKarp``"
msgstr "``pgr_edmondsKarp``"

msgid "``pgr_edmondsKarp`` — Calculates the flow on the graph edges that maximizes the flow from the sources to the targets using Edmonds Karp Algorithm."
msgstr "``pgr_edmondsKarp`` — 使用 Edmonds Karp 算法计算图边上的流量，以最大化从源到目标的流量。"

msgid "pgr_edmondsKarp(Combinations)"
msgstr "pgr_edmondsKarp(组合)"

msgid "Renamed from ``pgr_maxFlowEdmondsKarp``"
msgstr "从 ``pgr_maxFlowEdmondsKarp`` 更名而来"

msgid "Running time: :math:`O( V * E ^ 2)`"
msgstr "运行时间： :math:`O( V * E ^ 2)`"

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_edmondsKarp(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_edmondsKarp(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_edmondsKarp(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_edmondsKarp(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_edmondsKarp(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_edmondsKarp(`Edges SQL`_, `Combinations SQL`_)"

msgid "`Boost: Edmonds Karp max flow <https://www.boost.org/libs/graph/doc/edmonds_karp_max_flow.html>`__"
msgstr "`Boost: Edmonds Karp max flow <https://www.boost.org/libs/graph/doc/edmonds_karp_max_flow.html>`__"

msgid "https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm"
msgstr "https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm"

msgid "``pgr_edwardMoore`` - Experimental"
msgstr "``pgr_edwardMoore`` - 实验性"

msgid "``pgr_edwardMoore`` — Returns the shortest path using Edward-Moore algorithm."
msgstr "`pgr_edwardMoore`` - 使用 Edward-Moore 算法返回最短路径。"

msgid "Edward Moore’s Algorithm is an improvement of the Bellman-Ford Algorithm. It can compute the shortest paths from a single source vertex to all other vertices in a weighted directed graph. The main difference between Edward Moore's Algorithm and Bellman Ford's Algorithm lies in the run time."
msgstr "Edward Moore算法是Bellman-Ford算法的改进。 它可以计算加权有向图中从单个源顶点到所有其他顶点的最短路径。 Edward Moore算法和Bellman-Ford算法之间的主要区别在于运行时间。"

msgid "The worst-case running time of the algorithm is :math:`O(| V | * | E |)` similar to the time complexity of Bellman-Ford algorithm. However, experiments suggest that this algorithm has an average running time complexity of :math:`O( | E | )` for random graphs. This is significantly faster in terms of computation speed."
msgstr "该算法的最坏运行时间为 :math:`O(| V | * | E |)` ，类似于Bellman-Ford算法的时间复杂度。然而，实验表明，对于随机图，该算法的平均运行时间复杂度为 :math:`O( | E | )`。这在计算速度上明显更快。"

msgid "Thus, the algorithm is at-best, significantly faster than Bellman-Ford algorithm and is at-worst,as good as Bellman-Ford algorithm"
msgstr "因此，该算法在最好的情况下，明显快于 Bellman-Ford 算法，在最差的情况下，与 Bellman-Ford 算法一样好"

msgid "The `agg_cost` the non included values `(v, v)` is :math:`0`"
msgstr "未包含值 `(v, v)` 的 `agg_cost` 为 :math:`0`"

msgid "For optimization purposes, any duplicated value in the `start vids` or `end vids` are ignored."
msgstr "出于优化目的， `start vids` 或`end vids`中的任何重复值都将被忽略。"

msgid "Running time:"
msgstr "运行时间："

msgid "Worst case: :math:`O(| V | * | E |)`"
msgstr "最坏的情况： :math:`O(| V | * | E |)`"

msgid "Average case: :math:`O( | E | )`"
msgstr "平均情况： :math:`O( | E | )`"

msgid "pgr_edwardMoore(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr "pgr_edwardMoore(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid "pgr_edwardMoore(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr "pgr_edwardMoore(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid "pgr_edwardMoore(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr "pgr_edwardMoore(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"

msgid "pgr_edwardMoore(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr "pgr_edwardMoore(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_edwardMoore(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_edwardMoore(`Edges SQL`_, `Combinations SQL`_, [``directed``])"

msgid "Using a combinations table on an **undirected** graph."
msgstr "在 **无向** 图上使用组合表。"

msgid "https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm"
msgstr "https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm"

msgid "``pgr_extractVertices``"
msgstr "``pgr_extractVertices``"

msgid "``pgr_extractVertices`` — Extracts the vertices information"
msgstr "``pgr_extractVertices`` — 提取顶点信息"

msgid "This is an auxiliary function for extracting the vertex information of the set of edges of a graph."
msgstr "这是一个用于提取图的边集的顶点信息的辅助函数。"

msgid "When the edge identifier is given, then it will also calculate the in and out edges"
msgstr "当给出边标识符时，它也会计算出入边"

msgid "pgr_extractVertices(`Edges SQL`_, [``dryrun``])"
msgstr "pgr_extractVertices(`Edges SQL`_, [``dryrun``])"

msgid "RETURNS SETOF |result-extract|"
msgstr "RETURNS SETOF |result-extract|"

msgid "When line geometry is known"
msgstr "当线的几何形状已知时"

msgid "(Optional) identifier of the edge."
msgstr "（可选）边的标识符。"

msgid "``geom``"
msgstr "``geom``"

msgid "``LINESTRING``"
msgstr "``LINESTRING``"

msgid "Geometry of the edge."
msgstr "边的几何形状。"

msgid "This inner query takes precedence over the next two inner query, therefore other columns are ignored when ``geom`` column appears."
msgstr "该内部查询优先于接下来的两个内部查询，因此当 ``geom`` 列出现时，其他列将被忽略。"

msgid "Ignored columns:"
msgstr "忽略的列："

msgid "``startpoint``"
msgstr "``startpoint``"

msgid "``endpoint``"
msgstr "``endpoint``"

msgid "When vertex geometry is known"
msgstr "当顶点几何形状已知时"

msgid "To use this inner query the column ``geom`` should not be part of the set of columns."
msgstr "要使用此内部查询，列 ``geom`` 不应成为列集的一部分。"

msgid "``POINT``"
msgstr "``POINT``"

msgid "POINT geometry of the starting vertex."
msgstr "起始顶点的 POINT 几何图形。"

msgid "POINT geometry of the ending vertex."
msgstr "结束顶点POINT的几何图形。"

msgid "This inner query takes precedence over the next inner query, therefore other columns are ignored when ``startpoint`` and ``endpoint`` columns appears."
msgstr "此内部查询优先于下一个内部查询，因此当出现 ``startpoint`` 和 ``endpoint`` 列时，其他列将被忽略。"

msgid "When identifiers of vertices are known"
msgstr "当顶点的标识符已知时"

msgid "To use this inner query the columns ``geom``, ``startpoint`` and ``endpoint`` should not be part of the set of columns."
msgstr "要使用此内部查询，列 ``geom`` 、 ``startpoint`` 和 ``endpoint`` 不应成为列集的一部分。"

msgid "``NULL`` When the ``id`` is not part of the inner query"
msgstr "``NULL`` 当 ``id`` 不是内部查询的一部分时"

msgid "X value of the point geometry"
msgstr "点几何的X值"

msgid "``NULL`` When no geometry is provided"
msgstr "``NULL`` 当没有提供几何图形时"

msgid "Geometry of the point"
msgstr "点几何"

msgid "To get the query generated used to get the vertex information, use ``dryrun := true``."
msgstr "要获取用于生成顶点信息的查询，请使用 ``dryrun := true`` 。"

msgid "Create a routing topology"
msgstr "创建路由拓扑"

msgid "Make sure the database does not have the ``vertices_table``"
msgstr "确保数据库没有 ``vertices_table``"

msgid "Clean up the columns of the routing topology to be created"
msgstr "清理要创建的路由拓扑的列"

msgid "When the ``LINESTRING`` has a SRID then use ``geom::geometry(POINT, <SRID>)``"
msgstr "当 ``LINESTRING`` 具有 SRID 时，请使用 ``geom::geometry(POINT, <SRID>)``"

msgid "For big edge tables that are been prepared,"
msgstr "对于已经准备好的大型边表，"

msgid "Create it as ``UNLOGGED`` and"
msgstr "将其创建为 ``UNLOGGED`` 并"

msgid "After the table is created ``ALTER TABLE .. SET LOGGED``"
msgstr "创建表后，执行 ``ALTER TABLE .. SET LOGGED`` 操作"

msgid "Inspect the vertices table"
msgstr "检查顶点表"

msgid "Create the routing topology on the edge table"
msgstr "在边表上创建路由拓扑"

msgid "Updating the ``source`` information"
msgstr "更新 ``source`` 信息"

msgid "Updating the ``target`` information"
msgstr "更新 ``target`` 信息"

msgid "Inspect the routing topology"
msgstr "检查路由拓扑"

msgid "**Generated topology**"
msgstr "**生成拓扑**"

msgid "``pgr_findCloseEdges``"
msgstr "``pgr_findCloseEdges``"

msgid "``pgr_findCloseEdges`` - Finds the close edges to a point geometry."
msgstr "``pgr_findCloseEdges`` - 查找点几何图形的闭合边。"

msgid "``partial`` option is removed."
msgstr "``partial`` 选项已被移除。"

msgid "``pgr_findCloseEdges`` - An utility function that finds the closest edge to a point geometry."
msgstr "``pgr_findCloseEdges`` - 一个用于查找距离点状geometry最近边的工具函数。"

msgid "The geometries must be in the same coordinate system (have the same SRID)."
msgstr "几何图形必须位于同一坐标系中（具有相同的 SRID）。"

msgid "The code to do the calculations can be obtained for further specific adjustments needed by the application."
msgstr "可以获取计算代码，以便根据应用需要进行进一步的具体调整。"

msgid "``EMPTY SET`` is returned on dryrun executions"
msgstr "空结果集 ``EMPTY SET`` 会在试运行中返回"

msgid "pgr_findCloseEdges(`Edges SQL`_, **point**, **tolerance**, [**options**])"
msgstr "pgr_findCloseEdges(`Edges SQL`_, **point**, **tolerance**, [**options**])"

msgid "pgr_findCloseEdges(`Edges SQL`_, **points**, **tolerance**, [**options**])"
msgstr "pgr_findCloseEdges(`Edges SQL`_, **points**, **tolerance**, [**options**])"

msgid "**options:** ``[cap, dryrun]``"
msgstr "**options:** ``[cap, dryrun]``"

msgid "Returns set of |result-find|"
msgstr "返回集合 |result-find|"

msgid "One point"
msgstr "一个点"

msgid "Get two close edges to points of interest with :math:`pid = 5`"
msgstr "用 :math:`pid = 5` 获取两条与兴趣点接近的边"

msgid "``cap => 2``"
msgstr "``cap => 2``"

msgid "Many points"
msgstr "多点"

msgid "For each points of interests, find the closest edge."
msgstr "为每个兴趣点找出最近的边。"

msgid "**point**"
msgstr "**point**"

msgid "The point geometry"
msgstr "点几何"

msgid "**points**"
msgstr "**points**"

msgid "``POINT[]``"
msgstr "``POINT[]``"

msgid "An array of point geometries"
msgstr "点几何数组"

msgid "**tolerance**"
msgstr "**tolerance**"

msgid "Max distance between geometries"
msgstr "几何图形之间的最大距离"

msgid "Limit output rows"
msgstr "限制输出行数"

msgid "When ``false`` calculations are performed."
msgstr "当为 ``false`` 时，执行计算。"

msgid "When ``true`` calculations are not performed and the query to do the calculations is exposed in a PostgreSQL ``NOTICE``."
msgstr "当为 ``true`` 时，不执行计算，并在 PostgreSQL 的 ``NOTICE`` 中显示执行计算的查询。"

msgid "``geometry``"
msgstr "``geometry``"

msgid "The ``LINESTRING`` geometry of the edge."
msgstr "边的 ``LINESTRING`` 几何。"

msgid "When :math:`cap = 1`, it is the closest edge."
msgstr "当 :math:`cap = 1` 时，它是最近的边。"

msgid "Value in <0,1> that indicates the relative position from the first end-point of the edge."
msgstr "以 <0,1> 范围内的值，表示相对于边线第一个端点的相对位置。"

msgid "Value in ``[r, l]`` indicating if the point is:"
msgstr "``[r, l]`` 中的值指示该点是否为："

msgid "At the right ``r`` of the segment."
msgstr "位于线段右侧 ``r`` 。"

msgid "When the point is on the line it is considered to be on the right."
msgstr "当点在直线上时，它被认为是在右边。"

msgid "At the left ``l`` of the segment."
msgstr "位于线段左侧 ``l`` 。"

msgid "``distance``"
msgstr "``distance``"

msgid "Distance from the point to the edge."
msgstr "点到边线的距离。"

msgid "Original ``POINT`` geometry."
msgstr "原始的 ``POINT`` 几何形状。"

msgid "``LINESTRING`` geometry that connects the original **point** to the closest point of the edge with identifier ``edge_id``"
msgstr "连接原始 **point** 和具有标识符 ``edge_id`` 的边的最近点的 ``LINESTRING`` 几何体"

msgid "One point in an edge"
msgstr "边线上的一个点"

msgid "The green node is the original point."
msgstr "绿色节点为原始点。"

msgid "``geom`` has the value of the original point."
msgstr "``geom`` 包含原始点的坐标值。"

msgid "The geometry ``edge`` is a line that connects the original point with the edge :math:`sp \\rightarrow ep` edge."
msgstr "几何图形 ``edge`` 是连接原始点与边线 :math:`sp \\rightarrow ep` 的线段。"

msgid "The point is located at the left of the edge."
msgstr "该点位于边线的左侧。"

msgid "One point dry run execution"
msgstr "单点模拟执行"

msgid "Using the query from the previous example:"
msgstr "使用上一个示例中的查询："

msgid "Returns ``EMPTY SET``."
msgstr "返回 ``EMPTY SET`` 。"

msgid "``dryrun => true``"
msgstr "``dryrun => true``"

msgid "Generates a PostgreSQL ``NOTICE`` with the code used."
msgstr "生成一个包含用于计算所有列的代码的 PostgreSQL ``NOTICE`` 。"

msgid "The generated code can be used as a starting base code for additional requirements, like taking into consideration the SRID."
msgstr "生成的代码可用作满足其他要求（如考虑 SRID）的起始基础代码。"

msgid "Many points in an edge"
msgstr "一条边上有许多点"

msgid "The green nodes are the **original points**"
msgstr "绿色节点为 **原始点**"

msgid "The geometry ``geom``, marked as **g1** and **g2** are the **original points**"
msgstr "标为 **g1** 和 **g2** 的几何体 ``geom`` 是 **原始点**"

msgid "The geometry ``edge``, marked as **edge1** and **edge2** is a line that connects the **original point** with the closest point on the :math:`sp \\rightarrow ep` edge."
msgstr "标为 **edge1** 和 **edge2** 的几何图形 ``edge`` 是一条连接 ** 原始点** 和 :math:`sp \\rightarrow ep` 边上最近点的线。"

msgid "Many points dry run execution"
msgstr "多点模拟执行"

msgid "Do not process query"
msgstr "不处理查询"

msgid "Generate a PostgreSQL ``NOTICE`` with the code used to calculate all columns"
msgstr "生成一个包含用于计算所有列的代码的 PostgreSQL ``NOTICE``"

msgid "Find at most two routes to a given point"
msgstr "最多找到两条到达给定点的路线"

msgid "Using :doc:`pgr_withPoints`"
msgstr "使用 :doc:`pgr_withPoints`"

msgid "A point of interest table"
msgstr "兴趣点表"

msgid "Handling points outside the graph."
msgstr "处理图外的点。"

msgid "Points of interest"
msgstr "兴趣点"

msgid "Some times the applications work \"on the fly\" starting from a location that is not a vertex in the graph. Those locations, in pgRrouting are called points of interest."
msgstr "有时应用程序会“即时执行”，从不是图中顶点的位置开始。在pgRouting中，这些位置被称为兴趣点。"

msgid "The information needed in the points of interest is ``pid``, ``edge_id``, ``side``, ``fraction``."
msgstr "兴趣点所需的信息包括 ``pid``, ``edge_id``, ``side``, ``fraction`` 。"

msgid "On this documentation there will be some 6 fixed points of interest and they will be stored on a table."
msgstr "在这份文档中，将有6个固定的兴趣点，并且它们将被存储在一个表中。"

msgid "A unique identifier."
msgstr "唯一标识符。"

msgid "Identifier of the nearest segment."
msgstr "最近边线的标识符。"

msgid "Is it on the left, right or both sides of the segment ``edge_id``."
msgstr "位于边线 ``edge_id`` 的左侧、右侧还是两侧。"

msgid "Where in the segment is the point located."
msgstr "该点位于边的哪个位置。"

msgid "The geometry of the points."
msgstr "点的几何形状。"

msgid "The distance between ``geom`` and the segment ``edge_id``."
msgstr "``geom`` 与边线 ``edge_id`` 之间的距离。"

msgid "A segment that connects the ``geom`` of the point to the closest point on the segment ``edge_id``."
msgstr "一个连接点的 ``geom`` 到边 ``edge_id`` 上最近点的线段。"

msgid "``newPoint``"
msgstr "``newPoint``"

msgid "A point on segment ``edge_id`` that is the closest to ``geom``."
msgstr "边 ``edge_id`` 上距离 ``geom`` 最近的一个点。"

msgid "Points of interest fill up"
msgstr "兴趣点填充"

msgid "Inserting the points of interest."
msgstr "插入兴趣点。"

msgid "Filling the rest of the table."
msgstr "填充表格的其余部分。"

msgid "Any other additional modification: In this manual, point :math:`6` can be reached from both sides."
msgstr "任何其他额外的修改：在本手册中，可从两侧到达点 :math:`6`。"

msgid "The points of interest:"
msgstr "兴趣点："

msgid "``pgr_floydWarshall``"
msgstr "``pgr_floydWarshall``"

msgid "``pgr_floydWarshall`` - Returns the sum of the costs of the shortest path for each pair of nodes in the graph using Floyd-Warshall algorithm."
msgstr "``pgr_floydWarshall`` - 使用 Floyd-Warshall 算法返回图中每对节点的最短路径成本之和。"

msgid "The Floyd-Warshall algorithm, also known as Floyd's algorithm, is a good choice to calculate the sum of the costs of the shortest path for each pair of nodes in the graph, for *dense graphs*. We use Boost's implementation which runs in :math:`\\Theta(V^3)` time,"
msgstr "Floyd-Warshall算法，也被称为 Floyd算法，是计算图中每一对节点间最短路径的路径成本总和的一种良好选择，适用于*密集图*。我们使用Boost的实现，其运行时间为： :math:`\\Theta(V^3)`，"

msgid "pgr_floydWarshall(`Edges SQL`_, [``directed``])"
msgstr "pgr_floydWarshall(`Edges SQL`_, [``directed``])"

msgid "For a directed subgraph with edges :math:`\\{1, 2, 3, 4\\}`."
msgstr "对于有边 :math:`\\{1, 2, 3, 4\\}` 的有向子图。"

#, fuzzy
msgid "Boost `Floyd-Warshall <https://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html>`_"
msgstr "Boost `弗洛伊德-沃沙尔算法 <https://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html>`_"

msgid "``pgr_full_version``"
msgstr "``pgr_full_version``"

msgid "``pgr_full_version`` — Get the details of pgRouting version information."
msgstr "``pgr_full_version`` — 获取pgRouting版本信息的详细信息。"

msgid "Get complete details of pgRouting version information"
msgstr "获取 pgRouting 版本信息的完整详细信息"

msgid "pgr_full_version()"
msgstr "pgr_full_version()"

msgid "RETURNS |result-version|"
msgstr "RETURNS |result-version|"

msgid "Information about when this documentation was built"
msgstr "有关此文档何时构建的信息"

msgid "``version``"
msgstr "``version``"

msgid "pgRouting version"
msgstr "pgRouting 版本"

msgid "``build_type``"
msgstr "``build_type``"

msgid "The Build type"
msgstr "构建类型"

msgid "``compile_date``"
msgstr "``compile_date``"

msgid "Compilation date"
msgstr "编译日期"

msgid "``library``"
msgstr "``library``"

msgid "Library name and version"
msgstr "库名称和版本"

msgid "``system``"
msgstr "``system``"

msgid "Operative system"
msgstr "操作系统"

msgid "``postgreSQL``"
msgstr "``postgreSQL``"

msgid "pgsql used"
msgstr "使用pgsql"

msgid "``compiler``"
msgstr "``compiler``"

msgid "Compiler and version"
msgstr "编译器和版本"

msgid "``boost``"
msgstr "``boost``"

msgid "Boost version"
msgstr "Boost 版本"

msgid "``hash``"
msgstr "``hash``"

msgid "Git hash of pgRouting build"
msgstr "pgRouting 构建的 Git 哈希"

msgid "``pgr_hawickCircuits`` - Experimental"
msgstr "``pgr_hawickCircuits`` - 实验性"

msgid "``pgr_hawickCircuits`` — Returns the list of circuits using hawick circuits algorithm."
msgstr "``pgr_hawickCircuits`` — 使用 Hawick 电路算法返回电路列表。"

msgid "Hawick Circuit algorithm, is published in 2008 by Ken Hawick and Health A. James. This algorithm solves the problem of detecting and enumerating circuits in graphs. It is capable of circuit enumeration in graphs with directed-arcs, multiple-arcs and self-arcs with a memory efficient and high-performance im-plementation. It is an extension of Johnson's Algorithm of finding all the elementary circuits of a directed graph."
msgstr "Hawick Circuit 算法由 Ken Hawick 和 Health A. James 于 2008 年发表。 该算法解决了图中电路的检测和枚举问题。 它能够在具有有向弧、多弧和自弧的图中进行电路枚举，并具有内存高效和高性能的实现。 它是寻找有向图所有基本电路的约翰逊算法的扩展。"

msgid "There are 2 variations defined in the Boost Graph Library. Here, we have implemented only 2nd as it serves the most suitable and practical usecase. In this variation we get the circuits after filtering out the circuits caused by parallel edges. Parallel edge circuits have more use cases when you want to count the no. of circuits.Maybe in future, we will also implemenent this variation."
msgstr "Boost Graph Library 中定义了 2 个变体。 在这里，我们只实现了第二个，因为它服务于最合适和最实用的用例。 在这个变体中，我们在过滤掉由平行边缘引起的电路后得到电路。 当您想要计算数量时，并行边缘电路有更多用例。 也许将来我们也会实现这种变化。"

msgid "The algorithm implementation works only for directed graph"
msgstr "该算法实现仅适用于有向图"

msgid "It is a variation of Johnson's algorithm for circuit enumeration."
msgstr "这是对于电路枚举的一种格式，基于Johnson的算法。"

msgid "The algorithm outputs the distinct circuits present in the graph."
msgstr "该算法输出图中存在的不同电路。"

msgid "Time Complexity: :math:`O((V + E) (c + 1))`"
msgstr "时间复杂度： :math:`O((V + E) (c + 1))`"

msgid ":math:`|c|` is the number of circuits in the graph."
msgstr ":math:`|c|` 是图中电路的数目。"

msgid "pgr_hawickCircuits(`Edges SQL`_)"
msgstr "pgr_hawickCircuits(`Edges SQL`_)"

msgid "Circuits present in the pgRouting :doc:`sampledata`"
msgstr "pgRouting :doc:`sampledata` 中存在的电路"

msgid "Id of the circuit starting from ``1``"
msgstr "电路id从 ``1`` 开始"

msgid "Relative position in the path. Has value ``0`` for beginning of the path"
msgstr "在路径中的相对位置。数值 ``0`` 表示路径的起点"

msgid "Identifier of the starting vertex of the circuit."
msgstr "电路起始顶点的标识符。"

msgid "Identifier of the ending vertex of the circuit."
msgstr "电路结束顶点的标识符。"

msgid "Identifier of the node in the path from a vid to next vid."
msgstr "从 vid 到下一个 vid 的路径中节点的标识符。"

msgid "`Boost: Hawick Circuit Algorithm <https://www.boost.org/doc/libs/1_78_0/libs/graph/doc/hawick_circuits.html>`__"
msgstr "`Boost：Hawick 电路算法 <https://www.boost.org/doc/libs/1_78_0/libs/graph/doc/hawick_circuits.html>`__"

msgid "``pgr_isPlanar`` - Experimental"
msgstr "``pgr_isPlanar`` - 实验性"

msgid "``pgr_isPlanar`` — Returns a boolean depending upon the planarity of the graph."
msgstr "``pgr_isPlanar`` — 根据图的平面性返回布尔值。"

msgid "A graph is planar if it can be drawn in two-dimensional space with no two of its edges crossing. Such a drawing of a planar graph is called a plane drawing. Every planar graph also admits a straight-line drawing, which is a plane drawing where each edge is represented by a line segment. When a graph has :math:`K_5` or :math:`K_{3, 3}` as subgraph then the graph is not planar."
msgstr "如果一个图可以在二维空间中绘制，使得它的任意两条边都不相交，那么这个图就是平面图。这种平面图的绘制称为平面绘图。每个平面图也可以表示为一个直线绘图，即在平面绘图中，每条边都由一条线段表示。当一个图包含 :math:`K_5` 或 :math:`K_{3, 3}` 作为子图时，这个图就不是平面图。"

msgid "This implementation use the Boyer-Myrvold Planarity Testing."
msgstr "此实施使用 Boyer-Myrvold 平面度测试。"

msgid "It will return a boolean value depending upon the planarity of the graph."
msgstr "它将根据图形的平面性返回一个布尔值。"

msgid "Applicable only for **undirected** graphs."
msgstr "仅适用于 **无向** 图。"

msgid "The algorithm does not considers traversal costs in the calculations."
msgstr "该算法在计算中不考虑遍历成本。"

msgid "Running time: :math:`O(|V|)`"
msgstr "运行时间： :math:`O(|V|)`"

msgid "pgr_isPlanar(`Edges SQL`)"
msgstr "pgr_isPlanar(`Edges SQL`)"

msgid "RETURNS ``BOOLEAN``"
msgstr "返回 ``BOOLEAN``"

msgid "Returns a boolean ``(pgr_isplanar)``"
msgstr "返回一个布尔值 ``(pgr_isplanar)``"

msgid "``pgr_isplanar``"
msgstr "``pgr_isplanar``"

msgid "`true` when the graph is planar."
msgstr "当图形是平面时为 `true`。"

msgid "`false` when the graph is not planar."
msgstr "当图形不是平面时为 `false`。"

msgid "The following edges will make the subgraph with vertices {10, 15, 11, 16, 13} a :math:`K_1` graph."
msgstr "以下边将构成具有顶点 {10, 15, 11, 16, 13} 的子图，这个子图是一个 :math:`K_1` 图。"

msgid "The new graph is not planar because it has a :math:`K_5` subgraph. Edges in blue represent :math:`K_5` subgraph."
msgstr "新图不是平面图，因为它具有一个 :math:`K_5` 子图。蓝色的边代表 :math:`K_5` 子图。"

msgid "`Boost: Boyer Myrvold <https://www.boost.org/libs/graph/doc/boyer_myrvold.html>`__"
msgstr "`Boost: Boyer-Myrvold 算法 <https://www.boost.org/libs/graph/doc/boyer_myrvold.html>`__"

msgid "``pgr_johnson``"
msgstr "``pgr_johnson``"

#, fuzzy
msgid "``pgr_johnson`` - Returns the sum of the costs of the shortest path for each pair of nodes in the graph using Johnson algorithm."
msgstr "``pgr_johnson`` - 使用 Jhonson 算法返回图中每对节点的最短路径成本之和。"

msgid "The Johnson algorithm, is a good choice to calculate the sum of the costs of the shortest path for each pair of nodes in the graph, for *sparse graphs*. It uses the Boost's implementation which runs in :math:`O(V E \\log V)` time,"
msgstr "Johnson 算法是计算图中每对节点的最短路径总成本的一个良好选择，特别适用于*稀疏图*。它使用 Boost 实现，运行时间为 :math:`O(V E \\log V)` ，"

msgid "pgr johnson(`Edges SQL`_, [``directed``])"
msgstr "pgr johnson(`Edges SQL`_, [``directed``])"

msgid "Boost `Johnson <https://www.boost.org/libs/graph/doc/johnson_all_pairs_shortest.html>`_"
msgstr "Boost `Johnson 算法 <https://www.boost.org/libs/graph/doc/johnson_all_pairs_shortest.html>`_"

#, fuzzy
msgid "``pgr_kingOrdering`` - Experimental"
msgstr "``pgr_edgeColoring`` - 实验性"

#, fuzzy
msgid "``pgr_kingOrdering`` — Returns the King ordering of an undirected graph."
msgstr "``pgr_cuthillMckeeOrdering`` — 返回无向图的反向 Cuthill-Mckee 排序"

msgid "In numerical linear algebra and graph theory, the King ordering algorithm is a heuristic designed to reorder the vertices of a graph so as to reduce its bandwidth."
msgstr ""

msgid "The method follows a breadth-first search (BFS) traversal, but with a refinement: at each step, the unvisited neighbors of the current vertex are inserted into the queue in ascending order of their pseudo-degree, where the pseudo-degree of a vertex is the number of edges connecting it to yet-unvisited vertices. This prioritization often yields a smaller bandwidth compared to simpler BFS orderings."
msgstr ""

#, fuzzy
msgid "The implementation targets undirected graphs."
msgstr "该实现适用于 **无向** 图。"

msgid "Bandwidth minimization is an NP-complete problem; King ordering provides a practical local minimization approach."
msgstr ""

#, fuzzy
msgid "The time complexity is: :math:`O(m^2 \\log(m)|E|)`"
msgstr "运行时间复杂度为： :math:`O(m log(m)|V|)`"

#, fuzzy
msgid "where :math:`|E|` is the number of edges,"
msgstr "其中 :math:`|V|` 是顶点数，"

#, fuzzy
msgid ":math:`m` is the maximum degree among all vertices."
msgstr ":math:`m` 是图中顶点的最大度数。"

#, fuzzy
msgid "pgr_kingOrdering(`Edges SQL`_)"
msgstr "pgr_edgeColoring(`Edges SQL`_)"

#, fuzzy
msgid "`Boost: King Ordering <https://www.boost.org/libs/graph/doc/king_ordering.html>`__"
msgstr "`Boost: 边着色 <https://www.boost.org/libs/graph/doc/edge_coloring.html>`__"

msgid "``pgr_kruskal``"
msgstr "``pgr_kruskal``"

msgid "``pgr_kruskal`` — Minimum spanning tree of a graph using Kruskal's algorithm."
msgstr "``pgr_kruskal`` — 使用 Kruskal 算法的图的最小生成树。"

msgid "This algorithm finds the minimum spanning forest in a possibly disconnected graph using Kruskal's algorithm."
msgstr "该算法使用 Kruskal 算法在可能断开的图中找到最小生成森林。"

msgid "EMPTY SET is returned when there are no edges in the graph."
msgstr "当图中没有边时，返回 EMPTY SET。"

msgid "pgr_kruskal(`Edges SQL`_)"
msgstr "pgr_kruskal(`Edges SQL`_)"

msgid "Returns set of |result-mst|"
msgstr "返回 |result-mst| 的集合"

msgid "Minimum spanning forest"
msgstr "最小生成森林"

msgid "``pgr_kruskalBFS`` — Kruskal's algorithm for Minimum Spanning Tree with breadth First Search ordering."
msgstr "``pgr_kruskalBFS`` — Kruskal 的最小生成树算法，具有广度优先搜索排序。"

msgid "Added ``pred`` result columns."
msgstr "添加了 ``pred`` 结果列。"

msgid "Visits and extracts the nodes information in Breath First Search ordering of the Minimum Spanning Tree created using Kruskal's algorithm."
msgstr "访问并提取使用 Kruskal 算法创建的最小生成树的呼吸优先搜索排序中的节点信息。"

msgid "Returned tree nodes from a root vertex are on Breath First Search order"
msgstr "从根顶点返回的树节点遵循广度优先搜索顺序"

msgid "Breath First Search Running time: :math:`O(E + V)`"
msgstr "广度优先搜索运行时间： :math:`O(E + V)`"

msgid "pgr_kruskalBFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr "pgr_kruskalBFS(`Edges SQL`_, **root vid**, [``max_depth``])"

msgid "pgr_kruskalBFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr "pgr_kruskalBFS(`Edges SQL`_, **root vids**, [``max_depth``])"

msgid "The Minimum Spanning Tree having as root vertex :math:`6`"
msgstr "以根顶点为 :math:`6` 的最小生成树"

msgid "The Minimum Spanning Tree starting on vertices :math:`\\{9, 6\\}` with :math:`depth \\leq 3`"
msgstr "以顶点 :math:`\\{9, 6\\}` 为起点， :math:`depth \\leq 3` 的最小生成树"

msgid "``pgr_kruskalDD`` — Catchament nodes using Kruskal's algorithm."
msgstr "``pgr_kruskalDD`` — 使用 Kruskal 算法的汇流节点。"

msgid "Using Kruskal's algorithm, extracts the nodes that have aggregate costs less than or equal to a **distance** from a **root** vertex (or vertices) within the calculated minimum spanning tree."
msgstr "使用 Kruskal 算法，在计算的最小生成树中提取总成本小于或等于距 **根** 顶点（或多个顶点） **距离** 的节点。"

msgid "Returned tree nodes from a root vertex are on Depth First Search order."
msgstr "从根顶点返回的树节点遵循深度优先搜索顺序。"

msgid "Depth First Search running time: :math:`O(E + V)`"
msgstr "深度优先搜索运行时间： :math:`O(E + V)`"

msgid "pgr_kruskalDD(`Edges SQL`_, **root vid**, **distance**)"
msgstr "pgr_kruskalDD(`Edges SQL`_, **root vid**, **distance**)"

msgid "pgr_kruskalDD(`Edges SQL`_, **root vids**, **distance**)"
msgstr "pgr_kruskalDD(`Edges SQL`_, **root vids**, **distance**)"

msgid "The Minimum Spanning Tree starting on vertex :math:`6` with :math:`distance \\leq 3.5`"
msgstr "以顶点 :math:`6` 为起点的，总成本小于或等于 :math:`distance \\leq 3.5` 的最小生成树"

msgid "The Minimum Spanning Tree starting on vertices :math:`\\{9, 6\\}` with :math:`distance \\leq 3.5`"
msgstr "以顶点 :math:`\\{9, 6\\}` 为起点， :math:`distance \\leq 3.5` 的最小生成树"

msgid "``pgr_kruskalDFS`` — Kruskal's algorithm for Minimum Spanning Tree with Depth First Search ordering."
msgstr "``pgr_kruskalDFS`` — 具有深度优先搜索排序的最小生成树 Kruskal 算法。"

msgid "Visits and extracts the nodes information in Depth First Search ordering of the Minimum Spanning Tree created using Kruskal's algorithm."
msgstr "访问并提取使用 Kruskal 算法创建的最小生成树的深度优先搜索顺序中的节点信息。"

msgid "Returned tree nodes from a root vertex are on Depth First Search order"
msgstr "从根顶点返回的树节点按深度优先搜索顺序"

msgid "pgr_kruskalDFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr "pgr_kruskalDFS(`Edges SQL`_, **root vid**, [``max_depth``])"

msgid "pgr_kruskalDFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr "pgr_kruskalDFS(`Edges SQL`_, **root vids**, [``max_depth``])"

msgid "``pgr_lengauerTarjanDominatorTree`` - Experimental"
msgstr "``pgr_lengauerTarjanDominatorTree`` - 实验性"

msgid "``pgr_lengauerTarjanDominatorTree`` — Returns the immediate dominator of all vertices."
msgstr "``pgr_lengauerTarjanDominatorTree`` — 返回所有顶点的直接支配者。"

msgid "The algorithm calculates the *immediate dominator* of each vertex called **idom**, once **idom** of each vertex is calculated then by making every **idom** of each vertex as its parent, the dominator tree can be built."
msgstr "该算法计算每个顶点的*immediate dominator*，称为**idom**，一旦计算出每个顶点的**idom**，就可以将每个顶点的**idom**作为其父节点，从而构建支配者树。"

msgid "The algorithm works in directed graph only."
msgstr "该算法仅适用于有向图。"

msgid "The algorithm returns *idom* of each vertex."
msgstr "该算法返回每个顶点的* idom*。"

msgid "If the *root vertex* not present in the graph then it returns empty set."
msgstr "如果图中不存在*根顶点*，则返回空集。"

msgid "Running time: :math:`O((V+E)log(V+E))`"
msgstr "运行时间： :math:`O((V+E)log(V+E))`"

msgid "pgr_lengauerTarjanDominatorTree(`Edges SQL`_, **root vertex**)"
msgstr "pgr_lengauerTarjanDominatorTree(`Edges SQL`_, **root vertex**)"

msgid "Returns set of |result-idom|"
msgstr "返回 |result-idom| 的集合"

msgid "The dominator tree with root vertex :math:`5`"
msgstr "具有根顶点 :math:`5` 的支配树"

msgid "SQL query as described above."
msgstr "SQL 查询如上所述。"

msgid "**root vertex**"
msgstr "**root vertex**"

msgid "Returns set of ``(seq, vertex_id, idom)``"
msgstr "返回集合 ``(seq, vertex_id, idom)``"

msgid "``vertex_id``"
msgstr "``vertex_id``"

msgid "Identifier of vertex ."
msgstr "顶点的标识符。"

msgid "``idom``"
msgstr "``idom``"

msgid "Immediate dominator of vertex."
msgstr "顶点的直接支配者。"

msgid "Dominator tree of another component."
msgstr "另一个组件的支配树。"

msgid "`Boost: Lengauer-Tarjan dominator <https://www.boost.org/libs/graph/doc/lengauer_tarjan_dominator.htm>`__"
msgstr "`Boost: Lengauer-Tarjan 支配者算法 <https://www.boost.org/libs/graph/doc/lengauer_tarjan_dominator.htm>`__"

msgid "`Wikipedia: dominator tree <https://en.wikipedia.org/wiki/Dominator_(graph_theory)>`__"
msgstr "`维基百科:支配树 <https://en.wikipedia.org/wiki/Dominator_(graph_theory)>`__"

msgid "``pgr_lineGraph`` - Proposed"
msgstr "``pgr_lineGraph`` - 提议中"

msgid "``pgr_lineGraph`` — Transforms the given graph into its corresponding edge-based graph."
msgstr "``pgr_lineGraph`` — 将给定图转换为其相应的基于边的图。"

msgid "Works for directed and undirected graphs."
msgstr "适用于有向和无向图。"

msgid "Given a graph :math:`G`, its line graph :math:`L(G)` is a graph such that:"
msgstr "给定一个图 :math:`G`，其线图 :math:`L(G)` 是一个图，满足以下条件："

msgid "Each vertex of :math:`L(G)` represents an edge of :math:`G`."
msgstr ":math:`L(G)` 的每个顶点代表 :math:`G` 的一条边。"

msgid "Two vertices of :math:`L(G)` are adjacent if and only if their corresponding edges share a common endpoint in :math:`G`"
msgstr ":math:`L(G)` 的两个顶点相邻，当且仅当它们对应的边在 :math:`G` 中共享一个共同端点时"

msgid "The ``cost`` and ``reverse_cost`` columns of the result represent existence of the edge."
msgstr "结果中的 ``cost`` 和 ``reverse_cost`` 列表示边的存在性。"

msgid "When the graph is directed the result is directed."
msgstr "当图形是有向的，结果也是有向的。"

msgid "To get the complete Line Graph use unique identifiers on the double way edges (See `Additional Examples`_)."
msgstr "要获取完整的线图，请在双向边上使用唯一标识符 (See `Additional Examples`_)."

msgid "When the graph is undirected the result is undirected."
msgstr "当图无向时，成本矩阵是对称的。"

msgid "The ``reverse_cost`` is always :math:`-1`."
msgstr "``reverse_cost`` 始终为 :math:`-1` 。"

msgid "pgr_lineGraph(`Edges SQL`_, [``directed``])"
msgstr "pgr_lineGraph(`Edges SQL`_, [``directed``])"

msgid "Returns set of |result-lineg|"
msgstr "返回结果 |result-lineg|"

msgid "For an undirected graph with edges :math:'{2,4,5,8}'"
msgstr "对于一个undirected graph(无向图)，其边为 :math:'{2,4,5,8}'"

msgid "Gives a local identifier for the edge"
msgstr "给出边的本地标识符"

msgid "When `negative`: the source is the reverse edge in the original graph."
msgstr "为负时：源是原始图中的反向边。"

msgid "When `negative`: the target is the reverse edge in the original graph."
msgstr "为负时：目标是原始图中的反向边。"

msgid "Weight of the edge (``source``, ``target``)."
msgstr "边 (``source``, ``target``) 的权重。"

msgid "When `negative`: edge (``source``, ``target``) does not exist, therefore it’s not part of the graph."
msgstr "当为负时：边(``source``, ``target``)不存在，因此它不是图的一部分。"

msgid "Weight of the edge (``target``, ``source``)."
msgstr "边 (``target``, ``source``)的权重。"

msgid "When `negative`: edge (``target``, ``source``) does not exist, therefore it’s not part of the graph."
msgstr "当为负时：边(``target``, ``source``)不存在，因此它不是图的一部分。"

msgid "Given the following directed graph"
msgstr "给定以下有向图"

msgid ":math:`G(V,E) = G(\\{1,2,3,4\\},\\{ 1 \\rightarrow 2, 1 \\rightarrow 4, 2 \\rightarrow 3, 3 \\rightarrow 1, 3 \\rightarrow 2, 3 \\rightarrow 4, 4 \\rightarrow 3\\})`"
msgstr ":math:`G(V,E) = G(\\{1,2,3,4\\},\\{ 1 \\rightarrow 2, 1 \\rightarrow 4, 2 \\rightarrow 3, 3 \\rightarrow 1, 3 \\rightarrow 2, 3 \\rightarrow 4, 4 \\rightarrow 3\\})`"

msgid "Representation as directed with shared edge identifiers"
msgstr "用共享边标识符定向表示"

msgid "For the simplicity, the design of the edges table on the database, has the edge's identifiers are represented with 3 digits:"
msgstr "为了简化数据库中边表的设计，边的标识符采用3位数字表示："

msgid "hundreds"
msgstr "百位"

msgid "the source vertex"
msgstr "源点"

msgid "tens"
msgstr "十位"

msgid "always 0, acts as a separator"
msgstr "始终为 0，用作分隔符"

msgid "units"
msgstr "个位"

msgid "the target vertex"
msgstr "目标顶点"

msgid "In this image,"
msgstr "在这张图片中，"

msgid "Single or double head arrows represent one edge (row) on the edges table."
msgstr "单向或双向箭头表示边表中的一条边（行）。"

msgid "The numbers in the yellow shadow are the edge identifiers."
msgstr "黄色阴影中的数字是边缘标识符。"

msgid "Two pair of edges share the same identifier when the ``reverse_cost`` column is used."
msgstr "当使用 ``reverse_cost`` 列时，两个边对会共享相同的标识符。"

msgid "Edges :math:`{2 \\rightarrow 3, 3 \\rightarrow 2}` are represented with one edge row with :math:`id=203`."
msgstr "边 :math:`{2 \\rightarrow 3, 3 \\rightarrow 2}` 用一条边行表示，标识符其 :math:`id=203` 。"

msgid "Edges :math:`{3 \\rightarrow 4, 4 \\rightarrow 3}` are represented with one edge row with :math:`id=304`."
msgstr "边 :math:`{3 \\rightarrow 4, 4 \\rightarrow 3}` 用一条边的行表示，标识符为 :math:`id=304` 。"

msgid "The graph can be created as follows:"
msgstr "图表的创建过程如下："

msgid "Line Graph of a directed graph represented with shared edges"
msgstr "用共享边表示的有向图的线图"

msgid "The result is a directed graph."
msgstr "结果就是一个有向图。"

msgid "For :math:`seq=4` from :math:`203 \\leftrightarrow 304` represent two edges"
msgstr "对于 :math:`seq=4` ，从:math:`203 \\leftrightarrow 304` 表示两条边"

msgid "For all the other values of ``seq`` represent one edge."
msgstr "所有其他的 ``seq`` 值都代表一条边。"

msgid "The ``cost`` and ``reverse_cost`` values represent the existence of the edge."
msgstr "``cost`` 和 ``reverse_cost`` 的值表示边的存在。"

msgid "When positive: the edge exists."
msgstr "当为正数时：边缘存在。"

msgid "When negative: the edge does not exist."
msgstr "负数时：边缘不存在。"

msgid "Representation as directed with unique edge identifiers"
msgstr "作为有向图表示，并使用唯一的边标识符"

msgid "Single head arrows represent one edge (row) on the edges table."
msgstr "单头箭头代表边表中的一条边（行）。"

msgid "There are no double head arrows"
msgstr "没有双向头箭"

msgid "Two pair of edges share the same ending nodes and the ``reverse_cost`` column is not used."
msgstr "两对边共享相同的结束节点，不使用 ``reverse_cost`` 列。"

msgid "Edges :math:`{2 \\rightarrow 3, 3 \\rightarrow 2}` are represented with two edges :math:`id=203` and :math:`id=302` respectively."
msgstr "边 :math:`{2 \\rightarrow 3, 3 \\rightarrow 2}`分别用两条边表示，边标识符为 :math:`id=203` 和:math:`id=302` 。"

msgid "Edges :math:`{3 \\rightarrow 4, 4 \\rightarrow 3}` are represented with two edges :math:`id=304` and :math:`id=403` respectively."
msgstr "边 :math:`{3 \\rightarrow 4, 4 \\rightarrow 3}`分别用两条边表示，边标识符为 :math:`id=304` 和 :math:`id=403` 。"

msgid "Line Graph of a directed graph represented with unique edges"
msgstr "用唯一边表示的有向图的线图"

msgid "For :math:`seq=7` from :math:`203 \\leftrightarrow 302` represent two edges."
msgstr "对于 :math:`seq=7` 从 :math:`203 \\leftrightarrow 302` 代表两条边。"

msgid "For :math:`seq=8` from :math:`304 \\leftrightarrow 403` represent two edges."
msgstr "对于 :math:`seq=8` ，从 :math:`304 \\leftrightarrow 403` 表示两条边。"

msgid "wikipedia: `Line Graph <https://en.wikipedia.org/wiki/Line_graph>`__"
msgstr "维基百科: `Line Graph <https://en.wikipedia.org/wiki/Line_graph>`__"

msgid "mathworld: `Line Graph <https://mathworld.wolfram.com/LineGraph.html>`__"
msgstr "MathWorld在线数学资源: `Line Graph <https://mathworld.wolfram.com/LineGraph.html>`__"

msgid "``pgr_lineGraphFull`` - Experimental"
msgstr "``pgr_lineGraphFull`` - 实验性"

msgid "``pgr_lineGraphFull`` — Transforms a given graph into a new graph where all of the vertices from the original graph are converted to line graphs."
msgstr "``pgr_lineGraphFull`` — 将给定图转换为新图，其中原始图的所有顶点都转换为线图。"

msgid "Version 2.6.0"
msgstr "版本2.6.0"

msgid "``pgr_lineGraphFull``, converts original directed graph to a directed line graph by converting each vertex to a complete graph and keeping all the original edges. The new connecting edges have a cost 0 and go between the adjacent original edges, respecting the directionality."
msgstr "``pgr_lineGraphFull``, 通过将每个顶点转换为完全图并保留所有原始边，将原始有向图转换为有向线图。 新的连接边的成本为 0，并位于相邻的原始边之间，尊重方向性。"

msgid "A possible application of the resulting graph is **\"routing with two edge restrictions\"**:"
msgstr "结果图的一个可能的应用是 **\"具有两个边限制的路由\"**："

msgid "Setting a cost of using the vertex when routing between edges on the connecting edge"
msgstr "设置在连接边上的边之间布线时使用顶点的成本"

msgid "Forbid the routing between two edges by removing the connecting edge"
msgstr "通过删除连接边来禁止两条边之间的布线"

msgid "This is possible because each of the intersections (vertices) in the original graph are now complete graphs that have a new edge for each possible turn across that intersection."
msgstr "这是可能的，因为原始图中的每个交叉点（顶点）现在都是完整的图，对于穿过该交叉点的每个可能的转弯都有一条新边。"

msgid "This function is for **directed** graphs."
msgstr "该函数适用于 **有向** 图。"

msgid "Results are undefined when a negative vertex id is used in the input graph."
msgstr "当输入图中使用负顶点 id 时，结果是不确定的。"

msgid "Results are undefined when a duplicated edge id is used in the input graph."
msgstr "当输入图中使用重复的边 id 时，结果是不确定的。"

msgid "Running time: TBD"
msgstr "运行时间：TBD（待定）"

msgid "pgr_lineGraphFull(`Edges SQL`_)"
msgstr "pgr_lineGraphFull(`Edges SQL`_)"

msgid "Returns set of |result-linegf|"
msgstr "返回 |result-linegf| 的集合"

msgid "Full line graph of subgraph of edges :math:`\\{4, 7, 8, 10\\}`"
msgstr "边 :math:`\\{4, 7, 8, 10\\}` 子图的全线图"

msgid "The examples include the subgraph including edges 4, 7, 8, and 10 with ``reverse_cost``."
msgstr "示例包含边线 4、7、8 和 10 构成的子图，且包含 ``reverse_cost`` 。"

msgid "The data"
msgstr "数据"

msgid "This example displays how this graph transformation works to create additional edges for each possible turn in a graph."
msgstr "此示例显示此图形转换如何为图形中的每个可能的转弯创建附加边。"

msgid "|first|"
msgstr "|first|"

msgid "first"
msgstr "首先"

msgid "The transformation"
msgstr "转变"

msgid "|second|"
msgstr "|second|"

msgid "second"
msgstr "第二"

msgid "In the transformed graph, all of the edges from the original graph are still present (yellow), but we now have additional edges for every turn that could be made across vertex 7 (orange)."
msgstr "在转换后的图中，原始图中的所有边仍然存在（黄色），但现在我们为跨顶点 7 的每个转弯提供了额外的边（橙色）。"

msgid "Creating table that identifies transformed vertices"
msgstr "创建标识变换顶点的表"

msgid "The vertices in the transformed graph are each created by splitting up the vertices in the original graph. Unless a vertex in the original graph is a leaf vertex, it will generate more than one vertex in the transformed graph. One of the newly created vertices in the transformed graph will be given the same vertex identifier as the vertex that it was created from in the original graph, but the rest of the newly created vertices will have negative vertex ids."
msgstr "变换后的图中的每个顶点都是通过分割原始图中的顶点而创建的。 除非原始图中的某个顶点是叶顶点，否则它将在变换后的图中生成多个顶点。 转换后的图中新创建的顶点之一将被赋予与原始图中创建它的顶点相同的顶点标识符，但新创建的其余顶点将具有负顶点 id。"

msgid "Following is an example of how to generate a table that maps the ids of the newly created vertices with the original vertex that they were created from"
msgstr "以下是如何生成一个表的示例，该表将新创建的顶点的 id 与创建它们的原始顶点进行映射"

msgid "Store edge results"
msgstr "存储边结果"

msgid "The first step is to store the results of the ``pgr_lineGraphFull`` call into a table"
msgstr "第一步是将 ``pgr_lineGraphFull`` 调用的结果存储到表中"

msgid "Create the mapping table"
msgstr "创建映射表"

msgid "From the original graph's vertex information"
msgstr "从原始图的顶点信息"

msgid "Add the new vertices"
msgstr "增加新的顶点"

msgid "Filling the mapping table"
msgstr "填写映射表"

msgid "The positive vertex identifiers are the original identifiers"
msgstr "正的顶点标识符是原始标识符"

msgid "Inspecting the vertices map"
msgstr "检查顶点图"

msgid "The self loops happen when there is no cost traveling to the ``target`` and the source has an original value."
msgstr "当从源点到 ``target`` 没有旅行成本，并且源点具有原始值时，会出现自环。"

msgid "Updating values from self loops"
msgstr "从自循环更新值"

msgid "Inspecting the vertices table"
msgstr "检查顶点表"

msgid "Updating from inner self loops"
msgstr "从内部自我循环更新"

msgid "Adding a soft restriction"
msgstr "添加软限制"

msgid "A soft restriction going from vertex 6 to vertex 3 using edges 4 -> 7 is wanted."
msgstr "需要使用边 4 -> 7 从顶点 6 到顶点 3 的软限制。"

msgid "Identifying the restriction"
msgstr "识别限制条件"

msgid "Running a :doc:`pgr_dijkstraNear` the edge with cost 0, edge 8, is where the cost will be increased"
msgstr "运行 :doc:`pgr_dijkstraNear` 时，成本将会增加的地方是边 8，其成本为 0"

msgid "The edge to be altered is ``WHERE cost = 0 AND seq != 1 AND edge != -1`` from the previous query:"
msgstr "要更改的边是上一个查询中的 ``WHERE cost = 0 AND seq != 1 AND edge != -1`` ："

msgid "Adding a value to the restriction"
msgstr "向限制添加值"

msgid "Updating the cost to the edge:"
msgstr "将成本更新到边："

msgid "Routing from :math:`6` to :math:`3`"
msgstr "路由从 :math:`6` 到 :math:`3`"

msgid "Now the route does not use edge 8 and does a U turn on a leaf vertex."
msgstr "现在，该路线不使用边 8，而是在叶顶点上进行 U 形转弯。"

msgid "Simplifying leaf vertices"
msgstr "简化叶顶点"

msgid "In this example, there is no additional cost for traversing a leaf vertex."
msgstr "在这个例子中，遍历叶顶点没有额外的成本。"

msgid "Using the vertex map give the leaf verices their original value."
msgstr "使用顶点图赋予叶顶点其原始值。"

msgid "On the source column"
msgstr "在source 列"

msgid "On the target column"
msgstr "在target列"

msgid "Removing self loops on leaf nodes"
msgstr "删除叶节点上的自循环"

msgid "The self loops of the leaf nodes are"
msgstr "叶节点的自循环为"

msgid "Which can be removed"
msgstr "哪些可以删除"

msgid "Routing can be done now using the original vertices id using :doc:`pgr_dijkstra`"
msgstr "现在可以使用 :doc:`pgr_dijkstra` 使用原始顶点 id 来完成路由"

msgid "Complete routing graph"
msgstr "完整的路由图"

msgid "Add edges from the original graph"
msgstr "从原始图中添加边"

msgid "Add all the edges that are not involved in the line graph process to the new table"
msgstr "将所有不参与折线图过程的边添加到新表中"

msgid "Some administrative tasks to get new identifiers for the edges"
msgstr "一些获取边新标识符的管理任务"

msgid "Add the newly calculated edges"
msgstr "添加新计算的边"

msgid "Using the routing graph"
msgstr "使用路由图"

msgid "When using this method for routing with soft restrictions there will be uturns"
msgstr "当使用这种方法进行具有软限制的路由时，将会出现 uturn"

msgid "Routing from :math:`5` to :math:`1`"
msgstr "路由从 :math:`5` 到 :math:`1`"

msgid "https://en.wikipedia.org/wiki/Line_graph"
msgstr "https://en.wikipedia.org/wiki/Line_graph"

msgid "https://en.wikipedia.org/wiki/Complete_graph"
msgstr "https://en.wikipedia.org/wiki/Complete_graph"

msgid "``pgr_makeConnected`` - Experimental"
msgstr "``pgr_makeConnected`` - 实验性"

msgid "``pgr_makeConnected`` — Set of edges that will connect the graph."
msgstr "``pgr_makeConnected`` — 连接图的边集。"

msgid "Adds the minimum number of edges needed to make the input graph connected. The algorithm first identifies all of the connected components in the graph, then adds edges to connect those components together in a path. For example, if a graph contains three connected components A, B, and C, make_connected will add two edges. The two edges added might consist of one connecting a vertex in A with a vertex in B and one connecting a vertex in B with a vertex in C."
msgstr "添加使输入图连接所需的最小边数。 该算法首先识别图中的所有连接组件，然后添加边以将这些组件在路径中连接在一起。 例如，如果一个图包含三个连通分量 A、B 和 C，则 make_connected 将添加两条边。 添加的两条边可能包括一条连接 A 中的顶点与 B 中的顶点的边，以及一条连接 B 中的顶点与 C 中的顶点的边。"

msgid "It will give a minimum list of all edges which are needed in the graph to make connect it."
msgstr "它将给出图中连接它所需的所有边的最小列表。"

msgid "The algorithm does not considers geometric topology in the calculations."
msgstr "该算法在计算中不考虑遍历成本。"

msgid "pgr_makeConnected(`Edges SQL`_)"
msgstr "pgr_makeConnected(`Edges SQL`_)"

msgid "Returns set of |result-component-make|"
msgstr "返回结果 |result-component-make|"

msgid "List of edges that are needed to connect the graph."
msgstr "连接图形所需的边线列表。"

msgid "`Boost: make connected <https://www.boost.org/libs/graph/doc/make_connected.html>`__"
msgstr "`Boost: 使图连通 <https://www.boost.org/libs/graph/doc/make_connected.html>`__"

msgid "``pgr_maxCardinalityMatch``"
msgstr "``pgr_maxCardinalityMatch``"

msgid "``pgr_maxCardinalityMatch`` — Calculates a maximum cardinality matching in a graph."
msgstr "``pgr_maxCardinalityMatch`` — 计算图中的最大基数匹配。."

msgid "pgr_maxCardinalityMatch(text) returns only ``edge`` column."
msgstr "pgr_maxCardinalityMatch(text) 只返回 ``edge`` 列。"

msgid "Deprecated signature"
msgstr "已弃用的签名"

msgid "directed => ``false`` when used."
msgstr "使用时 directed => ``false`` 。"

msgid "Renamed from ``pgr_maximumCardinalityMatching``"
msgstr "从 ``pgr_maximumCardinalityMatching`` 重命名"

msgid "A matching or independent edge set in a graph is a set of edges without common vertices."
msgstr "图中的匹配或独立边集是一组没有公共顶点的边。"

msgid "A maximum matching is a matching that contains the largest possible number of edges."
msgstr "最大匹配是包含尽可能多的边的匹配。"

msgid "There may be many maximum matchings."
msgstr "可能有很多最大匹配。"

msgid "Calculates one possible maximum cardinality matching in a graph."
msgstr "计算图中一种可能的最大基数匹配。"

msgid "Running time: :math:`O( E*V * \\alpha(E,V))`"
msgstr "运行时间： :math:`O( E*V * \\alpha(E,V))`"

msgid ":math:`\\alpha(E,V)` is the inverse of the `Ackermann function`_."
msgstr ":math:`\\alpha(E,V)` 与 `Ackermann function`_ 相反。"

msgid "pgr_maxCardinalityMatch(`Edges SQL`_)"
msgstr "pgr_maxCardinalityMatch(`Edges SQL`_)"

msgid "Using all edges."
msgstr "使用所有边。"

msgid "SQL query, which should return a set of rows with the following columns:"
msgstr "SQL 查询，应返回一组包含以下列的行："

msgid "A positive value represents the existence of the edge (``source``, ``target``)."
msgstr "正值表示存在边 (``source``, ``target``) 。"

msgid "A positive value represents the existence of the edge (``target``, ``source``)"
msgstr "正值表示存在边 (``target``, ``source``)"

msgid "Identifier of the edge in the original query."
msgstr "原始查询中边的标识符。"

msgid "`Boost: maximum_matching <https://www.boost.org/libs/graph/doc/maximum_matching.html>`__"
msgstr "`Boost: 最大匹配 <https://www.boost.org/libs/graph/doc/maximum_matching.html>`__"

msgid "https://en.wikipedia.org/wiki/Matching_%28graph_theory%29"
msgstr "https://en.wikipedia.org/wiki/Matching_%28graph_theory%29"

msgid "https://en.wikipedia.org/wiki/Ackermann_function"
msgstr "https://en.wikipedia.org/wiki/Ackermann_function"

msgid "``pgr_maxFlow``"
msgstr "``pgr_maxFlow``"

msgid "``pgr_maxFlow`` — Calculates the maximum flow in a directed graph from the source(s) to the targets(s) using the Push Relabel algorithm."
msgstr "``pgr_maxFlow`` — 使用 Push Relabel 算法计算有向图中从源到目标的最大流量。"

msgid "pgr_maxFlow(Combinations)"
msgstr "pgr_maxFlow(组合)"

msgid "Calculates the maximum flow from the sources to the targets."
msgstr "计算从源头到目标的最大流量。"

msgid "When the maximum flow is **0** then there is no flow and **0** is returned."
msgstr "当最大流量为 **0** 时则没有流量，返回 **0** 。"

msgid "Uses the :doc:`pgr_pushRelabel <pgr_pushRelabel>` algorithm."
msgstr "使用 :doc:`pgr_pushRelabel <pgr_pushRelabel>` 算法。"

msgid "Running time: :math:`O( V ^ 3)`"
msgstr "运行时间： :math:`O( V ^ 3)`"

msgid "pgr_maxFlow(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_maxFlow(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_maxFlow(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_maxFlow(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_maxFlow(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_maxFlow(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_maxFlow(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_maxFlow(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_maxFlow(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_maxFlow(`Edges SQL`_, `Combinations SQL`_)"

msgid "RETURNS ``BIGINT``"
msgstr "返回 ``BIGINT``"

msgid "Maximum flow possible from the source(s) to the target(s)"
msgstr "从 source(s)到 target(s)的可能最大流量"

msgid "`Boost: push relabel max flow <https://www.boost.org/libs/graph/doc/push_relabel_max_flow.html>`__"
msgstr "`Boost: 推-重标最大流算法 <https://www.boost.org/libs/graph/doc/push_relabel_max_flow.html>`__"

msgid "https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm"
msgstr "https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm"

msgid "``pgr_maxFlowMinCost`` - Experimental"
msgstr "``pgr_maxFlowMinCost`` - 实验性"

msgid "``pgr_maxFlowMinCost`` — Calculates the edges that minimizes the total cost of the maximum flow on a graph"
msgstr "``pgr_maxFlowMinCost`` — 计算图上最大流的总成本最小化的边"

msgid "pgr_maxFlowMinCost(Combinations)"
msgstr "pgr_maxFlowMinCost(组合)"

#, fuzzy
msgid "|Boost| Boost Graph Inside."
msgstr "|Boost| Boost 图内部"

msgid "**TODO** check which statement is true:"
msgstr "**TODO** 检查哪个陈述是正确的："

msgid "The cost value of all input edges must be nonnegative."
msgstr "所有输入边的成本值必须是非负的。"

msgid "Process is done when the cost value of all input edges is nonnegative."
msgstr "当所有输入边的成本值为非负时，处理完成。"

msgid "Process is done on edges with nonnegative cost."
msgstr "过程是在具有非负成本的边上完成的。"

msgid "Running time: :math:`O(U * (E + V * logV))`"
msgstr "运行时间： :math:`O(U * (E + V * logV))`"

msgid "where :math:`U` is the value of the max flow."
msgstr "其中 :math:`U` 是最大流量的值。"

msgid ":math:`U` is upper bound on number of iterations. In many real world cases number of iterations is much smaller than :math:`U`."
msgstr ":math:`U`是迭代次数的上限。 在许多现实世界的情况下，迭代次数远小于 :math:`U` 。"

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_maxFlowMinCost(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_maxFlowMinCost(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_maxFlowMinCost(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_maxFlowMinCost(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_maxFlowMinCost(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_maxFlowMinCost(`Edges SQL`_, `Combinations SQL`_)"

msgid "Returns set of |result-flow-mincost|"
msgstr "返回 |result-flow-mincost| 的集合"

msgid "``pgr_maxFlowMinCost_Cost`` - Experimental"
msgstr "``pgr_maxFlowMinCost_Cost`` - 实验性"

msgid "``pgr_maxFlowMinCost_Cost`` — Calculates the minimum total cost of the maximum flow on a graph"
msgstr "``pgr_maxFlowMinCost_Cost`` — 计算图上最大流量的最小总成本"

msgid "pgr_maxFlowMinCost_Cost(Combinations)"
msgstr "pgr_maxFlowMinCost_Cost(组合)"

msgid "**The cost value of all input edges must be nonnegative.**"
msgstr "**所有输入边的成本值必须是非负的。**"

msgid "When the maximum flow is 0 then there is no flow and **0** is returned."
msgstr "当最大流量为0时则没有流量，返回 **0** 。"

msgid "Uses :doc:`pgr_maxFlowMinCost`."
msgstr "使用 :doc:`pgr_maxFlowMinCost`。"

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_maxFlowMinCost_Cost(`Edges SQL`_, `Combinations SQL`_)"

msgid "RETURNS FLOAT"
msgstr "RETURNS FLOAT"

msgid "Minimum Cost Maximum Flow possible from the source(s) to the target(s)"
msgstr "从source(s) 到target(s)的最小成本最大流量"

msgid "``pgr_pickDeliver`` - Experimental"
msgstr "``pgr_pickDeliver`` - 实验性"

msgid "``pgr_pickDeliver`` - Pickup and delivery Vehicle Routing Problem"
msgstr "``pgr_pickDeliver`` - 接送车辆路径问题"

msgid "Problem: Distribute and optimize the pickup-delivery pairs into a fleet of vehicles."
msgstr "问题：将取货-送货对分配并优化到车队中。"

msgid "Optimization problem is NP-hard."
msgstr "优化问题是NP-hard。"

msgid "pickup and Delivery with time windows."
msgstr "有时间窗口的取货和送货。"

msgid "All vehicles are equal."
msgstr "所有车辆都是平等的。"

msgid "Same Starting location."
msgstr "相同的起始位置。"

msgid "Same Ending location which is the same as Starting location."
msgstr "相同的结束位置与开始位置相同。"

msgid "All vehicles travel at the same speed."
msgstr "所有车辆以相同的速度行驶。"

msgid "A customer is for doing a pickup or doing a deliver."
msgstr "客户负责提货或送货。"

msgid "has an open time."
msgstr "有开放时间。"

msgid "has a closing time."
msgstr "有关闭时间。"

msgid "has a service time."
msgstr "有服务时间。"

msgid "has an (x, y) location."
msgstr "具有 (x, y) 位置。"

msgid "There is a customer where to deliver a pickup."
msgstr "有客户需要送货。"

msgid "travel time between customers is distance / speed"
msgstr "客户之间的旅行时间是距离/速度"

msgid "pickup and delivery pair is done with the same vehicle."
msgstr "取货和送货是使用同一辆车完成的。"

msgid "All trucks depart at time 0."
msgstr "所有卡车均在时间 0 出发。"

msgid "the algorithm will raise an exception when"
msgstr "该算法将在以下情况下引发异常"

msgid "If there is a pickup-deliver pair than violates time window"
msgstr "如果存在违反时间窗口的取货-送货对"

msgid "The speed, max_cycles, ma_capacity have illegal values"
msgstr "speed、max_cycles、ma_capacity 具有非法值"

msgid "Six different initial will be optimized - the best solution found will be result"
msgstr "将优化六个不同的初始值 - 找到的最佳解决方案将是结果"

msgid "Signature"
msgstr "标识"

msgid "pgr_pickDeliver(`Orders SQL`_, `Vehicles SQL`_, `Matrix SQL`_, [**options**])"
msgstr "pgr_pickDeliver(`Orders SQL`_, `Vehicles SQL`_, `Matrix SQL`_, [**options**])"

msgid "**options:** ``[factor, max_cycles, initial_sol]``"
msgstr "**options:** ``[factor, max_cycles, initial_sol]``"

msgid "Returns set of |result-pickdrop|"
msgstr "返回 |result-pickdrop| 的集合"

msgid "Solve the following problem"
msgstr "解决以下问题"

msgid "Given the vehicles:"
msgstr "给定车辆："

msgid "and the orders:"
msgstr "和顺序："

msgid "The parameters are:"
msgstr "参数是："

msgid "A `SELECT` statement that returns the following columns:"
msgstr "返回以下列的 `SELECT` 语句："

msgid "id, demand"
msgstr "id, demand"

msgid "p_node_id, p_open, p_close, [p_service,]"
msgstr "p_node_id, p_open, p_close, [p_service,]"

msgid "d_node_id, d_open, d_close, [d_service,]"
msgstr "d_node_id, d_open, d_close, [d_service,]"

msgid "id, capacity"
msgstr "id, capacity"

msgid "start_node_id, start_open, start_close [, start_service,]"
msgstr "start_node_id, start_open, start_close [, start_service,]"

msgid "[end_node_id, end_open, end_close, end_service]"
msgstr "[end_node_id, end_open, end_close, end_service]"

msgid "``pgr_pickDeliverEuclidean`` - Experimental"
msgstr "``pgr_pickDeliverEuclidean`` - 实验性"

msgid "``pgr_pickDeliverEuclidean`` - Pickup and delivery Vehicle Routing Problem"
msgstr "``pgr_pickDeliverEuclidean`` - 取货和送货车辆路径问题"

msgid "Replaces ``pgr_gsoc_vrppdtw``"
msgstr "替换 ``pgr_gsoc_vrppdtw``"

msgid "Pickup and Delivery:"
msgstr "取货和送货："

msgid "capacitated"
msgstr "带容量限制的"

msgid "with time windows."
msgstr "有时间窗口的。"

msgid "have (x, y) start and ending locations."
msgstr "有 (x, y) 开始和结束位置。"

msgid "have a start and ending service times."
msgstr "有开始和结束服务时间。"

msgid "An order is for doing a pickup and a a deliver."
msgstr "订单用于取货和送货。"

msgid "has (x, y) pickup and delivery locations."
msgstr "有 (x, y) 个取货和送货地点。"

msgid "has opening and closing times for the pickup and delivery locations."
msgstr "有提货和送货地点的开放和关闭时间。"

msgid "has a pickup and deliver service times."
msgstr "有取货和送货服务时间。"

msgid "Six different optional different initial solutions"
msgstr "六种不同的可选不同初始解决方案"

msgid "the best solution found will be result"
msgstr "找到的最佳解决方案将作为结果"

msgid "pgr_pickDeliverEuclidean(`Orders SQL`_, `Vehicles SQL`_, [**options**])"
msgstr "pgr_pickDeliverEuclidean(`Orders SQL`_, `Vehicles SQL`_, [**options**])"

msgid "p_x, p_y, p_open, p_close, [p_service,]"
msgstr "p_x, p_y, p_open, p_close, [p_service,]"

msgid "d_x, d_y, d_open, d_close, [d_service]"
msgstr "d_x, d_y, d_open, d_close, [d_service]"

msgid "start_x, start_y, start_open, start_close [, start_service, ]"
msgstr "start_x, start_y, start_open, start_close [, start_service, ]"

msgid "[ end_x, end_y, end_open, end_close, end_service ]"
msgstr "[ end_x, end_y, end_open, end_close, end_service ]"

msgid "This data example **lc101** is from data published at https://www.sintef.no/projectweb/top/pdptw/li-lim-benchmark/"
msgstr "此数据示例 **lc101** 来自 https://www.sintef.no/projectweb/top/pdptw/li-lim-benchmark/ 上发布的数据"

msgid "There are 25 vehicles in the problem all with the same characteristics."
msgstr "问题中有 25 辆具有相同特征的汽车。"

msgid "The original orders"
msgstr "原始订单"

msgid "The data comes in different rows for the pickup and the delivery of the same order."
msgstr "对于同一订单的取货和配送，数据位于不同的行中。"

msgid "The original data needs to be converted to an appropriate table:"
msgstr "需要将原始数据转换为适当的表格："

msgid "The query"
msgstr "查询"

msgid "Showing only the relevant information to compare with the best solution information published on https://www.sintef.no/projectweb/top/pdptw/100-customers/"
msgstr "仅显示相关信息，以便与 https://www.sintef.no/projectweb/top/pdptw/100-customers/ 上发布的最佳解决方案信息进行比较"

msgid "The best solution found for **lc101** is a travel time: 828.94"
msgstr "找到的 **lc101** 的最佳解是行程时间：828.94"

msgid "This implementation's travel time: 854.54"
msgstr "此实施的行程时间：854.54"

msgid "``pgr_prim``"
msgstr "``pgr_prim``"

msgid "``pgr_prim`` — Minimum spanning forest of a graph using Prim's algorithm."
msgstr "``pgr_prim`` — 使用 Prim 算法的图的最小生成森林。"

msgid "This algorithm finds the minimum spanning forest in a possibly disconnected graph using Prim's algorithm."
msgstr "该算法使用 Prim 算法在可能断开的图中找到最小生成森林。"

msgid "Prim's running time: :math:`O(E * log V)`"
msgstr "Prim运行时间： :math:`O(E * log V)`"

msgid "pgr_prim(`Edges SQL`_)"
msgstr "pgr_prim(`Edges SQL`_)"

msgid "Minimum spanning forest of a subgraph"
msgstr "子图的最小生成森林"

msgid "`Boost: Prim's algorithm documentation <https://www.boost.org/libs/graph/doc/prim_minimum_spanning_tree.html>`__"
msgstr "`Boost: Prim算法文档 <https://www.boost.org/libs/graph/doc/prim_minimum_spanning_tree.html>`__"

msgid "``pgr_primBFS`` — Prim's algorithm for Minimum Spanning Tree with Depth First Search ordering."
msgstr "``pgr_primBFS`` — Prim 的深度优先搜索排序最小生成树算法。"

msgid "Visits and extracts the nodes information in Breath First Search ordering of the Minimum Spanning Tree created using Prims's algorithm."
msgstr "访问并提取使用 Prims 算法创建的最小生成树的 Breath First Search 排序中的节点信息。"

msgid "pgr_primBFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr "pgr_primBFS(`Edges SQL`_, **root vid**, [``max_depth``])"

msgid "pgr_primBFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr "pgr_primBFS(`Edges SQL`_, **root vids**, [``max_depth``])"

msgid "``pgr_primDD`` — Catchament nodes using Prim's algorithm."
msgstr "``pgr_primDD`` — 使用 Prim 算法的集水区节点。"

msgid "Using Prim's algorithm, extracts the nodes that have aggregate costs less than or equal to a distance from a root vertex (or vertices) within the calculated minimum spanning tree."
msgstr "使用 Prim 算法，从计算出最小生成树中提取出那些与根节点（或根节点组）之间的聚合成本小于或等于某个距离的节点。"

msgid "pgr_primDD(`Edges SQL`_, **root vid**, **distance**)"
msgstr "pgr_primDD(`Edges SQL`_, **root vid**, **distance**)"

msgid "pgr_primDD(`Edges SQL`_, **root vids**, **distance**)"
msgstr "pgr_primDD(`Edges SQL`_, **root vids**, **distance**)"

msgid "``pgr_primDFS`` — Prim algorithm for Minimum Spanning Tree with Depth First Search ordering."
msgstr "``pgr_primDFS`` — 具有深度优先搜索排序的最小生成树的 Prim 算法。"

msgid "Visits and extracts the nodes information in Depth First Search ordering of the Minimum Spanning Tree created using Prims's algorithm."
msgstr "访问并提取使用 Prims 算法创建的最小生成树的深度优先搜索顺序中的节点信息。"

msgid "pgr_primDFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr "pgr_primDFS(`Edges SQL`_, **root vid**, [``max_depth``])"

msgid "pgr_primDFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr "pgr_primDFS(`Edges SQL`_, **root vids**, [``max_depth``])"

msgid "``pgr_pushRelabel``"
msgstr "``pgr_pushRelabel``"

msgid "``pgr_pushRelabel`` — Calculates the flow on the graph edges that maximizes the flow from the sources to the targets using Push Relabel Algorithm."
msgstr "``pgr_pushRelabel`` — 使用 Push Relabel 算法计算图边上的流量，以最大化从源到目标的流量。"

msgid "pgr_pushRelabel(Combinations)"
msgstr "pgr_pushRelabel(组合)"

msgid "Renamed from ``pgr_maxFlowPushRelabel``"
msgstr "由 ``pgr_maxFlowPushRelabel`` 重命名"

msgid "pgr_pushRelabel(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_pushRelabel(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_pushRelabel(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_pushRelabel(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_pushRelabel(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_pushRelabel(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_pushRelabel(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_pushRelabel(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_pushRelabel(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_pushRelabel(`Edges SQL`_, `Combinations SQL`_)"

msgid "``pgr_separateCrossing``"
msgstr "``pgr_separateCrossing``"

msgid "``pgr_separateCrossing`` - From crossing geometries generates geometries that do not cross."
msgstr "``pgr_separateCrossing`` - 从交叉几何图形生成不交叉的几何图形。"

msgid "Proposed function."
msgstr "提议的函数。"

msgid "This is an auxiliary function for separating crossing edges."
msgstr "这是一个用于分离交叉边线的辅助函数。"

msgid "pgr_separateCrossing(`Edges SQL`_, [``tolerance``, ``dryrun``])"
msgstr "pgr_separateCrossing(`Edges SQL`_, [``tolerance``, ``dryrun``])"

msgid "RETURNS |result-separate|"
msgstr "返回 |result-separate|"

msgid "Get the segments of the crossing geometries"
msgstr "获取交叉点几何形状的线段"

msgid "``tolerance``"
msgstr "``tolerance``"

msgid "0.01"
msgstr "0.01"

msgid "Used in ST_Snap before ST_Split"
msgstr "在 ST_Split 前使用 ST_Snap"

msgid "Get the code for further refinement."
msgstr "获取进一步完善的代码。"

msgid "When there are special details that need to be taken care of because of the final application or the quality of the data, the code can be obtained On a PostgreSQL ``NOTICE`` using the ``dryrun`` flag."
msgstr "当由于最终应用或数据质量需要特别处理时，可以通过在 PostgreSQL 中使用 ``NOTICE`` 和 ``dryrun`` 标志来获取代码。"

msgid "``pgr_separateTouching``"
msgstr "``pgr_separateTouching``"

msgid "``pgr_separateTouching`` - From touching geometries generates geometries that are properly connected at endpoints"
msgstr "``pgr_separateTouching`` - 将相互接触的几何图形转换为端点正确连接的几何图形"

msgid "This is an auxiliary function for processing geometries that touch but don't share exact endpoints, splitting them at their intersection points to improve network connectivity."
msgstr "此辅助函数用于处理几何图形相互接触但未共享端点的情况，通过在相交点处分割图形来增强网络连通性。"

msgid "pgr_separateTouching(`Edges SQL`_, [``tolerance``, ``dryrun``])"
msgstr "pgr_separateTouching(`Edges SQL`_, [``tolerance``, ``dryrun``])"

msgid "``pgr_sequentialVertexColoring`` - Proposed"
msgstr "``pgr_sequentialVertexColoring`` - 提议中"

msgid "``pgr_sequentialVertexColoring`` — Returns the vertex coloring of an undirected graph, using greedy approach."
msgstr "``pgr_sequentialVertexColoring`` — 使用贪婪方法返回无向图的顶点着色。"

msgid "Sequential vertex coloring algorithm is a graph coloring algorithm in which color identifiers are assigned to the vertices of a graph in a sequential manner, such that no edge connects two identically colored vertices."
msgstr "顺序顶点着色算法是一种图着色算法，其中颜色标识符以顺序方式分配给图的顶点，使得没有边连接两个相同颜色的顶点。"

msgid "The implementation is applicable only for **undirected** graphs."
msgstr "该实现仅适用于 **无向** 图。"

msgid "Provides the color to be assigned to all the vertices present in the graph."
msgstr "提供要分配给图中存在的所有顶点的颜色。"

msgid "Color identifiers values are in the Range :math:`[1, |V|]`"
msgstr "颜色标识符值在范围 :math:`[1, |V|]` 内"

msgid "The algorithm tries to assign the least possible color to every vertex."
msgstr "该算法尝试为每个顶点分配尽可能少的颜色。"

msgid "Efficient graph coloring is an NP-Hard problem, and therefore, this algorithm does not always produce optimal coloring. It follows a greedy strategy by iterating through all the vertices sequentially, and assigning the smallest possible color that is not used by its neighbors, to each vertex."
msgstr "高效的图着色是一个 NP 困难问题，因此，该算法并不总是产生最佳着色。 它遵循贪婪策略，依次迭代所有顶点，并将其邻居未使用的最小可能颜色分配给每个顶点。"

msgid "The returned rows are ordered in ascending order of the vertex value."
msgstr "返回的行按顶点值的升序排列。"

msgid "Sequential Vertex Coloring Running Time: :math:`O(|V|*(d + k))`"
msgstr "顺序顶点着色运行时间： :math:`O(|V|*(d + k))`"

msgid ":math:`d` is the maximum degree of the vertices in the graph,"
msgstr ":math:`d` 是图中顶点的最大度数，"

msgid ":math:`k` is the number of colors used."
msgstr ":math:`k` 是使用的颜色数量。"

msgid "pgr_sequentialVertexColoring(`Edges SQL`_)"
msgstr "pgr_sequentialVertexColoring(`Edges SQL`_)"

msgid "`Boost: Sequential Vertex Coloring <https://www.boost.org/libs/graph/doc/sequential_vertex_coloring.html>`__"
msgstr "`Boost: 顺序顶点着色 <https://www.boost.org/libs/graph/doc/sequential_vertex_coloring.html>`__"

#, fuzzy
msgid "``pgr_sloanOrdering`` - Experimental"
msgstr "``pgr_edgeColoring`` - 实验性"

#, fuzzy
msgid "``pgr_sloanOrdering`` — Returns the Sloan ordering of an undirected graph"
msgstr "``pgr_cuthillMckeeOrdering`` — 返回无向图的反向 Cuthill-Mckee 排序"

msgid "The Sloan ordering algorithm reorders the vertices of a graph to reduce bandwidth, profile, and wavefront properties, which is particularly useful for sparse matrix computations and finite element analysis."
msgstr ""

msgid "Finds a pseudoperipheral vertex pair to determine good starting points"
msgstr ""

msgid "Uses a priority-based algorithm that balances vertex degree and distance from the start vertex."
msgstr ""

msgid "Aims to minimize bandwidth (maximum difference between connected vertex indices."
msgstr ""

msgid "Typically produces better orderings than simple breadth-first approaches."
msgstr ""

msgid "Time complexity: :math:`O(V² + E)` where V is the number of vertices and E is the number of edges."
msgstr ""

#, fuzzy
msgid "pgr_sloanOrdering(`Edges SQL`_)"
msgstr "pgr_edgeColoring(`Edges SQL`_)"

msgid ":Example : Sloan ordering without specifying start vertex"
msgstr ""

#, fuzzy
msgid "New sloan ordering order."
msgstr "新的逆序排列。"

msgid "Sloan ordering of Original graph from Boost example (vertices 0-9)."
msgstr ""

#, fuzzy
msgid "`Boost: Sloan Ordering <https://www.boost.org/doc/libs/latest/libs/graph/doc/sloan_ordering.htm>`__"
msgstr "`Boost: 边着色 <https://www.boost.org/libs/graph/doc/edge_coloring.html>`__"

msgid "``pgr_stoerWagner`` - Experimental"
msgstr "``pgr_stoerWagner`` - 实验性"

msgid "``pgr_stoerWagner`` — The min-cut of graph using stoerWagner algorithm."
msgstr "``pgr_stoerWagner`` — 使用 stoerWagner 算法对图进行最小分割。"

msgid "Version 3.0"
msgstr "版本3.0"

msgid "In graph theory, the Stoer–Wagner algorithm is a recursive algorithm to solve the minimum cut problem in undirected weighted graphs with non-negative weights. The essential idea of this algorithm is to shrink the graph by merging the most intensive vertices, until the graph only contains two combined vertex sets. At each phase, the algorithm finds the minimum s-t cut for two vertices s and t chosen as its will. Then the algorithm shrinks the edge between s and t to search for non s-t cuts. The minimum cut found in all phases will be the minimum weighted cut of the graph."
msgstr "在图论中，Stoer-Wagner 算法是一种递归算法，用于解决具有非负权重的无向带权图中的最小割问题。 该算法的基本思想是通过合并最密集的顶点来收缩图，直到图仅包含两个组合的顶点集。 在每个阶段，算法都会找到任意选择的两个顶点 s 和 t 的最小 s-t 割。 然后算法缩小 s 和 t 之间的缘以搜索非 s-t 切割。 在所有阶段中找到的最小割将是图的最小加权割。"

msgid "A cut is a partition of the vertices of a graph into two disjoint subsets. A minimum cut is a cut for which the size or weight of the cut is not larger than the size of any other cut. For an unweighted graph, the minimum cut would simply be the cut with the least edges. For a weighted graph, the sum of all edges' weight on the cut determines whether it is a minimum cut."
msgstr "割是将图的顶点划分为两个不相交的子集。 最小切割是指切割的尺寸或重量不大于任何其他切割的尺寸的切割。 对于未加权的图，最小割只是具有最少边的割。 对于加权图，割线上所有边的权重之和决定了它是否是最小割。"

msgid "Sum of the weights of all edges between the two sets is mincut."
msgstr "两组之间所有边的权重之和是最小割。"

msgid "A **mincut** is a cut having the least weight."
msgstr "**最小切割** 是重量最小的切割。"

msgid "Values are returned when graph is connected."
msgstr "连接图形时返回值。"

msgid "When there is no edge in graph then EMPTY SET is return."
msgstr "当图中没有边时，则返回 EMPTY SET。"

msgid "When the graph is unconnected then EMPTY SET is return."
msgstr "当图形未连接时，则返回 EMPTY SET。"

msgid "Sometimes a graph has multiple min-cuts, but all have the same weight. The this function determines exactly one of the min-cuts as well as its weight."
msgstr "有时一个图有多个最小割，但都具有相同的权重。 该函数准确地确定最小切割之一及其权重。"

msgid "Running time: :math:`O(V*E + V^2*log V)`."
msgstr "运行时间： :math:`O(V*E + V^2*log V)`。"

msgid "pgr_stoerWagner(`Edges SQL`_)"
msgstr "pgr_stoerWagner(`Edges SQL`_)"

msgid "Returns set of |result-mincut|"
msgstr "返回 |result-mincut| 的集合"

msgid "min cut of the main subgraph"
msgstr "主子图的最小割"

msgid "Returns set of ``(seq, edge, cost, mincut)``"
msgstr "返回集合 ``(seq, edge, cost, mincut)``"

msgid "Edges which divides the set of vertices into two."
msgstr "将顶点集一分为二的边。"

msgid "Cost to traverse of edge."
msgstr "遍历边的成本。"

msgid "**mincut**"
msgstr "**mincut**"

msgid "Min-cut weight of a undirected graph."
msgstr "无向图的最小割权。"

msgid "Additional Example:"
msgstr "附加示例："

msgid "min cut of an edge"
msgstr "边的最小割"

msgid "Using :doc:`pgr_connectedComponents`"
msgstr "使用 :doc:`pgr_connectedComponents`"

msgid "`Boost: Stoer Wagner min cut <https://www.boost.org/libs/graph/doc/stoer_wagner_min_cut.html>`__"
msgstr "`Boost: Stoer-Wagner 最小割算法 <https://www.boost.org/libs/graph/doc/stoer_wagner_min_cut.html>`__"

msgid "https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm"
msgstr "https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm"

msgid "``pgr_strongComponents``"
msgstr "``pgr_strongComponents``"

msgid "``pgr_strongComponents`` — Strongly connected components of a directed graph using Tarjan's algorithm based on DFS."
msgstr "``pgr_strongComponents`` — 使用基于 DFS 的 Tarjan 算法构建有向图的强连通分量。"

msgid "A strongly connected component of a directed graph is a set of vertices that are all reachable from each other."
msgstr "有向图的强连接组件是一组彼此可达的顶点。"

msgid "Works for **directed** graphs."
msgstr "适用于 **有向** 图。"

msgid "Components are described by vertices identifiers."
msgstr "组件由顶点标识符描述。"

msgid "pgr_strongComponents(`Edges SQL`_)"
msgstr "pgr_strongComponents(`Edges SQL`_)"

msgid "The strong components of the graph"
msgstr "图的重要组成部分"

msgid "`Boost: Strong components <https://www.boost.org/libs/graph/doc/strong_components.html>`__"
msgstr "`Boost: 强连通分量 <https://www.boost.org/libs/graph/doc/strong_components.html>`__"

msgid "wikipedia: `Strongly connected component <https://en.wikipedia.org/wiki/Strongly_connected_component>`__"
msgstr "维基百科: `强连通分量 <https://en.wikipedia.org/wiki/Strongly_connected_component>`__"

msgid "``pgr_topologicalSort`` - Experimental"
msgstr "``pgr_topologicalSort`` - 实验性"

msgid "``pgr_topologicalSort`` — Linear ordering of the vertices for directed acyclic graphs (DAG)."
msgstr "``pgr_topologicalSort`` — 有向无环图 (DAG) 的顶点的线性排序。"

msgid "The topological sort algorithm creates a linear ordering of the vertices such that if edge :math:`(u,v)` appears in the graph, then :math:`v` comes before :math:`u` in the ordering."
msgstr "拓扑排序算法创建了一个顶点的线性排序，使得如果图中存在边 :math:`(u,v)`，则在排序中 :math:`v` 出现在 :math:`u` 之前。"

msgid "Process is valid for directed acyclic graphs only. otherwise it will throw warnings."
msgstr "该过程仅对有向无环图有效。 否则它会抛出警告。"

msgid "For optimization purposes, if there are more than one answer, the function"
msgstr "出于优化目的，如果有多个答案，则该函数"

msgid "will return one of them."
msgstr "将返回其中之一。"

msgid "The returned values are ordered in topological order:"
msgstr "返回的值按拓扑顺序排序："

msgid "pgr_topologicalSort(`Edges SQL`_)"
msgstr "pgr_topologicalSort(`Edges SQL`_)"

msgid "Topologically sorting the graph"
msgstr "对图进行拓扑排序"

msgid "Sequential value starting from :math:`1`"
msgstr "从 :math:`1` 开始的连续数值"

msgid "Linear topological ordering of the vertices"
msgstr "顶点的线性拓扑排序"

msgid "Additional examples"
msgstr "其他示例"

msgid "Topologically sorting the one way segments"
msgstr "对单向段进行拓扑排序"

msgid "Graph is not a DAG"
msgstr "图不是 DAG"

msgid "`Boost: topological sort <https://www.boost.org/libs/graph/doc/topological_sort.html>`__"
msgstr "`Boost: 拓扑排序 <https://www.boost.org/libs/graph/doc/topological_sort.html>`__"

msgid "``pgr_transitiveClosure`` - Experimental"
msgstr "``pgr_transitiveClosure`` - 实验性"

msgid "``pgr_transitiveClosure`` — Transitive closure graph of a directed graph."
msgstr "``pgr_transitiveClosure`` — 有向图的传递闭包图。"

msgid "Transforms the input directed graph into the transitive closure of the graph."
msgstr "将输入有向图转换为图的传递闭包。"

msgid "Process is valid for directed graphs."
msgstr "过程对于有向图有效。"

msgid "The transitive closure of an undirected graph produces a cluster graph"
msgstr "无向图的传递闭包产生簇图"

msgid "Reachability between vertices on an undirected graph happens when they belong to the same connected component. (see :doc:`pgr_connectedComponents`)"
msgstr "当无向图上的顶点属于同一连通分量时，就会发生它们之间的可达性。（参阅 :doc:`pgr_connectedComponents`）"

msgid "The returned values are not ordered"
msgstr "返回值未排序"

msgid "The returned graph is compressed"
msgstr "返回的图形是压缩后的"

msgid "Running time: :math:`O(|V||E|)`"
msgstr "运行时间： :math:`O(|V||E|)`"

msgid "The pgr_transitiveClosure function has the following signature:"
msgstr "pgr_transitiveClosure 函数具有以下签名："

msgid "pgr_transitiveClosure(`Edges SQL`_)"
msgstr "pgr_transitiveClosure(`Edges SQL`_)"

msgid "Returns set of |result-closure|"
msgstr "返回集合 |result-closure|"

msgid "Rechability of a subgraph"
msgstr "子图的可达性"

msgid "Identifier of the source of the edges"
msgstr "边来源的标识符"

msgid "``target_array``"
msgstr "``target_array``"

msgid "Identifiers of the targets of the edges"
msgstr "边目标的标识符"

msgid "Identifiers of the vertices that are reachable from vertex v."
msgstr "从顶点 v 可到达的顶点的标识符。"

msgid "`Boost: transitive closure <https://www.boost.org/libs/graph/doc/transitive_closure.html>`__"
msgstr "`Boost: 传递闭包 <https://www.boost.org/libs/graph/doc/transitive_closure.html>`__"

msgid "https://en.wikipedia.org/wiki/Transitive_closure"
msgstr "https://en.wikipedia.org/wiki/Transitive_closure"

msgid "``pgr_trsp``"
msgstr "``pgr_trsp``"

msgid "``pgr_trsp`` - routing vertices with restrictions."
msgstr "``pgr_trsp`` - 有限制的路由顶点。"

msgid "pgr_trsp(One to One)"
msgstr "pgr_trsp(One to One)"

msgid "pgr_trsp(One to Many)"
msgstr "pgr_trsp(One to Many)"

msgid "pgr_trsp(Many to One)"
msgstr "pgr_trsp(Many to One)"

msgid "pgr_trsp(Many to Many)"
msgstr "pgr_trsp(Many to Many)"

msgid "pgr_trsp(Combinations)"
msgstr "pgr_trsp （组合）"

msgid "Deprecated signatures"
msgstr "弃用签名"

msgid "pgr_trspViaVertices(text,anyarray,boolean,boolean,text)"
msgstr "pgr_trspViaVertices(text,anyarray,boolean,boolean,text)"

msgid "New prototypes"
msgstr "新原型"

msgid "pgr_trspViaVertices"
msgstr "pgr_trspViaVertices"

msgid "pgr_trspViaEdges"
msgstr "pgr_trspViaEdges"

msgid "Turn restricted shortest path (TRSP) is an algorithm that receives turn restrictions in form of a query like those found in real world navigable road networks."
msgstr "转弯限制最短路径 (TRSP) 是一种以查询形式接收转弯限制的算法，就像在现实世界的可通航道路网络中发现的那样。"

msgid "It does no guarantee the shortest path as it might contain restriction paths."
msgstr "它不保证最短路径，因为它可能包含限制路径。"

msgid "The general algorithm is as follows:"
msgstr "通用算法如下："

msgid "Execute a Dijkstra."
msgstr "执行 Dijkstra。"

msgid "If the solution passes thru a restriction then."
msgstr "如果解决方案通过了限制。"

msgid "Execute the **TRSP** algorithm with restrictions."
msgstr "有限制地执行 **TRSP** 算法。"

msgid "pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr "pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vid**, [``directed``])"

msgid "pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr "pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vids**, [``directed``])"

msgid "pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr "pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vids**, **end vid**, [``directed``])"

msgid "pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr "pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, `Combinations SQL`_, [``directed``])"

msgid "From vertex :math:`6` to vertex :math:`10` on an undirected graph."
msgstr "从无向图上的顶点 :math:`6` 到顶点 :math:`10`."

msgid "From vertex :math:`6` to vertices :math:`\\{10, 1\\}` on an undirected graph."
msgstr "无向图上从顶点 :math:`6` 到顶点 :math:`\\{10, 1\\}` 。"

msgid "From vertices :math:`\\{6, 1\\}` to vertex :math:`8` on a directed graph."
msgstr "有向图上从顶点 :math:`\\{6, 1\\}` 到顶点 :math:`8`。"

msgid "From vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 8\\}` on an undirected graph."
msgstr "无向图上从顶点 :math:`\\{6, 1\\}` 到顶点 :math:`\\{10, 8\\}`。"

msgid "Using a combinations table on an undirected graph."
msgstr "在无向图上使用组合表。"

msgid "`Deprecated documentation <https://docs.pgrouting.org/3.3/en/pgr_trsp.html>`_"
msgstr "`已弃用文档 <https://docs.pgrouting.org/3.3/en/pgr_trsp.html>`_"

msgid "``pgr_trspVia``"
msgstr "``pgr_trspVia``"

msgid "``pgr_trspVia`` Route that goes through a list of vertices with restrictions."
msgstr "``pgr_trspVia`` 穿过有限制的顶点列表的路线。"

msgid "Given a list of vertices and a graph, this function is equivalent to finding the shortest path between :math:`vertex_i` and :math:`vertex_{i+1}` for all :math:`i < size\\_of(via\\;vertices)` trying not to use restricted paths."
msgstr "给定一个顶点列表和一个图，这个函数等同于在所有 :math:`i < size\\_of(via\\;vertices)` 的情况下找到从 :math:`vertex_i` 到 :math:`vertex_{i+1}` 的最短路径，尽量避免使用受限路径。"

msgid "The paths represents the sections of the route."
msgstr "路径代表路线的各个部分。"

msgid "Execute a :doc:`pgr_dijkstraVia`."
msgstr "执行 :doc:`pgr_dijkstraVia`。"

msgid "For the set of sub paths of the solution that pass through a restriction then"
msgstr "对于通过限制的解决方案的子路径集，则"

msgid "Execute the **TRSP** algorithm with restrictions for the paths."
msgstr "执行对路径有限制的 **TRSP** 算法。"

msgid "**NOTE** when this is done, ``U_turn_on_edge`` flag is ignored."
msgstr "**注意**，完成此操作后， ``U_turn_on_edge`` 标志将被忽略。"

msgid "pgr_trspVia(`Edges SQL`_, `Restrictions SQL`_, **via vertices**, [**options**])"
msgstr "pgr_trspVia(`Edges SQL`_, `Restrictions SQL`_, **via vertices**, [**options**])"

msgid "All this examples are about the route that visits the vertices :math:`\\{5, 7, 1, 8, 15\\}` in that order on a directed graph."
msgstr "所有这些示例都是关于按有向图上的顺序访问顶点 :math:`\\{5, 7, 1, 8, 15\\}` 的路线。"

msgid "Simulation of how algorithm works."
msgstr "模拟算法的工作原理。"

msgid "The algorithm performs a :doc:`pgr_dijkstraVia`"
msgstr "该算法执行 :doc:`pgr_dijkstraVia`"

msgid "Detects which of the sub paths pass through a restriction in this case is for the ``path_id = 5`` from ``6`` to ``3`` because the path :math:`15 \\rightarrow 1` is restricted."
msgstr "检测哪些子路径通过了限制，本例中是针对 ``path_id = 5`` 从 ``6`` 到 ``3`` ，因为该路径 :math:`15 \\rightarrow 1` 受到限制。"

msgid "Executes the :doc:`pgr_trsp` algorithm for the conflicting paths."
msgstr "执行 :doc:`pgr_trsp` 针对冲突路径建议的算法。"

msgid "From the :doc:`pgr_dijkstraVia` result it removes the conflicting paths and builds the solution with the results of the :doc:`pgr_trsp` algorithm:"
msgstr "从 :doc:`pgr_dijkstraVia` 提议的结果中，它删除了冲突路径，并使用 :doc:`pgr_trsp` 提议的算法的结果构建解决方案："

msgid "Getting the same result as ``pgr_trspVia``:"
msgstr "得到与 ``pgr_trspVia`` 相同的结果："

msgid "Example 8"
msgstr "示例 8"

msgid "Sometimes ``U_turn_on_edge`` flag is ignored when is set to ``false``."
msgstr "有时，当设置为 ``false`` 时， ``U_turn_on_edge`` 标志会被忽略。"

msgid "The first step, doing a :doc:`pgr_dijkstraVia` does consider not making a U turn on the same edge. But the path :math:`16 \\rightarrow 13` (Rows 4 and 5) is restricted and the result is using it."
msgstr "第一步，进行 :doc:`pgr_dijkstraVia` 不考虑在同一边上掉头。 但路径 :math:`16 \\rightarrow 13` （第 4 行和第 5 行）受到限制，结果正在使用它。"

msgid "When executing the :doc:`pgr_trsp` algorithm for the conflicting path, there is no ``U_turn_on_edge`` flag."
msgstr "当执行 :doc:`pgr_trsp` 针对冲突路径的算法时，没有 ``U_turn_on_edge`` 标志。"

msgid "Therefore the result ignores the ``U_turn_on_edge`` flag when set to ``false``."
msgstr "因此，当设置为 ``false`` 时，结果会忽略 ``U_turn_on_edge`` 标志。"

msgid ":doc:`via-category`"
msgstr ":doc:`via-category`"

msgid "``pgr_trspVia_withPoints``"
msgstr "``pgr_trspVia_withPoints``"

msgid "``pgr_trspVia_withPoints`` - Route that goes through a list of vertices and/or points with restrictions."
msgstr "``pgr_trspVia_withPoints`` - 经过一系列具有限制的顶点和/或点的路线。"

msgid "Given a graph, a set of restriction on the graph edges, a set of points on the graphs edges and a list of vertices, this function is equivalent to finding the shortest path between :math:`vertex_i` and :math:`vertex_{i+1}` (where :math:`vertex` can be a vertex or a point on the graph) for all :math:`i < size\\_of(via\\;vertices)` trying not to use restricted paths."
msgstr "给定一个图、对图边的一组限制、图边上的一组点和一个顶点列表，该函数相当于查找 :math:`vertex_i` 和 :math:`vertex_{i+1}` 之间的最短路径（其中 :math:`vertex` 可以是图上的顶点或点） 对于所有 :math:`i < size\\_of(via\\;vertices)` 尝试不使用受限路径的人。"

msgid "is a sequence of paths"
msgstr "是一系列路径"

msgid "Build the Graph with the new points."
msgstr "用新点构建图表。"

msgid "The points identifiers will be converted to negative values."
msgstr "点标识符将转换为负值。"

msgid "The vertices identifiers will remain positive."
msgstr "顶点标识符将保持正值。"

msgid "Execute a :doc:`pgr_withPointsVia`."
msgstr "执行 :doc:`pgr_withPointsVia`。"

msgid "For the set of paths of the solution that pass through a restriction then"
msgstr "对于通过限制的解决方案的路径集合，则"

msgid "Execute the **TRSP** algorithm with restrictions for the path."
msgstr "执行对路径有限制的 **TRSP** 算法。"

msgid "Do not use negative values on identifiers of the inner queries."
msgstr "不要在内部查询的标识符上使用负值。"

#, fuzzy
msgid "pgr_trspVia_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **via vertices**, [**driving side**,] [**options**])"
msgstr "pgr_trspVia_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **via vertices**, [**options**])"

#, fuzzy
msgid "**options:** ``[directed, strict, U_turn_on_edge, details]``"
msgstr "**options:** ``[directed, strict, U_turn_on_edge]``"

msgid "Find the route that visits the vertices :math:`\\{-6, 15, -5\\}` in that order on an directed graph."
msgstr "在有向图上查找按顺序访问顶点 :math:`\\{-6, 15, -5\\}` 的路线。"

msgid "When positive it is considered a vertex identifier"
msgstr "当为正时，它被视为顶点标识符"

msgid "When negative it is considered a point identifier"
msgstr "当负数时，它被认为是一个点标识符"

#, fuzzy
msgid "[**driving side**]"
msgstr "**driving side**"

msgid "Value in [``r``, ``R``, ``l``, ``L``, ``b``, ``B``] indicating if the driving side is:"
msgstr "值在 [``r``, ``R``, ``l``, ``L``, ``b``, ``B``] 中表示驾驶的一侧是："

#, fuzzy
msgid "For directed graph:"
msgstr "有向图。"

#, fuzzy
msgid "[``r``, ``R``] for right driving side"
msgstr "``r``, ``R`` 表示右侧驾驶，"

#, fuzzy
msgid "[``l``, ``L``] for left driving side"
msgstr "``l``, ``L`` 表示左侧驾驶。"

#, fuzzy
msgid "For undirected graph:"
msgstr "在无向图上："

#, fuzzy
msgid "[``b``, ``B``] for both driving sides"
msgstr "``l``, ``L`` 表示左侧驾驶。"

msgid "Default values when parameter is missing:"
msgstr ""

#, fuzzy
msgid "[``r``, ``R``] for directed graph"
msgstr "[``b``, ``B``] 表示两侧通行（仅适用于无向图）"

#, fuzzy
msgid "[``l``, ``L``] for undirected graph"
msgstr "[``b``, ``B``] 表示两侧通行（仅适用于无向图）"

msgid "With points optional parameters"
msgstr "带点可选参数"

msgid "``details``"
msgstr "``details``"

msgid "For showing points stops."
msgstr ""

msgid "When ``true`` the results will include the points that are in the path."
msgstr "如果为 ``true`` ，结果将包括路径中的点。"

msgid "When ``false`` the results will not include the points that are in the path."
msgstr "如果为 ``false`` ，结果将不包括路径中的点。"

msgid "When ``start_vid``, ``end_vid`` and ``node`` columns have negative values, the identifier is for a Point."
msgstr "当 ``start_vid`` 、 ``end_vid`` 和 ``node`` 列具有负值时，该标识符用于Point。"

msgid "Use ``pgr_findCloseEdges`` for points on the fly"
msgstr "对动态点使用 ``pgr_findCloseEdges``"

msgid "Using :doc:`pgr_findCloseEdges`:"
msgstr "使用 :doc:`pgr_findCloseEdges`:"

msgid "Visit from vertex :math:`1` to the two locations on the graph of point `(2.9, 1.8)` in order of closeness to the graph."
msgstr "从顶点 :math:`1` 开始，按照距离图形最近的顺序访问点 `(2.9, 1.8)` 上的两个位置。"

msgid "Point :math:`-1` corresponds to the closest edge from point `(2.9, 1.8)`."
msgstr "点 :math:`-1`对应于距离点`(2.9, 1.8)` 最近的边。"

msgid "Point :math:`-2` corresponds to the next close edge from point `(2.9, 1.8)`."
msgstr "点 :math:`-2`对应于点`(2.9, 1.8)` 的下一个闭合边。"

msgid "Point :math:`-2` is visited on the route to from vertex :math:`1` to Point :math:`-1` (See row where :math:`seq = 4`)."
msgstr "点 :math:`-2`在从顶点 :math:`1` 到点 :math:`-1` 的路线上被访问（参见行 ，其中:math:`seq = 4`）。"

msgid "Usage variations"
msgstr "用法变化"

msgid "All this examples are about the route that visits the vertices :math:`\\{-6, 7, -4, 8, -2\\}` in that order on a directed graph."
msgstr "所有这些示例都是关于按有向图上的顺序访问顶点 :math:`\\{-6, 7, -4, 8, -2\\}` 的路线。"

msgid "Status of \"passes in front\" or \"visits\" of the nodes and points."
msgstr "节点、点的\"通过\"或\"访问\"状态。"

msgid "The algorithm performs a :doc:`pgr_withPointsVia`"
msgstr "该算法执行 :doc:`pgr_withPointsVia`"

msgid "Detects which of the paths pass through a restriction in this case is for the ``path_id = 1`` from ``-6`` to ``15`` because the path :math:`9 \\rightarrow 16` is restricted."
msgstr "检测哪些路径通过了限制，在本例中是针对从 ``-6`` 到 ``15`` 的 ``path_id = 1`` ，因为路径 :math:`9 \\rightarrow 16` 受到限制。"

msgid "Executes the :ref:`TRSP-family:TRSP algorithm` for the conflicting paths."
msgstr "对冲突路径执行 :ref:`TRSP-family:TRSP algorithm`。"

msgid "From the :doc:`pgr_withPointsVia` result it removes the conflicting paths and builds the solution with the results of the :doc:`pgr_trsp` algorithm:"
msgstr "从 :doc:`pgr_withPointsVia` 的结果中移除冲突的路径，并使用 :doc:`pgr_trsp` 算法的结果构建解决方案："

msgid "Getting the same result as ``pgr_trspVia_withPoints``:"
msgstr "得到与 ``pgr_trspVia_withPoints`` 相同的结果："

msgid "The first step, doing a :doc:`pgr_withPointsVia` does consider not making a U turn on the same edge. But the path :math:`9 \\rightarrow 16` (Rows 4 and 5) is restricted and the result is using it."
msgstr "第一步，执行 :doc:`pgr_withPointsVia` 不考虑在同一条边上进行掉头。但是路径 :math:`9 \\rightarrow 16` （第4行和第5行）受到限制，结果中使用了它。"

msgid "When executing the :doc:`pgr_trsp_withPoints` algorithm for the conflicting path, there is no ``U_turn_on_edge`` flag."
msgstr "当执行 :doc:`pgr_trsp_withPoints` 针对冲突路径的算法时，没有 ``U_turn_on_edge`` 标志。"

msgid "Therefore the result ignores the ``U_turn_on_edge`` flag when set to ``false``. From the :doc:`pgr_withPointsVia` result it removes the conflicting paths and builds the solution with the results of the :doc:`pgr_trsp` algorithm. In this case a U turn is been done using the same edge."
msgstr "因此，当设置为 ``false`` 时，结果会忽略 ``U_turn_on_edge`` 标志。 从 :doc:`pgr_withPointsVia` 结果中，它删除了冲突路径，并使用 :doc:`pgr_trsp` 算法的结果构建解决方案。 在这种情况下，使用相同的边缘完成 U 形转弯。"

msgid "``pgr_trsp_withPoints``"
msgstr "``pgr_trsp_withPoints``"

msgid "``pgr_trsp_withPoints`` Routing Vertex/Point with restrictions."
msgstr "``pgr_trsp_withPoints`` 有限制的路由顶点/点。"

#, fuzzy
msgid "Modify the graph to include points defined by `Points SQL`_. Consider the invalid paths on `Restrictions SQL`_. Using Dijkstra algorithm, find the shortest path."
msgstr "修改图形，使其包含由 points_sql 定义的点。使用 Dijkstra 算法找出最短路径"

msgid "Vertices of the graph are:"
msgstr "图的顶点是："

msgid "**positive** when it belongs to the `Edges SQL`_"
msgstr "当它属于 `Edges SQL`_ 时为 **正**"

msgid "**negative** when it belongs to the `Points SQL`_"
msgstr "当它属于 `Points SQL`_ 为 **负**"

msgid "The `agg_cost` in the non included values `(v, v)` is `0`"
msgstr "非包含值 `(v, v)` 中的 `agg_cost` 为 `0`"

msgid "The `agg_cost` in the non included values `(u, v)` is :math:`\\infty`"
msgstr "非包含值 `(u, v)` 中的 `agg_cost` 为 :math:`\\infty`"

#, fuzzy
msgid "For optimization purposes, any duplicated value in the input arrays of **start vids** or **end vids** or are ignored."
msgstr "出于优化目的， `start vids` 或`end vids`中的任何重复值都将被忽略。"

msgid "Running time: :math:`O(|start\\_vids|\\times(V \\log V + E))`"
msgstr "运行时间： :math:`O(|start\\_vids|\\times(V \\log V + E))`"

#, fuzzy
msgid "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vid**, **end vid**, [**driving side**,] [**options**])"
msgstr "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vid**, **end vids**, [**options**])"

#, fuzzy
msgid "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vid**, **end vids**, [**driving side**,] [**options**])"
msgstr "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vid**, **end vids**, [**options**])"

#, fuzzy
msgid "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vids**, **end vid**, [**driving side**,] [**options**])"
msgstr "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vid**, **end vids**, [**options**])"

#, fuzzy
msgid "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vids**, **end vids**, [**driving side**,] [**options**])"
msgstr "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vid**, **end vids**, [**options**])"

#, fuzzy
msgid "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, `Combinations SQL`_, [**driving side**,] [**options**])"
msgstr "pgr_trspVia_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **via vertices**, [**options**])"

msgid "**options:** ``[directed, details]``"
msgstr "**options:** ``[directed, details]``"

#, fuzzy
msgid "From point :math:`1` to vertex :math:`10` with right driving side in directed graph. (with details)"
msgstr "从点 :math:`1` 到顶点 :math:`10`，在有向图上显示左侧驾驶侧配置的详细信息。"

msgid "From point :math:`1` to point :math:`3` and vertex :math:`7` on an undirected graph"
msgstr "无向图上的点 :math:`1` 到点 :math:`3` 和顶点 :math:`7`"

#, fuzzy
msgid "From point :math:`1` and vertex :math:`6` to point :math:`3` with right driving side in directed graph. (without details)"
msgstr "无向图上从点 :math:`1` 和顶点 :math:`6` 到点 :math:`3`到顶点 :math:`1` 的详细信息。"

#, fuzzy
msgid "From point :math:`1` and vertex :math:`6` to point :math:`3` and vertex :math:`1` with left side driving."
msgstr "从点 :math:`1` 和顶点 :math:`6` 到点 :math:`3` 和顶点 :math:`1`。"

msgid "Two combinations"
msgstr "两种组合"

#, fuzzy
msgid "From point :math:`1` to vertex :math:`10`, and from vertex :math:`6` to point :math:`3` with right side driving. (with details)"
msgstr "从点 :math:`1` 到顶点 :math:`10`，以及从顶点 :math:`6` 到点 :math:`3` ，**右侧** 行驶。"

msgid "Use :doc:`pgr_findCloseEdges` in the `Points SQL`_."
msgstr "在 `Points SQL`_ 中使用 :doc:`pgr_findCloseEdges` 。"

msgid "Find the routes from vertex :math:`1` to the two closest locations on the graph of point `(2.9, 1.8)`."
msgstr "找到从顶点 :math:`1` 到点 `(2.9, 1.8)` 图上两个最近位置的路线。"

#, fuzzy
msgid "All the examples are about traveling from point :math:`1` and vertex :math:`5` to points :math:`\\{2, 3, 6\\}` and vertices :math:`\\{10, 11\\}` with restrictions"
msgstr "所有示例都是关于从点 :math:`1` 和顶点 :math:`5` 到点 :math:`\\{2, 3, 6\\}` 和顶点 :math:`\\{10, 11\\}` 的旅行"

msgid "Passes in front or visits with right side driving."
msgstr "从前方超车或右侧行驶来访。"

msgid "For point :math:`6` and vertex :math:`11`."
msgstr "对于点 :math:`6` 和顶点 :math:`11` 。"

msgid "Passes in front or visits with left side driving."
msgstr "从前方超车或以左侧驾驶方式行驶。"

msgid "``pgr_turnRestrictedPath`` - Experimental"
msgstr "``pgr_turnRestrictedPath`` - 实验性"

msgid "``pgr_turnRestrictedPath`` Using Yen's algorithm Vertex - Vertex routing with restrictions"
msgstr "``pgr_turnRestrictedPath`` 使用 Yen 算法进行带有限制的顶点到顶点路径规划"

msgid "Using Yen's algorithm to obtain K shortest paths and analyze the paths to select the paths that do not use the restrictions"
msgstr "利用Yen算法获得K条最短路径并对路径进行分析以选择不使用限制的路径"

msgid "pgr_turnRestrictedPath(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vid**, **K**, [**options**])"
msgstr "pgr_turnRestrictedPath(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vid**, **K**, [**options**])"

msgid "**options:** ``[directed, heap_paths, stop_on_first, strict]``"
msgstr "**options:** ``[directed, heap_paths, stop_on_first, strict]``"

msgid "From vertex :math:`3` to vertex :math:`8` on a directed graph"
msgstr "从有向图上的顶点 :math:`3` 到顶点 :math:`8`"

msgid "Special optional parameters"
msgstr "特殊可选参数"

msgid "``stop_on_first``"
msgstr "``stop_on_first``"

msgid "When ``true`` stops on first path found that dos not violate restrictions"
msgstr "当 ``true`` 停止在发现不违反限制的第一条路径上时"

msgid "When ``false`` returns at most K paths"
msgstr "当 ``false`` 时返回最多 K 条路径"

msgid "When ``true`` returns only paths that do not violate restrictions"
msgstr "当 ``true`` 时仅返回不违反限制的路径"

msgid "When ``false`` returns the paths found"
msgstr "当 ``false`` 返回找到的路径"

msgid "From vertex :math:`3` to :math:`8` with ``strict`` flag on."
msgstr "从顶点 :math:`3` 到 :math:`8`，并启用 ``strict`` 标志。"

msgid "No results because the only path available follows a restriction."
msgstr "没有结果，因为唯一可用的路径受到限制。"

msgid "From vertex :math:`3` to vertex :math:`8` on an undirected graph"
msgstr "从无向图上的顶点 :math:`3` 到顶点 :math:`8`"

msgid "From vertex :math:`3` to vertex :math:`8` with more alternatives"
msgstr "从顶点 :math:`3` 到顶点 :math:`8` 更多选择"

msgid "``pgr_version``"
msgstr "``pgr_version``"

msgid "``pgr_version`` — Query for pgRouting version information."
msgstr "``pgr_version`` — 查询pgRouting版本信息。"

msgid "Breaking change on result columns"
msgstr "结果列的重大变化"

msgid "Support for old signature ends"
msgstr "对旧签名的支持结束"

msgid "Returns pgRouting version information."
msgstr "返回 pgRouting 版本信息。"

msgid "pgr_version()"
msgstr "pgr_version()"

msgid "RETURNS ``TEXT``"
msgstr "返回 ``TEXT``"

msgid "pgRouting Version for this documentation"
msgstr "本文档的 pgRouting 版本"

msgid "``pgr_vrpOneDepot`` - Experimental"
msgstr "``pgr_vrpOneDepot`` - 实验性"

msgid "**No documentation available**"
msgstr "**无可用文档**"

msgid "**TBD**"
msgstr "**TBD**"

msgid "TBD"
msgstr "TBD"

msgid "``pgr_withPoints`` - Returns the shortest path in a graph with additional temporary vertices."
msgstr "``pgr_withPoints`` - 返回图中带有附加临时顶点的最短路径。"

msgid "pgr_withPoints(Combinations)"
msgstr "pgr_withPoints（组合）"

#, fuzzy
msgid "Modify the graph to include points defined by `Points SQL`_. Using Dijkstra algorithm, find the shortest path."
msgstr "修改图形，使其包含由 points_sql 定义的点。使用 Dijkstra 算法找出最短路径"

#, fuzzy
msgid "pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, [**driving side**] [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, [**driving side**] [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, [**driving side**] [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**, [**driving side**] [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "pgr_withPoints(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, [**driving side**] [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "**options:** ``[directed, details])``"
msgstr "**options:** ``[directed, details]``"

#, fuzzy
msgid "From point :math:`1` to vertex :math:`10` with right driving side in directed graph. (without details)"
msgstr "从点 :math:`1` 到顶点 :math:`10`，在有向图上显示左侧驾驶侧配置的详细信息。"

msgid "Identifier of the starting vertex of the path. Negative value is for point’s identifier."
msgstr "路径起始顶点的标识符。 负值用于点的标识符。"

msgid "Array of identifiers of starting vertices. Negative values are for point’s identifiers."
msgstr "起始顶点的标识符数组。 负值用于点的标识符。"

msgid "Identifier of the ending vertex of the path. Negative value is for point’s identifier."
msgstr "路径结束顶点的标识符。 负值用于点的标识符。"

msgid "Array of identifiers of ending vertices. Negative values are for point’s identifiers."
msgstr "结束顶点的标识符数组。 负值用于点的标识符。"

msgid "All the examples are about traveling from point :math:`1` and vertex :math:`5` to points :math:`\\{2, 3, 6\\}` and vertices :math:`\\{10, 11\\}`"
msgstr "所有示例都是关于从点 :math:`1` 和顶点 :math:`5` 到点 :math:`\\{2, 3, 6\\}` 和顶点 :math:`\\{10, 11\\}` 的旅行"

msgid "``pgr_withPointsCost`` - Calculates the shortest path and returns only the aggregate cost of the shortest path found, for the combination of points given."
msgstr "``pgr_withPointsCost`` - 计算最短路径，并只返回所给点组合的最短路径的总成本。"

msgid "pgr_withPointsCost(Combinations)"
msgstr "pgr_withPointsCost（组合）"

msgid "Modify the graph to include points defined by points_sql. Using Dijkstra algorithm, return only the aggregate cost of the shortest path found."
msgstr "修改图形以包含由 points_sql 定义的点。使用 Dijkstra 算法，只返回找到的最短路径的总成本。"

msgid "Returns the sum of the costs of the shortest path for pair combination of vertices in the modified graph."
msgstr "返回修改图中顶点对组合的最短路径成本之和。"

#, fuzzy
msgid "The returned values are in the form of a set of |matrix-result|."
msgstr "返回值的形式为一组`(start_vid, end_vid, agg_cost)` 。"

msgid "**positive** when it belongs to the edges_sql"
msgstr "当它属于edges_sql时为 **正**"

msgid "**negative** when it belongs to the points_sql"
msgstr "当它属于 points_sql时为 **负**"

msgid "If the values returned are stored in a table, the unique index would be the pair: `(start_vid, end_vid)`."
msgstr "如果返回的值存储在表中，则唯一索引将是这一对： `(start_vid, end_vid)` 。"

msgid "For **undirected** graphs, the results are **symmetric**."
msgstr "对于 **无向** 图，结果是 **对称** 的。"

#, fuzzy
msgid "pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, [**driving side**] [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, [**driving side**] [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, [**driving side**] [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**, [**driving side**] [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, [**driving side**] [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "**options:** ``[directed]``"
msgstr "**options:** ``[directed, cap]``"

msgid "There is no **details** flag, unlike the other members of the withPoints family of functions."
msgstr "与 withPoints 函数系列的其他成员不同，没有 **详细信息** 标志。"

#, fuzzy
msgid "From point :math:`1` to vertex :math:`10` with right driving side in directed graph."
msgstr "从点 :math:`1` 到顶点 :math:`10`，在有向图上显示左侧驾驶侧配置的详细信息。"

#, fuzzy
msgid "From point :math:`1` and vertex :math:`6` to point :math:`3` with right driving side in directed graph."
msgstr "无向图上从点 :math:`1` 和顶点 :math:`6` 到点 :math:`3`到顶点 :math:`1` 的详细信息。"

#, fuzzy
msgid "From point :math:`1` to vertex :math:`10`, and from vertex :math:`6` to point :math:`3` with right side driving."
msgstr "从点 :math:`1` 到顶点 :math:`10`，以及从顶点 :math:`6` 到点 :math:`3` ，**右侧** 行驶。"

msgid "Find the cost of the routes from vertex :math:`1` to the two closest locations on the graph of point `(2.9, 1.8)`."
msgstr "求从顶点 :math:`1` 到图中点 `(2.9, 1.8)` 的两个最近位置的路线成本。"

msgid "Being close to the graph does not mean have a shorter route."
msgstr "靠近图表并不意味着路线更短。"

msgid "Right side driving topology"
msgstr "右侧驾驶拓扑"

msgid "Traveling from point :math:`1` and vertex :math:`5` to points :math:`\\{2, 3, 6\\}` and vertices :math:`\\{10, 11\\}`"
msgstr "从点 :math:`1` 和顶点 :math:`5` 出发，前往点 :math:`\\{2, 3, 6\\}` 和顶点 :math:`\\{10, 11\\}`"

msgid "Left side driving topology"
msgstr "左侧驾驶拓扑"

msgid "Does not matter driving side driving topology"
msgstr "与驱动端驱动拓扑无关"

msgid "``pgr_withPointsCostMatrix`` - Calculates a cost matrix using :doc:`pgr_withPoints`."
msgstr "``pgr_withPointsCostMatrix`` - 使用 :doc:`pgr_withPoints` 计算成本矩阵。"

#, fuzzy
msgid "pgr_withPointsCostMatrix(`Edges SQL`_, `Points SQL`_, **start vids**, [**driving side**] [**options**])"
msgstr "pgr_withPointsCostMatrix(`Edges SQL`_, `Points SQL`_, **start vids**, [**options**])"

msgid "Cost matrix for points :math:`\\{1, 6\\}` and vertices :math:`\\{10, 11\\}` on an **undirected** graph"
msgstr "**无向** 图上的点 :math:`\\{1, 6\\}` 和顶点 :math:`\\{10, 11\\}` 的成本矩阵"

msgid "Returning a **symmetrical** cost matrix"
msgstr "返回 **对称** 成本矩阵"

msgid "Using the default ``side`` value on the **points_sql** query"
msgstr "在 **points_sql** 查询上使用默认 ``side`` 值"

#, fuzzy
msgid "Using the default ``driving side`` value"
msgstr "使用默认 ``driving_side`` 值"

msgid "Find the matrix cost of the routes from vertex :math:`1` and the two closest locations on the graph of point `(2.9, 1.8)`."
msgstr "求从顶点 :math:`1` 到图上点 `(2.9, 1.8)` 的两个最近位置的路线的矩阵成本。"

msgid "``pgr_withPointsDD`` - Returns the driving **distance** from a starting point."
msgstr "``pgr_withPointsDD`` - 返回从起点开始的行驶 **距离** 。"

#, fuzzy
msgid "Output columns standardized to |result-spantree|"
msgstr "新的输出列是 |result-spantree|"

msgid "When ``details`` is ``false``:"
msgstr "当 ``details`` 为 ``false`` 时："

#, fuzzy
msgid "Points reached within the distance are not included."
msgstr "只有那些被访问的兴趣点会被移除，也就是说，位于一定距离范围内被到达的兴趣点会被包含在内"

#, fuzzy
msgid "Deprecated signatures:"
msgstr "弃用签名"

msgid "Modify the graph to include points and using Dijkstra algorithm, extracts all the nodes and points that have costs less than or equal to the value ``**distance**`` from the starting point. The edges extracted will conform the corresponding spanning tree."
msgstr "修改图以包含点，并使用 Dijkstra 算法，提取成本小于或等于距起点 ``**距离**`` 值的所有节点和点。 提取的边将符合相应的生成树。"

#, fuzzy
msgid "pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vid**, **distance**, [**driving side**], [**options A**])"
msgstr "pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vid**, **distance**, **driving side**, [**options A**])"

#, fuzzy
msgid "pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vids**, **distance**, [**driving side**], [**options B**])"
msgstr "pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vids**, **distance**, **driving side**, [**options B**])"

msgid "**options A:** ``[directed, details]``"
msgstr "**options A:** ``[directed, details]``"

msgid "**options B:** ``[directed, details, equicost]``"
msgstr "**options B:** ``[directed, details, equicost]``"

#, fuzzy
msgid "pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vid**, **distance**, [**driving side**], [**options**])"
msgstr "pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vid**, **distance**, **driving side**, [**options**])"

msgid "Right side driving topology, from point :math:`1` within a distance of :math:`3.3` with details."
msgstr "右侧驾驶拓扑，从点 :math:`1` 开始，距离不超过 :math:`3.3`，并提供详细信息。"

#, fuzzy
msgid "pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vids**, **distance**, [**driving side**], [**options**])"
msgstr "pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vids**, **distance**, **driving side**, [**options**])"

msgid "**options:** ``[directed, details, equicost]``"
msgstr "**options:** ``[directed, details, equicost]``"

msgid "From point :math:`1` and vertex :math:`16` within a distance of :math:`3.3` with ``equicost`` on a directed graph"
msgstr "从点 :math:`1` 和顶点 :math:`16` 出发，在有向图上以 ``equicost`` 模式，在距离不超过 :math:`3.3` 的范围内"

msgid "Negative values represent a point"
msgstr "负值代表一个点"

msgid "Find the driving distance from the two closest locations on the graph of point `(2.9, 1.8)`."
msgstr "求图上点 `(2.9, 1.8)` 距离最近的两个位置的行驶距离。"

msgid "Point :math:`-1` corresponds to the closest edge from point :math:`(2.9, 1.8)`."
msgstr "点 :math:`-1` 对应距离点 :math:`(2.9, 1.8)` 最近的边。"

msgid "Point :math:`-2` corresponds to the next close edge from point :math:`(2.9, 1.8)`."
msgstr "点 :math:`-2` 对应于点 :math:`(2.9, 1.8)` 的下一条近边。"

msgid "Driving side does not matter"
msgstr "驾驶侧并不重要"

msgid "From point :math:`1` within a distance of :math:`3.3`, does not matter driving side, with details."
msgstr "从点 :math:`1` 开始，在距离不超过 :math:`3.3` 的范围内，无论驾驶方向如何，提供详细信息。"

msgid "``pgr_withPointsKSP``"
msgstr "``pgr_withPointsKSP``"

msgid "``pgr_withPointsKSP`` — Yen's algorithm for K shortest paths using Dijkstra."
msgstr "``pgr_withPointsKSP`` — Yen 使用 Dijkstra 计算 K 最短路径的算法。"

msgid "pgr_withPointsKSP(One to Many)"
msgstr "pgr_withPointsKSP(One to Many)"

msgid "pgr_withPointsKSP(Many to One)"
msgstr "pgr_withPointsKSP(Many to One)"

msgid "pgr_withPointsKSP(Many to Many)"
msgstr "pgr_withPointsKSP(Many to Many)"

msgid "pgr_withPointsKSP(Combinations)"
msgstr "pgr_withPointsKSP(Combinations)"

msgid "Modifies the graph to include the points defined in the `Points SQL`_ and using Yen algorithm, finds the :math:`K` shortest paths."
msgstr "修改图以包括 `Points SQL`_ 中定义的点并使用 Yen 算法查找 :math:`K` 最短路径。"

#, fuzzy
msgid "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, **K**, [**driving side**], [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, **K**, [**driving side**], [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, **K**, [**driving side**], [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**, **K**, [**driving side**], [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**, **K**, **driving_side**, [**options**])"

#, fuzzy
msgid "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, **K**, [**driving side**], [**options**])"
msgstr "pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, **K**, **driving_side**, [**options**])"

msgid "**options:** ``[directed, heap_paths, details]``"
msgstr "**options:** ``[directed, heap_paths, details]``"

msgid "Get 2 paths from Point :math:`1` to point :math:`2` on a directed graph with **left** side driving."
msgstr "在具有 **左侧** 驾驶的有向图上，从点 :math:`1` 到点 :math:`2` 获取两条路径。"

msgid "For a directed graph."
msgstr "有向图。"

msgid "No details are given about distance of other points of the query."
msgstr "没有给出有关查询的其他点的距离的详细信息。"

msgid "No heap paths are returned."
msgstr "不返回堆路径。"

msgid "Get 2 paths from point :math:`1` to point :math:`3` and vertex :math:`7` on an undirected graph"
msgstr "在无向图上从点 :math:`1` 到点 :math:`3` 和顶点 :math:`7` 获取两条路径"

msgid "Get a path from point :math:`1` and vertex :math:`6` to point :math:`3` on a **directed** graph with **right** side driving and **details** set to **True**"
msgstr "在具有 **右侧** 驾驶的 **有向** 图上，从点 :math:`1` 和顶点 :math:`6` 到点 :math:`3` 获取一条路径，且 **details** 设置为 **True**"

msgid "Get a path from point :math:`1` and vertex :math:`6` to point :math:`3` and vertex :math:`1` on a **directed** graph with **left** side driving and **heap_paths** set to **True**"
msgstr "在具有 **左侧** 驾驶的 **有向** 图上，从点 :math:`1` 和顶点 :math:`6` 到点 :math:`3` 和顶点 :math:`1` 获取一条路径，且 **heap_paths** 设置为 **True**"

msgid "Using a combinations table on an **directed** graph"
msgstr "在 **有向** 图上使用组合表"

msgid "Number of required paths"
msgstr "所需路径的数量"

msgid "withPointsKSP optional parameters"
msgstr "withPointsKSP可选参数"

msgid "Get :math:`2` paths using left side driving topology, from vertex :math:`1` to the closest location on the graph of point `(2.9, 1.8)`."
msgstr "使用左侧驾驶拓扑，从顶点 :math:`1` 到离点 `(2.9, 1.8)` 最近的位置获取 :math:`2` 条路径。"

msgid "Left driving side"
msgstr "左驾驶侧"

msgid "Get :math:`2` paths using left side driving topology, from point :math:`1` to point :math:`3` with details."
msgstr "使用左侧驾驶拓扑，从点 :math:`1` 到点 :math:`3` 获取 :math:`2` 条路径，并包含详细信息。"

msgid "Right driving side"
msgstr "右驾驶侧"

msgid "Get :math:`2` paths using right side driving topology from, point :math:`1` to point :math:`2` with heap paths and details."
msgstr "使用右侧驾驶拓扑，从点 :math:`1` 到点 :math:`2` 获取 :math:`2` 条路径，同时使用堆路径（heap paths）并包含详细信息。"

msgid "``pgr_withPointsVia``"
msgstr "``pgr_withPointsVia``"

msgid "``pgr_withPointsVia`` - Route that goes through a list of vertices and/or points."
msgstr "``pgr_withPointsVia`` - 经过一系列顶点和/或点的路线。"

msgid "Given a graph, a set of points on the graphs edges and a list of vertices, this function is equivalent to finding the shortest path between :math:`vertex_i` and :math:`vertex_{i+1}` (where :math:`vertex` can be a vertex or a point on the graph) for all :math:`i < size\\_of(via\\;vertices)`."
msgstr "给定一个图、图上边缘的一组点以及一个顶点列表，此函数相当于找到 :math:`vertex_i` 和 :math:`vertex_{i+1}` 之间的最短路径（其中 :math:`vertex` 可以是一个顶点或图上的一个点），对于所有的 :math:`i` ，满足 :math:`i < size\\_of(via\\;vertices)` 。"

#, fuzzy
msgid "pgr_withPointsVia(`Edges SQL`_, `Points SQL`_, **via vertices**, [**driving side**] [**options**])"
msgstr "pgr_withPointsVia(`Edges SQL`_, `Points SQL`_, **via vertices**, [**options**])"

#, fuzzy
msgid "Find the route that visits the vertices :math:`\\{ -6, 15, -1\\}` in that order with right driving side in directed graph.."
msgstr "在有向图上查找按顺序访问顶点 :math:`\\{-6, 15, -5\\}` 的路线。"

msgid "Use :doc:`pgr_findCloseEdges` in the `Points SQL`_"
msgstr "在 `Points SQL`_ 中使用 :doc:`pgr_findCloseEdges` 函数"

msgid "All this examples are about the route that visits the vertices :math:`\\{-1, 7, -3, 16, 15\\}` in that order on a **directed** graph."
msgstr "所有这些示例都是关于在 **有向** 图上按顺序访问顶点 :math:`\\{-1, 7, -3, 16, 15\\}` 的路线。"

msgid "Prim - Family of functions"
msgstr "Prim - 函数族"

msgid "The prim algorithm was developed in 1930 by Czech mathematician Vojtěch Jarník. It is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. The algorithm operates by building this tree one vertex at a time, from an arbitrary starting vertex, at each step adding the cheapest possible connection from the tree to another vertex."
msgstr "prim 算法由捷克数学家 Vojtěch Jarník 于 1930 年开发。 它是一种贪心算法，为带权无向图找到最小生成树。 这意味着它找到形成包含每个顶点的树的边的子集，其中树中所有边的总权重最小化。 该算法的运行方式是从任意起始顶点一次构建一个顶点，在每一步添加从树到另一个顶点的最便宜的可能连接。"

msgid "This algorithms find the minimum spanning forest in a possibly disconnected graph; in contrast, the most basic form of Prim's algorithm only finds minimum spanning trees in connected graphs. However, running Prim's algorithm separately for each connected component of the graph, then it is called minimum spanning forest."
msgstr "该算法在可能不连通的图中找到最小生成森林； 相反，Prim 算法的最基本形式只能在连通图中找到最小生成树。 然而，对图的每个连通分量分别运行Prim算法，则称为最小生成森林。"

msgid "From boost Graph: \"The algorithm as implemented in Boost.Graph does not produce correct results on graphs with parallel edges.\""
msgstr "来自 boost Graph：“Boost.Graph 中实现的算法不会在具有平行边的图上产生正确的结果。”"

msgid "Boost: `Prim's algorithm <https://www.boost.org/libs/graph/doc/prim_minimum_spanning_tree.html>`__"
msgstr "Boost: `Prim算法 <https://www.boost.org/libs/graph/doc/prim_minimum_spanning_tree.html>`__"

msgid "Wikipedia: `Prim's algorithm <https://en.wikipedia.org/wiki/Prim%27s_algorithm>`__"
msgstr "维基百科: `Prim算法 <https://en.wikipedia.org/wiki/Prim%27s_algorithm>`__"

msgid "Proposed Functions"
msgstr "提议的功能"

msgid ":doc:`pgr_lineGraph` - Transformation algorithm for generating a Line Graph."
msgstr ":doc:`pgr_lineGraph` - 用于生成折线图的转换算法。"

msgid "Reference"
msgstr "参考"

msgid "Release Notes"
msgstr "发布说明"

msgid "To see the full list of changes check the list of `Git commits <https://github.com/pgRouting/pgrouting/commits>`_ on Github."
msgstr "要查看完整的更改列表，请检查 Github 上的 `Git提交列表 <https://github.com/pgRouting/pgrouting/commits>`_ 。"

msgid "Mayors"
msgstr "主要版本"

msgid "pgRouting 4"
msgstr "pgRouting 4"

msgid "Minors 4.x"
msgstr "Minors 4.x"

#, fuzzy
msgid "pgRouting 4.1"
msgstr "pgRouting 4.0"

#, fuzzy
msgid "pgRouting 4.1.0 Release Notes"
msgstr "pgRouting 3.1.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 4.1.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%204.1.0%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求,请访问： `GitHub 4.0.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%204.0.0%22>`__"

msgid "No changes yet"
msgstr ""

msgid "pgRouting 3"
msgstr "pgRouting 3"

msgid "Minors 3.x"
msgstr "3.x小版本"

msgid "pgRouting 3.8"
msgstr "pgRouting 3.8"

msgid "pgRouting 3.8.0 Release Notes"
msgstr "pgRouting 3.8.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.8.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.8.0%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.8.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.8.0%22>`__"

msgid "Promotion to official function of pgRouting."
msgstr "升级为 pgRouting 的官方函数。"

msgid "Metric"
msgstr "度量"

msgid "`#2760 <https://github.com/pgRouting/pgrouting/issues/2760>`__: Promoted to official pgr_degree in version 3.8"
msgstr "`#2760 <https://github.com/pgRouting/pgrouting/issues/2760>`__:pgr_degree 在 3.8 版本升级为正式函数"

msgid "Utilities"
msgstr "实用程序"

msgid "`#2772 <https://github.com/pgRouting/pgrouting/issues/2772>`__: Promoted to official pgr_extractVertices in version 3.8"
msgstr "`#2772 <https://github.com/pgRouting/pgrouting/issues/2772>`__ :pgr_extractVertices 在 3.8 版本升级为正式函数"

msgid "`#2774 <https://github.com/pgRouting/pgrouting/issues/2774>`__: Promoted to official pgr_findCloseEdges in version 3.8"
msgstr "`#2774 <https://github.com/pgRouting/pgrouting/issues/2774>`__:pgr_findCloseEdges 在 3.8 版本升级为正式函数"

msgid "`#2873 <https://github.com/pgRouting/pgrouting/issues/2873>`__: Promoted to official pgr_separateCrossing in version 3.8"
msgstr "`#2873 <https://github.com/pgRouting/pgrouting/issues/2873>`__: pgr_separateCrossing 在3.8版本中被提升为官方函数"

msgid "`#2874 <https://github.com/pgRouting/pgrouting/issues/2874>`__: Promoted to official pgr_separateTouching in version 3.8"
msgstr "`#2874 <https://github.com/pgRouting/pgrouting/issues/2874>`__: pgr_separateTouching 在3.8版本中被提升为官方函数"

msgid "Proposed functions"
msgstr "提议函数"

msgid "Contraction"
msgstr "收缩"

msgid "`#2790 <https://github.com/pgRouting/pgrouting/issues/2790>`__: pgr_contractionDeadEnd new contraction function"
msgstr "`#2790 <https://github.com/pgRouting/pgrouting/issues/2790>`__:创建新收缩函数 pgr_contractionDeadEnd"

msgid "`#2791 <https://github.com/pgRouting/pgrouting/issues/2791>`__: pgr_contractionLinear new contraction function"
msgstr "`#2791 <https://github.com/pgRouting/pgrouting/issues/2791>`__:创建新收缩函数 pgr_contractionLinear"

msgid "`#2536 <https://github.com/pgRouting/pgrouting/issues/2536>`__: Support for contraction hierarchies (pgr_contractionHierarchies)"
msgstr "`#2536 <https://github.com/pgRouting/pgrouting/issues/2536>`__: 支持收缩层级(pgr_contractionHierarchies)"

msgid "`#2848 <https://github.com/pgRouting/pgrouting/issues/2848>`__: Create pgr_separateCrossing new utility function"
msgstr "`#2848 <https://github.com/pgRouting/pgrouting/issues/2848>`__:创建新工具函数 pgr_separateCrossing"

msgid "`#2849 <https://github.com/pgRouting/pgrouting/issues/2849>`__: Create of pgr_separateTouching new utility function"
msgstr "`#2849 <https://github.com/pgRouting/pgrouting/issues/2849>`__:创建新工具函数 pgr_separateTouching"

msgid "Official functions changes"
msgstr "官方功能变更"

msgid "`#2786 <https://github.com/pgRouting/pgrouting/issues/2786>`__: pgr_contraction(edges) new signature"
msgstr "`#2786 <https://github.com/pgRouting/pgrouting/issues/2786>`__:pgr_contraction(edges) 新签名"

msgid "C/C++ code enhancements"
msgstr "C/C++ 代码增强"

msgid "`#2802 <https://github.com/pgRouting/pgrouting/issues/2802>`__: Code reorganization on pgr_contraction"
msgstr "`#2802 <https://github.com/pgRouting/pgrouting/issues/2802>`__:pgr_contraction 函数进行了代码重构"

#, fuzzy
msgid "Other enhancements:"
msgstr "代码改进"

#, fuzzy
msgid "`#2869 <https://github.com/pgRouting/pgrouting/issues/2869>`__:"
msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

msgid "SQL code enhancements"
msgstr "SQL 代码优化"

msgid "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__: Rewrite pgr_nodeNetwork"
msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

msgid "Deprecation of SQL functions"
msgstr "SQL 函数的弃用"

msgid "`#2749 <https://github.com/pgRouting/pgrouting/issues/2749>`__: Deprecate pgr_AlphaShape in 3.8"
msgstr "`#2749 <https://github.com/pgRouting/pgrouting/issues/2749>`__:在 3.8 中弃用 pgr_AlphaShape"

msgid "`#2750 <https://github.com/pgRouting/pgrouting/issues/2750>`__: Deprecate pgr_CreateTopology in 3.8"
msgstr "`#2750 <https://github.com/pgRouting/pgrouting/issues/2750>`__:在 3.8 中弃用 pgr_CreateTopology"

msgid "`#2753 <https://github.com/pgRouting/pgrouting/issues/2753>`__: Deprecate pgr_analyzeGraph in 3.8"
msgstr "`#2753 <https://github.com/pgRouting/pgrouting/issues/2753>`__:在 3.8 中弃用 pgr_analyzeGraph"

msgid "`#2754 <https://github.com/pgRouting/pgrouting/issues/2754>`__: Deprecate pgr_analyzeOneWay in 3.8"
msgstr "`#2754 <https://github.com/pgRouting/pgrouting/issues/2754>`__:在 3.8 中弃用 pgr_analyzeOneWay"

msgid "`#2826 <https://github.com/pgRouting/pgrouting/issues/2826>`__: Deprecate pgr_createVerticesTable in 3.8"
msgstr "`#2826 <https://github.com/pgRouting/pgrouting/issues/2826>`__:在 3.8 中弃用 pgr_createVerticesTable"

msgid "In the deprecated functions:"
msgstr "已弃用的函数中："

msgid "Migration section is created."
msgstr "迁移部分已创建。"

msgid "The use of the functions is removed in the documentation."
msgstr "文档中已移除这些函数的使用说明。"

msgid "pgRouting 3.7"
msgstr "pgRouting 3.7"

msgid "pgRouting 3.7.3 Release Notes"
msgstr "pgRouting 3.7.3 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.7.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.3%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `Git closed milestone for 3.7.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.3%22>`__"

#, fuzzy
msgid "`#2731 <https://github.com/pgRouting/pgrouting/issues/2731>`__: Build Failure on Ubuntu 22"
msgstr "`#2731 <https://github.com/pgRouting/pgrouting/pull/2731>`__ Ubuntu 22 上的构建失败"

msgid "pgRouting 3.7.2 Release Notes"
msgstr "pgRouting 3.7.2 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.7.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.2%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.2版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.2%22>`__"

#, fuzzy
msgid "`#2713 <https://github.com/pgRouting/pgrouting/issues/2713>`__: cmake missing some policies and min version"
msgstr "`#2713 <https://github.com/pgRouting/pgrouting/pull/2713>`__ cMake 缺少一些策略和最低版本要求"

msgid "Using OLD policies: CMP0148, CMP0144, CMP0167"
msgstr "使用旧版策略：CMP0148，CMP0144，CMP0167"

msgid "Minimum cmake version 3.12"
msgstr "CMake最低版本要求 3.12"

#, fuzzy
msgid "`#2707 <https://github.com/pgRouting/pgrouting/issues/2707>`__: Build failure in pgRouting 3.7.1 on Alpine"
msgstr "`#2707 <https://github.com/pgRouting/pgrouting/pull/2707>`__ pgRouting 3.7.1 在 Alpine 上的构建失败"

#, fuzzy
msgid "`#2706 <https://github.com/pgRouting/pgrouting/issues/2706>`__: winnie crashing on pgr_betweennessCentrality"
msgstr "`#2706 <https://github.com/pgRouting/pgrouting/pull/2706>`__ 修复 pgr_betweennessCentrality 导致 winnie 崩溃"

msgid "pgRouting 3.7.1 Release Notes"
msgstr "pgRouting 3.7.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.7.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.1%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.1版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.1%22>`__"

#, fuzzy
msgid "`#2680 <https://github.com/pgRouting/pgrouting/issues/2680>`__: fails to compile under mingw64 gcc 13.2"
msgstr "`#2680 <https://github.com/pgRouting/pgrouting/pull/2680>`__ 在 mingw64 gcc 13.2 下编译失败"

#, fuzzy
msgid "`#2689 <https://github.com/pgRouting/pgrouting/issues/2689>`__: When point is a vertex, the withPoints family do not return results."
msgstr "`#2689 <https://github.com/pgRouting/pgrouting/pull/2689>`__ 当 point 是顶点时，withPoints 系列不返回结果。"

msgid "C/C++ code enhancemet"
msgstr "C/C++ 代码优化"

msgid "TRSP family"
msgstr "TRSP 系列"

msgid "pgRouting 3.7.0 Release Notes"
msgstr "pgRouting 3.7.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.7.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.0%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.0%22>`__"

msgid "Support"
msgstr "支持"

#, fuzzy
msgid "`#2656 <https://github.com/pgRouting/pgrouting/issues/2656>`__: Stop support of PostgreSQL12 on pgrouting v3.7"
msgstr "`#2656 <https://github.com/pgRouting/pgrouting/pull/2656>`__ 在 pgrouting v3.7 上停止支持 PostgreSQL12"

msgid "Stopping support of PostgreSQL 12"
msgstr "停止支持 PostgreSQL 12"

msgid "CI does not test for PostgreSQL 12"
msgstr "CI 不测试 PostgreSQL 12"

msgid "pgr_betweennessCentrality"
msgstr "pgr_betweennessCentrality"

#, fuzzy
msgid "`#2605 <https://github.com/pgRouting/pgrouting/issues/2605>`__: Standardize spanning tree functions output"
msgstr "`#2605 <https://github.com/pgRouting/pgrouting/pull/2605>`__ 标准化生成树函数的输出"

msgid "Functions:"
msgstr "新函数:"

msgid "Experimental promoted to proposed."
msgstr "实验性提升为提议。"

#, fuzzy
msgid "`#2635 <https://github.com/pgRouting/pgrouting/issues/2635>`__: pgr_LineGraph ignores directed flag and use negative values for identifiers."
msgstr "`#2635 <https://github.com/pgRouting/pgrouting/pull/2635>`__ pgr_LineGraph 忽略了有向标志，并使用负值作为标识符。"

msgid "``pgr_lineGraph``"
msgstr "``pgr_lineGraph``"

msgid "Code enhancement"
msgstr "代码改进"

#, fuzzy
msgid "`#2599 <https://github.com/pgRouting/pgrouting/issues/2599>`__: Driving distance cleanup"
msgstr "`#2599 <https://github.com/pgRouting/pgrouting/pull/2599>`__ 行车距离清理"

#, fuzzy
msgid "`#2607 <https://github.com/pgRouting/pgrouting/issues/2607>`__: Read postgresql data on C++"
msgstr "`#2607 <https://github.com/pgRouting/pgrouting/pull/2607>`__ 在 C++ 上读取 postgresql 数据"

#, fuzzy
msgid "`#2614 <https://github.com/pgRouting/pgrouting/issues/2614>`__: Clang tidy does not work"
msgstr "`#2614 <https://github.com/pgRouting/pgrouting/pull/2614>`__ Clang tidy 不工作"

msgid "pgRouting 3.6"
msgstr "pgRouting 3.6"

msgid "pgRouting 3.6.3 Release Notes"
msgstr "pgRouting 3.6.3 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.6.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.3%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.6.3版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.3%22>`__"

msgid "Explicit minimum requirements:"
msgstr "最低要求："

msgid "postgres 11.0.0"
msgstr "postgres 11.0.0"

msgid "postgis 3.0.0"
msgstr "postgis 3.0.0"

msgid "g++ 13+ is supported"
msgstr "支持 g++ 13+"

msgid "Code fixes"
msgstr "代码修正"

msgid "Fix warnings from cpplint."
msgstr "修复来自 cpplint 的警告。"

msgid "Fix warnings from clang 18."
msgstr "修复来自 clang 18 的警告。"

msgid "CI tests"
msgstr "CI tests"

msgid "Add a clang tidy test on changed files."
msgstr "为已更改的文件添加 clang tidy 测试。"

msgid "Update test not done on versions: 3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.1.0, 3.1.1, 3.1.2"
msgstr "未对以下版本进行更新测试3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.1.0, 3.1.1, 3.1.2"

msgid "Documentation"
msgstr "文档"

msgid "Results of documentation queries adujsted to boost 1.83.0 version:"
msgstr "根据 boost 1.83.0 版本进行的文档查询结果："

msgid "pgr_stoerWagner"
msgstr "pgr_stoerWagner"

msgid "pgtap tests"
msgstr "pgtap 测试"

msgid "bug fixes"
msgstr "bug fixes"

msgid "pgRouting 3.6.2 Release Notes"
msgstr "pgRouting 3.6.2 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.6.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.2%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `Git closed milestone for 3.6.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.2%22>`__"

msgid "Upgrade fix"
msgstr "升级修复"

msgid "The upgrade was failing for same minor"
msgstr "升级失败的主要原因是"

msgid "Fix warnings from cpplint"
msgstr "修复来自 cpplint 的警告"

msgid "Others"
msgstr "其他"

msgid "Adjust NEWS generator"
msgstr "调整新闻生成器"

msgid "Name change to `NEWS.md` for better visualization on GitHub"
msgstr "更名为 `NEWS.md` ，以便在 GitHub 上更好地可视化"

msgid "pgRouting 3.6.1 Release Notes"
msgstr "pgRouting 3.6.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.6.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.1%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.6.1Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.1%22>`_"

#, fuzzy
msgid "`#2588 <https://github.com/pgRouting/pgrouting/issues/2588>`__: pgrouting 3.6.0 fails to build on OSX"
msgstr "`#2588 <https://github.com/pgRouting/pgrouting/pull/2588>`__ pgrouting 3.6.0 在 OSX 上构建失败"

msgid "pgRouting 3.6.0 Release Notes"
msgstr "pgRouting 3.6.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.6.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.0%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请访问 `Git 3.6.0 里程碑的已关闭问题和拉取请求 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.0%22>`_"

#, fuzzy
msgid "`#2516 <https://github.com/pgRouting/pgrouting/issues/2516>`__: Standardize output pgr_aStar"
msgstr "`#2516 <https://github.com/pgRouting/pgrouting/pull/2516>`__ 标准化输出 pgr_aStar"

msgid "Standardize output columns to |short-generic-result|"
msgstr "将输出列标准化为 |short-generic-result|"

#, fuzzy
msgid "`#2523 <https://github.com/pgRouting/pgrouting/issues/2523>`__: Standardize output pgr_bdAstar"
msgstr "`#2523 <https://github.com/pgRouting/pgrouting/pull/2523>`__ 标准化输出 pgr_bdAstar"

#, fuzzy
msgid "`#2547 <https://github.com/pgRouting/pgrouting/issues/2547>`__: Standardize output and modifying signature pgr_KSP"
msgstr "`#2547 <https://github.com/pgRouting/pgrouting/pull/2547>`__ 标准化输出和修改签名 pgr_KSP"

#, fuzzy
msgid "`#2548 <https://github.com/pgRouting/pgrouting/issues/2548>`__: Standardize output pgr_drivingDistance"
msgstr "`#2548 <https://github.com/pgRouting/pgrouting/pull/2548>`__ 标准化输出 pgr_drivingDistance"

msgid "Proposed functions changes"
msgstr "提议函数改变"

#, fuzzy
msgid "`#2544 <https://github.com/pgRouting/pgrouting/issues/2544>`__: Standardize output and modifying signature pgr_withPointsDD"
msgstr "`#2544 <https://github.com/pgRouting/pgrouting/pull/2544>`__ 标准化输出和修改签名 pgr_withPointsDD"

#, fuzzy
msgid "`#2546 <https://github.com/pgRouting/pgrouting/issues/2546>`__: Standardize output and modifying signature pgr_withPointsKSP"
msgstr "`#2546 <https://github.com/pgRouting/pgrouting/pull/2546>`__ 标准化输出和修改签名 pgr_withPointsKSP"

#, fuzzy
msgid "`#2504 <https://github.com/pgRouting/pgrouting/issues/2504>`__: To C++ pg data get, fetch and check."
msgstr "`#2504 <https://github.com/pgRouting/pgrouting/pull/2504>`__ 获取、提取和检查C++ pg数据。"

msgid "Stopping support for compilation with MSVC."
msgstr "停止支持使用 MSVC 进行编译。"

#, fuzzy
msgid "`#2505 <https://github.com/pgRouting/pgrouting/issues/2505>`__: Using namespace."
msgstr "`#2505 <https://github.com/pgRouting/pgrouting/pull/2505>`__ 使用命名空间。"

#, fuzzy
msgid "`#2512 <https://github.com/pgRouting/pgrouting/issues/2512>`__: [Dijkstra] Removing duplicate code on Dijkstra."
msgstr "`#2512 <https://github.com/pgRouting/pgrouting/pull/2512>`__ [Dijkstra] 删除 Dijkstra 上的重复代码。"

#, fuzzy
msgid "`#2517 <https://github.com/pgRouting/pgrouting/issues/2517>`__: Astar code simplification."
msgstr "`#2517 <https://github.com/pgRouting/pgrouting/pull/2517>`__ Astar 代码简化。"

#, fuzzy
msgid "`#2521 <https://github.com/pgRouting/pgrouting/issues/2521>`__: Dijkstra code simplification."
msgstr "`#2521 <https://github.com/pgRouting/pgrouting/pull/2521>`__ Dijkstra 代码简化。"

#, fuzzy
msgid "`#2522 <https://github.com/pgRouting/pgrouting/issues/2522>`__: bdAstar code simplification."
msgstr "`#2522 <https://github.com/pgRouting/pgrouting/pull/2522>`__ bdAstar 代码简化。"

#, fuzzy
msgid "`#2490 <https://github.com/pgRouting/pgrouting/issues/2490>`__: Automatic page history links."
msgstr "`#2490 <https://github.com/pgRouting/pgrouting/pull/2490>`__ 自动页面历史链接。"

msgid "..rubric:: Standardize SQL"
msgstr "..rubric:: 标准化 SQL"

#, fuzzy
msgid "`#2555 <https://github.com/pgRouting/pgrouting/issues/2555>`__: Standardize deprecated messages"
msgstr "`#2555 <https://github.com/pgRouting/pgrouting/pull/2555>`__ 过时信息标准化"

msgid "On new internal function: do not use named parameters and default parameters."
msgstr "新内部函数：不使用命名参数和默认参数。"

msgid "pgRouting 3.5"
msgstr "pgRouting 3.5"

msgid "pgRouting 3.5.1 Release Notes"
msgstr "pgRouting 3.5.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.5.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.5.1%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.5.1 Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.5.1%22>`_"

msgid "Documentation fixes"
msgstr "文档修复"

msgid "Changes on the documentation to the following:"
msgstr "将文件修改如下："

msgid "pgr_degree"
msgstr "pgr_degree"

msgid "pgr_ksp"
msgstr "pgr_ksp"

msgid "Automatic page history links"
msgstr "自动页面历史链接"

msgid "using bootstrap_version 2 because 3+ does not do dropdowns"
msgstr "使用 bootstrap_version 2，因为 3+ 不支持下拉菜单"

msgid "Issue fixes"
msgstr "问题修复"

#, fuzzy
msgid "`#2565 <https://github.com/pgRouting/pgrouting/issues/2565>`__: pgr_lengauerTarjanDominatorTree triggers an assertion"
msgstr "`#2565 <https://github.com/pgRouting/pgrouting/issues/2565>`__ pgr_lengauerTarjanDominatorTree 触发了一个断言"

msgid "SQL enhancements"
msgstr "SQL 增强功能"

#, fuzzy
msgid "`#2561 <https://github.com/pgRouting/pgrouting/issues/2561>`__: Not use wildcards on SQL"
msgstr "`#2561 <https://github.com/pgRouting/pgrouting/issues/2561>`__ 在 SQL 中不使用通配符"

#, fuzzy
msgid "`#2559 <https://github.com/pgRouting/pgrouting/issues/2559>`__: pgtap test using sampledata"
msgstr "`#2559 <https://github.com/pgRouting/pgrouting/issues/2559>`__ pgtap 测试使用 示例数据"

msgid "Build fixes"
msgstr "构建修复"

msgid "Fix winnie build"
msgstr "修复 Winnie 构建"

msgid "Fix clang warnings"
msgstr "修复 clang 警告"

msgid "Grouping headers of postgres readers"
msgstr "将postgres读取器的头部进行分组"

msgid "pgRouting 3.5.0 Release Notes"
msgstr "pgRouting 3.5.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.5.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.5.0%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.5.0 Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.5.0%22>`_"

msgid "Dijkstra"
msgstr "Dijkstra"

msgid "pgRouting 3.4"
msgstr "pgRouting 3.4"

msgid "pgRouting 3.4.2 Release Notes"
msgstr "pgRouting 3.4.2 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.4.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.2%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.4.2Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.2%22>`_"

msgid "`#2394 <https://github.com/pgRouting/pgrouting/issues/2394>`__: pgr_bdAstar accumulates heuristic cost in visited node cost."
msgstr "`#2394 <https://github.com/pgRouting/pgrouting/issues/2394>`__: pgr_bdAstar 在访问的节点成本中累积了启发式成本。"

msgid "`#2427 <https://github.com/pgRouting/pgrouting/issues/2427>`__: pgr_createVerticesTable & pgr_createTopology, variable should be of type Record."
msgstr "`#2427 <https://github.com/pgRouting/pgrouting/issues/2427>`__: pgr_createVerticesTable & pgr_createTopology，变量应为 Record 类型。"

msgid "pgRouting 3.4.1 Release Notes"
msgstr "pgRouting 3.4.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.4.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.1%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.4.1Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.1%22>`_"

msgid "`#2401 <https://github.com/pgRouting/pgrouting/issues/2401>`__: pgRouting 3.4.0 do not build docs when sphinx is too low or missing"
msgstr "`#2401 <https://github.com/pgRouting/pgrouting/issues/2401>`__: pgRouting 3.4.0 在 sphinx 过低或丢失时不构建文档"

msgid "`#2398 <https://github.com/pgRouting/pgrouting/issues/2398>`__: v3.4.0 does not upgrade from 3.3.3"
msgstr "`#2398 <https://github.com/pgRouting/pgrouting/issues/2398>`__: v3.4.0 不能从 3.3.3 升级"

msgid "pgRouting 3.4.0 Release Notes"
msgstr "pgRouting 3.4.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.4.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.0%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.4.0 Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.0%22>`_"

msgid "`#1891 <https://github.com/pgRouting/pgrouting/issues/1891>`__: pgr_ksp doesn't give all correct shortest path"
msgstr "`#1891 <https://github.com/pgRouting/pgrouting/issues/1891>`__: pgr_ksp 没有给出所有正确的最短路径"

msgid "New proposed functions."
msgstr "新提议函数。"

msgid "With points"
msgstr "带点"

msgid "pgr_withPointsVia(One Via)"
msgstr "pgr_withPointsVia(One Via)"

msgid "Turn Restrictions"
msgstr "转向限制"

msgid "Via with turn restrictions"
msgstr "有转向限制的通道"

msgid "pgr_trspVia(One Via)"
msgstr "pgr_trspVia(One Via)"

msgid "pgr_trspVia_withPoints(One Via)"
msgstr "pgr_trspVia_withPoints(One Via)"

msgid "pgr_trsp_withPoints(One to One)"
msgstr "pgr_trsp_withPoints(One to One)"

msgid "pgr_trsp_withPoints(One to Many)"
msgstr "pgr_trsp_withPoints(One to Many)"

msgid "pgr_trsp_withPoints(Many to One)"
msgstr "pgr_trsp_withPoints(Many to One)"

msgid "pgr_trsp_withPoints(Many to Many)"
msgstr "pgr_trsp_withPoints(Many to Many)"

msgid "pgr_trsp_withPoints(Combinations)"
msgstr "pgr_trsp_withPoints(Combinations)"

msgid "Topology"
msgstr "拓扑结构"

msgid "pgr_findCloseEdges(One point)"
msgstr "pgr_findCloseEdges(One point)"

msgid "pgr_findCloseEdges(Many points)"
msgstr "pgr_findCloseEdges(Many points)"

msgid "pgr_cuthillMckeeOrdering"
msgstr "pgr_cuthillMckeeOrdering"

msgid "Unclassified"
msgstr "未分类"

msgid "pgr_hawickCircuits"
msgstr "pgr_hawickCircuits"

msgid "Flow functions"
msgstr "流程函数"

msgid "pgr_maxCardinalityMatch(text)"
msgstr "pgr_maxCardinalityMatch(text)"

msgid "Deprecating: pgr_maxCardinalityMatch(text,boolean)"
msgstr "已弃用： pgr_maxCardinalityMatch(text,boolean)"

msgid "Deprecated Functions"
msgstr "已废弃的函数"

msgid "pgr_trsp(text,integer,float8,integer,float8,boolean,boolean,text)"
msgstr "pgr_trsp(text,integer,float8,integer,float8,boolean,boolean,text)"

msgid "pgr_trspViaEdges(text,integer[],float[],boolean,boolean,text)"
msgstr "pgr_trspViaEdges(text,integer[],float[],boolean,boolean,text)"

msgid "pgRouting 3.3"
msgstr "pgRouting 3.3"

msgid "pgRouting 3.3.5 Release Notes"
msgstr "pgRouting 3.3.5 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.3.5 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.5%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.3.4Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.4%22>`_"

msgid "pgRouting 3.3.4 Release Notes"
msgstr "pgRouting 3.3.4 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.3.4 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.4%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.3.4Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.4%22>`_"

msgid "`#2400 <https://github.com/pgRouting/pgrouting/issues/2400>`__: pgRouting 3.3.3 does not build in focal"
msgstr "`#2400 <https://github.com/pgRouting/pgrouting/issues/2400>`__: pgRouting 3.3.3 在 Focal 上无法构建"

msgid "pgRouting 3.3.3 Release Notes"
msgstr "pgRouting 3.3.3 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.3.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.3%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.3.3Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.3%22>`_"

msgid "Ignoring optional boolean parameter, as the algorithm works only for undirected graphs."
msgstr "忽略可选的布尔参数，因为该算法只适用于无向图。"

msgid "pgRouting 3.3.2 Release Notes"
msgstr "pgRouting 3.3.2 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.3.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.2%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.3.2Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.2%22>`_"

msgid "Revised documentation"
msgstr "修订文档"

msgid "Simplifying table names and table columns, for example:"
msgstr "简化表名和表列，例如："

msgid "``edges`` instead of ``edge_table``"
msgstr "``edges`` 而不是 ``edge_table``"

msgid "Removing unused columns ``category_id`` and ``reverse_category_id``."
msgstr "删除未使用的列 ``category_id`` 和 ``reverse_category_id`` 。"

msgid "``combinations`` instead of ``combinations_table``"
msgstr "``combinations`` 而不是 ``combinations_table``"

msgid "Using PostGIS standard for geometry column."
msgstr "使用 PostGIS 标准的几何列。"

msgid "``geom`` instead of ``the_geom``"
msgstr "``geom`` 而不是 ``the_geom``"

msgid "Avoiding usage of functions that modify indexes, columns etc on tables."
msgstr "避免使用修改表中索引、列等的函数。"

msgid "Using ``pgr_extractVertices`` to create a routing topology"
msgstr "使用 ``pgr_extractVertices`` 创建路由拓扑"

msgid "Restructure of the pgRouting concepts page."
msgstr "pgRouting概念页面的重构。"

msgid "`#2276 <https://github.com/pgRouting/pgrouting/issues/2276>`__: edgeDisjointPaths issues with start_vid and combinations"
msgstr "`#2276 <https://github.com/pgRouting/pgrouting/issues/2276>`__: edgeDisjointPaths 与 start_vid 和组合的问题"

msgid "`#2312 <https://github.com/pgRouting/pgrouting/issues/2312>`__: pgr_extractVertices error when target is not BIGINT"
msgstr "`#2312 <https://github.com/pgRouting/pgrouting/issues/2312>`__: 当目标不是 BIGINT 时 pgr_extractVertices 错误"

msgid "`#2357 <https://github.com/pgRouting/pgrouting/issues/2357>`__: Apply clang-tidy performance-*"
msgstr "`#2357 <https://github.com/pgRouting/pgrouting/issues/2357>`__: 应用 clang-tidy performance-*"

msgid "pgRouting 3.3.1 Release Notes"
msgstr "pgRouting 3.3.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.3.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.1%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.1版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.1%22>`__"

msgid "`#2216 <https://github.com/pgRouting/pgrouting/issues/2216>`__: Warnings when using clang"
msgstr "`#2216 <https://github.com/pgRouting/pgrouting/issues/2216>`__: 使用 clang 时发出警告"

msgid "`#2266 <https://github.com/pgRouting/pgrouting/issues/2266>`__: Error processing restrictions"
msgstr "`#2266 <https://github.com/pgRouting/pgrouting/issues/2266>`__: 处理限制时出错"

msgid "pgRouting 3.3.0 Release Notes"
msgstr "pgRouting 3.3.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.3.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.0%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.8.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.8.0%22>`__"

msgid "`#2057 <https://github.com/pgRouting/pgrouting/issues/2057>`__: trspViaEdges columns in different order"
msgstr "`#2057 <https://github.com/pgRouting/pgrouting/issues/2057>`__: trspViaEdges 列的顺序不同"

msgid "`#2087 <https://github.com/pgRouting/pgrouting/issues/2087>`__: pgr_extractVertices to proposed"
msgstr "`#2087 <https://github.com/pgRouting/pgrouting/issues/2087>`__: pgr_extractVertices 变为提议状态"

msgid "`#2201 <https://github.com/pgRouting/pgrouting/issues/2201>`__: pgr_depthFirstSearch to proposed"
msgstr "`#2201 <https://github.com/pgRouting/pgrouting/issues/2201>`__: pgr_depthFirstSearch 变为提议状态"

msgid "`#2202 <https://github.com/pgRouting/pgrouting/issues/2202>`__: pgr_sequentialVertexColoring to proposed"
msgstr "`#2202 <https://github.com/pgRouting/pgrouting/issues/2202>`__: pgr_sequentialVertexColoring 变为提议状态"

msgid "`#2203 <https://github.com/pgRouting/pgrouting/issues/2203>`__: pgr_dijkstraNear and pgr_dijkstraNearCost to proposed"
msgstr "`#2203 <https://github.com/pgRouting/pgrouting/issues/2203>`__: pgr_dijkstraNear 和 pgr_dijkstraNearCost 变为提议状态"

msgid "Coloring"
msgstr "着色"

msgid "Experimental promoted to Proposed"
msgstr "实验性提升为提议"

msgid "pgr_dijkstraNear(Combinations)"
msgstr "pgr_dijkstraNear(组合)"

msgid "pgr_dijkstraNear(Many to Many)"
msgstr "pgr_dijkstraNear(Many to Many)"

msgid "pgr_dijkstraNear(Many to One)"
msgstr "pgr_dijkstraNear(Many to One)"

msgid "pgr_dijkstraNear(One to Many)"
msgstr "pgr_dijkstraNear(One to Many)"

msgid "pgr_dijkstraNearCost(Combinations)"
msgstr "pgr_dijkstraNearCost(组合)"

msgid "pgr_dijkstraNearCost(Many to Many)"
msgstr "pgr_dijkstraNearCost(Many to Many)"

msgid "pgr_dijkstraNearCost(Many to One)"
msgstr "pgr_dijkstraNearCost(Many to One)"

msgid "pgr_dijkstraNearCost(One to Many)"
msgstr "pgr_dijkstraNearCost(One to Many)"

msgid "pgr_extractVertices"
msgstr "pgr_extractVertices"

msgid "Traversal"
msgstr "遍历"

msgid "pgr_depthFirstSearch(Multiple vertices)"
msgstr "pgr_depthFirstSearch(多个顶点)"

msgid "pgr_depthFirstSearch(Single vertex)"
msgstr "pgr_depthFirstSearch(单个顶点 )"

msgid "pgRouting 3.2"
msgstr "pgRouting 3.2"

msgid "pgRouting 3.2.2 Release Notes"
msgstr "pgRouting 3.2.2 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.2.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.2.2%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.2版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.2%22>`__"

msgid "`#2093 <https://github.com/pgRouting/pgrouting/issues/2093>`__: Compilation on Visual Studio"
msgstr "`#2093 <https://github.com/pgRouting/pgrouting/issues/2093>`__: 在 Visual Studio 上编译"

msgid "`#2189 <https://github.com/pgRouting/pgrouting/issues/2189>`__: Build error on RHEL 7"
msgstr "`#2189 <https://github.com/pgRouting/pgrouting/issues/2189>`__: RHEL 7 上的构建错误"

msgid "pgRouting 3.2.1 Release Notes"
msgstr "pgRouting 3.2.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.2.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.2.1%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.1版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.1%22>`__"

msgid "`#1883 <https://github.com/pgRouting/pgrouting/issues/1883>`__: pgr_TSPEuclidean crashes connection on Windows"
msgstr "`#1883 <https://github.com/pgRouting/pgrouting/issues/1883>`__:pgr_TSPEuclidean 在 Windows 上导致连接崩溃"

msgid "The solution is to use Boost::graph::metric_tsp_approx"
msgstr "解决方案是使用 Boost::graph::metric_tsp_approx"

msgid "To not break user's code the optional parameters related to the TSP Annaeling are ignored"
msgstr "为避免破坏用户代码，与 TSP Annaeling 有关的可选参数将被忽略"

msgid "The function with the annaeling optional parameters is deprecated"
msgstr "带有 annaeling 可选参数的函数已被弃用"

msgid "pgRouting 3.2.0 Release Notes"
msgstr "pgRouting 3.2.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.2.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.2.0%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.8.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.8.0%22>`__"

msgid "`#1850 <https://github.com/pgRouting/pgrouting/issues/1850>`__: Change Boost min version to 1.56"
msgstr "`#1850 <https://github.com/pgRouting/pgrouting/issues/1850>`__: 将 Boost 最低版本更改为 1.56"

msgid "Removing support for Boost v1.53, v1.54 & v1.55"
msgstr "删除对 Boost v1.53、v1.54 和 v1.55 的支持"

msgid "Dijkstra Near"
msgstr "Dijkstra Near"

msgid "pgr_isPlanar"
msgstr "pgr_isPlanar"

msgid "pgr_lengauerTarjanDominatorTree"
msgstr "pgr_lengauerTarjanDominatorTree"

msgid "pgr_makeConnected"
msgstr "pgr_makeConnected"

msgid "Astar"
msgstr "Astar"

msgid "Bidirectional Astar"
msgstr "双向Astar"

msgid "Bidirectional Dijkstra"
msgstr "双向 Dijkstra"

msgid "pgRouting 3.1"
msgstr "pgRouting 3.1"

msgid "pgRouting 3.1.4 Release Notes"
msgstr "pgRouting 3.1.4 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.1.4 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.4%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.3.4Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.4%22>`_"

msgid "Issues fixes"
msgstr "问题修复"

msgid "pgRouting 3.1.3 Release Notes"
msgstr "pgRouting 3.1.3 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.1.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.3%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `Git closed milestone for 3.7.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.3%22>`__"

msgid "`#1825 <https://github.com/pgRouting/pgrouting/issues/1825>`__: Boost versions are not honored"
msgstr "`#1825 <https://github.com/pgRouting/pgrouting/issues/1825>`__: Boost 版本不受支持"

msgid "`#1849 <https://github.com/pgRouting/pgrouting/issues/1849>`__: Boost 1.75.0 geometry \"point_xy.hpp\" build error on macOS environment"
msgstr "`#1849 <https://github.com/pgRouting/pgrouting/issues/1849>`__: macOS 环境中的 Boost 1.75.0 几何“point_xy.hpp”构建错误"

msgid "`#1861 <https://github.com/pgRouting/pgrouting/issues/1861>`__: vrp functions crash server"
msgstr "`#1861 <https://github.com/pgRouting/pgrouting/issues/1861>`__: vrp功能使服务器崩溃"

msgid "pgRouting 3.1.2 Release Notes"
msgstr "pgRouting 3.1.2 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.1.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.2%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.2版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.2%22>`__"

msgid "`#1304 <https://github.com/pgRouting/pgrouting/issues/1304>`__: FreeBSD 12 64-bit crashes on pgr_vrOneDepot tests Experimental Function"
msgstr "`#1304 <https://github.com/pgRouting/pgrouting/issues/1304>`__: FreeBSD 12 64 位在 pgr_vrOneDepot 测试实验函数中崩溃"

msgid "`#1356 <https://github.com/pgRouting/pgrouting/issues/1356>`__: tools/testers/pg_prove_tests.sh fails when PostgreSQL port is not passed"
msgstr "`#1356 <https://github.com/pgRouting/pgrouting/issues/1356>`__: tools/testers/pg_prove_tests.sh 在未传递 PostgreSQL 端口时失败"

msgid "`#1725 <https://github.com/pgRouting/pgrouting/issues/1725>`__: Server crash on pgr_pickDeliver and pgr_vrpOneDepot on openbsd"
msgstr "`#1725 <https://github.com/pgRouting/pgrouting/issues/1725>`__: openbsd上的pgr_pickDeliver和pgr_vrpOneDepot服务器崩溃"

msgid "`#1760 <https://github.com/pgRouting/pgrouting/issues/1760>`__: TSP server crash on ubuntu 20.04 #1760"
msgstr "`#1760 <https://github.com/pgRouting/pgrouting/issues/1760>`__: TSP 服务器在 ubuntu 20.04 上崩溃 #1760"

msgid "`#1770 <https://github.com/pgRouting/pgrouting/issues/1770>`__: Remove warnings when using clang compiler"
msgstr "`#1770 <https://github.com/pgRouting/pgrouting/issues/1770>`__: 删除使用 clang 编译器时的警告"

msgid "pgRouting 3.1.1 Release Notes"
msgstr "pgRouting 3.1.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.1.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.1%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.1版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.1%22>`__"

msgid "`#1733 <https://github.com/pgRouting/pgrouting/issues/1733>`__: pgr_bdAstar fails when source or target vertex does not exist in the graph"
msgstr "`#1733 <https://github.com/pgRouting/pgrouting/issues/1733>`__: 当图中不存在源顶点或目标顶点时，pgr_bdAstar 失败"

msgid "`#1647 <https://github.com/pgRouting/pgrouting/issues/1647>`__: Linear Contraction contracts self loops"
msgstr "`#1647 <https://github.com/pgRouting/pgrouting/issues/1647>`__: 线性收缩收缩自循环"

msgid "`#1640 <https://github.com/pgRouting/pgrouting/issues/1640>`__: pgr_withPoints fails when points_sql is empty"
msgstr "`#1640 <https://github.com/pgRouting/pgrouting/issues/1640>`__: pgr_withPoints 在 points_sql 为空时失败"

msgid "`#1616 <https://github.com/pgRouting/pgrouting/issues/1616>`__: Path evaluation on C++ not updated before the results go back to C"
msgstr "`#1616 <https://github.com/pgRouting/pgrouting/issues/1616>`__: C++ 上的路径评估在结果返回 C 之前没有更新"

msgid "`#1300 <https://github.com/pgRouting/pgrouting/issues/1300>`__: pgr_chinesePostman crash on test data"
msgstr "`#1300 <https://github.com/pgRouting/pgrouting/issues/1300>`__:pgr_chinesePostman 在测试数据上崩溃"

msgid "pgRouting 3.1.0 Release Notes"
msgstr "pgRouting 3.1.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.1.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.0%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.8.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.8.0%22>`__"

msgid "pgr_dijkstra(combinations)"
msgstr "pgr_dijkstra(组合)"

msgid "pgr_dijkstraCost(combinations)"
msgstr "pgr_dijkstraCost(组合)"

msgid "Build changes"
msgstr "构建变更"

msgid "Minimal requirement for Sphinx: version 1.8"
msgstr "对 Sphinx 的最低要求：1.8 版本"

msgid "pgRouting 3.0"
msgstr "pgRouting 3.0"

msgid "pgRouting 3.0.6 Release Notes"
msgstr "pgRouting 3.0.6 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.0.6 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.6%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.8.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.8.0%22>`__"

msgid "pgRouting 3.0.5 Release Notes"
msgstr "pgRouting 3.0.5 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.0.5 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.5%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.8.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.8.0%22>`__"

msgid "Backport issue fixes"
msgstr "回溯问题修复"

msgid "pgRouting 3.0.4 Release Notes"
msgstr "pgRouting 3.0.4 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.0.4 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.4%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.3.4Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.4%22>`_"

msgid "pgRouting 3.0.3 Release Notes"
msgstr "pgRouting 3.0.3 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.0.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.3%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `Git closed milestone for 3.7.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.3%22>`__"

msgid "pgRouting 3.0.2 Release Notes"
msgstr "pgRouting 3.0.2 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.0.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.2%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.2版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.2%22>`__"

msgid "`#1378 <https://github.com/pgRouting/pgrouting/issues/1378>`__: Visual Studio build failing"
msgstr "`#1378 <https://github.com/pgRouting/pgrouting/issues/1378>`__: Visual Studio 构建失败"

msgid "pgRouting 3.0.1 Release Notes"
msgstr "pgRouting 3.0.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.0.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.1%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.1版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.1%22>`__"

msgid "`#232 <https://github.com/pgRouting/pgrouting/issues/232>`__: Honor client cancel requests in C /C++ code"
msgstr "`#232 <https://github.com/pgRouting/pgrouting/issues/232>`__: 在 C /C++ 代码中尊重客户端取消请求"

msgid "pgRouting 3.0.0 Release Notes"
msgstr "pgRouting 3.0.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 3.0.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.0%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求,请访问： `GitHub 4.0.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%204.0.0%22>`__"

msgid "Fixed Issues"
msgstr "问题修复"

msgid "`#1153 <https://github.com/pgRouting/pgrouting/issues/1153>`__: Renamed pgr_eucledianTSP to pgr_TSPeuclidean"
msgstr "`#1153 <https://github.com/pgRouting/pgrouting/issues/1153>`__: 将 pgr_eucledianTSP 更名为 pgr_TSPeuclidean"

msgid "`#1188 <https://github.com/pgRouting/pgrouting/issues/1188>`__: Removed CGAL dependency"
msgstr "`#1188 <https://github.com/pgRouting/pgrouting/issues/1188>`__: 删除了 CGAL 依赖"

msgid "`#1002 <https://github.com/pgRouting/pgrouting/issues/1002>`__: Fixed contraction issues:"
msgstr "`#1002 <https://github.com/pgRouting/pgrouting/issues/1002>`__: 修复收缩问题："

msgid "`#1004 <https://github.com/pgRouting/pgrouting/issues/1004>`__: Contracts when forbidden vertices do not belong to graph"
msgstr "`#1004 <https://github.com/pgRouting/pgrouting/issues/1004>`__: 当禁止的顶点不属于图时的收缩"

msgid "`#1005 <https://github.com/pgRouting/pgrouting/issues/1005>`__: Intermideate results eliminated"
msgstr "`#1005 <https://github.com/pgRouting/pgrouting/issues/1005>`__: 消除中间结果"

msgid "`#1006 <https://github.com/pgRouting/pgrouting/issues/1006>`__: No loss of information"
msgstr "`#1006 <https://github.com/pgRouting/pgrouting/issues/1006>`__: 无信息丢失"

msgid "New Functions"
msgstr "新函数"

msgid "Kruskal family"
msgstr "Kruskal族"

msgid "pgr_kruskal"
msgstr "pgr_kruskal"

msgid "pgr_kruskalBFS"
msgstr "pgr_kruskalBFS"

msgid "pgr_kruskalDD"
msgstr "pgr_kruskalDD"

msgid "pgr_kruskalDFS"
msgstr "pgr_kruskalDFS"

msgid "Prim family"
msgstr "Prim族"

msgid "pgr_prim"
msgstr "pgr_prim"

msgid "pgr_primDD"
msgstr "pgr_primDD"

msgid "pgr_primDFS"
msgstr "pgr_primDFS"

msgid "pgr_primBFS"
msgstr "pgr_primBFS"

msgid "Proposed moved to official on pgRouting"
msgstr "pgRouting 中的提议已升级为正式版本"

msgid "aStar Family"
msgstr "aStar族"

msgid "pgr_aStarCost(One to One)"
msgstr "pgr_aStarCost(One to One)"

msgid "pgr_aStarCost(One to Many)"
msgstr "pgr_aStarCost(One to Many)"

msgid "pgr_aStarCost(Many to One)"
msgstr "pgr_aStarCost(Many to One)"

msgid "pgr_aStarCost(Many to Many)"
msgstr "pgr_aStarCost(Many to Many)"

msgid "pgr_aStarCostMatrix"
msgstr "pgr_aStarCostMatrix"

msgid "bdAstar Family"
msgstr "bdAstar 族"

msgid "pgr_bdAstarCost(One to One)"
msgstr "pgr_bdAstarCost(One to One)"

msgid "pgr_bdAstarCost(One to Many)"
msgstr "pgr_bdAstarCost(One to Many)"

msgid "pgr_bdAstarCost(Many to One)"
msgstr "pgr_bdAstarCost(Many to One)"

msgid "pgr_bdAstarCost(Many to Many)"
msgstr "pgr_bdAstarCost(Many to Many)"

msgid "pgr_bdAstarCostMatrix"
msgstr "pgr_bdAstarCostMatrix"

msgid "bdDijkstra Family"
msgstr "bdDijkstra族"

msgid "pgr_bdDijkstraCost(One to One)"
msgstr "pgr_bdDijkstraCost(One to One)"

msgid "pgr_bdDijkstraCost(One to Many)"
msgstr "pgr_bdDijkstraCost(One to Many)"

msgid "pgr_bdDijkstraCost(Many to One)"
msgstr "pgr_bdDijkstraCost(Many to One)"

msgid "pgr_bdDijkstraCost(Many to Many)"
msgstr "pgr_bdDijkstraCost(Many to Many)"

msgid "pgr_bdDijkstraCostMatrix"
msgstr "pgr_bdDijkstraCostMatrix"

msgid "Flow Family"
msgstr "Flow族"

msgid "pgr_pushRelabel(One to One)"
msgstr "pgr_pushRelabel(One to One)"

msgid "pgr_pushRelabel(One to Many)"
msgstr "pgr_pushRelabel(One to Many)"

msgid "pgr_pushRelabel(Many to One)"
msgstr "pgr_pushRelabel(Many to One)"

msgid "pgr_pushRelabel(Many to Many)"
msgstr "pgr_pushRelabel(Many to Many)"

msgid "pgr_edmondsKarp(One to One)"
msgstr "pgr_edmondsKarp(One to One)"

msgid "pgr_edmondsKarp(One to Many)"
msgstr "pgr_edmondsKarp(One to Many)"

msgid "pgr_edmondsKarp(Many to One)"
msgstr "pgr_edmondsKarp(Many to One)"

msgid "pgr_edmondsKarp(Many to Many)"
msgstr "pgr_edmondsKarp(Many to Many)"

msgid "pgr_boykovKolmogorov (One to One)"
msgstr "pgr_boykovKolmogorov (One to One)"

msgid "pgr_boykovKolmogorov (One to Many)"
msgstr "pgr_boykovKolmogorov (One to Many)"

msgid "pgr_boykovKolmogorov (Many to One)"
msgstr "pgr_boykovKolmogorov (Many to One)"

msgid "pgr_boykovKolmogorov (Many to Many)"
msgstr "pgr_boykovKolmogorov (Many to Many)"

msgid "pgr_maxCardinalityMatching"
msgstr "pgr_maxCardinalityMatching"

msgid "pgr_edgeDisjointPaths(One to One)"
msgstr "pgr_edgeDisjointPaths(One to One)"

msgid "pgr_edgeDisjointPaths(One to Many)"
msgstr "pgr_edgeDisjointPaths(One to Many)"

msgid "pgr_edgeDisjointPaths(Many to One)"
msgstr "pgr_edgeDisjointPaths(Many to One)"

msgid "pgr_edgeDisjointPaths(Many to Many)"
msgstr "pgr_edgeDisjointPaths(Many to Many)"

msgid "Components family"
msgstr "分量族"

msgid "pgr_connectedComponents"
msgstr "pgr_connectedComponents"

msgid "pgr_strongComponents"
msgstr "pgr_strongComponents"

msgid "pgr_biconnectedComponents"
msgstr "pgr_biconnectedComponents"

msgid "pgr_articulationPoints"
msgstr "pgr_articulationPoints"

msgid "pgr_bridges"
msgstr "pgr_bridges"

msgid "Contraction:"
msgstr "收缩："

msgid "Removed unnecessary column seq"
msgstr "删除了不必要的列 seq"

msgid "Bug Fixes"
msgstr "Bug修复"

msgid "pgr_maxFlowMinCost"
msgstr "pgr_maxFlowMinCost"

msgid "pgr_maxFlowMinCost_Cost"
msgstr "pgr_maxFlowMinCost_Cost"

msgid "pgr_dagShortestpath"
msgstr "pgr_dagShortestpath"

msgid "VRP category"
msgstr "VRP（车辆路径问题）类别"

msgid "pgr_pickDeliverEuclidean"
msgstr "pgr_pickDeliverEuclidean"

msgid "pgr_pickDeliver"
msgstr "pgr_pickDeliver"

msgid "Chinese Postman family"
msgstr "中国邮递员问题族"

msgid "pgr_chinesePostman"
msgstr "pgr_chinesePostman"

msgid "pgr_chinesePostmanCost"
msgstr "pgr_chinesePostmanCost"

msgid "Breadth First Search family"
msgstr "广度优先搜索族"

msgid "Bellman Ford family"
msgstr "Bellman Ford族"

msgid "Moved to legacy"
msgstr "已移至旧版"

msgid "pgr_labelGraph - Use the components family of functions instead."
msgstr "使用连通分量函数族替代 pgr_labelGraph。"

msgid "Max flow - functions were renamed on v2.5.0"
msgstr "Max flow - 2.5.0 版对函数进行了重命名"

msgid "pgr_maxFlowPushRelabel"
msgstr "pgr_maxFlowPushRelabel"

msgid "pgr_maxFlowBoykovKolmogorov"
msgstr "pgr_maxFlowBoykovKolmogorov"

msgid "pgr_maxFlowEdmondsKarp"
msgstr "pgr_maxFlowEdmondsKarp"

msgid "pgr_maximumcardinalitymatching"
msgstr "pgr_maximumcardinalitymatching"

msgid "VRP"
msgstr "VRP（车辆路径问题）"

msgid "pgr_gsoc_vrppdtw"
msgstr "pgr_gsoc_vrppdtw"

msgid "TSP old signatures"
msgstr "TSP 旧签名"

msgid "pgr_pointsAsPolygon"
msgstr "pgr_pointsAsPolygon"

msgid "pgr_alphaShape old signature"
msgstr "pgr_alphaShape 旧签名"

msgid "pgRouting 2"
msgstr "pgRouting 2"

msgid "Minors 2.x"
msgstr "2.x小版本"

msgid "pgRouting 2.6"
msgstr "pgRouting 2.6"

msgid "pgRouting 2.6.3 Release Notes"
msgstr "pgRouting 2.6.3 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.6.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.6.3%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.6.3版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.3%22>`__"

#, fuzzy
msgid "`#1219 <https://github.com/pgRouting/pgrouting/issues/1219>`__: Implicit cast for via_path integer to text"
msgstr "`#1219 <https://github.com/pgRouting/pgrouting/pull/1219>`__ via_path 整数到文本的隐式转换"

#, fuzzy
msgid "`#1193 <https://github.com/pgRouting/pgrouting/issues/1193>`__: Fixed pgr_pointsAsPolygon breaking when comparing strings in WHERE clause"
msgstr "`#1193 <https://github.com/pgRouting/pgrouting/pull/1193>`__ 修复了比较 WHERE 子句中的字符串时 pgr_pointsAsPolygon 中断的问题"

#, fuzzy
msgid "`#1185 <https://github.com/pgRouting/pgrouting/issues/1185>`__: Improve FindPostgreSQL.cmake"
msgstr "`#1185 <https://github.com/pgRouting/pgrouting/pull/1185>`__ 改进 FindPostgreSQL.cmake"

msgid "pgRouting 2.6.2 Release Notes"
msgstr "pgRouting 2.6.2 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.6.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.6.2%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `Git closed milestone for 3.6.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.2%22>`__"

#, fuzzy
msgid "`#1152 <https://github.com/pgRouting/pgrouting/issues/1152>`__: Fixes driving distance when vertex is not part of the graph"
msgstr "`#1152 <https://github.com/pgRouting/pgrouting/issues/1152>`__ 修复了顶点不属于图时的行驶距离问题"

#, fuzzy
msgid "`#1098 <https://github.com/pgRouting/pgrouting/issues/1098>`__: Fixes windows test"
msgstr "`#1098 <https://github.com/pgRouting/pgrouting/issues/1098>`__ 修复 Windows 测试"

#, fuzzy
msgid "`#1165 <https://github.com/pgRouting/pgrouting/issues/1165>`__: Fixes build for python3 and perl5"
msgstr "`#1165 <https://github.com/pgRouting/pgrouting/issues/1165>`__ 修复了 python3 和 perl5 的构建问题"

msgid "pgRouting 2.6.1 Release Notes"
msgstr "pgRouting 2.6.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.6.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.6.1%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.6.1Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.1%22>`_"

msgid "Fixes server crash on several functions."
msgstr "修复了多个函数导致服务器崩溃的问题。"

msgid "pgr_floydWarshall"
msgstr "pgr_floydWarshall"

msgid "pgr_johnson"
msgstr "pgr_johnson"

msgid "pgr_bdDijstra"
msgstr "pgr_bdDijstra"

msgid "pgr_alphashape"
msgstr "pgr_alphashape"

msgid "pgr_dijkstraCostMatrix"
msgstr "pgr_dijkstraCostMatrix"

msgid "pgr_drivingDistance"
msgstr "pgr_drivingDistance"

msgid "pgr_dijkstraVia (proposed)"
msgstr "pgr_dijkstraVia (提议)"

msgid "pgr_boykovKolmogorov (proposed)"
msgstr "pgr_boykovKolmogorov (提议)"

msgid "pgr_edgeDisjointPaths (proposed)"
msgstr "pgr_edgeDisjointPaths （提议）"

msgid "pgr_edmondsKarp (proposed)"
msgstr "pgr_edmondsKarp (提议)"

msgid "pgr_maxCardinalityMatch (proposed)"
msgstr "pgr_maxCardinalityMatch （提议）"

msgid "pgr_maxFlow (proposed)"
msgstr "pgr_maxFlow （提议）"

msgid "pgr_withPoints (proposed)"
msgstr "pgr_withPoints （提议）"

msgid "pgr_withPointsCost (proposed)"
msgstr "pgr_withPointsCost （提议）"

msgid "pgr_withPointsKSP (proposed)"
msgstr "pgr_withPointsKSP（提议）"

msgid "pgr_withPointsDD (proposed)"
msgstr "pgr_withPointsDD （提议）"

msgid "pgr_withPointsCostMatrix (proposed)"
msgstr "pgr_withPointsCostMatrix （提议）"

msgid "pgr_contractGraph (experimental)"
msgstr "pgr_contractGraph （实验性）"

msgid "pgr_pushRelabel (experimental)"
msgstr "pgr_pushRelabel （实验性）"

msgid "pgr_vrpOneDepot (experimental)"
msgstr "pgr_vrpOneDepot （实验性）"

msgid "pgr_gsoc_vrppdtw (experimental)"
msgstr "pgr_gsoc_vrppdtw （实验性）"

msgid "Fixes for deprecated functions where also applied but not tested"
msgstr "修复了已应用但未测试的已弃用函数"

msgid "Removed compilation warning for g++8"
msgstr "删除了 g++8 的编译警告"

msgid "Fixed a fallthrugh on Astar and bdAstar."
msgstr "修复了 Astar 和 bdAstar 上的一个故障。"

msgid "pgRouting 2.6.0 Release Notes"
msgstr "pgRouting 2.6.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.6.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.6.0%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请访问 `Git 3.6.0 里程碑的已关闭问题和拉取请求 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.0%22>`_"

msgid "pgr_lineGraphFull"
msgstr "pgr_lineGraphFull"

msgid "Fix pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean[,text])"
msgstr "修复pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean[,text])"

msgid "without restrictions"
msgstr "无限制"

msgid "calls pgr_dijkstra when both end points have a fraction IN (0,1)"
msgstr "当两个端点的分数都在 (0,1) 内时，调用 pgr_dijkstra"

msgid "calls pgr_withPoints when at least one fraction NOT IN (0,1)"
msgstr "当至少有一个分数不在 (0,1) 范围内时，调用 pgr_withPoints"

msgid "with restrictions"
msgstr "有限制"

msgid "calls original trsp code"
msgstr "调用原始 TRSP 代码"

msgid "Internal code"
msgstr "内部代码"

msgid "Cleaned the internal code of trsp(text,integer,integer,boolean,boolean [, text])"
msgstr "清除了 trsp(text,integer,integer,boolean,boolean [, text]) 的内部代码"

msgid "Removed the use of pointers"
msgstr "删除了指针的使用"

msgid "Internal code can accept BIGINT"
msgstr "内部代码可接受 BIGINT"

msgid "Cleaned the internal code of withPoints"
msgstr "清理了 withPoints 的内部代码"

msgid "pgRouting 2.5"
msgstr "pgRouting 2.5"

msgid "pgRouting 2.5.5 Release Notes"
msgstr "pgRouting 2.5.5 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.5.5 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.5%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.5.1 Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.5.1%22>`_"

msgid "Fixes driving distance when vertex is not part of the graph"
msgstr "修复顶点不在图中时的行驶距离问题"

msgid "Fixes windows test"
msgstr "修复 windows测试"

msgid "Fixes build for python3 and perl5"
msgstr "修复了 python3 和 perl5 的构建问题"

msgid "pgRouting 2.5.4 Release Notes"
msgstr "pgRouting 2.5.4 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.5.4 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.4%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.3.4Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.4%22>`_"

msgid "pgRouting 2.5.3 Release Notes"
msgstr "pgRouting 2.5.3 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.5.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.3%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `Git closed milestone for 3.7.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.3%22>`__"

msgid "Fix for postgresql 11: Removed a compilation error when compiling with postgreSQL"
msgstr "postgresql 11 的修复：删除了与 postgreSQL 一起编译时出现的编译错误"

msgid "pgRouting 2.5.2 Release Notes"
msgstr "pgRouting 2.5.2 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.5.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.2%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.2版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.2%22>`__"

msgid "Fix for postgresql 10.1: Removed a compiler condition"
msgstr "postgresql 10.1 的修复：删除了一个编译器条件"

msgid "pgRouting 2.5.1 Release Notes"
msgstr "pgRouting 2.5.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.5.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.1%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.5.1 Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.5.1%22>`_"

msgid "Fixed prerequisite minimum version of: cmake"
msgstr "修正了 cmake 的最低版本要求"

msgid "pgRouting 2.5.0 Release Notes"
msgstr "pgRouting 2.5.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.5.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.0%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.5.0 Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.5.0%22>`_"

msgid "enhancement:"
msgstr "增强："

msgid "pgr_version is now on SQL language"
msgstr "pgr_version 现在使用 SQL 语言"

msgid "Breaking change on:"
msgstr "重大变更："

msgid "pgr_edgeDisjointPaths:"
msgstr "pgr_edgeDisjointPaths："

msgid "Added path_id, cost and agg_cost columns on the result"
msgstr "在结果中添加了 path_id、cost 和 agg_cost 列"

msgid "Parameter names changed"
msgstr "更改参数名称"

msgid "The many version results are the union of the One to One version"
msgstr "多版本结果是一对一版本的并集"

msgid "New Signatures"
msgstr "新签名"

msgid "pgr_bdAstar(One to One)"
msgstr "pgr_bdAstar(One to One)"

msgid "pgr_lineGraph"
msgstr "pgr_lineGraph"

msgid "pgr_bdastar - use pgr_bdAstar instead"
msgstr "pgr_bdastar - 使用 pgr_bdAstar 代替"

msgid "Renamed functions"
msgstr "重新命名的功能"

msgid "pgr_maxFlowPushRelabel - use pgr_pushRelabel instead"
msgstr "pgr_maxFlowPushRelabel - 使用 pgr_pushRelabel 代替"

msgid "pgr_maxFlowEdmondsKarp -use pgr_edmondsKarp instead"
msgstr "pgr_maxFlowEdmondsKarp - 使用 pgr_edmondsKarp 代替"

msgid "pgr_maxFlowBoykovKolmogorov - use pgr_boykovKolmogorov instead"
msgstr "pgr_maxFlowBoykovKolmogorov - 使用 pgr_boykovKolmogorov代替"

msgid "pgr_maximumCardinalityMatching - use pgr_maxCardinalityMatch instead"
msgstr "pgr_maximumCardinalityMatching - 使用 pgr_maximumCardinalityMatch 代替"

msgid "Deprecated Function"
msgstr "已废弃的功能"

msgid "pgr_pointToEdgeNode"
msgstr "pgr_pointToEdgeNode"

msgid "pgRouting 2.4"
msgstr "pgRouting 2.4"

msgid "pgRouting 2.4.2 Release Notes"
msgstr "pgRouting 2.4.2 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.4.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.4.2%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.4.2Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.2%22>`_"

msgid "Improvement"
msgstr "改进"

msgid "Works for postgreSQL 10"
msgstr "适用于 postgreSQL 10"

msgid "Fixed: Unexpected error column \"cname\""
msgstr "已修复：列 \"cname \"出现意外错误"

msgid "Replace __linux__ with __GLIBC__ for glibc-specific headers and functions"
msgstr "将 __linux__ 替换为 __GLIBC__ 以获取 glibc 特定的标头和函数"

msgid "pgRouting 2.4.1 Release Notes"
msgstr "pgRouting 2.4.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.4.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.4.1%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.4.1Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.1%22>`_"

msgid "Fixed compiling error on macOS"
msgstr "修正了 macOS 上的编译错误"

msgid "Condition error on pgr_withPoints"
msgstr "pgr_withPoints 上的条件错误"

msgid "pgRouting 2.4.0 Release Notes"
msgstr "pgRouting 2.4.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.4.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.4.0%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.4.0 Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.0%22>`_"

msgid "Deprecated signatures."
msgstr "已废弃的签名。"

msgid "pgr_bddijkstra - use pgr_bdDijkstra instead"
msgstr "pgr_bddijkstra - 使用 pgr_bdDijkstra代替"

msgid "pgr_pointsToVids"
msgstr "pgr_pointsToVids"

msgid "Bug fixes on proposed functions"
msgstr "提议函数的Bug修复"

msgid "pgr_withPointsKSP: fixed ordering"
msgstr "pgr_withPointsKSP:修复了排序问题"

msgid "TRSP original code is used with no changes on the compilation warnings"
msgstr "使用 TRSP 原始代码，未对编译警告进行任何修改"

msgid "pgRouting 2.3"
msgstr "pgRouting 2.3"

msgid "pgRouting 2.3.2 Release Notes"
msgstr "pgRouting 2.3.2 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.3.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.3.2%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.3.2Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.2%22>`_"

msgid "Fixed pgr_gsoc_vrppdtw crash when all orders fit on one truck."
msgstr "修正了当所有订单都装在一辆卡车上时 pgr_gsoc_vrppdtw 崩溃的问题。"

msgid "Fixed pgr_trsp:"
msgstr "修正了 pgr_trsp："

msgid "Alternate code is not executed when the point is in reality a vertex"
msgstr "当实际上的点是一个顶点时，替代代码不会被执行"

msgid "Fixed ambiguity on seq"
msgstr "修正了 seq 上的歧义"

msgid "pgRouting 2.3.1 Release Notes"
msgstr "pgRouting 2.3.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.3.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.3.1%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.1版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.1%22>`__"

msgid "Leaks on proposed max_flow functions"
msgstr "提议 max_flow 函数的泄漏问题"

msgid "Regression error on pgr_trsp"
msgstr "pgr_trsp出现的回归错误"

msgid "Types discrepancy on pgr_createVerticesTable"
msgstr "pgr_createVerticesTable 上的类型差异"

msgid "pgRouting 2.3.0 Release Notes"
msgstr "pgRouting 2.3.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.3.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.3.0%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求,请访问： `GitHub 4.0.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%204.0.0%22>`__"

msgid "pgr_eucledianTSP"
msgstr "pgr_eucledianTSP"

msgid "pgr_maxFlowPushRelabel(One to One)"
msgstr "pgr_maxFlowPushRelabel(One to One)"

msgid "pgr_maxFlowPushRelabel(One to Many)"
msgstr "pgr_maxFlowPushRelabel(One to Many)"

msgid "pgr_maxFlowPushRelabel(Many to One)"
msgstr "pgr_maxFlowPushRelabel(Many to One)"

msgid "pgr_maxFlowPushRelabel(Many to Many)"
msgstr "pgr_maxFlowPushRelabel(Many to Many)"

msgid "pgr_maxFlowEdmondsKarp(One to One)"
msgstr "pgr_maxFlowEdmondsKarp(One to One)"

msgid "pgr_maxFlowEdmondsKarp(One to Many)"
msgstr "pgr_maxFlowEdmondsKarp(One to Many)"

msgid "pgr_maxFlowEdmondsKarp(Many to One)"
msgstr "pgr_maxFlowEdmondsKarp(Many to One)"

msgid "pgr_maxFlowEdmondsKarp(Many to Many)"
msgstr "pgr_maxFlowEdmondsKarp(Many to Many)"

msgid "pgr_maxFlowBoykovKolmogorov (One to One)"
msgstr "pgr_maxFlowBoykovKolmogorov (One to One)"

msgid "pgr_maxFlowBoykovKolmogorov (One to Many)"
msgstr "pgr_maxFlowBoykovKolmogorov (One to Many)"

msgid "pgr_maxFlowBoykovKolmogorov (Many to One)"
msgstr "pgr_maxFlowBoykovKolmogorov (Many to One)"

msgid "pgr_maxFlowBoykovKolmogorov (Many to Many)"
msgstr "pgr_maxFlowBoykovKolmogorov (Many to Many)"

msgid "pgr_maximumCardinalityMatching"
msgstr "pgr_maximumCardinalityMatching"

msgid "pgr_contractGraph"
msgstr "pgr_contractGraph"

msgid "pgr_tsp - use pgr_TSP or pgr_eucledianTSP instead"
msgstr "pgr_tsp - 使用 pgr_TSP 或 pgr_eucledianTSP 代替"

msgid "pgr_aStar - use pgr_aStar instead"
msgstr "pgr_aStar - 使用 pgr_aStar 代替"

msgid "pgr_flip_edges"
msgstr "pgr_flip_edges"

msgid "pgr_vidsToDmatrix"
msgstr "pgr_vidsToDmatrix"

msgid "pgr_pointsToDMatrix"
msgstr "pgr_pointsToDMatrix"

msgid "pgr_textToPoints"
msgstr "pgr_textToPoints"

msgid "pgRouting 2.2"
msgstr "pgRouting 2.2"

msgid "pgRouting 2.2.4 Release Notes"
msgstr "pgRouting 2.2.4 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.2.4 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.2.4%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `3.3.4Git 关闭里程碑 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.4%22>`_"

msgid "Bogus uses of extern \"C\""
msgstr "无效的extern \"C\""

msgid "Build error on Fedora 24 + GCC 6.0"
msgstr "Fedora 24 + GCC 6.0 上的构建错误"

msgid "Regression error pgr_nodeNetwork"
msgstr "pgr_nodeNetwork的回归错误"

msgid "pgRouting 2.2.3 Release Notes"
msgstr "pgRouting 2.2.3 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.2.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.2.3%22>`__"
msgstr "要查看此版本关闭的所有问题和拉取请求，请参阅 `Git closed milestone for 3.7.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.3%22>`__"

msgid "Fixed compatibility issues with PostgreSQL 9.6."
msgstr "修复了 PostgreSQL 9.6 的兼容性问题。"

msgid "pgRouting 2.2.2 Release Notes"
msgstr "pgRouting 2.2.2 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.2.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.2.2%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.2版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.2%22>`__"

msgid "Fixed regression error on pgr_drivingDistance"
msgstr "修正了 pgr_drivingDistance 的回归错误"

msgid "pgRouting 2.2.1 Release Notes"
msgstr "pgRouting 2.2.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.2.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.2.1%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.1版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.1%22>`__"

msgid "Server crash fix on pgr_alphaShape"
msgstr "修复 pgr_alphaShape 使服务器崩溃问题"

msgid "Bug fix on With Points family of functions"
msgstr "在 With Points 函数族中的Bug修复"

msgid "pgRouting 2.2.0 Release Notes"
msgstr "pgRouting 2.2.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.2.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.2.0%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求,请访问： `GitHub 4.0.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%204.0.0%22>`__"

msgid "Improvements"
msgstr "改进"

msgid "pgr_nodeNetwork"
msgstr "pgr_nodeNetwork"

msgid "Adding a row_where and outall optional parameters"
msgstr "添加 row_where 和 outall 可选参数"

msgid "Signature fix"
msgstr "签名修复"

msgid "pgr_dijkstra -- to match what is documented"
msgstr "pgr_dijkstra -- 与文档中的内容相匹配"

msgid "pgr_Johnson"
msgstr "pgr_Johnson"

msgid "pgr_dijkstraCost(One to One)"
msgstr "pgr_dijkstraCost(One to One)"

msgid "pgr_dijkstraCost(One to Many)"
msgstr "pgr_dijkstraCost(One to Many)"

msgid "pgr_dijkstraCost(Many to One)"
msgstr "pgr_dijkstraCost(Many to One)"

msgid "pgr_dijkstraCost(Many to Many)"
msgstr "pgr_dijkstraCost(Many to Many)"

msgid "Proposed Functionality"
msgstr "建议的功能"

msgid "pgr_withPoints(One to One)"
msgstr "pgr_withPoints(One to One)"

msgid "pgr_withPoints(One to Many)"
msgstr "pgr_withPoints(One to Many)"

msgid "pgr_withPoints(Many to One)"
msgstr "pgr_withPoints(Many to One)"

msgid "pgr_withPoints(Many to Many)"
msgstr "pgr_withPoints(Many to Many)"

msgid "pgr_withPointsCost(One to One)"
msgstr "pgr_withPointsCost(One to One)"

msgid "pgr_withPointsCost(One to Many)"
msgstr "pgr_withPointsCost(One to Many)"

msgid "pgr_withPointsCost(Many to One)"
msgstr "pgr_withPointsCost(Many to One)"

msgid "pgr_withPointsCost(Many to Many)"
msgstr "pgr_withPointsCost(Many to Many)"

msgid "pgr_withPointsDD(single vertex)"
msgstr "pgr_withPointsDD(单个顶点)"

msgid "pgr_withPointsDD(multiple vertices)"
msgstr "pgr_withPointsDD(多个顶点)"

msgid "pgr_apspWarshall use pgr_floydWarshall instead"
msgstr "pgr_apspWarshall 改用 pgr_floydWarshall"

msgid "pgr_apspJohnson use pgr_Johnson instead"
msgstr "pgr_apspJohnson 改用 pgr_Johnson"

msgid "pgr_kDijkstraCost use pgr_dijkstraCost instead"
msgstr "pgr_kDijkstraCost 改用 pgr_dijkstraCost"

msgid "pgr_kDijkstraPath use pgr_dijkstra instead"
msgstr "pgr_kDijkstraPath 改用 pgr_dijkstra"

msgid "Renamed and Deprecated Function"
msgstr "已更名和废弃的函数"

msgid "pgr_makeDistanceMatrix renamed to _pgr_makeDistanceMatrix"
msgstr "pgr_makeDistanceMatrix 更名为 _pgr_makeDistanceMatrix"

msgid "pgRouting 2.1"
msgstr "pgRouting 2.1"

msgid "pgRouting 2.1.0 Release Notes"
msgstr "pgRouting 2.1.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.1.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.1.0%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求,请访问： `GitHub 4.0.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%204.0.0%22>`__"

msgid "Refactored"
msgstr "重构"

msgid "pgr_dijkstra(One to One)"
msgstr "pgr_dijkstra(One to One)"

msgid "pgr_alphaShape function now can generate better (multi)polygon with holes and alpha parameter."
msgstr "pgr_alphaShape 函数现在可以生成带有孔和 alpha 参数的更好的（多）多边形。"

msgid "Proposed functions from Steve Woodbridge, (Classified as Convenience by the author.)"
msgstr "Steve Woodbridge 提出的函数（作者分类为便利性函数。）"

msgid "pgr_pointToEdgeNode - convert a point geometry to a vertex_id based on closest edge."
msgstr "pgr_pointToEdgeNode - 根据最近的边将点几何体转换为基于 vertex_id 的函数。"

msgid "pgr_flipEdges - flip the edges in an array of geometries so the connect end to end."
msgstr "pgr_flipEdges - 翻转几何体数组中的边，以便它们端对端连接。"

msgid "pgr_textToPoints - convert a string of x,y;x,y;... locations into point geometries."
msgstr "pgr_textToPoints - 将一串 x,y;x,y;... 位置字符串转换为点几何体。"

msgid "pgr_pointsToVids - convert an array of point geometries into vertex ids."
msgstr "pgr_pointsToVids - 将点几何数组转换为顶点id。"

msgid "pgr_pointsToDMatrix - Create a distance matrix from an array of points."
msgstr "pgr_pointsToDMatrix - 从点数组创建距离矩阵。"

msgid "pgr_vidsToDMatrix - Create a distance matrix from an array of vertix_id."
msgstr "pgr_vidsToDMatrix - 从 vertix_id 数组创建距离矩阵。"

msgid "Added proposed functions from GSoc Projects:"
msgstr "添加了 GSoc 项目的提议函数："

msgid "pgr_vrppdtw"
msgstr "pgr_vrppdtw"

msgid "pgr_vrponedepot"
msgstr "pgr_vrponedepot"

msgid "pgr_getColumnName"
msgstr "pgr_getColumnName"

msgid "pgr_getTableName"
msgstr "pgr_getTableName"

msgid "pgr_isColumnCndexed"
msgstr "pgr_isColumnCndexed"

msgid "pgr_isColumnInTable"
msgstr "pgr_isColumnInTable"

msgid "pgr_quote_ident"
msgstr "pgr_quote_ident"

msgid "pgr_versionless"
msgstr "pgr_versionless"

msgid "pgr_startPoint"
msgstr "pgr_startPoint"

msgid "pgr_endPoint"
msgstr "pgr_endPoint"

msgid "pgr_pointToId"
msgstr "pgr_pointToId"

msgid "No longer supported"
msgstr "不再支持"

msgid "Removed the 1.x legacy functions"
msgstr "删除了 1.x 版遗留函数"

msgid "Some bug fixes in other functions"
msgstr "修复了其他函数中的一些bug"

msgid "Refactoring Internal Code"
msgstr "重构内部代码"

msgid "A C and C++ library for developer was created"
msgstr "为开发人员创建了一个 C 和 C++ 库"

msgid "encapsulates postgreSQL related functions"
msgstr "封装了与 postgreSQL 相关的函数"

msgid "encapsulates Boost.Graph graphs"
msgstr "封装了 Boost.Graph 图"

msgid "Directed Boost.Graph"
msgstr "有向 Boost.Graph"

msgid "Undirected Boost.graph."
msgstr "无向 Boost.graph。"

msgid "allow any-integer in the id's"
msgstr "允许任何整数作为id"

msgid "allow any-numerical on the cost/reverse_cost columns"
msgstr "允许在 cost/reverse_cost 列中使用任何数值"

msgid "Instead of generating many libraries: - All functions are encapsulated in one library - The library has the prefix 2-1-0"
msgstr "无需生成多个程序库： - 所有功能都封装在一个程序库中 - 程序库的前缀为 2-1-0"

msgid "pgRouting 2.0"
msgstr "pgRouting 2.0"

msgid "pgRouting 2.0.1 Release Notes"
msgstr "pgRouting 2.0.1 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.0.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.0.1%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求，请访问： `GitHub 3.7.1版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.1%22>`__"

msgid "Minor bug fixes."
msgstr "小bug修复。"

msgid "No track of the bug fixes were kept."
msgstr "没有记录错误修复情况。"

msgid "pgRouting 2.0.0 Release Notes"
msgstr "pgRouting 2.0.0 发布说明"

#, fuzzy
msgid "To see all issues & pull requests closed by this release see the `Github milestone for 2.0.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.0.0%22>`__"
msgstr "查看本版本已关闭的所有议题和拉取请求,请访问： `GitHub 4.0.0版本里程碑关闭列表 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%204.0.0%22>`__"

msgid "With the release of pgRouting 2.0.0 the library has abandoned backwards compatibility to `pgRouting 1.0`_ releases. The main Goals for this release are:"
msgstr "随着 pgRouting 2.0.0 的发布，该库已放弃向后兼容 `pgRouting 1.0`_ 版本。此版本的主要目标是："

msgid "Major restructuring of pgRouting."
msgstr "对 pgRouting 进行重大重组。"

msgid "Standardization of the function naming"
msgstr "函数命名标准化"

msgid "Preparation of the project for future development."
msgstr "为项目的未来发展做好准备。"

msgid "As a result of this effort:"
msgstr "作为这一努力的结果："

msgid "pgRouting has a simplified structure"
msgstr "pgRouting 具有简化的结构"

msgid "Significant new functionality has being added"
msgstr "新增重要函数"

msgid "Documentation has being integrated"
msgstr "文件已整合"

msgid "Testing has being integrated"
msgstr "测试已经被整合"

msgid "And made it easier for multiple developers to make contributions."
msgstr "并使多个开发人员更容易做出贡献。"

msgid "Important Changes"
msgstr "重要变更"

msgid "Graph Analytics - tools for detecting and fixing connection some problems in a graph"
msgstr "图分析--用于检测和修复图中某些连接问题的工具"

msgid "A collection of useful utility functions"
msgstr "一组有用的实用函数"

msgid "Two new All Pairs Short Path algorithms (pgr_apspJohnson, pgr_apspWarshall)"
msgstr "两种新的全对最短路径算法（pgr_apspJohnson 和 pgr_apspWarshall）"

msgid "Bi-directional Dijkstra and A-star search algorithms (pgr_bdAstar, pgr_bdDijkstra)"
msgstr "双向 Dijkstra 和 A-star 搜索算法 (pgr_bdAstar, pgr_bdDijkstra)"

msgid "One to many nodes search (pgr_kDijkstra)"
msgstr "一对多节点的搜索 (pgr_kDijkstra)"

msgid "K alternate paths shortest path (pgr_ksp)"
msgstr "K 条备选路径最短路径（pgr_ksp）"

msgid "New TSP solver that simplifies the code and the build process (pgr_tsp), dropped \"Gaul Library\" dependency"
msgstr "新的 TSP 求解器简化了代码和构建过程（pgr_tsp），放弃了对 \"Gaul 库 \"的依赖"

msgid "Turn Restricted shortest path (pgr_trsp) that replaces Shooting Star"
msgstr "取代了 Shooting Star的转向受限最短路径（pgr_trsp）"

msgid "Dropped support for Shooting Star"
msgstr "放弃对 Shooting Star的支持"

msgid "Built a test infrastructure that is run before major code changes are checked in"
msgstr "构建了在签入主要代码更改之前运行的测试基础架构"

msgid "Tested and fixed most all of the outstanding bugs reported against 1.x that existing in the 2.0-dev code base."
msgstr "测试并修复了 2.0-dev 代码库中存在的几乎所有已报告的 1.x 版本中的未解决问题。"

msgid "Improved build process for Windows"
msgstr "改进了 Windows 的构建过程"

msgid "Automated testing on Linux and Windows platforms trigger by every commit"
msgstr "每次提交都会触发 Linux 和 Windows 平台上的自动测试"

msgid "Modular library design"
msgstr "模块化库设计"

msgid "Compatibility with PostgreSQL 9.1 or newer"
msgstr "与 PostgreSQL 9.1 或更新版本兼容"

msgid "Compatibility with PostGIS 2.0 or newer"
msgstr "与 PostGIS 2.0 或更新版本兼容"

msgid "Installs as PostgreSQL EXTENSION"
msgstr "作为 PostgreSQL 扩展程序安装"

msgid "Return types re factored and unified"
msgstr "返回类型重构和统一"

msgid "Support for table SCHEMA in function parameters"
msgstr "在函数参数中支持表 SCHEMA"

msgid "Support for ``st_`` PostGIS function prefix"
msgstr "支持 ``st_`` PostGIS 函数前缀"

msgid "Added ``pgr_`` prefix to functions and types"
msgstr "为函数和类型添加了 ``pgr_`` 前缀"

msgid "Better documentation: https://docs.pgrouting.org"
msgstr "更好的文档：https://docs.pgrouting.org"

msgid "shooting_star is discontinued"
msgstr "shooting_star 已停用"

msgid "pgRouting 1"
msgstr "pgRouting 1"

msgid "pgRouting 1.0"
msgstr "pgRouting 1.0"

msgid "To see the issues closed by this release see the `Git closed issues for 1.x <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release+1.x%22+is%3Aclosed>`_ on Github. The following release notes have been copied from the previous ``RELEASE_NOTES`` file and are kept as a reference."
msgstr "要查看此版本关闭的问题，请参阅 Github 上的 `1.x Git 已关闭问题 <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release+1.x%22+is%3Aclosed>`_ 。以下的发布说明已从之前的 ``RELEASE_NOTES`` 文件中复制，并作为参考保留。"

msgid "Changes for release 1.05"
msgstr "1.05 版的更改"

msgid "Changes for release 1.03"
msgstr "1.03 版的更改"

msgid "Much faster topology creation"
msgstr "拓扑创建速度更快"

msgid "Changes for release 1.02"
msgstr "1.02 版的更改"

msgid "Shooting* bug fixes"
msgstr "Shooting*错误修复"

msgid "Compilation problems solved"
msgstr "编译问题已解决"

msgid "Changes for release 1.01"
msgstr "1.01 版的更改"

msgid "Changes for release 1.0"
msgstr "1.0 版的更改"

msgid "Core and extra functions are separated"
msgstr "核心函数和附加函数分开"

msgid "Cmake build process"
msgstr "Cmake 构建过程"

msgid "Changes for release 1.0.0b"
msgstr "1.0.0b 版的更改"

msgid "Additional SQL file with more simple names for wrapper functions"
msgstr "带有更简单的包装函数名称的附加 SQL 文件"

msgid "Changes for release 1.0.0a"
msgstr "1.0.0a 版的更改"

msgid "Shooting* shortest path algorithm for real road networks"
msgstr "Shooting* 真实道路网络的最短路径算法"

msgid "Several SQL bugs were fixed"
msgstr "修复了多个 SQL 错误"

msgid "Changes for release 0.9.9"
msgstr "0.9.9 版的更改"

msgid "PostgreSQL 8.2 support"
msgstr "支持 PostgreSQL 8.2"

msgid "Shortest path functions return empty result if they could not find any path"
msgstr "如果找不到任何路径，最短路径函数会返回空结果"

msgid "Changes for release 0.9.8"
msgstr "0.9.8 版的更改"

msgid "Renumbering scheme was added to shortest path functions"
msgstr "为最短路径函数添加了重新编号方案"

msgid "Directed shortest path functions were added"
msgstr "增加了有向最短路径函数"

msgid "routing_postgis.sql was modified to use dijkstra in TSP search"
msgstr "修改routing_postgis.sql以在TSP搜索中使用dijkstra"

msgid "Function Families"
msgstr "函数族"

msgid "Sample Data"
msgstr "示例数据"

msgid "The documentation provides very simple example queries based on a small sample network that resembles a city. To be able to execute the majority of the examples queries, follow the instructions below."
msgstr "该文档基于一个类似城市的小型示例网络提供了非常简单的查询示例。要执行大多数示例查询，请按照以下说明操作。"

msgid "Main graph"
msgstr "主图"

msgid "A graph consists of a set of edges and a set of vertices."
msgstr "图由一组边和一组顶点组成。"

msgid "The following city is to be inserted into the database:"
msgstr "要在数据库中插入以下城市："

msgid "Information known at this point is the geometry of the edges, cost values, capacity values, category values and some locations that are not in the graph."
msgstr "此时已知的信息包括边的几何形状、成本值、容量值、类别值和一些不在图中的位置。"

msgid "The process to have working topology starts by inserting the edges. After that everything else is calculated."
msgstr "拓扑结构的工作流程从插入边开始。然后再计算其他所有内容。"

msgid "The database design for the documentation of pgRouting, keeps in the same row 2 segments, one in the direction of the geometry and the second in the opposite direction. Therefore some information has the ``reverse_`` prefix which corresponds to the segment on the opposite direction of the geometry."
msgstr "pgRouting 文档中的数据库设计将同一行中保留了两个线段，一段是几何方向的边，另一段是相反方向的边。因此，一些信息带有 ``reverse_`` 前缀，表示与几何体相反方向的边段。"

msgid "Identifier of the starting vertex of the geometry ``geom``."
msgstr "几何体 ``geom`` 的起始顶点的标识符。"

msgid "Identifier of the ending vertex of the geometry ``geom``"
msgstr "几何体 ``geom`` 终止顶点的标识符"

msgid "Cost to traverse from `source` to ``target``."
msgstr "从 `source` 到 ``target`` 的遍历成本。"

msgid "Cost to traverse from `target` to ``source``."
msgstr "从 `target` 到 ``source`` 的遍历成本。"

msgid "Flow capacity from `source` to ``target``."
msgstr "从 `source` 到 ``target`` 的流量。"

msgid "Flow capacity from `target` to ``source``."
msgstr "从 `target` 到 ``source`` 的流量。"

msgid "``category``"
msgstr "``category``"

msgid "``reverse_category``"
msgstr "``reverse_category``"

msgid ":math:`x` coordinate of the starting vertex of the geometry."
msgstr ":math:`x` 几何图形起始顶点的坐标。"

msgid "For convenience it is saved on the table but can be calculated as ``ST_X(ST_StartPoint(geom))``."
msgstr "该值被直接保存到表中，但实际上可以通过此函数进行动态计算 ``ST_X(ST_StartPoint(geom))`` 。"

msgid ":math:`y` coordinate of the ending vertex of the geometry."
msgstr ":math:`y` 几何图形结束顶点的坐标。"

msgid "For convenience it is saved on the table but can be calculated as ``ST_Y(ST_EndPoint(geom))``."
msgstr "该值被直接保存到表中，但实际上可以通过此函数进行动态计算 ``ST_Y(ST_EndPoint(geom))`` 。"

msgid "The geometry of the segments."
msgstr "分段的几何形状。"

msgid "Starting on PostgreSQL 12::"
msgstr "从 PostgreSQL 12 开始：："

msgid "Optionally indexes on different columns can be created. The recommendation is to have"
msgstr "可以选择在不同的列上创建索引。推荐创建"

msgid "``id`` indexed."
msgstr "``id`` 列创建索引 。"

msgid "``source`` and ``target`` columns indexed to speed up pgRouting queries."
msgstr "``source`` 和 ``target`` 列建立索引以加快 pgRouting 查询。"

msgid "``geom`` indexed to speed up geometry processes that might be needed in the front end."
msgstr "``geom`` 字段建立空间索引，为加速前端可能需要的几何处理。"

msgid "For this small example the indexes are skipped, except for ``id``"
msgstr "对于这个小例子，除了 ``id`` 以外，索引被省略了"

msgid "Edges data"
msgstr "边数据"

msgid "Inserting into the database the information of the edges:"
msgstr "将边的信息插入数据库："

msgid "Negative values on the cost, capacity and category means that the edge do not exist."
msgstr "成本、容量和类别上的负值表示不存在边。"

msgid "Vertices"
msgstr "顶点"

msgid "The vertex information is calculated based on the identifier of the edge and the geometry and saved on a table. Saving all the information provided by :doc:`pgr_extractVertices`:"
msgstr "根据边的标识符和几何形状计算顶点信息并保存在表中。 保存 :doc:`pgr_extractVertices` 提供的所有信息 ："

msgid "In this case the because the ``CREATE`` statement was not used, the definition of an index on the table is needed."
msgstr "在本例中，由于未使用 ``CREATE`` 语句，因此需要在表上定义索引。"

msgid "The structure of the table is:"
msgstr "表的结构如下："

msgid "Vertices data"
msgstr "顶点数据"

msgid "The saved information of the vertices is:"
msgstr "保存的顶点信息为："

msgid "Here is where adding more columns to the vertices table can be done. Additional columns names and types will depend on the application."
msgstr "这里可以为顶点表添加更多的列。附加列的名称和类型取决于应用程序。"

msgid "The topology"
msgstr "拓扑结构"

msgid "This queries based on the vertices data create a topology by filling the ``source`` and ``target`` columns in the edges table."
msgstr "此查询基于顶点数据，通过填充边表中的 ``source`` 列和 ``target`` 列来创建拓扑。"

msgid "Topology data"
msgstr "拓扑数据"

msgid "Points outside the graph"
msgstr "图之外的点"

msgid "Support tables"
msgstr "支持表"

msgid "Many functions can be used with a combinations of ``(source, target)`` pairs when wanting a route from ``source`` to ``target``."
msgstr "当需要从 ``source`` 到 ``target`` 的路由时，许多函数都可以与 ``(source, target)`` 对组合使用。"

msgid "For convenience of this documentation, some combinations will be stored on a table:"
msgstr "为了方便本文档的说明，部分组合结果将存储在表中："

msgid "Inserting the data:"
msgstr "插入数据："

msgid "Combinations data"
msgstr "组合数据"

msgid "Some functions accept soft restrictions about the segments."
msgstr "一些函数接受关于段的软约束。"

msgid "Images"
msgstr "图片"

msgid "Red arrows correspond when ``cost`` > 0 in the edge table."
msgstr "红色箭头对应边表中 ``cost`` > 0 的情况。"

msgid "Blue arrows correspond when ``reverse_cost`` > 0 in the edge table."
msgstr "蓝色箭头对应边表中的 ``reverse_cost`` > 0 的情况。"

msgid "Points are outside the graph."
msgstr "点位于图之外。"

msgid "Click on the graph to enlarge."
msgstr "点击图可放大。"

msgid "Directed graph with ``cost`` and ``reverse_cost``"
msgstr "带 ``cost`` 和 ``reverse_cost`` 的有向图"

msgid "When working with city networks, this is recommended for point of view of vehicles."
msgstr "在使用城市网络时，建议从车辆的角度考虑。"

msgid "Directed, with cost and reverse_cost"
msgstr "具有cost和reverse_cost的有向图"

msgid "Undirected graph with ``cost`` and ``reverse_cost``"
msgstr "具有 ``cost`` 和 ``reverse_cost`` 的无向图"

msgid "When working with city networks, this is recommended for point of view of pedestrians."
msgstr "在使用城市网络时，建议从行人的角度考虑。"

msgid "Undirected, with cost and reverse cost"
msgstr "带有cost和 reverse cost的无向图"

msgid "Directed graph with ``cost``"
msgstr "有 ``cost`` 的有向图"

msgid "Directed, with cost"
msgstr "有向，有成本"

msgid "Undirected graph with ``cost``"
msgstr "带有 ``cost`` 的无向图"

msgid "Undirected, with cost"
msgstr "无向，有成本"

msgid "Pick & Deliver Data"
msgstr "取货和送货数据"

msgid "Spanning Tree - Category"
msgstr "生成树 - 类别"

msgid "A spanning tree of an undirected graph is a tree that includes all the vertices of G with the minimum possible number of edges."
msgstr "一个无向图的生成树是包括图 G 的所有顶点并具有可能的最小数量的边的树。"

msgid "For a disconnected graph, there there is no single tree, but a spanning forest, consisting of a spanning tree of each connected component."
msgstr "对于不连通的图，不存在单棵树，而是由每个连通分量的生成树组成的生成林。"

msgid "Characteristics:"
msgstr "特征："

msgid "pgRouting community support is available through the `pgRouting website <https://pgrouting.org/support.html>`_, `documentation <https://docs.pgrouting.org>`_, tutorials, mailing lists and others. If you’re looking for :ref:`commercial support <support_commercial>`, find below a list of companies providing pgRouting development and consulting services."
msgstr "pgRouting 社区支持可通过 `pgRouting 网站 <https://pgrouting.org/support.html>`_、`文档 <https://docs.pgrouting.org>`_、教程、邮件列表等获得。 如果您正在寻求 :ref:`商业支持 <support_commercial>`，请在下面找到提供 pgRouting 开发和咨询服务的公司列表。"

msgid "Reporting Problems"
msgstr "报告问题"

msgid "Bugs are reported and managed in an `issue tracker <https://github.com/pgrouting/pgrouting/issues>`_. Please follow these steps:"
msgstr "错误在 `问题跟踪器 <https://github.com/pgrouting/pgrouting/issues>`_ 中报告和管理。 请按照以下步骤操作："

msgid "Search the tickets to see if your problem has already been reported. If so, add any extra context you might have found, or at least indicate that you too are having the problem. This will help us prioritize common issues."
msgstr "搜索票证以查看您的问题是否已被报告。 如果是这样，请添加您可能发现的任何额外上下文，或者至少表明您也遇到了问题。 这将帮助我们优先考虑常见问题。"

msgid "If your problem is unreported, create a `new issue <https://github.com/pgRouting/pgrouting/issues/new>`__ for it."
msgstr "如果您的问题未报告，请为其创建一个 `新问题 <https://github.com/pgRouting/pgrouting/issues/new>`__ 。"

msgid "In your report include explicit instructions to replicate your issue. The best tickets include the exact SQL necessary to replicate a problem."
msgstr "在您的报告中包含重现问题的明确说明。 最好的票证包含复制问题所需的确切 SQL。"

msgid "If you can test older versions of PostGIS for your problem, please do. On your ticket, note the earliest version the problem appears."
msgstr "如果您可以测试旧版本的 PostGIS 来解决您的问题，请这样做。 在您的票证上，记下问题出现的最早版本。"

msgid "For the versions where you can replicate the problem, note the operating system and version of pgRouting, PostGIS and PostgreSQL."
msgstr "对于可以重现问题的版本，请记下操作系统以及 pgRouting、PostGIS 和 PostgreSQL 的版本。"

msgid "It is recommended to use the following wrapper on the problem to pin point the step that is causing the problem."
msgstr "建议对问题使用以下包装器来查明导致问题的步骤。"

#, fuzzy
msgid "Mailing List, Matrix, GIS StackExchange"
msgstr "邮件列表和GIS StackExchange"

#, fuzzy
msgid "There are two mailing lists for pgRouting hosted on OSGeo discourse server:"
msgstr "OSGeo 邮件列表服务器上托管有两个 pgRouting 邮件列表："

#, fuzzy
msgid "User mailing list: https://discourse.osgeo.org/c/pgrouting/pgrouting-users/"
msgstr "开发人员邮件列表： https://discourse.osgeo.org/c/pgrouting/pgrouting-dev/"

msgid "Developer mailing list: https://discourse.osgeo.org/c/pgrouting/pgrouting-dev/"
msgstr "开发人员邮件列表： https://discourse.osgeo.org/c/pgrouting/pgrouting-dev/"

msgid "Subscribe: https://discourse.osgeo.org/g/pgrouting-dev"
msgstr "订阅：https://discourse.osgeo.org/g/pgrouting-dev"

msgid "For general questions and topics about how to use pgRouting, please write to the user mailing list."
msgstr "有关如何使用 pgRouting 的一般问题和主题，请写信给用户邮件列表。"

msgid "If you want to chat with fellow pgRouting users and contributors, you can join our matrix channel: `pgRouting matrix channel <https://matrix.to/#/#pgrouting:osgeo.org>`_."
msgstr ""

msgid "You can also ask at `GIS StackExchange <https://gis.stackexchange.com/>`_ and tag the question with ``pgrouting``. Find all questions tagged with ``pgrouting`` under https://gis.stackexchange.com/questions/tagged/pgrouting or subscribe to the `pgRouting questions feed <https://gis.stackexchange.com/feeds/tag?tagnames=pgrouting&sort=newest>`_."
msgstr "您还可以在 `GIS StackExchange <https://gis.stackexchange.com/>`_ 上提问，并使用 ``pgrouting`` 标签。查找所有带有 ``pgrouting`` 标签的问题，请访问 https://gis.stackexchange.com/questions/tagged/pgrouting 或订阅 `pgRouting 问题订阅 <https://gis.stackexchange.com/feeds/tag?tagnames=pgrouting&sort=newest>`_ 。"

msgid "Commercial Support"
msgstr "商业支持"

msgid "For users who require professional support, development and consulting services, consider contacting any of the following organizations, which have significantly contributed to the development of pgRouting:"
msgstr "对于需要专业支持、开发和咨询服务的用户，请考虑联系以下任何一个组织，这些组织对 pgRouting 的发展做出了重大贡献："

msgid "**Company**"
msgstr "**公司**"

msgid "**Offices in**"
msgstr "**办事处**"

msgid "**Website**"
msgstr "**网站**"

msgid "Germany, Japan"
msgstr "德国，日本"

msgid "https://georepublic.info"
msgstr "https://georepublic.info"

msgid "United States"
msgstr "美国"

msgid "https://www.paragoncorporation.com"
msgstr "https://www.paragoncorporation.com"

msgid "Netlab"
msgstr "Netlab"

msgid "Capranica, Italy"
msgstr "Capranica，意大利"

msgid "https://www.osgeo.org/service-providers/netlab/"
msgstr "https://www.osgeo.org/service-providers/netlab/"

msgid "Transformation - Family of functions"
msgstr "转换 - 函数族"

msgid "This family of functions is used for transforming a given input graph :math:`G(V,E)` into a new graph :math:`G'(V',E')`."
msgstr "该函数族用于将给定的输入图 :math:`G(V,E)` 转换为新图 :math:`G'(V',E')`。"

msgid "Traversal - Family of functions"
msgstr "Traversal - 函数族"

msgid "Utility functions"
msgstr "实用工具函数集"

msgid "Via - Category"
msgstr "Via - 类别"

msgid "This category intends to solve the general problem:"
msgstr "该类别旨在解决普遍问题："

msgid "Given a graph and a list of vertices, find the shortest path between :math:`vertex_i` and :math:`vertex_{i+1}` for all vertices"
msgstr "给定一个图和一个顶点列表，找到所有相邻顶点对 :math:`vertex_i` 和 :math:`vertex_{i+1}` 之间的最短路径"

msgid "In other words, find a continuous route that visits all the vertices in the order given."
msgstr "换句话说，寻找一条连续路径，使其按照给定顺序访问所有节点。"

msgid "path"
msgstr "path"

msgid "represents a section of a **route**."
msgstr "代表 **route** 的一部分。"

msgid "route"
msgstr "route"

msgid "is a sequence of **paths**"
msgstr "是一系列 **paths**"

msgid "**Used in:**"
msgstr "**用于：**"

msgid "Besides the compulsory parameters each function has, there are optional parameters that exist due to the kind of function."
msgstr "除了每个函数具有的强制参数之外，由于函数的种类而存在可选参数。"

msgid "Used in all Via functions"
msgstr "用于所有 Via 功能"

msgid "Depending on the function one or more inner queries are needed."
msgstr "根据函数需要一个或多个内部查询。"

msgid "withPoints - Category"
msgstr "withPoints - 类别"

msgid "When points are added to the graph."
msgstr "当点添加到图中时。"

msgid "The **with points** category modifies the graph on the fly by adding points on edges as required by the `Points SQL`_ query."
msgstr "**with points** 类别通过根据 `Points SQL`_ 查询的要求在边上添加点来动态修改图形。"

msgid "The functions within this category give the ability to process between arbitrary points located outside the original graph."
msgstr "该类别中的函数能够在位于原始图之外的任意点之间进行处理。"

msgid "This category of functions was thought for routing vehicles, but might as well work for some other application not involving vehicles."
msgstr "此类功能被认为用于路由车辆，但也可能适用于其他一些不涉及车辆的应用程序。"

msgid "When given a point identifier ``pid`` that its being mapped to an edge with an identifier ``edge_id``, with a fraction from the source to the target along the edge ``fraction`` and some additional information about which side of the edge the point is on ``side``, then processing from arbitrary points can be done on fixed networks."
msgstr "当给定一个点标识符 ``pid`` ，它被映射到具有标识符 ``edge_id`` 的边上，并且有一个从源到目标沿边的分数 ``fraction`` ，以及关于点位于边的哪一侧的其他信息 ``side`` ，那么可以在固定网络上从任意点进行处理。"

msgid "All this functions consider as many traits from the \"real world\" as possible:"
msgstr "所有这些函数都考虑了尽可能多的“现实世界”特征："

msgid "Kind of graph:"
msgstr "图的种类："

msgid "**directed** graph"
msgstr "**有向** 图"

msgid "**undirected** graph"
msgstr "**无向** 图"

msgid "Arriving at the point:"
msgstr "到达点："

msgid "Compulsory arrival on the side of the segment where the point is located."
msgstr "强制到达该点所在航段的一侧。"

msgid "On either side of the segment."
msgstr "位于该段的两侧。"

msgid "Countries with:"
msgstr "具有以下条件的国家："

msgid "**Right** side driving"
msgstr "**右侧** 驾驶"

msgid "**Left** side driving"
msgstr "**左侧** 驾驶"

msgid "Some points are:"
msgstr "一些要点是："

msgid "**Permanent**: for example the set of points of clients stored in a table in the data base."
msgstr "**永久**：例如，存储在表中的客户端点集 数据库。"

msgid "The graph has been modified to permanently have those points as vertices."
msgstr "图已修改为将这些点永久用作顶点。"

msgid "There is a table on the database that describes the points"
msgstr "数据库上有一个描述点的表格"

msgid "**Temporal**: for example points given through a web application"
msgstr "**时间**：例如通过 Web 应用程序给出的点"

msgid "The numbering of the points are handled with negative sign."
msgstr "点的编号用负号处理。"

msgid "This sign change is to avoid confusion when there is a vertex with the same identifier as the point identifier."
msgstr "这种符号变化是为了避免当存在与点标识符具有相同标识符的顶点时发生混淆。"

msgid "Original point identifiers are to be positive."
msgstr "原始点标识符应为正数。"

msgid "Transformation to negative is done internally."
msgstr "向负数的转变是在内部完成的。"

msgid "Interpretation of the sign on the node information of the output"
msgstr "解释输出的节点上的符号信息"

msgid "positive sign is a vertex of the original graph"
msgstr "正号是原始图的顶点"

msgid "negative sign is a point of the `Points SQL`_"
msgstr "负号是 `Points SQL`_ 的一个点"

msgid "About points"
msgstr "关于积分"

msgid "For this section the following city (see :doc:`sampledata`) some interesting points such as restaurant, supermarket, post office, etc. will be used as example."
msgstr "本节将以下列城市（参见 :doc:`sampledata`）的一些有趣的点为例，如餐馆、超市、邮局等。"

msgid "The graph is **directed**"
msgstr "图是 **有向** 的"

msgid "Red arrows show the ``(source, target)`` of the edge on the edge table"
msgstr "红色箭头显示边表上的边 ``(source, target)``"

msgid "Blue arrows show the ``(target, source)`` of the edge on the edge table"
msgstr "蓝色箭头显示边表上的边 ``(target, source)``"

msgid "Each point location shows where it is located with relation of the edge ``(source, target)``"
msgstr "每个点位置显示它与边 ``(source, target)`` 的关系"

msgid "On the right for points **2** and **4**."
msgstr "在右侧为第 **2** 点和第 **4** 点。"

msgid "On the left for points **1**, **3** and **5**."
msgstr "左侧为第 **1**、**3** 和 **5** 点。"

msgid "On both sides for point **6**."
msgstr "在两侧为第 **6** 点。"

msgid "The representation on the data base follows the `Points SQL`_ description, and for this example:"
msgstr "数据库上的表示遵循 `Points SQL`_ 描述，对于本示例："

msgid "Driving side"
msgstr "驾驶侧"

msgid "In the following images:"
msgstr "在下面的图片中："

msgid "The squared vertices are the temporary vertices,"
msgstr "平方顶点是临时顶点，"

msgid "The temporary vertices are added according to the driving side,"
msgstr "根据驾驶侧添加临时顶点，"

msgid "visually showing the differences on how depending on the driving side the data is interpreted."
msgstr "直观地显示不同驾驶侧数据解释方式的差异。"

msgid "Point **1** located on edge ``(6, 5)``"
msgstr "点 **1** 位于边 ``(6, 5)``"

msgid "Point **2** located on edge ``(16, 17)``"
msgstr "点 **2** 位于边缘 ``(16, 17)``"

msgid "Point **3** located on edge ``(8, 12)``"
msgstr "点 **3** 位于边缘 ``(8, 12)``"

msgid "Point **4** located on edge ``(1, 3)``"
msgstr "点 **4** 位于边 ``(1, 3)``"

msgid "Point **5** located on edge ``(10, 11)``"
msgstr "点 **5** 位于边缘 ``(10, 11)``"

msgid "Point **6** located on edges ``(6, 7)`` and ``(7, 6)``"
msgstr "点 **6** 位于边 ``(6, 7)`` 和 ``(7, 6)``"

msgid "Point **1** located on edge ``(5, 6)``"
msgstr "点 **1** 位于边 ``(5, 6)``"

msgid "Point **2** located on edge ``(17, 16)``"
msgstr "点 **2** 位于边 ``(17, 16)``"

msgid "Point **4** located on edge ``(3, 1)``"
msgstr "点 **4** 位于边 ``(3, 1)``"

msgid "Like having all points to be considered in both sides ``b``"
msgstr "就像双方都要考虑所有点 ``b``"

msgid "Preferred usage on **undirected** graphs"
msgstr "首选用于**非定向**图形"

msgid "On the :doc:`TRSP-family` this option is not valid"
msgstr "在 :doc:`TRSP-family` 上，此选项无效"

msgid "Point **1** located on edge ``(5, 6)`` and ``(6, 5)``"
msgstr "点 **1** 位于边 ``(5, 6)`` 和 ``(6, 5)``"

msgid "Point **2** located on edge ``(17, 16)``and ``16, 17``"
msgstr "点 **2** 位于边 ``(17, 16)`` 和 ``16, 17``"

msgid "Point **4** located on edge ``(3, 1)`` and ``(1, 3)``"
msgstr "点 **4** 位于边 ``(3, 1)`` 和 ``(1, 3)``"

msgid "Creating temporary vertices"
msgstr "创建临时顶点"

msgid "This section will demonstrate how a temporary vertex is created internally on the graph."
msgstr "本节将演示如何在图内部创建临时顶点。"

msgid "Problem"
msgstr "问题"

msgid "For edge:"
msgstr "对于边:"

msgid "insert point:"
msgstr "插入点："

msgid "On a right hand side driving network"
msgstr "在右侧行驶网络"

msgid "Arrival to point ``-2`` can be achieved only via vertex **16**."
msgstr "只有通过顶点 **16** 才能到达 ``-2`` 点。"

msgid "Does not affects edge ``(17, 16)``, therefore the edge is kept."
msgstr "不影响边 ``(17, 16)`` ，因此边被保留。"

msgid "It only affects the edge ``(16, 17)``, therefore the edge is removed."
msgstr "它只影响边 ``(16, 17)`` ，因此边被移除。"

msgid "Create two new edges:"
msgstr "创建两条新边："

msgid "Edge ``(16, -2)`` with cost ``0.4`` (original cost * fraction == :math:`1 * 0.4`)"
msgstr "边 ``(16, -2)`` 的成本为 ``0.4`` （原始成本 * 分数 == :math:`1 * 0.4` ）"

msgid "Edge ``(-2, 17)`` with cost ``0.6`` (the remaining cost)"
msgstr "边 ``(-2, 17)`` 的成本为``0.6`` （剩余成本）"

msgid "The total cost of the additional edges is equal to the original cost."
msgstr "附加边的总成本等于原始成本。"

msgid "If more points are on the same edge, the process is repeated recursevly."
msgstr "如果同一条边上有更多点，则递归地重复该过程。"

msgid "On a left hand side driving network"
msgstr "在左侧驾驶网络上"

msgid "Arrival to point ``-2`` can be achieved only via vertex **17**."
msgstr "只有通过顶点 **17** 才能到达点 ``-2`` 。"

msgid "Does not affects edge ``(16, 17)``, therefore the edge is kept."
msgstr "不影响边 ``(16, 17)`` ，因此保留边。"

msgid "It only affects the edge ``(17, 16)``, therefore the edge is removed."
msgstr "它只影响边 ``(17, 16)`` ，因此边被移除。"

msgid "Work with the original edge ``(16, 17)`` as the fraction is a fraction of the original:"
msgstr "使用原始边 ``(16, 17)`` ，因为分数是原始边的分数："

msgid "Flip the Edges and add them to the graph:"
msgstr "翻转边并将它们添加到图中："

msgid "Edge ``(17, -2)`` becomes ``(-2, 16)`` with cost ``0.4`` and is added to the graph."
msgstr "边 ``(17, -2)`` 变为 ``(-2, 16)`` ，成本为``0.4`` ，并添加到图中。"

msgid "Edge ``(-2, 16)`` becomes ``(17, -2)`` with cost ``0.6`` and is added to the graph."
msgstr "边 ``(-2, 16)`` 变为 ``(17, -2)`` ，成本为 ``0.6`` ，并添加到图中。"

msgid "When driving side does not matter"
msgstr "当驾驶侧无关紧要时"

msgid "Arrival to point ``-2`` can be achieved via vertices **16** or **17**."
msgstr "可通过顶点 **16** 或 **17** 到达 ``-2`` 点。"

msgid "Affects the edges ``(16, 17)`` and ``(17, 16)``, therefore the edges are removed."
msgstr "影响边 ``(16, 17)`` 和 ``(17, 16)`` ，因此边被移除。"

msgid "Create four new edges:"
msgstr "创建四个新边："

msgid "Flip the Edges and add all the edges to the graph:"
msgstr "翻转边并将所有边添加到图中："

msgid "Edge ``(16, -2)`` is added to the graph."
msgstr "边 ``(16, -2)`` 被添加到图中。"

msgid "Edge ``(-2, 17)`` is added to the graph."
msgstr "边 ``(-2, 17)`` 被添加到图中。"

msgid "Edge ``(16, -2)`` becomes ``(-2, 16)`` with cost ``0.4`` and is added to the graph."
msgstr "边 ``(16, -2)`` 变为 ``(-2, 16)`` ，成本为 0.4，并添加到图中。"

msgid "Edge ``(-2, 17)`` becomes ``(17, -2)`` with cost ``0.6`` and is added to the graph."
msgstr "边 ``(-2, 17)`` 变为``(17, -2)`` ，成本为 ``0.6`` ，并添加到图中。"

msgid "withPoints - Family of functions"
msgstr "withPoints - 函数族"

msgid "This family of functions belongs to the :doc:`withPoints-category` and the functions that compose them are based one way or another on dijkstra algorithm."
msgstr "这一系列函数属于 :doc:`withPoints-category`，组成它们的函数以某种方式基于 dijkstra 算法。"

msgid "Depending on the name:"
msgstr "取决于名称："

msgid "pgr_withPoints is pgr_dijkstra **with points**"
msgstr "pgr_withPoints 是 **带有点** 的 pgr_dijkstra"

msgid "pgr_withPointsCost is pgr_dijkstraCost **with points**"
msgstr "pgr_withPointsCost 是 **带有点** 的 pgr_dijkstraCost"

msgid "pgr_withPointsCostMatrix is pgr_dijkstraCostMatrix **with points**"
msgstr "pgr_withPointsCostMatrix 是 **带有点** 的 pgr_dijkstraCostMatrix"

msgid "pgr_withPointsKSP is pgr_ksp **with points**"
msgstr "pgr_withPointsKSP 是 **带有点** 的 pgr_ksp"

msgid "pgr_withPointsDD is pgr_drivingDistance **with points**"
msgstr "pgr_withPointsDD 是 **带有点** 的 pgr_drivenDistance"

msgid "pgr_withPointsvia is pgr_dijkstraVia **with points**"
msgstr "pgr_withPointsvia 是 pgr_dijkstraVia **with points** 的版本"

#, fuzzy
#~ msgid "See also"
#~ msgstr "另请参阅"

#~ msgid "It is expected to terminate faster than pgr_aStar"
#~ msgstr "预计其执行速度将快于 pgr_aStar 函数"

#~ msgid "pgRouting 4.0.0 Release Notes"
#~ msgstr "pgRouting 4.0.0 发布说明"

#, fuzzy
#~ msgid "The user's documentation is build by default"
#~ msgstr "用于用户文档"

#, fuzzy
#~ msgid "The translated languages (en, es, sv, zh_Hans) HTML documentation is build by default"
#~ msgstr "用于用户文档"

#, fuzzy
#~ msgid "Developers's Documentation is not build when"
#~ msgstr "对于开发者文档"

#~ msgid "New experimental functions"
#~ msgstr "新实验性函数"

#, fuzzy
#~ msgid "`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__: pgr_DAGshortestPath"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2909 <https://github.com/pgRouting/pgrouting/issues/2909>`__: pgr_turnRestrictedPaths"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#~ msgid "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"
#~ msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#~ msgid "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__: pgr_trspviavertices"
#~ msgstr "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__: pgr_trspviavertices"

#, fuzzy
#~ msgid "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__ _pgr_alphashape(text,double precision)"
#~ msgstr "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__: pgr_alphaShape"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_checkverttab(text,text[],integer,text)"
#~ msgstr "`#2827 <https://github.com/pgRouting/pgrouting/issues/2827>`__: pgr_createVerticesTable"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_createindex(text,text,text,integer,text)"
#~ msgstr "`#2786 <https://github.com/pgRouting/pgrouting/issues/2786>`__:pgr_contraction(edges) 新签名"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_createindex(text,text,text,text,integer,text)"
#~ msgstr "`#2786 <https://github.com/pgRouting/pgrouting/issues/2786>`__:pgr_contraction(edges) 新签名"

#, fuzzy
#~ msgid "`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__ _pgr_dagshortestpath(text,anyarray,anyarray,boolean,boolean)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__ _pgr_dagshortestpath(text,text,boolean,boolean)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ _pgr_dijkstranear(text,anyarray,anyarray,bigint,boolean)"
#~ msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
#~ msgid "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ _pgr_dijkstranear(text,anyarray,bigint,bigint,boolean)"
#~ msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
#~ msgid "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ _pgr_dijkstranear(text,bigint,anyarray,bigint,boolean)"
#~ msgstr "`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: pgr_contraction"

#, fuzzy
#~ msgid "`#2735 <https://github.com/pgRouting/pgrouting/issues/2735>`__ _pgr_drivingdistance(text,anyarray,double precision,boolean,boolean)"
#~ msgstr "_pgr_drivingdistance(text,anyarray,double precision,boolean,boolean)"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_endpoint(geometry)"
#~ msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_getcolumnname(text,text,integer,text)"
#~ msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_getcolumnname(text,text,text,integer,text)"
#~ msgstr "`#2786 <https://github.com/pgRouting/pgrouting/issues/2786>`__:pgr_contraction(edges) 新签名"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_getcolumntype(text,text,integer,text)"
#~ msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_getcolumntype(text,text,text,integer,text)"
#~ msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_gettablename(text,integer,text)"
#~ msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_iscolumnindexed(text,text,integer,text)"
#~ msgstr "`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__:重写 pgr_nodeNetwork"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_iscolumnindexed(text,text,text,integer,text)"
#~ msgstr "`#2786 <https://github.com/pgRouting/pgrouting/issues/2786>`__:pgr_contraction(edges) 新签名"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_iscolumnintable(text,text)"
#~ msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
#~ msgid "`#2899 <https://github.com/pgRouting/pgrouting/issues/2899>`__ _pgr_maxcardinalitymatch(text,boolean)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_startpoint(geometry)"
#~ msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
#~ msgid "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__ _pgr_trspviavertices(text,integer[],boolean,boolean,text)"
#~ msgstr "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__: pgr_trspviavertices"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ _pgr_trspvia_withpoints(text,text,text,anyarray,boolean,boolean,boolean,character,boolean)"
#~ msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ _pgr_trsp_withpoints(text,text,text,anyarray,anyarray,boolean,character,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ _pgr_trsp_withpoints(text,text,text,text,boolean,character,boolean)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__ _pgr_tspeuclidean(text,bigint,bigint,double precision,integer,integer,integer,double precision,double precision,double precision,boolean)"
#~ msgstr "_pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"

#, fuzzy
#~ msgid "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ _pgr_versionless(text,text)"
#~ msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
#~ msgid "`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__ _pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
#~ msgid "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__ _pgr_withpointsksp(text,text,anyarray,anyarray,integer,character,boolean,boolean,boolean,boolean)"
#~ msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
#~ msgid "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__ _pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,character,boolean)"
#~ msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
#~ msgid "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__ _pgr_withpointsksp(text,text,text,integer,character,boolean,boolean,boolean)"
#~ msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
#~ msgid "`#2741 <https://github.com/pgRouting/pgrouting/issues/2741>`__ _pgr_withpointsvia(text,bigint[],double precision[],boolean)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2741 <https://github.com/pgRouting/pgrouting/issues/2741>`__ _pgr_withpointsvia(text,text,anyarray,boolean,boolean,boolean,character,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
#~ msgid "`#2899 <https://github.com/pgRouting/pgrouting/issues/2899>`__ pgr_maxcardinalitymatch(text,boolean)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__ pgr_trspviaedges(text,integer[],double precision[],boolean,boolean,text)"
#~ msgstr "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: pgr_trspviaedges"

#, fuzzy
#~ msgid "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__ pgr_trspviavertices(text,anyarray,boolean,boolean,text)"
#~ msgstr "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__: pgr_trspviavertices"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_trspvia_withpoints(text,text,text,anyarray,boolean,boolean,boolean,character,boolean)"
#~ msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_trsp_withpoints(text,text,text,anyarray,anyarray,boolean,character,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_trsp_withpoints(text,text,text,anyarray,bigint,boolean,character,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_trsp_withpoints(text,text,text,bigint,anyarray,boolean,character,boolean)"
#~ msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_trsp_withpoints(text,text,text,bigint,bigint,boolean,character,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_trsp_withpoints(text,text,text,text,boolean,character,boolean)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__ pgr_tspeuclidean(text,bigint,bigint,double precision,integer,integer,integer,double precision,double precision,double precision,boolean)"
#~ msgstr "_pgr_trsp(text,integer,double precision,integer,double precision,boolean,boolean,text)"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withpointscostmatrix(text,text,anyarray,boolean,character)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withpointscost(text,text,anyarray,anyarray,boolean,character)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withpointscost(text,text,anyarray,bigint,boolean,character)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withpointscost(text,text,bigint,anyarray,boolean,character)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withpointscost(text,text,bigint,bigint,boolean,character)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withpointscost(text,text,text,boolean,character)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__ pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
#~ msgid "`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__ pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

#, fuzzy
#~ msgid "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__ pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,character,boolean)"
#~ msgstr "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,boolean)``"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withpoints(text,text,anyarray,anyarray,boolean,character,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withpoints(text,text,anyarray,bigint,boolean,character,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withpoints(text,text,bigint,anyarray,boolean,character,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withpoints(text,text,bigint,bigint,boolean,character,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,bigint,double precision,boolean,character,boolean)"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withpoints(text,text,text,boolean,character,boolean)"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#, fuzzy
#~ msgid "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ pgr_withpointsvia(text,text,anyarray,boolean,boolean,boolean,character,boolean)"
#~ msgstr "pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,boolean,boolean)"

#, fuzzy
#~ msgid "_pgr_drivingdistance => _pgr_drivingdistancev4"
#~ msgstr "``pgr_drivingDistance`` - 返回起始节点的行驶距离。"

#, fuzzy
#~ msgid "_pgr_withpointsdd => _pgr_withpointsddv4"
#~ msgstr "pgr_withPointsKSP 是 **带有点** 的 pgr_ksp"

#, fuzzy
#~ msgid "_pgr_withpointsksp => _pgr_withpointsksp_v4"
#~ msgstr "pgr_withPointsKSP 是 **带有点** 的 pgr_ksp"

#, fuzzy
#~ msgid "_pgr_trspvia_withpoints => _pgr_trspvia_withpoints_v4"
#~ msgstr "pgr_withPoints 是 **带有点** 的 pgr_dijkstra"

#, fuzzy
#~ msgid "_pgr_trsp_withpoints => _pgr_trsp_withpoints_v4"
#~ msgstr "pgr_withPointsKSP 是 **带有点** 的 pgr_ksp"

#, fuzzy
#~ msgid "_pgr_withpointsvia => _pgr_withpointsvia_v4"
#~ msgstr "pgr_withPointsvia 是 pgr_dijkstraVia **with points** 的版本"

#, fuzzy
#~ msgid "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__ _pgr_alphashape"
#~ msgstr "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__: pgr_alphaShape"

#, fuzzy
#~ msgid "`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__ _pgr_dagshortestpath"
#~ msgstr "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"

#~ msgid "The ``pgr_aStarCost`` function summarizes of the cost of the shortest path using the A* algorithm."
#~ msgstr "``pgr_aStarCost`` 函数通过 A* 算法汇总最短路径的成本。"

#~ msgid "The results are equivalent to the union of the results of the pgr_bdAStar(One to One) on the:"
#~ msgstr "结果等效于以下情形中 pgr_bdAStar(One to One) 结果的并集："

#~ msgid "The ``pgr_bdAstarCost`` function summarizes of the cost of the shortest path using the bidirectional A* algorithm."
#~ msgstr "``pgr_bdAstarCost`` 函数通过双向 A* 算法汇总最短路径的成本。"

#~ msgid "``pgr_bdAstarCostMatrix`` - Calculates the a cost matrix using :doc:`pgr_aStar`."
#~ msgstr "``pgr_bdAstarCostMatrix`` - 使用 :doc:`pgr_aStar` 计算成本矩阵。"

#~ msgid "Using internally the :doc:`pgr_bdAstar` algorithm"
#~ msgstr "内部使用 :doc:`pgr_bdAstar` 算法"

#~ msgid "Signature change on pgr_bdDijsktra(One to One)"
#~ msgstr "函数的签名变更 pgr_bdDijsktra(One to One)"

#~ msgid "The ``pgr_bdDijkstraCost`` function summarizes of the cost of the shortest path using the bidirectional Dijkstra Algorithm."
#~ msgstr "``pgr_bdDijkstraCost`` 函数通过双向 Dijkstra 算法汇总最短路径的成本值。"

#, fuzzy
#~ msgid "It is well-known that the shortest paths between a single source and all other vertices can be found using Breadth First Search in :math:`O(|E|)` in an unweighted graph, i.e. the distance is the minimal number of edges that you need to traverse from the source to another vertex. We can interpret such a graph also as a weighted graph, where every edge has the weight :math:`1`. If not all edges in graph have the same weight, that we need a more general algorithm, like Dijkstra's Algorithm which runs in :math:`O(|E|log|V|)` time."
#~ msgstr "众所周知，在无权重图中，使用广度优先搜索（Breadth First Search）可以在 :math:`O(|E|)` 内找到单个源点与所有其他顶点之间的最短路径，也就是说，距离是指从源点到另一个顶点所需的最少边数。我们也可以把这样的图解释为加权图，其中每条边的权重为 :math:`1`。如果图中不是所有边的权重都相同，我们就需要一种更通用的算法，比如 Dijkstra 算法，它的运行时间为 :math:`O(|E|log|V||)`。"

#, fuzzy
#~ msgid "New experimental function"
#~ msgstr "新实验性功能。"

#, fuzzy
#~ msgid "..rubric:: Version 3.0.0"
#~ msgstr "版本3.0.0"

#~ msgid "``pgr_dijkstraNear`` - Proposed"
#~ msgstr "``pgr_dijkstraNear`` - 提议中"

#~ msgid "``pgr_dijkstraNearCost`` - Proposed"
#~ msgstr "``pgr_dijkstraNearCost`` - 提议中"

#~ msgid "Boost `floyd-Warshall <https://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html>`_"
#~ msgstr "Boost `弗洛伊德-沃沙尔算法 <https://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html>`_"

#, fuzzy
#~ msgid "``pgr_kingOrdering`` — Returns the King ordering of an undirected graphs"
#~ msgstr "``pgr_cuthillMckeeOrdering`` — 返回无向图的反向 Cuthill-Mckee 排序"

#~ msgid "|boost| graph inside."
#~ msgstr "|boost| 图内。"

#, fuzzy
#~ msgid "``pgr_sloanOrdering`` — Returns the sloan ordering of an undirected graph"
#~ msgstr "``pgr_cuthillMckeeOrdering`` — 返回无向图的反向 Cuthill-Mckee 排序"

#, fuzzy
#~ msgid "|Boost| Boost Graph inside"
#~ msgstr "|Boost| Boost 图内部"

#, fuzzy
#~ msgid "..rubric::Summary"
#~ msgstr "..rubric:: 标准化 SQL"

#~ msgid "Additionally there are 2 categories under this family"
#~ msgstr "此外，该功能系列下还包含2个分类"

#~ msgid "Does not have a default value."
#~ msgstr "没有默认值。"

#~ msgid "Using an invalid value throws an ``ERROR``."
#~ msgstr "使用无效值会引发 ``ERROR`` 。"

#~ msgid "``pgr_dijkstraVia`` - Proposed"
#~ msgstr "``pgr_dijkstraVia`` - 提议中"

#~ msgid "[``r``, ``R``] for right driving side (for directed graph only)"
#~ msgstr "[``r``, ``R``] 表示右侧驾驶（仅适用于有向图）"

#~ msgid "[``l``, ``L``] for left driving side (for directed graph only)"
#~ msgstr "[``l``, ``L``]表示左侧驾驶（仅适用有向图）"

#~ msgid "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vid**, **end vid**, [**options**])"
#~ msgstr "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vid**, **end vid**, [**options**])"

#~ msgid "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vid**, **end vids**, [**options**])"
#~ msgstr "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vid**, **end vids**, [**options**])"

#~ msgid "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vids**, **end vid**, [**options**])"
#~ msgstr "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vids**, **end vid**, [**options**])"

#~ msgid "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vids**, **end vids**, [**options**])"
#~ msgstr "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, **start vids**, **end vids**, [**options**])"

#~ msgid "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Combinations SQL`_, `Points SQL`_, [**options**])"
#~ msgstr "pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Combinations SQL`_, `Points SQL`_, [**options**])"

#~ msgid "**options:** ``[directed, driving_side, details]``"
#~ msgstr "**options:** ``[directed, driving_side, details]``"

#~ msgid "``b``, ``B`` for both."
#~ msgstr "``b``, ``B`` 表示两侧通行（不限制驾驶方向）。"

#~ msgid "Valid values differ for directed and undirected graphs:"
#~ msgstr "有效值因有向图和无向图而异："

#~ msgid "In directed graphs: [``r``, ``R``, ``l``, ``L``]."
#~ msgstr "有向图中：[``r``, ``R``, ``l``, ``L``]。"

#~ msgid "In undirected graphs: [``b``, ``B``]."
#~ msgstr "无向图中：[``b``, ``B``]。"
