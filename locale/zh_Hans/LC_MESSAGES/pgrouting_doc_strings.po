# SOME DESCRIPTIVE TITLE.
# Copyright (C) pgRouting Contributors - Version v3.6.0-dev
# This file is distributed under the same license as the pgRouting package.
# Regina Obe <regina@arrival3d.com>, 2023.
# Wangdapeng <wangdapeng20191008@gmail.com>, 2023.
# Zuochenwei <zuochenwei5@gmail.com>, 2023.
# Celia Virginia Vergara Castillo <vicky@erosion.dev>, 2023.
# Wang Dapeng <wangdapeng20191008@gmail.com>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: pgRouting v3.6.0-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-28 18:11+0000\n"
"PO-Revision-Date: 2023-10-21 03:23+0000\n"
"Last-Translator: Wang Dapeng <wangdapeng20191008@gmail.com>\n"
"Language-Team: Chinese (Simplified) <https://weblate.osgeo.org/projects/"
"pgrouting/pgrouting-develop/zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.0\n"

msgid "BFS - Category"
msgstr "BFS-类别"

msgid ":doc:`pgr_kruskalBFS`"
msgstr ":doc:`pgr_kruskalBFS`"

msgid ":doc:`pgr_primBFS`"
msgstr ":doc:`pgr_primBFS`"

msgid "Traversal using breadth first search."
msgstr "使用广度优先搜索进行遍历。"

msgid "It's implementation is only on **undirected** graph."
msgstr "它的实现仅在**无向**图上。"

msgid "Process is done only on edges with positive costs."
msgstr "仅在具有正成本的边进行处理。"

msgid "When the graph is connected"
msgstr "当图连通时"

msgid "The resulting edges make up a tree"
msgstr "由此产生的边组成一棵树"

msgid "When the graph is not connected,"
msgstr "当图不连通时"

msgid "Finds a minimum spanning tree for each connected component."
msgstr "为每个连通分量找到最小生成树。"

msgid "The resulting edges make up a forest."
msgstr "由此产生的边构成了一片森林。"

msgid "Parameters"
msgstr "参数"

msgid "Parameter"
msgstr "参数"

msgid "Type"
msgstr "类型"

msgid "Description"
msgstr "描述"

msgid "`Edges SQL`_"
msgstr "`Edges SQL`_"

msgid "``TEXT``"
msgstr "``TEXT``"

msgid "`Edges SQL`_ as described below."
msgstr "`Edges SQL`_如下所述。"

msgid "**root vid**"
msgstr "**root vid**"

msgid "``BIGINT``"
msgstr "``BIGINT``"

msgid "Identifier of the root vertex of the tree."
msgstr "树的根顶点的标识符。"

msgid ""
"When value is :math:`0` then gets the spanning forest starting in aleatory "
"nodes for each tree in the forest."
msgstr "当值为 :math:`0` 时，则获取从森林中每棵树的随机节点开始的生成森林。"

msgid "**root vids**"
msgstr "**root vids**"

msgid "``ARRAY`` [ **ANY-INTEGER** ]"
msgstr "``ARRAY`` [ **ANY-INTEGER** ]"

msgid "Array of identifiers of the root vertices."
msgstr "根顶点的标识符数组。"

msgid ":math:`0` values are ignored"
msgstr ":math:`0` 值被忽略"

msgid "For optimization purposes, any duplicated value is ignored."
msgstr "出于优化目的，任何重复的值都将被忽略。"

msgid "Where:"
msgstr "其中："

msgid "ANY-INTEGER"
msgstr "ANY-INTEGER"

msgid "SMALLINT, INTEGER, BIGINT"
msgstr "SMALLINT, INTEGER, BIGINT"

msgid "ANY-NUMERIC"
msgstr "ANY-NUMERIC"

msgid "SMALLINT, INTEGER, BIGINT, REAL, FLOAT, NUMERIC"
msgstr "SMALLINT, INTEGER, BIGINT, REAL, FLOAT, NUMERIC"

msgid "BFS optional parameters"
msgstr "BFS可选参数"

msgid "Default"
msgstr "默认"

msgid "``max_depth``"
msgstr "``max_depth``"

msgid ":math:`9223372036854775807`"
msgstr ":math:`9223372036854775807`"

msgid "Upper limit of the depth of the tree."
msgstr "树深度的上限。"

msgid "When negative throws an error."
msgstr "为负数时抛出错误。"

msgid "Inner Queries"
msgstr "内部查询"

msgid "Edges SQL"
msgstr "Edges SQL"

msgid "Column"
msgstr "列"

msgid "``id``"
msgstr "``id``"

msgid "**ANY-INTEGER**"
msgstr "**ANY-INTEGER**"

msgid "Identifier of the edge."
msgstr "边的标识符"

msgid "``source``"
msgstr "``source``"

msgid "Identifier of the first end point vertex of the edge."
msgstr "边的第一个端点顶点的标识符。"

msgid "``target``"
msgstr "``target``"

msgid "Identifier of the second end point vertex of the edge."
msgstr "边的第二个端点顶点的标识符。"

msgid "``cost``"
msgstr "``cost``"

msgid "**ANY-NUMERICAL**"
msgstr "**ANY-NUMERICAL**"

msgid "Weight of the edge (``source``, ``target``)"
msgstr "边(``source``, ``target``)的权重"

msgid "``reverse_cost``"
msgstr "``reverse_cost``"

msgid "-1"
msgstr "-1"

msgid "Weight of the edge (``target``, ``source``)"
msgstr "边(``target``, ``source``)的权重"

msgid ""
"When negative: edge (``target``, ``source``) does not exist, therefore it's "
"not part of the graph."
msgstr "当为负时：边（``target``, ``source``）不存在，因此它不是图的一部分。"

msgid "``SMALLINT``, ``INTEGER``, ``BIGINT``"
msgstr "``SMALLINT``, ``INTEGER``, ``BIGINT``"

msgid "ANY-NUMERICAL"
msgstr "ANY-NUMERICAL"

msgid "``SMALLINT``, ``INTEGER``, ``BIGINT``, ``REAL``, ``FLOAT``"
msgstr "``SMALLINT``, ``INTEGER``, ``BIGINT``, ``REAL``, ``FLOAT``"

msgid "Result Columns"
msgstr "结果列"

msgid "Returns SET OF ``(seq, depth, start_vid, node, edge, cost, agg_cost)``"
msgstr "返回一组``(seq, depth, start_vid, node, edge, cost, agg_cost)``"

msgid "``seq``"
msgstr "``seq``"

msgid "Sequential value starting from :math:`1`."
msgstr "从:math:`1`开始的顺序值。"

msgid "``depth``"
msgstr "``depth``"

msgid "Depth of the ``node``."
msgstr "``node``的深度"

msgid ":math:`0` when ``node`` = ``start_vid``."
msgstr ":math:`0` 当``node`` = ``start_vid``。"

msgid "``start_vid``"
msgstr "``start_vid``"

msgid "Identifier of the root vertex."
msgstr "根顶点的标识符。"

msgid "``node``"
msgstr "``node``"

msgid "Identifier of ``node`` reached using ``edge``."
msgstr "使用``edge``到达的``node``的标识符。"

msgid "``edge``"
msgstr "``edge``"

msgid "Identifier of the ``edge`` used to arrive to ``node``."
msgstr "用于到达``node``的``edge``的标识符。"

msgid ":math:`-1` when ``node`` = ``start_vid``."
msgstr ":math:`-1` 当``node`` = ``start_vid``。"

msgid "``FLOAT``"
msgstr "``FLOAT``"

msgid "Cost to traverse ``edge``."
msgstr "遍历``edge``的成本。"

msgid "``agg_cost``"
msgstr "``agg_cost``"

msgid "Aggregate cost from ``start_vid`` to ``node``."
msgstr "从``start_vid``到``node``的总成本。"

msgid "See Also"
msgstr "另请参阅"

msgid ""
"`Boost: Prim's algorithm <https://www.boost.org/libs/graph/doc/"
"prim_minimum_spanning_tree.html>`__"
msgstr ""
"`Boost: Prim's algorithm <https://www.boost.org/libs/graph/doc/"
"prim_minimum_spanning_tree.html>`__"

msgid ""
"`Boost: Kruskal's algorithm <https://www.boost.org/libs/graph/doc/"
"kruskal_min_spanning_tree.html>`__"
msgstr ""
"`Boost: Kruskal's algorithm <https://www.boost.org/libs/graph/doc/"
"kruskal_min_spanning_tree.html>`__"

msgid ""
"`Wikipedia: Prim's algorithm <https://en.wikipedia.org/wiki/Prim"
"%27s_algorithm>`__"
msgstr ""
"`Wikipedia: Prim's algorithm <https://en.wikipedia.org/wiki/Prim"
"%27s_algorithm>`__"

msgid ""
"`Wikipedia: Kruskal's algorithm <https://en.wikipedia.org/wiki/"
"Kruskal's_algorithm>`__"
msgstr ""
"`Wikipedia: Kruskal's algorithm <https://en.wikipedia.org/wiki/"
"Kruskal's_algorithm>`__"

msgid "Indices and tables"
msgstr "索引和表格"

msgid ":ref:`genindex`"
msgstr ":ref:`genindex`"

msgid ":ref:`search`"
msgstr ":ref:`search`"

msgid "DFS - Category"
msgstr "DFS - 类别"

msgid "Traversal using Depth First Search."
msgstr "使用深度优先搜索进行遍历。"

msgid ":doc:`pgr_kruskalDFS`"
msgstr ":doc:`pgr_kruskalDFS`"

msgid ":doc:`pgr_primDFS`"
msgstr ":doc:`pgr_primDFS`"

msgid "Proposed"
msgstr "建议"

msgid "Proposed functions for next mayor release."
msgstr "下一版本的拟议功能。"

msgid "They are not officially in the current release."
msgstr "它们并未正式出现在当前版本中。"

msgid "They will likely officially be part of the next mayor release:"
msgstr "它们可能会正式成为下一个版本的一部分："

msgid "The functions make use of ANY-INTEGER and ANY-NUMERICAL"
msgstr "这些函数使用 ANY-INTEGER 和 ANY-NUMERICAL"

msgid "Name might not change. (But still can)"
msgstr "名字可能不会改变。（但仍然有可能改变）"

msgid "Signature might not change. (But still can)"
msgstr "签名可能不会改变。（但仍然有可能改变）"

msgid "Functionality might not change. (But still can)"
msgstr "功能可能不会改变。（但仍然有可能改变）"

msgid "pgTap tests have being done. But might need more."
msgstr "pgTap 测试已经完成。 但可能需要更多。"

msgid "Documentation might need refinement."
msgstr "文档可能需要完善。"

msgid ""
":doc:`pgr_depthFirstSearch` - Depth first search traversal of the graph."
msgstr ":doc:`pgr_depthFirstSearch` - 图的深度优先搜索遍历。"

msgid "In general:"
msgstr "一般来说："

msgid "K shortest paths - Category"
msgstr "K最短路径 - 类别"

msgid ":doc:`pgr_KSP` - Yen's algorithm based on pgr_dijkstra"
msgstr ":doc:`pgr_KSP` - 基于 pgr_dijkstra 的 Yen 算法"

msgid ":doc:`pgr_withPointsKSP` - Yen's algorithm based on pgr_withPoints"
msgstr ":doc:`pgr_withPointsKSP` - 基于 pgr_withPoints 的 Yen 算法"

msgid "TRSP - Family of functions"
msgstr "TRSP - 函数族"

msgid "When points are also given as input:"
msgstr "当点也作为输入给出时："

msgid ":doc:`pgr_trsp` - Vertex - Vertex routing with restrictions."
msgstr ":doc:`pgr_trsp` - Vertex - 有限制的顶点路由。"

msgid ":doc:`pgr_trspVia` - Via Vertices routing with restrictions."
msgstr ":doc:`pgr_trspVia` - 有限制的通过顶点路由。"

msgid ":doc:`pgr_trsp_withPoints` - Vertex/Point routing with restrictions."
msgstr ":doc:`pgr_trsp_withPoints` - 有限制的顶点/点路由。"

msgid ""
":doc:`pgr_trspVia_withPoints` - Via Vertex/point routing with restrictions."
msgstr ":doc:`pgr_trspVia_withPoints` - 通过有限制的顶点/点路由。"

msgid ""
"Read the :doc:`migration` about how to migrate from the deprecated TRSP "
"functionality to the new signatures or replacement functions."
msgstr ""
"阅读 :doc:`migration` 了解如何从已弃用的 TRSP 功能迁移到新的签名或替换功能。"

msgid "Experimental"
msgstr "实验性的"

msgid "Possible server crash"
msgstr "可能服务器崩溃"

msgid "These functions might create a server crash"
msgstr "这些功能可能会导致服务器崩溃"

msgid "Experimental functions"
msgstr "实验功能"

msgid "They are not officially of the current release."
msgstr "它们不是当前版本的正式版本。"

msgid "They likely will not be officially be part of the next release:"
msgstr "它们可能不会正式成为下一个版本的一部分："

msgid "The functions might not make use of ANY-INTEGER and ANY-NUMERICAL"
msgstr "这些函数可能不使用 ANY-INTEGER 和 ANY-NUMERICAL"

msgid "Name might change."
msgstr "名称可能会改变。"

msgid "Signature might change."
msgstr "签名可能会改变。"

msgid "Functionality might change."
msgstr "功能可能会改变。"

msgid "pgTap tests might be missing."
msgstr "pgTap 测试可能丢失。"

msgid "Might need c/c++ coding."
msgstr "可能需要 c/c++编码。"

msgid "May lack documentation."
msgstr "可能缺乏文档。"

msgid "Documentation if any might need to be rewritten."
msgstr "文档（如果有）可能需要重写。"

msgid "Documentation examples might need to be automatically generated."
msgstr "可能需要自动生成文档示例。"

msgid "Might need a lot of feedback from the comunity."
msgstr "可能需要社区的大量反馈。"

msgid "Might depend on a proposed function of pgRouting"
msgstr "可能取决于 pgRouting 的拟议功能"

msgid "Might depend on a deprecated function of pgRouting"
msgstr "可能依赖于 pgRouting 的已弃用函数"

msgid ":doc:`pgr_turnRestrictedPath` - Routing with restrictions."
msgstr ":doc:`pgr_turnRestrictedPath` - 有限制的路由。"

msgid "Introduction"
msgstr "介绍"

msgid ""
"Road restrictions are a sequence of road segments that can not be taken in a "
"sequential manner. Some restrictions are implicit on a directed graph, for "
"example, one way roads where the wrong way edge is not even inserted on the "
"graph. But normally on turns like no left turn or no right turn, hence the "
"name turn restrictions, there are sometimes restrictions."
msgstr ""
"道路限制是一系列不能按顺序采取的路段。 有向图上隐含了一些限制，例如单向道路，"
"其中错误的边甚至不会插入到图上。 但通常在转弯时如不许左转或不许右转，因此得名"
"转弯限制，这儿是一些常见限制"

msgid "TRSP algorithm"
msgstr "TRSP算法"

msgid ""
"The internal TRSP algorithm performs a lookahead over the dijkstra algorithm "
"in order to find out if the attempted path has a restriction. This allows "
"the algorithm to pass twice on the same vertex."
msgstr ""
"内部 TRSP 算法对 dijkstra 算法执行前瞻，以查明尝试的路径是否有限制。 这允许算"
"法在同一顶点上传递两次"

msgid "`Edges SQL`_ query as described."
msgstr "`Edges SQL`_按描述查询。"

msgid "`Restrictions SQL`_"
msgstr "`Restrictions SQL`_"

msgid "`Restrictions SQL`_ query as described."
msgstr "`Restrictions SQL`_按描述查询。"

msgid "**via vertices**"
msgstr "**via vertices**"

msgid "``ARRAY[`` **ANY-INTEGER** ``]``"
msgstr "``ARRAY[`` **ANY-INTEGER** ``]``"

msgid "Array of ordered vertices identifiers that are going to be visited."
msgstr "将要访问的有序顶点标识符数组。"

msgid "Restrictions"
msgstr "限制"

msgid ""
"On road networks, there are restrictions such as left or right turn "
"restrictions, no U turn restrictions."
msgstr "在道路网络上，有左转或右转限制等限制，没有掉头限制。"

msgid ""
"A restriction is a sequence of edges, called path and that path is to be "
"avoided."
msgstr "限制是一系列边，称为路径，并且要避免该路径。"

msgid "**Restrictions on the road network**"
msgstr "**道路网络的限制**"

msgid "These restrictions are represented on a table as follows:"
msgstr "这些限制在表格中表示如下："

msgid ""
"The table has an identifier, which maybe is needed for the administration of "
"the restrictions, but the algorithms do not need that information. If given "
"it will be ignored."
msgstr ""
"该表有一个标识符，这可能是管理限制所需要的，但算法不需要该信息。 如果给出，它"
"将被忽略。"

msgid "Restrictions SQL"
msgstr "Restrictions SQL"

msgid "``path``"
msgstr "``path``"

msgid "``ARRAY`` [**ANY-INTEGER**]"
msgstr "``ARRAY`` [**ANY-INTEGER**]"

msgid ""
"Sequence of edge identifiers that form a path that is not allowed to be "
"taken. - Empty arrays or ``NULL`` arrays are ignored. - Arrays that have a "
"``NULL`` element will raise an exception."
msgstr ""
"形成不允许采用的路径的边缘标识符序列。 - 空数组或 ``NULL`` 数组将被忽略。 - "
"具有 ``NULL`` 元素的数组将引发异常。"

msgid "``Cost``"
msgstr "``Cost``"

msgid "Cost of taking the forbidden path."
msgstr "走禁路的成本。"

msgid "Traveling Sales Person - Family of functions"
msgstr "Traveling Sales Person - 函数族"

msgid ":doc:`pgr_TSP` - When input is given as matrix cell information."
msgstr ":doc:`pgr_TSP`- 当输入作为矩阵单元信息给出时。"

msgid ":doc:`pgr_TSPeuclidean` - When input are coordinates."
msgstr ":doc:`pgr_TSPeuclidean` - 当输入是坐标时。"

msgid "Table of Contents"
msgstr "目录"

msgid "General Information"
msgstr "一般信息"

msgid "Problem Definition"
msgstr "问题定义"

msgid "The travelling salesperson problem (TSP) asks the following question:"
msgstr "旅行推销员问题 (TSP) 提出以下问题："

msgid ""
"*Given a list of cities and the distances between each pair of cities, which "
"is the shortest possible route that visits each city exactly once and "
"returns to the origin city?*"
msgstr ""
"*给定一个城市列表以及每对城市之间的距离，哪条是访问每个城市一次并返回出发城市"
"的最短路线？*"

msgid "Origin"
msgstr "起源"

msgid ""
"The traveling sales person problem was studied in the 18th century by "
"mathematicians **Sir William Rowam Hamilton** and **Thomas Penyngton "
"Kirkman**."
msgstr ""
"旅行推销员问题由数学家 **William Rowam Hamilton 爵士**和 **Thomas Penyngton "
"Kirkman** 于 18 世纪研究。"

msgid ""
"A discussion about the work of Hamilton & Kirkman can be found in the book "
"**Graph Theory (Biggs et  al. 1976)**."
msgstr ""
"关于Hamilton和Kirkman的工作的讨论可以在**《图论》（Biggs等人，1976年）**一书"
"中找到。"

msgid "ISBN-13: 978-0198539162"
msgstr "ISBN-13: 978-0198539162"

msgid "ISBN-10: 0198539169"
msgstr "ISBN-10: 0198539169"

msgid ""
"It is believed that the general form of the TSP have been first studied by "
"Kalr Menger in Vienna and Harvard. The problem was later promoted by "
"Hassler, Whitney & Merrill at Princeton. A detailed description about the "
"connection between Menger & Whitney, and the development of the TSP can be "
"found in `On the history of combinatorial optimization (till 1960) <https://"
"homepages.cwi.nl/~lex/files/histco.ps>`__"
msgstr ""
"人们认为旅行推销员问题（TSP）的一般形式最早由维也纳和哈佛的卡尔·门格尔（Karl "
"Menger）研究。后来，普林斯顿的哈斯勒、惠特尼和梅里尔（Hassler, Whitney & "
"Merrill）进一步推动了这个问题。关于门格尔和惠特尼之间的联系以及TSP的发展，可"
"以在`组合优化的历史(直到1960年) <https://homepages.cwi.nl/~lex/files/histco."
"ps>`__。"

msgid "To calculate the number of different tours through :math:`n` cities:"
msgstr "计算经过:math:`n` 城市的不同旅行次数："

msgid "Given a starting city,"
msgstr "给定一个起始城市，"

msgid "There are :math:`n-1` choices for the second city,"
msgstr "第二个城市还有:math:`n-1`个选择，"

msgid "And  :math:`n-2` choices for the third city, etc."
msgstr "以及第三个城市有:math:`n-2`个选择等。"

msgid "Multiplying these together we get :math:`(n-1)!  = (n-1) (n-2) . .  1`."
msgstr "将它们相乘我们得到:math:`(n-1)!  = (n-1) (n-2) . .  1`。"

msgid ""
"Now since the travel costs do not depend on the direction taken around the "
"tour:"
msgstr "现在，由于旅行成本不取决于旅行的方向："

msgid "this number by 2"
msgstr "这个数字乘2"

msgid ":math:`(n-1)!/2`."
msgstr ":math:`(n-1)!/2`。"

msgid "Characteristics"
msgstr "特征"

msgid "This problem is an NP-hard optimization problem."
msgstr "该问题是一个NP-hard优化问题。"

msgid "Metric Algorithm is used"
msgstr "使用度量算法"

msgid ""
"Implementation generates solutions that *are twice as long as the optimal "
"tour in the worst case* when:"
msgstr "*在最坏的情况下，实施产生的解决方案的时间是最佳旅行的两倍*："

msgid "Graph is undirected"
msgstr "图是无向的"

msgid "Graph is fully connected"
msgstr "图是全连通的"

msgid "Graph where traveling costs on edges obey the triangle inequality."
msgstr "图中，边上的旅行成本服从三角不等式。"

msgid "On an undirected graph:"
msgstr "在无向图上："

msgid "The traveling costs are symmetric:"
msgstr "旅行费用是对称的："

msgid ""
"Traveling costs from ``u`` to ``v`` are just as much as traveling from ``v`` "
"to ``u``"
msgstr "从 ``u`` 到 ``v`` 的旅行费用与从 ``v`` 到 ``u`` 的旅行费用相同"

msgid "TSP optional parameters"
msgstr "TSP 可选参数"

msgid "``start_id``"
msgstr "``start_id``"

msgid "``0``"
msgstr "``0``"

msgid "The first visiting vertex"
msgstr "第一个访问顶点"

msgid "When `0` any vertex can become the first visiting vertex."
msgstr "当 `0` 时，任何顶点都可以成为第一个访问顶点。"

msgid "``end_id``"
msgstr "``end_id``"

msgid "Last visiting vertex before returning to ``start_vid``."
msgstr "返回 ``start_vid`` 之前最后访问的顶点。"

msgid ""
"When ``0`` any vertex can become the last visiting vertex before returning "
"to ``start_id``."
msgstr ""
"当为 ``0`` 时，任何顶点都可以成为返回 ``start_id`` 之前最后访问的顶点。"

msgid ""
"When ``NOT 0`` and ``start_id = 0`` then it is the first and last vertex"
msgstr "当 ``NOT 0`` 且 ``start_id = 0``时，它是第一个和最后一个顶点"

msgid "References"
msgstr "参考"

msgid ""
"`Boost's metric appro's metric approximation <https://www.boost.org/libs/"
"graph/doc/metric_tsp_approx.html>`__"
msgstr ""
"`Boost 的 metric appro 的 metric 近似 <https://www.boost.org/libs/graph/doc/"
"metric_tsp_approx.html>`__"

msgid "`University of Waterloo TSP <https://www.math.uwaterloo.ca/tsp/>`__"
msgstr ""
"`滑铁卢大学（University of Waterloo ）TSP <https://www.math.uwaterloo.ca/tsp/"
">`__"

msgid ""
"`Wikipedia: Traveling Salesman Problem <https://en.wikipedia.org/wiki/"
"Traveling_salesman_problem>`__"
msgstr ""
"`维基百科：旅行商问题 <https://en.wikipedia.org/wiki/"
"Traveling_salesman_problem>`__"

msgid "Vehicle Routing Functions - Category (Experimental)"
msgstr "车辆路由功能 - 类别（实验）"

msgid "Pickup and delivery problem"
msgstr "取货和送货问题"

msgid ":doc:`pgr_pickDeliver` - Pickup & Delivery using a Cost Matrix"
msgstr ":doc:`pgr_pickDeliver` - 使用成本矩阵的取货&送货"

msgid ""
":doc:`pgr_pickDeliverEuclidean` - Pickup & Delivery with Euclidean distances"
msgstr ":doc:`pgr_pickDeliverEuclidean` - 使用欧几里得距离的取货&送货"

msgid "Distribution problem"
msgstr "分配问题"

msgid ":doc:`pgr_vrpOneDepot` - From a single depot, distributes orders"
msgstr ":doc:`pgr_vrpOneDepot` - 从单个仓库分发订单"

msgid "Contents"
msgstr "内容"

msgid ""
"Vehicle Routing Problems `VRP` are **NP-hard** optimization problem, it "
"generalises the travelling salesman problem (TSP)."
msgstr "车辆路径问题 `VRP` 是 **NP-hard**优化问题，它推广了旅行商问题 (TSP)。"

msgid "The objective of the VRP is to minimize the total route cost."
msgstr "VRP 的目标是最小化总路由成本。"

msgid "There are several variants of the VRP problem,"
msgstr "VRP 问题有多种变体，"

msgid "**pgRouting does not try to implement all variants.**"
msgstr "**pgRouting 并不尝试实现所有变体。**"

msgid ""
"Capacitated Vehicle Routing Problem `CVRP` where The vehicles have limited "
"carrying capacity of the goods."
msgstr "容量车辆路径问题 `CVRP` 其中车辆的货物承载能力有限。"

msgid ""
"Vehicle Routing Problem with Time Windows `VRPTW` where the locations have "
"time windows within which the vehicle's visits must be made."
msgstr ""
"具有时间窗口的车辆路由问题 `VRPTW`，其中位置具有车辆必须访问的时间窗口。"

msgid ""
"Vehicle Routing Problem with Pickup and Delivery `VRPPD` where a number of "
"goods need to be moved from certain pickup locations to other delivery "
"locations."
msgstr ""
"取货和送货的车辆路径问题`VRPPD`，其中大量货物需要从某些取货地点移动到其他送货"
"地点。"

msgid "Limitations"
msgstr "局限性"

msgid "No multiple time windows for a location."
msgstr "一个位置没有多个时间窗口。"

msgid "Less vehicle used is considered better."
msgstr "使用的车辆越少越好。"

msgid "Less total duration is better."
msgstr "总持续时间越短越好。"

msgid "Less wait time is better."
msgstr "等待时间越短越好。"

msgid "Pick & Delivery"
msgstr "取货 & 送货"

msgid ""
"Problem: `CVRPPDTW` Capacitated Pick and Delivery Vehicle Routing problem "
"with Time Windows"
msgstr "问题：`CVRPPDTW` 具有时间窗口的有能力分拣和送货车辆路径问题"

msgid "Times are relative to `0`"
msgstr "时间是相对于`0`的"

msgid "The vehicles"
msgstr "车辆"

msgid "have start and ending service duration times."
msgstr "有开始和结束服务持续时间。"

msgid "have opening and closing times for the start and ending locations."
msgstr "有开始和结束地点的开放和关闭时间。"

msgid "have a capacity."
msgstr "具有容量"

msgid "The orders"
msgstr "订单"

msgid "Have pick up and delivery locations."
msgstr "有提货和送货地点。"

msgid "Have opening and closing times for the pickup and delivery locations."
msgstr "有提货和送货地点的开放和关闭时间。"

msgid "Have pickup and delivery duration service times."
msgstr "有取货和送货持续时间的服务时间。"

msgid ""
"have a demand request for moving goods from the pickup location to the "
"delivery location."
msgstr "有将货物从取货地点移动到交货地点的需求请求。"

msgid "Time based calculations:"
msgstr "基于时间的计算："

msgid "Travel time between customers is :math:`distance / speed`"
msgstr "客户之间的旅行时间为:math:`distance / speed`"

msgid "Pickup and delivery order pair is done by the same vehicle."
msgstr "取货和送货订单对由同一辆车完成。"

msgid "A pickup is done before the delivery."
msgstr "送货前会进行取货。"

msgid "Pick & deliver"
msgstr "取货 & 送货"

msgid "Used in :doc:`pgr_pickDeliverEuclidean`"
msgstr "用于:doc:`pgr_pickDeliverEuclidean`"

msgid "`Orders SQL`_"
msgstr "`Orders SQL`_"

msgid "`Orders SQL`_ as described below."
msgstr "`Orders SQL`_如下所述。"

msgid "`Vehicles SQL`_"
msgstr "`Vehicles SQL`_"

msgid "`Vehicles SQL`_ as described below."
msgstr "`Vehicles SQL`_ 如下所述。"

msgid "Used in :doc:`pgr_pickDeliver`"
msgstr "用于:doc:`pgr_pickDeliver`"

msgid "`Matrix SQL`_"
msgstr "`Matrix SQL`_"

msgid "`Matrix SQL`_ as described below."
msgstr "`Matrix SQL`_ 如下所述。"

msgid "Pick-Deliver optional parameters"
msgstr "取货-送货可选参数"

msgid "``factor``"
msgstr "``factor``"

msgid "``NUMERIC``"
msgstr "``NUMERIC``"

msgid "1"
msgstr "1"

msgid "Travel time multiplier. See :ref:`pd_factor`"
msgstr "旅行时间乘数。 请参阅:ref:`pd_factor`"

msgid "``max_cycles``"
msgstr "``max_cycles``"

msgid "``INTEGER``"
msgstr "``INTEGER``"

msgid "10"
msgstr "10"

msgid "Maximum number of cycles to perform on the optimization."
msgstr "执行优化的最大周期数。"

msgid "``initial_sol``"
msgstr "``initial_sol``"

msgid "4"
msgstr "4"

msgid "Initial solution to be used."
msgstr "要使用的初始解决方案。"

msgid "``1`` One order per truck"
msgstr "``1`` 每辆卡车一份订单"

msgid "``2`` Push front order."
msgstr "``2`` 提前订单"

msgid "``3`` Push back order."
msgstr "``3`` 推迟订单"

msgid "``4`` Optimize insert."
msgstr "``4`` 优化插入。"

msgid ""
"``5`` Push back order that allows more orders to be inserted at the back"
msgstr "``5`` 推迟订单，允许在后面插入更多订单"

msgid ""
"``6`` Push front order that allows more orders to be inserted at the front"
msgstr "``6`` 提前订单，允许在前面插入更多订单"

msgid "Orders SQL"
msgstr "订单 SQL"

msgid "Common columns for the orders SQL in both implementations:"
msgstr "两种实现中订单 SQL 的公共列："

msgid "|ANY-INTEGER|"
msgstr "|ANY-INTEGER|"

msgid "Identifier of the pick-delivery order pair."
msgstr "提货-交货订单对的标识符。"

msgid "``demand``"
msgstr "``demand``"

msgid "|ANY-NUMERICAL|"
msgstr "|ANY-NUMERICAL|"

msgid "Number of units in the order"
msgstr "订单中的单位数量"

msgid "``p_open``"
msgstr "``p_open``"

msgid "The time, relative to 0, when the pickup location opens."
msgstr "相对于0的时间，提货地点开放。"

msgid "``p_close``"
msgstr "``p_close``"

msgid "The time, relative to 0, when the pickup location closes."
msgstr "提货地点关闭的时间（相对于 0）。"

msgid "[``p_service``]"
msgstr "[``p_service``]"

msgid "The duration of the loading at the pickup location."
msgstr "在取货地点装载的持续时间。"

msgid "When missing: 0 time units are used"
msgstr "缺失时：使用 0 个时间单位"

msgid "``d_open``"
msgstr "``d_open``"

msgid "The time, relative to 0, when the delivery location opens."
msgstr "交货地点开放的时间（相对于 0）。"

msgid "``d_close``"
msgstr "``d_close``"

msgid "The time, relative to 0, when the delivery location closes."
msgstr "交货地点关闭的时间（相对于 0）。"

msgid "[``d_service``]"
msgstr "[``d_service``]"

msgid "The duration of the unloading at the delivery location."
msgstr "在交货地点卸货的持续时间。"

msgid ""
"For :doc:`pgr_pickDeliver` the pickup and delivery identifiers of the "
"locations are needed:"
msgstr "对于:doc:`pgr_pickDeliver`，需要位置的取货和送货标识符："

msgid "``p_node_id``"
msgstr "``p_node_id``"

msgid ""
"The node identifier of the pickup, must match a vertex identifier in the "
"`Matrix SQL`_."
msgstr "取货的节点标识符必须与`Matrix SQL`_ 中的顶点标识符匹配。"

msgid "``d_node_id``"
msgstr "``d_node_id``"

msgid ""
"The node identifier of the delivery, must match a vertex identifier in the "
"`Matrix SQL`_."
msgstr "送货的节点标识符必须与 `Matrix SQL`_中的顶点标识符匹配。"

msgid ""
"For :doc:`pgr_pickDeliverEuclidean` the :math:`(x, y)` values of the "
"locations are needed:"
msgstr "对于 :doc:`pgr_pickDeliverEuclidean`，这需要位置的:math:`(x, y)`值："

msgid "``p_x``"
msgstr "``p_x``"

msgid ":math:`x` value of the pick up location"
msgstr "取货地点的:math:`x`值"

msgid "``p_y``"
msgstr "``p_y``"

msgid ":math:`y` value of the pick up location"
msgstr "取货地点的:math:`y`值"

msgid "``d_x``"
msgstr "``d_x``"

msgid ":math:`x` value of the delivery location"
msgstr "送货地点的:math:`x`值"

msgid "``d_y``"
msgstr "``d_y``"

msgid ":math:`y` value of the delivery location"
msgstr "送货地点的:math:`y` 值"

msgid "Vehicles SQL"
msgstr "车辆 SQL"

msgid "Common columns for the vehicles SQL in both implementations:"
msgstr "两种实现中车辆 SQL 的公共列："

msgid "Identifier of the vehicle."
msgstr "车辆的标识符。"

msgid "``capacity``"
msgstr "``capacity``"

msgid "Maiximum capacity units"
msgstr "最大容量单位"

msgid "``start_open``"
msgstr "``start_open``"

msgid "The time, relative to 0, when the starting location opens."
msgstr "起始位置打开的时间（相对于 0）。"

msgid "``start_close``"
msgstr "``start_close``"

msgid "The time, relative to 0, when the starting location closes."
msgstr "起始位置关闭的时间（相对于 0）。"

msgid "[``start_service``]"
msgstr "[``start_service``]"

msgid "The duration of the loading at the starting location."
msgstr "在起始位置加载的持续时间。"

msgid "When missing: A duration of :math:`0` time units is used."
msgstr "缺失时：使用 :math:`0` 个时间单位的持续时间。"

msgid "[``end_open``]"
msgstr "[``end_open``]"

msgid "The time, relative to 0, when the ending location opens."
msgstr "结束位置打开的时间（相对于 0）。"

msgid "When missing: The value of ``start_open`` is used"
msgstr "缺失时：使用``start_open``的值"

msgid "[``end_close``]"
msgstr "[``end_close``]"

msgid "The time, relative to 0, when the ending location closes."
msgstr "结束位置关闭的时间（相对于 0）。"

msgid "When missing: The value of ``start_close`` is used"
msgstr "缺失时：使用``start_close``的值"

msgid "[``end_service``]"
msgstr "[``end_service``]"

msgid "The duration of the loading at the ending location."
msgstr "在结束位置加载的持续时间。"

msgid "When missing: A duration in ``start_service`` is used."
msgstr "缺失时：使用 ``start_service`` 中的持续时间。"

msgid ""
"For :doc:`pgr_pickDeliver` the starting and ending identifiers of the "
"locations are needed:"
msgstr "对于 :doc:`pgr_pickDeliver`，需要位置的开始和结束标识符："

msgid "``start_node_id``"
msgstr "``start_node_id``"

msgid ""
"The node identifier of the start location, must match a vertex identifier in "
"the `Matrix SQL`_."
msgstr "起始位置的节点标识符必须与 `Matrix SQL`_ 中的顶点标识符匹配。"

msgid "[``end_node_id``]"
msgstr "[``end_node_id``]"

msgid ""
"The node identifier of the end location, must match a vertex identifier in "
"the `Matrix SQL`_."
msgstr "结束位置的节点标识符必须与 `Matrix SQL`_ 中的顶点标识符匹配。"

msgid "When missing: ``end_node_id`` is used."
msgstr "缺少时：使用``end_node_id``。"

msgid "``start_x``"
msgstr "``start_x``"

msgid ":math:`x` value of the starting location"
msgstr "起始位置的:math:`x`值"

msgid "``start_y``"
msgstr "``start_y``"

msgid ":math:`y` value of the starting location"
msgstr "起始位置的:math:`y`值"

msgid "[``end_x``]"
msgstr "[``end_x``]"

msgid ":math:`x` value of the ending location"
msgstr "结束位置的:math:`x`值"

msgid "When missing: ``start_x`` is used."
msgstr "缺失时：使用``start_x``值。"

msgid "[``end_y``]"
msgstr "[``end_y``]"

msgid ":math:`y` value of the ending location"
msgstr "结束位置的:math:`y`值"

msgid "When missing: ``start_y`` is used."
msgstr "缺失时：使用``start_y``值。"

msgid "Matrix SQL"
msgstr "矩阵SQL"

msgid "Set of |matrix-result|"
msgstr "|matrix-result|的集合"

msgid "Identifier of the starting vertex."
msgstr "起始顶点的标识符。"

msgid "``end_vid``"
msgstr "``end_vid``"

msgid "Identifier of the ending vertex."
msgstr "结束顶点的标识符。"

msgid "Aggregate cost from ``start_vid`` to ``end_vid``."
msgstr "从 ``start_vid`` 到 ``end_vid`` 的总成本。"

msgid "Return columns"
msgstr "返回列"

msgid "Sequential value starting from **1**."
msgstr "从**1**开始的顺序值。"

msgid "``vehicle_seq``"
msgstr "``vehicle_seq``"

msgid ""
"Sequential value starting from **1** for current vehicles. The :math:`n_{th}"
"` vehicle in the solution."
msgstr "当前车辆从 **1** 开始的顺序值。 解决方案中的第 :math:`n_{th}` 辆车。"

msgid "Value :math:`-2` indicates it is the summary row."
msgstr "值 :math:`-2` 表示它是汇总行"

msgid "``vehicle_id``"
msgstr "``vehicle_id``"

msgid "BIGINT"
msgstr "BIGINT"

msgid "Current vehicle identifier."
msgstr "当前车辆标识符。"

msgid "Sumary row has the **total capacity violations**."
msgstr "摘要行有**总容量违规情况**。"

msgid ""
"A capacity violation happens when overloading or underloading a vehicle."
msgstr "当车辆超载或欠载时，就会发生容量违规。"

msgid "``stop_seq``"
msgstr "``stop_seq``"

msgid "INTEGER"
msgstr "INTEGER"

msgid ""
"Sequential value starting from **1** for the stops made by the current "
"vehicle. The :math:`m_{th}` stop of the current vehicle."
msgstr "当前车辆停止的顺序值，从 **1** 开始。 当前第:math:`m_{th}`车辆的停止。"

msgid "Sumary row has the **total time windows violations**."
msgstr "摘要行包含**总时间窗口违规情况**。"

msgid ""
"A time window violation happens when arriving after the location has closed."
msgstr "在该地点关闭后到达时，会发生时间窗口违规。"

msgid "``stop_type``"
msgstr "``stop_type``"

msgid "Kind of stop location the vehicle is at"
msgstr "车辆所在的停车位置类型"

msgid ":math:`-1`: at the solution summary row"
msgstr ":math:`-1`: 在解决方案摘要行"

msgid ":math:`1`: Starting location"
msgstr ":math:`1`: 起始位置"

msgid ":math:`2`: Pickup location"
msgstr ":math:`2`: 取货位置"

msgid ":math:`3`: Delivery location"
msgstr ":math:`3`: 送货位置"

msgid ":math:`6`: Ending location and indicates the vehicle's summary row"
msgstr ":math:`6`: 结束位置并指示车辆的摘要行"

msgid "``order_id``"
msgstr "``order_id``"

msgid "Pickup-Delivery order pair identifier."
msgstr "取货-送货订单对标识符。"

msgid ""
"Value :math:`-1`: When no order is involved on the current stop location."
msgstr "值:math:`-1`: 当前停留位置没有订单参与。"

msgid "``cargo``"
msgstr "``cargo``"

msgid "Cargo units of the vehicle when leaving the stop."
msgstr "车辆离开停车点时的货物单位。"

msgid "Value :math:`-1` on solution summary row."
msgstr "值:math:`-1`在解决方案摘要行。"

msgid "``travel_time``"
msgstr "``travel_time``"

msgid "Travel time from previous ``stop_seq`` to current ``stop_seq``."
msgstr "从前一个 ``stop_seq`` 到当前 ``stop_seq`` 的行程时间。"

msgid "Summary has the **total traveling time**:"
msgstr "总结一下**总的行程时间**："

msgid "The sum of all the ``travel_time``."
msgstr "所有 ``travel_time`` 的总和。"

msgid "``arrival_time``"
msgstr "``arrival_time``"

msgid "Time spent waiting for current location to open."
msgstr "等待当前位置打开所花费的时间。"

msgid ":math:`-1`: at the solution summary row."
msgstr ":math:`-1`: 在解决方案摘要行。"

msgid ":math:`0`: at the starting location."
msgstr ":math:`0`: 在起始位置。"

msgid "``wait_time``"
msgstr "``wait_time``"

msgid "Summary row has the **total waiting time**:"
msgstr "摘要行包含**总等待时间**："

msgid "The sum of all the ``wait_time``."
msgstr "所有 ``wait_time`` 的总和。"

msgid "``service_time``"
msgstr "``service_time``"

msgid "Service duration at current location."
msgstr "当前位置的服务持续时间。"

msgid "Summary row has the **total service time**:"
msgstr "摘要行包含**总服务时间**："

msgid "The sum of all the ``service_time``."
msgstr "所有``service_time``的总和。"

msgid "``departure_time``"
msgstr "``departure_time``"

msgid "The time at which the vehicle departs from the stop."
msgstr "车辆离开车站的时间。"

msgid ":math:`arrival\\_time + wait\\_time + service\\_time`."
msgstr ":math:`arrival\\_time + wait\\_time + service\\_time`。"

msgid "The ending location has the **total time** used by the current vehicle."
msgstr "结束位置有当前车辆使用的**总时间**。"

msgid "Summary row has the **total solution time**:"
msgstr "摘要行包含**总解决问题时间**："

msgid ""
":math:`total\\ traveling\\ time + total\\ waiting\\ time + total\\ service\\ "
"time`."
msgstr ""
":math:`total\\ traveling\\ time + total\\ waiting\\ time + total\\ service\\ "
"time`。"

msgid "Summary Row"
msgstr "摘要行"

msgid "Continues the sequence"
msgstr "继续序列"

msgid "**total capacity violations**:"
msgstr "**总容量违规**："

msgid "**total time windows violations**:"
msgstr "**总时间窗口违规**："

msgid ":math:`-1`"
msgstr ":math:`-1`"

msgid "**total traveling time**:"
msgstr "**总行程时间**："

msgid "**total waiting time**:"
msgstr "**总行程时间**："

msgid "**total service time**:"
msgstr "**总服务时间**："

msgid "Handling Parameters"
msgstr "处理参数"

msgid ""
"To define a problem, several considerations have to be done, to get "
"consistent results. This section gives an insight of how parameters are to "
"be considered."
msgstr ""
"要定义问题，必须考虑多种因素才能获得一致的结果。 本节深入了解如何考虑参数。"

msgid "`Capacity and Demand Units Handling`_"
msgstr "`容量和需求单位处理`_"

msgid "`Locations`_"
msgstr "`位置`_"

msgid "`Time Handling`_"
msgstr "`时间处理`_"

msgid "`Factor Handling`_"
msgstr "`因素处理`_"

msgid "Capacity and Demand Units Handling"
msgstr "容量和需求单位处理"

msgid "The `capacity` of a vehicle, can be measured in:"
msgstr "车辆的`容量`可以通过以下方式测量："

msgid "Volume units like :math:`m^3`."
msgstr "体积单位如:math:`m^3`。"

msgid "Area units like :math:`m^2` (when no stacking is allowed)."
msgstr "面积单位如:math:`m^2`（不允许堆叠时）。"

msgid "Weight units like :math:`kg`."
msgstr "重量单位如:math:`kg`。"

msgid "Number of boxes that fit in the vehicle."
msgstr "车辆内可容纳的箱子数量。"

msgid "Number of seats in the vehicle"
msgstr "车内座位数"

msgid ""
"The `demand` request of the pickup-deliver orders must use the same units as "
"the units used in the vehicle's `capacity`."
msgstr "取货-送货订单的`需求`请求必须使用与车辆`容量`中使用的单位相同的单位。"

msgid ""
"To handle problems like:  10 (equal dimension) boxes of apples and 5 kg of "
"feathers that are to be transported (not packed in boxes)."
msgstr "处理这样的问题：10箱（等尺寸）苹果和5公斤羽毛需要运输（不装箱）。"

msgid ""
"If the vehicle's **capacity** is measured in `boxes`, a conversion of `kg of "
"feathers` to `number of boxes` is needed."
msgstr ""
"如果车辆的 **容量**以`箱子`来衡量，则需要将`羽毛的千克`换算为`箱子的数量`。"

msgid ""
"If the vehicle's **capacity** is measured in `kg`, a conversion of `box of "
"apples` to `kg` is needed."
msgstr "如果车辆的**容量**以`kg`为单位，则需要将`一箱苹果`换算为`kg`。"

msgid "Showing how the 2 possible conversions can be done"
msgstr "显示如何完成两种可能的转换"

msgid ""
"Let: - :math:`f\\_boxes`: number of boxes needed for `1` kg of feathers. - :"
"math:`a\\_weight`: weight of `1` box of apples."
msgstr ""
"设：- :math:`f\\_boxes`：`1`公斤羽毛所需的箱子数量。- :math:`a\\_weight`：`1`"
"箱子苹果的重量。"

msgid "Capacity Units"
msgstr "容量单位"

msgid "apples"
msgstr "苹果"

msgid "feathers"
msgstr "羽毛"

msgid "boxes"
msgstr "箱子"

msgid ":math:`5 * f\\_boxes`"
msgstr ":math:`5 * f\\_boxes`"

msgid "kg"
msgstr "千克"

msgid ":math:`10 * a\\_weight`"
msgstr ":math:`10 * a\\_weight`"

msgid "5"
msgstr "5"

msgid "Locations"
msgstr "位置"

msgid "When using :doc:`pgr_pickDeliverEuclidean`:"
msgstr "当使用 :doc:`pgr_pickDeliverEuclidean`："

msgid "The vehicles have :math:`(x, y)` pairs for start and ending locations."
msgstr "车辆有起点和终点:math:`(x, y)`对。"

msgid "The orders Have :math:`(x, y)` pairs for pickup and delivery locations."
msgstr "订单有取货和送货地点:math:`(x, y)`对。"

msgid "When using :doc:`pgr_pickDeliver`:"
msgstr "当使用:doc:`pgr_pickDeliver`:"

msgid "The vehicles have identifiers for the start and ending locations."
msgstr "车辆具有起始位置和结束位置的标识符。"

msgid "The orders have identifiers for the pickup and delivery locations."
msgstr "订单具有取货和送货地点的标识符。"

msgid "All the identifiers are indices to the given matrix."
msgstr "所有标识符都是给定矩阵的索引。"

msgid "Time Handling"
msgstr "时间处理"

msgid ""
"The times are relative to **0**. All time units have to be converted to a "
"**0** reference and the same time units."
msgstr ""
"时间是相对于 **0** 的。所有时间单位都必须转换为 **0** 参考和相同的时间单位。"

msgid ""
"Suppose that a vehicle's driver starts the shift at 9:00 am and ends the "
"shift at 4:30 pm and the service time duration is 10 minutes with 30 seconds."
msgstr ""
"假设车辆驾驶员上午 9:00 开始换班，下午 4:30 结束换班，服务时间为 10 分钟 30 "
"秒。"

msgid "Meaning of 0"
msgstr "0的含义"

msgid "time units"
msgstr "时间单位"

msgid "9:00 am"
msgstr "9:00 am"

msgid "4:30 pm"
msgstr "4:30 pm"

msgid "10 min 30 secs"
msgstr "10 min 30 secs"

msgid "0:00 am"
msgstr "0:00 am"

msgid "hours"
msgstr "小时"

msgid "9"
msgstr "9"

msgid "16.5"
msgstr "16.5"

msgid ":math:`10.5 / 60  = 0.175`"
msgstr ":math:`10.5 / 60  = 0.175`"

msgid "minutes"
msgstr "分钟"

msgid ":math:`9*60 = 54`"
msgstr ":math:`9*60 = 54`"

msgid ":math:`16.5*60 = 990`"
msgstr ":math:`16.5*60 = 990`"

msgid "10.5"
msgstr "10.5"

msgid "0"
msgstr "0"

msgid "7.5"
msgstr "7.5"

msgid ":math:`7.5*60 = 540`"
msgstr ":math:`7.5*60 = 540`"

msgid "Factor handling"
msgstr "因素处理"

msgid ""
"``factor`` acts as a multiplier to convert from distance values to time "
"units the matrix values or the euclidean values."
msgstr "`因子``充当乘数，将距离值转换为时间单位、矩阵值或欧几里得值。"

msgid "When the values are already in the desired time units"
msgstr "当值已处于所需时间单位时"

msgid "``factor`` should be **1**"
msgstr "``因数``应为 **1**"

msgid "When ``factor`` > 1 the travel times are faster"
msgstr "当``因子`` > 1 时，行程时间更快"

msgid "When ``factor`` < 1 the travel times are slower"
msgstr "当 ``因子`` < 1 时，行程时间会变慢"

msgid "For the :doc:`pgr_pickDeliverEuclidean`:"
msgstr "用于:doc:`pgr_pickDeliverEuclidean`:"

msgid ""
"Working with time units in seconds, and x/y in lat/lon: Factor: would depend "
"on the location of the points and on the average velocity say 25m/s is the "
"velocity."
msgstr ""
"使用以秒为单位的时间单位，以及以纬度/经度为单位的 x/y： 因子：取决于点的位置"
"和平均速度，例如 25m/s 是速度。"

msgid "Latitude"
msgstr "纬度"

msgid "Conversion"
msgstr "转换"

msgid "Factor"
msgstr "因素"

msgid "45"
msgstr "45"

msgid "1 longitude degree is (78846.81m)/(25m/s)"
msgstr "1经度为(78846.81m)/(25m/s)"

msgid "3153 s"
msgstr "3153 s"

msgid "1 longitude degree is (111319.46 m)/(25m/s)"
msgstr "1经度为(111319.46 m)/(25m/s)"

msgid "4452 s"
msgstr "4452 s"

msgid "For the :doc:`pgr_pickDeliver`:"
msgstr "用于:doc:`pgr_pickDeliver`:"

msgid ""
"Given :math:`v = d / t` therefore :math:`t = d / v` And the ``factor`` "
"becomes :math:`1 / v`"
msgstr ""
"给定 :math:`v = d / t` 因此:math:`t = d / v` 并且``因子``变为:math:`1 / v`"

msgid "v"
msgstr "v"

msgid "Velocity"
msgstr "速度"

msgid "d"
msgstr "d"

msgid "Distance"
msgstr "距离"

msgid "t"
msgstr "t"

msgid "Time"
msgstr "时间"

msgid ""
"For the following equivalences :math:`10m/s \\approx 600m/min \\approx 36 km/"
"hr`"
msgstr "对于以下等价 :math:`10m/s \\approx 600m/min \\approx 36 km/hr`"

msgid ""
"Working with time units in seconds and the matrix been in meters: For a "
"1000m lenght value on the matrix:"
msgstr ""
"使用以秒为单位的时间单位和以米为单位的矩阵：对于矩阵上的 1000m 长度值："

msgid "Units"
msgstr "单位"

msgid "velocity"
msgstr "速度"

msgid "Result"
msgstr "结果"

msgid "seconds"
msgstr "秒"

msgid ":math:`10 m/s`"
msgstr ":math:`10 m/s`"

msgid ":math:`\\frac{1}{10m/s}`"
msgstr ":math:`\\frac{1}{10m/s}`"

msgid ":math:`0.1s/m`"
msgstr ":math:`0.1s/m`"

msgid ":math:`1000m * 0.1s/m = 100s`"
msgstr ":math:`1000m * 0.1s/m = 100s`"

msgid ":math:`600 m/min`"
msgstr ":math:`600 m/min`"

msgid ":math:`\\frac{1}{600m/min}`"
msgstr ":math:`\\frac{1}{600m/min}`"

msgid ":math:`0.0016min/m`"
msgstr ":math:`0.0016min/m`"

msgid ":math:`1000m * 0.0016min/m = 1.6min`"
msgstr ":math:`1000m * 0.0016min/m = 1.6min`"

msgid "Hours"
msgstr "小时"

msgid ":math:`36 km/hr`"
msgstr ":math:`36 km/hr`"

msgid ":math:`\\frac{1}{36 km/hr}`"
msgstr ":math:`\\frac{1}{36 km/hr}`"

msgid ":math:`0.0277hr/km`"
msgstr ":math:`0.0277hr/km`"

msgid ":math:`1km * 0.0277hr/km = 0.0277hr`"
msgstr ":math:`1km * 0.0277hr/km = 0.0277hr`"

msgid "https://en.wikipedia.org/wiki/Vehicle_routing_problem"
msgstr "https://en.wikipedia.org/wiki/Vehicle_routing_problem"

msgid "The queries use the :doc:`sampledata` network."
msgstr "查询使用:doc:`sampledata` 网络。"

msgid "A* - Family of functions"
msgstr "A* - 函数族"

msgid ""
"The A* (pronounced \"A Star\") algorithm is based on Dijkstra's algorithm "
"with a heuristic that allow it to solve most shortest path problems by "
"evaluation only a sub-set of the overall graph."
msgstr ""
"A*（发音为“A星”）算法基于 Dijkstra 算法，其启发式算法使其能够通过仅评估整个图"
"的子集来解决大多数最短路径问题。"

msgid ":doc:`pgr_aStar` - A* algorithm for the shortest path."
msgstr ":doc:`pgr_aStar` - A* 最短路径算法。"

msgid ":doc:`pgr_aStarCost` - Get the aggregate cost of the shortest paths."
msgstr ":doc:`pgr_aStarCost` - 获取最短路径的总成本。"

msgid ":doc:`pgr_aStarCostMatrix` - Get the cost matrix of the shortest paths."
msgstr ":doc:`pgr_aStarCostMatrix` - 获取最短路径的成本矩阵。"

msgid "The main Characteristics are:"
msgstr "主要特点是："

msgid "Process works for directed and undirected graphs."
msgstr "流程适用于有向图和无向图。"

msgid "Ordering is:"
msgstr "顺序是"

msgid "first by ``start_vid`` (if exists)"
msgstr "首先按``start_vid``（如果存在）"

msgid "then by ``end_vid``"
msgstr "然后按``end_vid``"

msgid "Values are returned when there is a path."
msgstr "当存在路径时返回值。"

msgid "Let :math:`v` and :math:`u` be nodes on the graph:"
msgstr "设 :math:`v` 和 :math:`u` 为图上的节点："

msgid "If there is no path from :math:`v` to :math:`u`:"
msgstr "如果没有从:math:`v` 到 :math:`u`的路径："

msgid "no corresponding row is returned"
msgstr "没有返回对应的行"

msgid "``agg_cost`` from :math:`v` to :math:`u` is :math:`\\infty`"
msgstr "从:math:`v`到:math:`u`的``agg_cost`` 是 :math:`\\infty`"

msgid "There is no path when :math:`v = u` therefore"
msgstr "当:math:`v = u`没有路径，因此"

msgid "``agg_cost`` from `v` to `u` is :math:`0`"
msgstr "从`v`到`u`的``agg_cost``是:math:`0`"

msgid "When :math:`(x,y)` coordinates for the same vertex identifier differ:"
msgstr "当同一顶点标识符的:math:`(x,y)` 坐标不同时："

msgid "A random selection of the vertex's :math:`(x,y)` coordinates is used."
msgstr "使用随机选择的顶点的:math:`(x,y)`坐标。"

msgid "Running time: :math:`O((E + V) * \\log V)`"
msgstr "运行时间：:math:`O((E + V) * \\log V)`"

msgid "aStar optional Parameters"
msgstr "aStar可选参数"

msgid "``heuristic``"
msgstr "``heuristic``"

msgid "Heuristic number. Current valid values 0~5."
msgstr "Heuristic 数字。当前有效值0~5。"

msgid "0: :math:`h(v) = 0` (Use this value to compare with pgr_dijkstra)"
msgstr "0: :math:`h(v) = 0` (使用该值与 pgr_dijkstra 进行比较)"

msgid "1: :math:`h(v) = abs(max(\\Delta x, \\Delta y))`"
msgstr "1: :math:`h(v) = abs(max(\\Delta x, \\Delta y))`"

msgid "2: :math:`h(v) = abs(min(\\Delta x, \\Delta y))`"
msgstr "2: :math:`h(v) = abs(min(\\Delta x, \\Delta y))`"

msgid "3: :math:`h(v) = \\Delta x * \\Delta x + \\Delta y * \\Delta y`"
msgstr "3: :math:`h(v) = \\Delta x * \\Delta x + \\Delta y * \\Delta y`"

msgid "4: :math:`h(v) = sqrt(\\Delta x * \\Delta x + \\Delta y * \\Delta y)`"
msgstr "4: :math:`h(v) = sqrt(\\Delta x * \\Delta x + \\Delta y * \\Delta y)`"

msgid "5: :math:`h(v) = abs(\\Delta x) + abs(\\Delta y)`"
msgstr "5: :math:`h(v) = abs(\\Delta x) + abs(\\Delta y)`"

msgid "``1``"
msgstr "``1``"

msgid "For units manipulation. :math:`factor > 0`."
msgstr "对于单位操作。:math:`factor > 0`。"

msgid "``epsilon``"
msgstr "``epsilon``"

msgid "For less restricted results. :math:`epsilon >= 1`."
msgstr "对于限制较少的结果。:math:`epsilon >= 1`。"

msgid ""
"See :ref:`heuristics <astar_heuristics>` available and :ref:`factor "
"<astar_factor>` handling."
msgstr ""
"查看可用的:ref:`heuristics <astar_heuristics>`和:ref:`factor <astar_factor>`"
"处理。"

msgid "Advanced documentation"
msgstr "高级文档"

msgid "Heuristic"
msgstr "Heuristic"

msgid "Currently the heuristic functions available are:"
msgstr "目前可用的heuristic函数有："

msgid "where :math:`\\Delta x = x_1 - x_0` and :math:`\\Delta y = y_1 - y_0`"
msgstr "其中 :math:`\\Delta x = x_1 - x_0`和:math:`\\Delta y = y_1 - y_0`"

msgid "Analysis 1"
msgstr "分析1"

msgid ""
"Working with cost/reverse_cost as length in degrees, x/y in lat/lon: Factor "
"= 1   (no need to change units)"
msgstr ""
"使用 cost/reverse_cost 作为长度（以度为单位），x/y 以纬度/经度为单位：因子 = "
"1（无需更改单位）"

msgid "Analysis 2"
msgstr "分析2"

msgid ""
"Working with cost/reverse_cost as length in meters, x/y in lat/lon: Factor "
"=  would depend on the location of the points:"
msgstr ""
"使用 cost/reverse_cost 作为以米为单位的长度，以纬度/经度为单位的 x/y： "
"Factor = 将取决于点的位置："

msgid "1 longitude degree is  78846.81 m"
msgstr "1经度为78846.81 m"

msgid "78846"
msgstr "78846"

msgid "1 longitude degree is 111319.46 m"
msgstr "1经度为111319.46 m"

msgid "111319"
msgstr "111319"

msgid "Analysis 3"
msgstr "分析3"

msgid ""
"Working with cost/reverse_cost as time in seconds, x/y in lat/lon: Factor: "
"would depend on the location of the points and on the average speed say 25m/"
"s is the speed."
msgstr ""
"使用 cost/reverse_cost 作为以秒为单位的时间，以 lat/lon 为单位的 x/y： 因子："
"取决于点的位置和平均速度，例如 25m/s 是速度。"

msgid ":doc:`bdAstar-family`"
msgstr ":doc:`bdAstar-family`"

msgid "https://www.boost.org/libs/graph/doc/astar_search.html"
msgstr "https://www.boost.org/libs/graph/doc/astar_search.html"

msgid "https://en.wikipedia.org/wiki/A*_search_algorithm"
msgstr "https://en.wikipedia.org/wiki/A*_search_algorithm"

msgid "All Pairs - Family of Functions"
msgstr "All Pairs - 函数族"

msgid "The following functions work on all vertices pair combinations"
msgstr "以下函数适用于所有顶点对组合"

msgid ":doc:`pgr_floydWarshall` - Floyd-Warshall's algorithm."
msgstr ":doc:`pgr_floydWarshall` - Floyd-Warshall 算法。"

msgid ":doc:`pgr_johnson` - Johnson's algorithm"
msgstr ":doc:`pgr_johnson` - Johnson算法"

msgid "The main characteristics are:"
msgstr "主要特点是："

msgid "It does not return a path."
msgstr "它不返回路径。"

msgid ""
"Returns the sum of the costs of the shortest path for each pair of nodes in "
"the graph."
msgstr "返回图中每对节点的最短路径成本之和。"

msgid ""
"Boost returns a :math:`V \\times V` matrix, where the infinity values. "
"Represent the distance between vertices for which there is no path."
msgstr ""
"Boost 返回一个:math:`V \\times V`矩阵，其中无穷大值。 表示没有路径的顶点之间"
"的距离。"

msgid ""
"We return only the non infinity values in form of a set of `(start_vid, "
"end_vid, agg_cost)`."
msgstr "我们仅以一组 `(start_vid, end_vid, agg_cost)` 的形式返回非无穷大值。"

msgid ""
"Let be the case the values returned are stored in a table, so the unique "
"index would be the pair: `(start_vid, end_vid)`."
msgstr "假设返回的值存储在表中，因此唯一索引将是一对：`(start_vid, end_vid)`。"

msgid "For the undirected graph, the results are symmetric."
msgstr "对于无向图，结果是对称的。"

msgid "The  `agg_cost` of `(u, v)` is the same as for `(v, u)`."
msgstr "`(u, v)` 的  `agg_cost` 与 `(v, u)`相同。"

msgid "When  `start_vid` = `end_vid`, the `agg_cost` = 0."
msgstr "当`start_vid` = `end_vid`时，`agg_cost`= 0。"

msgid "**Recommended, use a bounding box of no more than 3500 edges.**"
msgstr "**建议使用不超过 3500 条边的边界框。**"

msgid "Optional parameters"
msgstr "可选参数"

msgid "``directed``"
msgstr "``directed``"

msgid "``BOOLEAN``"
msgstr "``BOOLEAN``"

msgid "``true``"
msgstr "``true``"

msgid "When ``true`` the graph is considered `Directed`"
msgstr "当 ``true``时，该图被视为有`有向`"

msgid "When ``false`` the graph is considered as `Undirected`."
msgstr "如果为 ``false``，则该图被视为 `无向`。"

msgid "Performance"
msgstr "表现"

msgid "The following tests:"
msgstr "以下测试："

msgid "non server computer"
msgstr "非服务式计算机"

msgid "with AMD 64 CPU"
msgstr "配备 AMD 64 CPU"

msgid "4G memory"
msgstr "4G内存"

msgid "trusty"
msgstr "可靠"

msgid "posgreSQL version 9.3"
msgstr "postgreSQL 版本 9.3"

msgid "Data"
msgstr "数据"

msgid "The following data was used"
msgstr "使用了以下数据"

msgid "Data processing was done with osm2pgrouting-alpha"
msgstr "数据处理是使用 osm2pgrouting-alpha 完成的"

msgid "Results"
msgstr "结果"

msgid "Test"
msgstr "测试"

msgid "One"
msgstr "一"

msgid ""
"This test is not with a bounding box The density of the passed graph is "
"extremely low. For each <SIZE> 30 tests were executed to get the average The "
"tested query is:"
msgstr ""
"该测试没有使用边界框，通过的图形密度极低。 对于每个 <SIZE> 执行 30 次测试以获"
"得平均值， 测试的查询是："

msgid "The results of this tests are presented as:"
msgstr "该测试的结果如下："

msgid "SIZE"
msgstr "SIZE"

msgid "is the number of edges given as input."
msgstr "是作为输入给出的边数。"

msgid "EDGES"
msgstr "EDGES"

msgid "is the total number of records in the query."
msgstr "是查询中的记录总数。"

msgid "DENSITY"
msgstr "DENSITY"

msgid "is the density of the data :math:`\\dfrac{E}{V \\times (V-1)}`."
msgstr "是数据:math:`\\dfrac{E}{V \\times (V-1)}`的密度。"

msgid "OUT ROWS"
msgstr "OUT ROWS"

msgid "is the number of records returned by the queries."
msgstr "是查询返回的记录数。"

msgid "Floyd-Warshall"
msgstr "Floyd-Warshall"

msgid "is the average execution time in seconds of pgr_floydWarshall."
msgstr "是 pgr_floydWarshall 的平均执行时间（以秒为单位）。"

msgid "Johnson"
msgstr "Johnson"

msgid "is the average execution time in seconds of pgr_johnson."
msgstr "是 pgr_johnson 的平均执行时间（以秒为单位）。"

msgid "500"
msgstr "500"

msgid "0.18E-7"
msgstr "0.18E-7"

msgid "1346"
msgstr "1346"

msgid "0.14"
msgstr "0.14"

msgid "0.13"
msgstr "0.13"

msgid "1000"
msgstr "1000"

msgid "0.36E-7"
msgstr "0.36E-7"

msgid "2655"
msgstr "2655"

msgid "0.23"
msgstr "0.23"

msgid "0.18"
msgstr "0.18"

msgid "1500"
msgstr "1500"

msgid "0.55E-7"
msgstr "0.55E-7"

msgid "4110"
msgstr "4110"

msgid "0.37"
msgstr "0.37"

msgid "0.34"
msgstr "0.34"

msgid "2000"
msgstr "2000"

msgid "0.73E-7"
msgstr "0.73E-7"

msgid "5676"
msgstr "5676"

msgid "0.56"
msgstr "0.56"

msgid "2500"
msgstr "2500"

msgid "0.89E-7"
msgstr "0.89E-7"

msgid "7177"
msgstr "7177"

msgid "0.84"
msgstr "0.84"

msgid "0.51"
msgstr "0.51"

msgid "3000"
msgstr "3000"

msgid "1.07E-7"
msgstr "1.07E-7"

msgid "8778"
msgstr "8778"

msgid "1.28"
msgstr "1.28"

msgid "0.68"
msgstr "0.68"

msgid "3500"
msgstr "3500"

msgid "1.24E-7"
msgstr "1.24E-7"

msgid "10526"
msgstr "10526"

msgid "2.08"
msgstr "2.08"

msgid "0.95"
msgstr "0.95"

msgid "4000"
msgstr "4000"

msgid "1.41E-7"
msgstr "1.41E-7"

msgid "12484"
msgstr "12484"

msgid "3.16"
msgstr "3.16"

msgid "1.24"
msgstr "1.24"

msgid "4500"
msgstr "4500"

msgid "1.58E-7"
msgstr "1.58E-7"

msgid "14354"
msgstr "14354"

msgid "4.49"
msgstr "4.49"

msgid "1.47"
msgstr "1.47"

msgid "5000"
msgstr "5000"

msgid "1.76E-7"
msgstr "1.76E-7"

msgid "16503"
msgstr "16503"

msgid "6.05"
msgstr "6.05"

msgid "1.78"
msgstr "1.78"

msgid "5500"
msgstr "5500"

msgid "1.93E-7"
msgstr "1.93E-7"

msgid "18623"
msgstr "18623"

msgid "7.53"
msgstr "7.53"

msgid "2.03"
msgstr "2.03"

msgid "6000"
msgstr "6000"

msgid "2.11E-7"
msgstr "2.11E-7"

msgid "20710"
msgstr "20710"

msgid "8.47"
msgstr "8.47"

msgid "2.37"
msgstr "2.37"

msgid "6500"
msgstr "6500"

msgid "2.28E-7"
msgstr "2.28E-7"

msgid "22752"
msgstr "22752"

msgid "9.99"
msgstr "9.99"

msgid "2.68"
msgstr "2.68"

msgid "7000"
msgstr "7000"

msgid "2.46E-7"
msgstr "2.46E-7"

msgid "24687"
msgstr "24687"

msgid "11.82"
msgstr "11.82"

msgid "3.12"
msgstr "3.12"

msgid "7500"
msgstr "7500"

msgid "2.64E-7"
msgstr "2.64E-7"

msgid "26861"
msgstr "26861"

msgid "13.94"
msgstr "13.94"

msgid "3.60"
msgstr "3.60"

msgid "8000"
msgstr "8000"

msgid "2.83E-7"
msgstr "2.83E-7"

msgid "29050"
msgstr "29050"

msgid "15.61"
msgstr "15.61"

msgid "4.09"
msgstr "4.09"

msgid "8500"
msgstr "8500"

msgid "3.01E-7"
msgstr "3.01E-7"

msgid "31693"
msgstr "31693"

msgid "17.43"
msgstr "17.43"

msgid "4.63"
msgstr "4.63"

msgid "9000"
msgstr "9000"

msgid "3.17E-7"
msgstr "3.17E-7"

msgid "33879"
msgstr "33879"

msgid "19.19"
msgstr "19.19"

msgid "5.34"
msgstr "5.34"

msgid "9500"
msgstr "9500"

msgid "3.35E-7"
msgstr "3.35E-7"

msgid "36287"
msgstr "36287"

msgid "20.77"
msgstr "20.77"

msgid "6.24"
msgstr "6.24"

msgid "10000"
msgstr "10000"

msgid "3.52E-7"
msgstr "3.52E-7"

msgid "38491"
msgstr "38491"

msgid "23.26"
msgstr "23.26"

msgid "6.51"
msgstr "6.51"

msgid "Two"
msgstr "二"

msgid ""
"This test is with a bounding box The density of the passed graph higher than "
"of the Test One. For each <SIZE> 30 tests were executed to get the average "
"The tested edge query is:"
msgstr ""
"该测试带有边界框。通过的图形的密度高于测试一的密度。 对于每个 <SIZE> 执行 30 "
"次测试以获得平均值，测试的边缘查询为："

msgid "The tested queries"
msgstr "测试的查询"

msgid "is the size of the bounding box."
msgstr "是边界框的大小。"

msgid "0.001"
msgstr "0.001"

msgid "44"
msgstr "44"

msgid "0.0608"
msgstr "0.0608"

msgid "1197"
msgstr "1197"

msgid "0.10"
msgstr "0.10"

msgid "0.002"
msgstr "0.002"

msgid "99"
msgstr "99"

msgid "0.0251"
msgstr "0.0251"

msgid "4330"
msgstr "4330"

msgid "0.003"
msgstr "0.003"

msgid "223"
msgstr "223"

msgid "0.0122"
msgstr "0.0122"

msgid "18849"
msgstr "18849"

msgid "0.12"
msgstr "0.12"

msgid "0.004"
msgstr "0.004"

msgid "358"
msgstr "358"

msgid "0.0085"
msgstr "0.0085"

msgid "71834"
msgstr "71834"

msgid "0.16"
msgstr "0.16"

msgid "0.005"
msgstr "0.005"

msgid "470"
msgstr "470"

msgid "0.0070"
msgstr "0.0070"

msgid "116290"
msgstr "116290"

msgid "0.22"
msgstr "0.22"

msgid "0.19"
msgstr "0.19"

msgid "0.006"
msgstr "0.006"

msgid "639"
msgstr "639"

msgid "0.0055"
msgstr "0.0055"

msgid "207030"
msgstr "207030"

msgid "0.27"
msgstr "0.27"

msgid "0.007"
msgstr "0.007"

msgid "843"
msgstr "843"

msgid "0.0043"
msgstr "0.0043"

msgid "346930"
msgstr "346930"

msgid "0.64"
msgstr "0.64"

msgid "0.38"
msgstr "0.38"

msgid "0.008"
msgstr "0.008"

msgid "996"
msgstr "996"

msgid "0.0037"
msgstr "0.0037"

msgid "469936"
msgstr "469936"

msgid "0.90"
msgstr "0.90"

msgid "0.49"
msgstr "0.49"

msgid "0.009"
msgstr "0.009"

msgid "1146"
msgstr "1146"

msgid "0.0032"
msgstr "0.0032"

msgid "613135"
msgstr "613135"

msgid "1.26"
msgstr "1.26"

msgid "0.62"
msgstr "0.62"

msgid "0.010"
msgstr "0.010"

msgid "1360"
msgstr "1360"

msgid "0.0027"
msgstr "0.0027"

msgid "849304"
msgstr "849304"

msgid "1.87"
msgstr "1.87"

msgid "0.82"
msgstr "0.82"

msgid "0.011"
msgstr "0.011"

msgid "1573"
msgstr "1573"

msgid "0.0024"
msgstr "0.0024"

msgid "1147101"
msgstr "1147101"

msgid "2.65"
msgstr "2.65"

msgid "1.04"
msgstr "1.04"

msgid "0.012"
msgstr "0.012"

msgid "1789"
msgstr "1789"

msgid "0.0021"
msgstr "0.0021"

msgid "1483629"
msgstr "1483629"

msgid "3.72"
msgstr "3.72"

msgid "1.35"
msgstr "1.35"

msgid "0.013"
msgstr "0.013"

msgid "1975"
msgstr "1975"

msgid "0.0019"
msgstr "0.0019"

msgid "1846897"
msgstr "1846897"

msgid "4.86"
msgstr "4.86"

msgid "1.68"
msgstr "1.68"

msgid "0.014"
msgstr "0.014"

msgid "2281"
msgstr "2281"

msgid "0.0017"
msgstr "0.0017"

msgid "2438298"
msgstr "2438298"

msgid "7.08"
msgstr "7.08"

msgid "2.28"
msgstr "2.28"

msgid "0.015"
msgstr "0.015"

msgid "2588"
msgstr "2588"

msgid "0.0015"
msgstr "0.0015"

msgid "3156007"
msgstr "3156007"

msgid "10.28"
msgstr "10.28"

msgid "2.80"
msgstr "2.80"

msgid "0.016"
msgstr "0.016"

msgid "2958"
msgstr "2958"

msgid "0.0013"
msgstr "0.0013"

msgid "4090618"
msgstr "4090618"

msgid "14.67"
msgstr "14.67"

msgid "3.76"
msgstr "3.76"

msgid "0.017"
msgstr "0.017"

msgid "3247"
msgstr "3247"

msgid "0.0012"
msgstr "0.0012"

msgid "4868919"
msgstr "4868919"

msgid "18.12"
msgstr "18.12"

msgid "4.48"
msgstr "4.48"

msgid ":doc:`pgr_johnson`"
msgstr ":doc:`pgr_johnson`"

msgid ":doc:`pgr_floydWarshall`"
msgstr ":doc:`pgr_floydWarshall`"

msgid ""
"Boost `floyd-Warshall <https://www.boost.org/libs/graph/doc/"
"floyd_warshall_shortest.html>`__"
msgstr ""
"Boost `floyd-Warshall <https://www.boost.org/libs/graph/doc/"
"floyd_warshall_shortest.html>`__"

msgid "Bidirectional A* - Family of functions"
msgstr "双向A* - 函数族"

msgid ""
"The bidirectional A* (pronounced \"A Star\") algorithm is based on the A* "
"algorithm."
msgstr "双向A*（发音为\"A星\"）算法基于A*算法。"

msgid ":doc:`pgr_bdAstar` - Bidirectional A* algorithm for obtaining paths."
msgstr ":doc:`pgr_bdAstar` - 获取路径的双向A*算法。"

msgid ""
":doc:`pgr_bdAstarCost` - Bidirectional A* algorithm to calculate the cost of "
"the paths."
msgstr ":doc:`pgr_bdAstarCost` - 双向 A* 算法计算路径成本。"

msgid ""
":doc:`pgr_bdAstarCostMatrix` - Bidirectional A* algorithm to calculate a "
"cost matrix of paths."
msgstr ":doc:`pgr_bdAstarCostMatrix` - 用于计算路径成本矩阵的双向 A* 算法。"

msgid ""
"Based on A* algorithm, the bidirectional search finds a shortest path from a "
"starting vertex (``start_vid``) to an ending vertex (``end_vid``). It runs "
"two simultaneous searches: one forward from the ``start_vid``, and one "
"backward from the ``end_vid``, stopping when the two meet in the middle. "
"This implementation can be used with a directed graph and an undirected "
"graph."
msgstr ""
"基于A*算法，双向搜索找到从起始顶点(``start_vid``)到结束顶点(``end_vid``)的最"
"短路径。 它同时运行两项搜索：一项从 ``start_vid`` 向前搜索，一项从 "
"``end_vid``向后搜索，当两者在中间相遇时停止。 该实现可以与有向图和无向图一起"
"使用。"

msgid ""
"For large graphs where there is a path bewtween the starting vertex and "
"ending vertex:"
msgstr "对于起始顶点和结束顶点之间存在路径的大型图:"

msgid "It is expected to terminate faster than pgr_astar"
msgstr "预计终止速度比 pgr_astar 更快"

msgid ":doc:`aStar-family`"
msgstr ":doc:`aStar-family`"

msgid "Previous versions of this page"
msgstr "此页面的先前版本"

msgid "Bidirectional Dijkstra - Family of functions"
msgstr "双向 Dijkstra - 函数族"

msgid ""
":doc:`pgr_bdDijkstra` - Bidirectional Dijkstra algorithm for the shortest "
"paths."
msgstr ":doc:`pgr_bdDijkstra` - 最短路径的双向 Dijkstra 算法。"

msgid ""
":doc:`pgr_bdDijkstraCost` - Bidirectional Dijkstra to calculate the cost of "
"the shortest paths"
msgstr ":doc:`pgr_bdDijkstraCost` - 双向 Dijkstra 计算最短路径的成本"

msgid ""
":doc:`pgr_bdDijkstraCostMatrix` - Bidirectional Dijkstra algorithm  to "
"create a matrix of costs of the shortest paths."
msgstr ""
":doc:`pgr_bdDijkstraCostMatrix` - 双向 Dijkstra 算法创建最短路径成本矩阵。"

msgid "Synopsis"
msgstr "概要"

msgid ""
"Based on Dijkstra's algorithm, the bidirectional search finds a shortest "
"path a starting vertex to an ending vertex."
msgstr "基于 Dijkstra 算法，双向搜索找到起始顶点到结束顶点的最短路径。"

msgid ""
"It runs two simultaneous searches: one forward from the source, and one "
"backward from the target, stopping when the two meet in the middle."
msgstr ""
"它同时运行两项搜索：一项从源向前搜索，一项从目标向后搜索，当两者在中间相遇时"
"停止。"

msgid ""
"This implementation can be used with a directed graph and an undirected "
"graph."
msgstr "该实现可以与有向图和无向图一起使用。"

msgid ""
"A negative value on a cost column is interpreted as the edge does not exist."
msgstr "成本列上的负值被解释为边不存在。"

msgid "When there is no path:"
msgstr "当没有路径时："

msgid "When the starting vertex and ending vertex are the same."
msgstr "当起始顶点和结束顶点相同时。"

msgid ""
"The **aggregate cost** of the non included values :math:`(v, v)` is :math:`0`"
msgstr "未包含值:math:`(v, v)`的**aggregate cost**为:math:`0`"

msgid ""
"When the starting vertex and ending vertex are the different and there is no "
"path:"
msgstr "当起始顶点和结束顶点不同且不存在路径时："

msgid ""
"The **aggregate cost** the non included values :math:`(u, v)` is :math:`"
"\\infty`"
msgstr "未包含值:math:`(u, v)`的**aggregate cost**是:math:`\\infty`"

msgid ""
"For optimization purposes, any duplicated value in the starting vertices or "
"on the ending vertices are ignored."
msgstr "出于优化目的，起始顶点或结束顶点中的任何重复值都将被忽略。"

msgid "Running time (worse case scenario): :math:`O((V \\log V + E))`"
msgstr "运行时间（最坏情况）：:math:`O((V \\log V + E))`"

msgid "It is expected to terminate faster than pgr_dijkstra"
msgstr "预计终止速度比 pgr_dijkstra 更快"

msgid "Chinese Postman Problem - Family of functions (Experimental)"
msgstr "中国邮递员问题 - 函数族（实验）"

msgid ":doc:`pgr_chinesePostman`"
msgstr ":doc:`pgr_chinesePostman`"

msgid ":doc:`pgr_chinesePostmanCost`"
msgstr ":doc:`pgr_chinesePostmanCost`"

msgid "**The main characteristics are:**"
msgstr "**主要特点是：**"

msgid "Process is done only on edges with **positive** costs."
msgstr "仅在具有**正**成本的边缘进行处理。"

msgid "Running time: :math:`O(E * (E + V * logV))`"
msgstr "运行时间：:math:`O(E * (E + V * logV))`"

msgid "Graph must be connected."
msgstr "图必须是连通的。"

msgid ""
"An Edges SQL that represents a **directed** graph with the following columns"
msgstr "表示具有以下列的有向图的 Edges SQL"

msgid "Coloring - Family of functions"
msgstr "着色 - 函数族"

msgid ""
":doc:`pgr_sequentialVertexColoring` - Vertex coloring algorithm using greedy "
"approach."
msgstr ":doc:`pgr_sequentialVertexColoring` - 顶点着色算法采用贪心法。"

msgid ""
":doc:`pgr_bipartite` - Bipartite graph algorithm using a DFS-based coloring "
"approach."
msgstr ":doc:`pgr_bipartite` - 使用基于 DFS 的着色方法的二分图算法。"

msgid ""
":doc:`pgr_edgeColoring` - Edge Coloring algorithm using Vizing's theorem."
msgstr ":doc:`pgr_edgeColoring` - 使用 Vizing 定理的边缘着色算法。"

msgid "Returns SET OF ``(vertex_id, color_id)``"
msgstr "返回``(vertex_id, color_id)``的集合"

msgid "``vertex_id``"
msgstr "``vertex_id``"

msgid "Identifier of the vertex."
msgstr "顶点的标识符。"

msgid "``color_id``"
msgstr "``color_id``"

msgid "Identifier of the color of the vertex."
msgstr "顶点颜色的标识符。"

msgid "The minimum value of color is 1."
msgstr "颜色的最小值为 1。"

msgid "Returns SET OF ``(edge_id, color_id)``"
msgstr "返回``(edge_id, color_id)``的集合"

msgid "``edge_id``"
msgstr "``edge_id``"

msgid "Identifier of the color of the edge."
msgstr "边颜色的标识符。"

msgid ""
"`Boost: Sequential Vertex Coloring algorithm documentation <https://www."
"boost.org/libs/graph/doc/sequential_vertex_coloring.html>`__"
msgstr ""
"`Boost：顺序顶点着色算法文档 <https://www.boost.org/libs/graph/doc/"
"sequential_vertex_coloring.html>`__"

msgid ""
"`Wikipedia: Graph coloring <https://en.wikipedia.org/wiki/Graph_coloring>`__"
msgstr "`维基百科：图着色<https://en.wikipedia.org/wiki/Graph_coloring>`__"

msgid ""
"`Boost: is_bipartite <https://www.boost.org/libs/graph/doc/is_bipartite."
"html>`__"
msgstr ""
"`Boost: is_bipartite <https://www.boost.org/libs/graph/doc/is_bipartite."
"html>`__"

msgid ""
"`Wikipedia: bipartite graph <https://en.wikipedia.org/wiki/"
"Bipartite_graph>`__"
msgstr "`维基百科：二分图 <https://en.wikipedia.org/wiki/Bipartite_graph>`__"

msgid ""
"`Boost: Edge Coloring Algorithm documentation <https://www.boost.org/libs/"
"graph/doc/edge_coloring.html>`__"
msgstr ""
"`Boost：边缘着色算法文档 <https://www.boost.org/libs/graph/doc/edge_coloring."
"html>`__"

msgid ""
"`Wikipedia: Graph Coloring <https://en.wikipedia.org/wiki/Graph_coloring>`__"
msgstr "`维基百科：图着色 <https://en.wikipedia.org/wiki/Graph_coloring>`__"

msgid "Components - Family of functions"
msgstr "分量 - 函数族"

msgid ""
":doc:`pgr_connectedComponents` - Connected components of an undirected graph."
msgstr ":doc:`pgr_connectedComponents` - 无向图的连通分量。"

msgid ""
":doc:`pgr_strongComponents` - Strongly connected components of a directed "
"graph."
msgstr ":doc:`pgr_strongComponents` - 有向图的强连通分量。"

msgid ""
":doc:`pgr_biconnectedComponents` - Biconnected components of an undirected "
"graph."
msgstr ":doc:`pgr_biconnectedComponents` - 无向图的双连通分量。"

msgid ""
":doc:`pgr_articulationPoints` - Articulation points of an undirected graph."
msgstr ":doc:`pgr_articulationPoints` - 无向图的铰接点。"

msgid ":doc:`pgr_bridges` - Bridges of an undirected graph."
msgstr ":doc:`pgr_bridges` - 无向图的桥。"

msgid ":doc:`pgr_makeConnected` - Details of edges to make graph connected."
msgstr ":doc:`pgr_makeConnected` - 使图形连接的边的详细信息。"

msgid "Contraction - Family of functions"
msgstr "收缩 - 函数族"

msgid ":doc:`pgr_contraction`"
msgstr ":doc:`pgr_contraction`"

msgid ""
"In large graphs, like the road graphs, or electric networks, graph "
"contraction can be used to speed up some graph algorithms. Contraction "
"reduces the size of the graph by removing some of the vertices and edges "
"and, for example, might add edges that represent a sequence of original "
"edges decreasing the total time and space used in graph algorithms."
msgstr ""
"在大型图中，例如道路图或电网，图收缩可用于加速某些图算法。 收缩通过删除一些顶"
"点和边来减小图的大小，例如，可能会添加表示原始边序列的边，从而减少图算法中使"
"用的总时间和空间。"

msgid ""
"This implementation gives a flexible framework for adding contraction "
"algorithms in the future, currently, it supports two algorithms:"
msgstr "该实现为将来添加收缩算法提供了灵活的框架，目前它支持两种算法："

msgid "Dead end contraction"
msgstr "死端收缩"

msgid "Linear contraction"
msgstr "线性收缩"

msgid "Allowing the user to:"
msgstr "允许用户："

msgid "Forbid contraction on a set of nodes."
msgstr "禁止在一组节点上收缩。"

msgid ""
"Decide the order of the contraction algorithms and set the maximum number of "
"times they are to be executed."
msgstr "决定收缩算法的顺序并设置它们要执行的最大次数。"

msgid "Contraction of the leaf nodes of the graph."
msgstr "图的叶节点的收缩。"

msgid "Dead end"
msgstr "死端"

msgid "A node is considered a **dead end** node when"
msgstr "当一个节点被认为是**死端**节点时"

msgid "On undirected graphs:"
msgstr "在无向图上："

msgid "The number of adjacent vertices is 1."
msgstr "相邻顶点的个数为1。"

msgid "On directed graphs:"
msgstr "在有向图上："

msgid "There are no outgoing edges and has at least one incoming edge."
msgstr "没有传出边缘，但至少有一个传入边缘。"

msgid "There are no incoming edges and has at least one outgoing edge."
msgstr "没有传入边缘，但至少有一个传出边缘。"

msgid ""
"When the conditions are true then the `Operation: Dead End Contraction`_ can "
"be done."
msgstr "当条件成立时，可以进行当条件成立时，可以进行`操作: 死端收缩`_"

msgid "Dead end vertex on undirected graph"
msgstr "无向图上的死端顶点"

msgid "The green nodes are `dead end`_ nodes"
msgstr "绿色节点是`死端`_节点"

msgid "The blue nodes have an unlimited number of edges."
msgstr "蓝色节点具有无限数量的边。"

msgid "Node"
msgstr "节点"

msgid "Adjecent nodes"
msgstr "相邻节点"

msgid "Number of adjacent nodes"
msgstr "相邻节点数"

msgid ":math:`a`"
msgstr ":math:`a`"

msgid ":math:`\\{u\\}`"
msgstr ":math:`\\{u\\}`"

msgid ":math:`b`"
msgstr ":math:`b`"

msgid ":math:`\\{v\\}`"
msgstr ":math:`\\{v\\}`"

msgid "Dead end vertex on directed graph"
msgstr "有向图上的死端顶点"

msgid ""
"The blue nodes have an unlimited number of incoming and/or outgoing edges."
msgstr "蓝色节点具有无限数量的传入和/或传出边缘。"

msgid "Number of incoming edges"
msgstr "传入边数"

msgid "Number of outgoing edges"
msgstr "传出边数"

msgid ":math:`c`"
msgstr ":math:`c`"

msgid ":math:`\\{v, w\\}`"
msgstr ":math:`\\{v, w\\}`"

msgid "2"
msgstr "2"

msgid ":math:`d`"
msgstr ":math:`d`"

msgid ":math:`\\{x\\}`"
msgstr ":math:`\\{x\\}`"

msgid ":math:`e`"
msgstr ":math:`e`"

msgid ":math:`\\{x, y\\}`"
msgstr ":math:`\\{x, y\\}`"

msgid ""
"From above, nodes :math:`\\{a, b, d\\}` are dead ends because the number of "
"adjacent vertices is 1. No further checks are needed for those nodes."
msgstr ""
"从上面来看，节点:math:`\\{a, b, d\\}`是死端，因为相邻顶点的数量为 1。不需要对"
"这些节点进行进一步检查。"

msgid ""
"On the following table, nodes :math:`\\{c, e\\}` because the even that the "
"number of adjacent vertices is not 1 for"
msgstr "下表中，节点 :math:`\\{c, e\\}`因为相邻顶点数不为1的偶数为"

msgid "Operation: Dead End Contraction"
msgstr "操作：死端收缩"

msgid ""
"The dead end contraction will stop until there are no more dead end nodes. "
"For example from the following graph where :math:`w` is the `dead end`_ node:"
msgstr ""
"死端收缩将停止，直到不再有死端节点。 例如，从下图中，其中:math:`w`是`死端`_节"
"点："

msgid ""
"After contracting :math:`w`, node :math:`v` is now a `dead end`_ node and is "
"contracted:"
msgstr "收缩 :math:`w`后，节点:math:`v`现在是一个`死端`_ 节点并且已收缩："

msgid ""
"After contracting :math:`v`, stop. Node :math:`u` has the information of "
"nodes that were contrcted."
msgstr "在收缩:math:`v`之后，停止。节点:math:`u`有已收缩节点的信息。"

msgid "Node :math:`u` has the information of nodes that were contracted."
msgstr "节点:math:`u`有已收缩节点的信息。"

msgid "In the algorithm, linear contraction is represented by 2."
msgstr "算法中，线性收缩用2表示。"

msgid "Linear"
msgstr "线性"

msgid ""
"In case of an undirected graph, a node is considered a `linear` node when"
msgstr "在无向图的情况下，当满足以下条件时，节点被视为`线性`节点："

msgid "The number of adjacent vertices is 2."
msgstr "相邻顶点的数量为2。"

msgid "In case of a directed graph, a node is considered a `linear` node when"
msgstr "在有向图的情况下，当满足以下条件时，节点被视为`线性`节点："

msgid "Linearity is symmetrical"
msgstr "线性是对称的"

msgid "Linear vertex on undirected graph"
msgstr "无向图上的线性顶点"

msgid "The green nodes are `linear`_ nodes"
msgstr "绿色节点是`线性`_节点"

msgid "The blue nodes have an unlimited number of incoming and outgoing edges."
msgstr "蓝色节点具有无限数量的传入和传出边缘。"

msgid "Undirected"
msgstr "无向"

msgid ":math:`v`"
msgstr ":math:`v`"

msgid ":math:`\\{u, w\\}`"
msgstr ":math:`\\{u, w\\}`"

msgid "Linear vertex on directed graph"
msgstr "有向图上的线性顶点"

msgid "The white node is not linear because the linearity is not symetrical."
msgstr "白色节点不是线性的，因为线性不对称。"

msgid "It is possible to go :math:`y \\rightarrow c \\rightarrow z`"
msgstr "它是可能去走:math:`y \\rightarrow c \\rightarrow z`"

msgid "It's not possible to go :math:`z \\rightarrow c \\rightarrow y`"
msgstr "不可能走:math:`z \\rightarrow c \\rightarrow y`"

msgid "Is symmetrical?"
msgstr "是对称的吗？"

msgid ":math:`\\{u, v\\}`"
msgstr ":math:`\\{u, v\\}`"

msgid "yes"
msgstr "是"

msgid ":math:`\\{w, x\\}`"
msgstr ":math:`\\{w, x\\}`"

msgid ":math:`\\{y, z\\}`"
msgstr ":math:`\\{y, z\\}`"

msgid "no"
msgstr "否"

msgid "Operation: Linear Contraction"
msgstr "操作：线性收缩"

msgid ""
"The linear contraction will stop when there are no more linear nodes. For "
"example from the following graph where :math:`v` and :math:`w` are `linear`_ "
"nodes:"
msgstr ""
"当不再有线性节点时，线性收缩将停止。 例如，在下图中，其中:math:`v`和:math:`w`"
"是`线性`_节点："

msgid "Contracting :math:`w`,"
msgstr "收缩:math:`w`，"

msgid "The vertex :math:`w` is removed from the graph"
msgstr "顶点 :math:`w`已从图中移除"

msgid ""
"The edges :math:`v \\rightarrow w` and  :math:`w \\rightarrow z` are removed "
"from the graph."
msgstr "边:math:`v \\rightarrow w`和:math:`w \\rightarrow z`已从图中移除。"

msgid ""
"A new edge :math:`v \\rightarrow z` is inserted represented with red color."
msgstr "插入一条新边 :math:`v \\rightarrow z`，以红色表示。"

msgid "Contracting :math:`v`:"
msgstr "收缩:math:`v`："

msgid "The vertex :math:`v` is removed from the graph"
msgstr "顶点:math:`v`已从图中移除"

msgid ""
"The edges :math:`u \\rightarrow v` and  :math:`v \\rightarrow z` are removed "
"from the graph."
msgstr "边:math:`u \\rightarrow v`和 :math:`v \\rightarrow z`已从图中移除。"

msgid ""
"A new edge :math:`u \\rightarrow z` is inserted represented with red color."
msgstr "插入一条新边:math:`u \\rightarrow z`，以红色表示。"

msgid ""
"Edge :math:`u \\rightarrow z` has the information of nodes that were "
"contracted."
msgstr "边:math:`u \\rightarrow z`有收缩点的信息。"

msgid "The cycle"
msgstr "循环"

msgid ""
"Contracting a graph, can be done with more than one operation. The order of "
"the operations affect the resulting contracted graph, after applying one "
"operation, the set of vertices that can be contracted by another operation "
"changes."
msgstr ""
"收缩一张图可以通过多个操作来完成。 操作的顺序会影响生成的收缩图，在应用一个操"
"作后，可以由另一操作收缩的顶点集会发生变化。"

msgid ""
"This implementation, cycles ``max_cycles`` times through "
"``operations_order`` ."
msgstr "此实现通过``operations_order``循环 ``max_cycles`` 次。"

msgid "Contracting sample data"
msgstr "收缩示例数据"

msgid ""
"In this section, building and using a contracted graph will be shown by "
"example."
msgstr "在本节中，将通过示例展示构建和使用收缩图。"

msgid "The :doc:`sampledata` for an undirected graph is used"
msgstr "使用无向图的:doc:`sampledata`"

msgid "a dead end operation first followed by a linear operation."
msgstr "首先是死端操作，然后是线性操作。"

msgid "Construction of the graph in the database"
msgstr "数据库中图的构建"

msgid "Original Data"
msgstr "原始数据"

msgid ""
"The following query shows the original data involved in the contraction "
"operation."
msgstr "以下查询显示了收缩操作所涉及的原始数据。"

msgid "The original graph:"
msgstr "原始图"

msgid "Contraction results"
msgstr "收缩结果"

msgid ""
"The results do not represent the contracted graph. They represent the "
"changes done to the graph after applying the contraction algorithm."
msgstr "结果不代表收缩图。 它们表示应用收缩算法后对图所做的更改。"

msgid ""
"Observe that vertices, for example, :math:`6` do not appear in the results "
"because it was not affected by the contraction algorithm."
msgstr "例如，观察到顶点:math:`6`没有出现在结果中，因为它不受收缩算法的影响。"

msgid "After doing the dead end contraction operation:"
msgstr "进行死端收缩操作后："

msgid "After doing the linear contraction operation to the graph above:"
msgstr "对上图进行线性收缩运算后："

msgid "The process to create the contraction graph on the database:"
msgstr "在数据库上创建收缩图的过程："

msgid "Add additional columns"
msgstr "添加附加列"

msgid ""
"Adding extra columns to the ``edge_table`` and ``edge_table_vertices_pgr`` "
"tables, where:"
msgstr "向``edge_table`` 和``edge_table_vertices_pgr`` 表添加额外的列，其中："

msgid "``contracted_vertices``"
msgstr "``contracted_vertices``"

msgid "The vertices set belonging to the vertex/edge"
msgstr "属于顶点/边的顶点集"

msgid "``is_contracted``"
msgstr "``is_contracted``"

msgid "On the vertex table"
msgstr "在顶点表上"

msgid ""
"when ``true`` the vertex is contracted, its not part of the contracted graph."
msgstr "当 ``true`` 时，顶点收缩，它不是收缩图的一部分。"

msgid ""
"when ``false`` the vertex is not contracted, its part of the contracted "
"graph."
msgstr "当 ``false`` 时，顶点不收缩，它是收缩图的一部分。"

msgid "``is_new``"
msgstr "``is_new``"

msgid "On the edge table"
msgstr "在边表上"

msgid ""
"when ``true`` the edge was generated by the contraction algorithm. its part "
"of the contracted graph."
msgstr "当 ``true`` 时，边缘由收缩算法生成。 它是收缩图的一部分。"

msgid ""
"when ``false`` the edge is an original edge, might be or not part of the "
"contracted graph."
msgstr "当 ``false`` 时，边是原始边，可能是也可能不是收缩图的一部分。"

msgid "Store contraction information"
msgstr "存储收缩信息"

msgid "Store the `contraction results`_ in a table"
msgstr "将`收缩结果`_存储在表中"

msgid "The vertex table update"
msgstr "顶点表更新"

msgid ""
"Use ``is_contracted`` column to indicate the vertices that are contracted."
msgstr "使用 ``is_contracted``列来指示收缩的顶点。"

msgid ""
"Fill ``contracted_vertices`` with the information from the results tha "
"belong to the vertices."
msgstr "使用属于顶点的结果中的信息填充``contracted_vertices``。"

msgid "The modified vertices table:"
msgstr "修改后的顶点表："

msgid "The edge table update"
msgstr "边缘表更新"

msgid "Insert the new edges generated by pgr_contraction."
msgstr "插入由 pgr_contraction 生成的新边。"

msgid "The modified ``edge_table``."
msgstr "修改后的``edge_table``。"

msgid "The contracted graph"
msgstr "收缩图"

msgid "Vertices that belong to the contracted graph."
msgstr "属于收缩图的顶点。"

msgid "Edges that belong to the contracted graph."
msgstr "属于收缩图的边。"

msgid "Contracted graph"
msgstr "收缩图"

msgid "Using the contracted graph"
msgstr "使用收缩图"

msgid "Using the contracted graph with ``pgr_dijkstra``"
msgstr "将收缩图与 ``pgr_dijkstra`` 一起使用"

msgid ""
"There are three cases when calculating the shortest path between a given "
"source and target in a contracted graph:"
msgstr "计算收缩图中给定源和目标之间的最短路径时，存在三种情况："

msgid "Case 1: Both source and target belong to the contracted graph."
msgstr "情况1：源和目标都属于收缩图。"

msgid "Case 2: Source and/or target belong to an edge subgraph."
msgstr "情况 2：源和/或目标属于边缘子图。"

msgid "Case 3: Source and/or target belong to a vertex."
msgstr "情况 3：源和/或目标属于一个顶点。"

msgid ""
"Using the `Edges that belong to the contracted graph.`_ on lines 11 to 20."
msgstr "使用`属于收缩图的边。`_ 第 11 至 20 行。"

msgid "Case 1"
msgstr "情况1"

msgid ""
"When both source and target belong to the contracted graph, a path is found."
msgstr "当源和目标都属于收缩图时，就找到了一条路径。"

msgid "Case 2"
msgstr "情况2"

msgid ""
"When source and/or target belong to an edge subgraph then a path is not "
"found."
msgstr "当源和/或目标属于边缘子图时，则找不到路径。"

msgid ""
"In this case, the contracted graph do not have an edge connecting with node :"
"math:`4`."
msgstr "在这种情况下，收缩图没有与节点:math:`4` 相连的边。"

msgid "Case 3"
msgstr "情况3"

msgid "When source and/or target belong to a vertex then a path is not found."
msgstr "当源和/或目标属于顶点时，则找不到路径。"

msgid ""
"In this case, the contracted graph do not have an edge connecting with node :"
"math:`7` and of node :math:`4` of the second case."
msgstr ""
"在这种情况下，收缩图没有与第二种情况的节点:math:`7`和节点 :math:`4`连接的边。"

msgid "Refining the above function to include nodes that belong to an edge."
msgstr "改进上述函数以包含属于边的节点。"

msgid "The vertices that need to be expanded are calculated on lines 11 to 17."
msgstr "需要扩展的顶点在第 11 至 17 行计算。"

msgid ""
"Adding to the contracted graph that additional section on lines 26 to 28."
msgstr "将第 26 至 28 行的附加部分添加到收缩图中。"

msgid ""
"When source and/or target belong to an edge subgraph, now, a path is found."
msgstr "当源和目标都属于收缩图时，就找到了一条路径。"

msgid "The routing graph now has an edge connecting with node :math:`4`."
msgstr "路由图现在有一条与节点:math:`4` 连接的边。"

msgid ""
"In this case, the contracted graph do not have an edge connecting with node :"
"math:`7`."
msgstr "在这种情况下，收缩图没有与节点:math:`7`相连的边。"

msgid "The vertices that need to be expanded are calculated on lines 19 to 24."
msgstr "需要扩展的顶点在第19到24行计算。"

msgid ""
"Adding to the contracted graph that additional section on lines 38 to 40."
msgstr "将第 38 至 40 行的附加部分添加到收缩图中。"

msgid ""
"The code change do not affect this case so when source and/or target belong "
"to an edge subgraph, a path is still found."
msgstr ""
"代码更改不会影响这种情况，因此当源和/或目标属于边缘子图时，仍然会找到路径。"

msgid "When source and/or target belong to a vertex, now, a path is found."
msgstr "当源和/或目标属于一个顶点时，现在就找到了一条路径。"

msgid "Now, the routing graph has an edge connecting with node :math:`7`."
msgstr "现在，路由图有一条与节点:math:`7`连接的边。"

msgid ":doc:`sampledata`"
msgstr ":doc:`sampledata`"

msgid ""
"https://www.cs.cmu.edu/afs/cs/academic/class/15210-f12/www/lectures/"
"lecture16.pdf"
msgstr ""
"https://www.cs.cmu.edu/afs/cs/academic/class/15210-f12/www/lectures/"
"lecture16.pdf"

msgid "https://algo2.iti.kit.edu/documents/routeplanning/geisberger_dipl.pdf"
msgstr "https://algo2.iti.kit.edu/documents/routeplanning/geisberger_dipl.pdf"

msgid "Cost - Category"
msgstr "成本 - 类别"

msgid ":doc:`pgr_aStarCost`"
msgstr ":doc:`pgr_aStarCost`"

msgid ":doc:`pgr_bdAstarCost`"
msgstr ":doc:`pgr_bdAstarCost`"

msgid ":doc:`pgr_dijkstraCost`"
msgstr ":doc:`pgr_dijkstraCost`"

msgid ":doc:`pgr_bdDijkstraCost`"
msgstr ":doc:`pgr_bdDijkstraCost`"

msgid ":doc:`pgr_dijkstraNearCost`"
msgstr ":doc:`pgr_dijkstraNearCost`"

msgid ":doc:`pgr_withPointsCost`"
msgstr ":doc:`pgr_withPointsCost`"

msgid "Each function works as part of the family it belongs to."
msgstr "每个函数都是其所属家族的一部分。"

msgid ""
"Returns the sum of the costs of the shortest path of each pair combination "
"of nodes requested."
msgstr "返回所请求的每对节点组合的最短路径的成本总和。"

msgid ""
"Let be the case the values returned are stored in a table, so the unique "
"index would be the pair: ``(start_vid, end_vid)``."
msgstr ""
"假设返回的值存储在表中，因此唯一索引将是一对：``(start_vid, end_vid)``。"

msgid ""
"Depending on the function and its parameters, the results can be symmetric."
msgstr "根据函数及其参数，结果可能是对称的。"

msgid ""
"The  **aggregate cost** of :math:`(u, v)` is the same as for :math:`(v, u)`."
msgstr ":math:`(u, v)`的**总成本**与 :math:`(v, u)`的相同。"

msgid ""
"Any duplicated value in the start or end vertex identifiers are ignored."
msgstr "起始或结束顶点标识符中的任何重复值都将被忽略。"

msgid "The returned values are ordered:"
msgstr "返回值是有序的："

msgid "``start_vid`` ascending"
msgstr "``start_vid`` 升序"

msgid "``end_vid`` ascending"
msgstr "``end_vid``升序"

msgid "Cost Matrix - Category"
msgstr "成本矩阵 - 类别"

msgid ":doc:`pgr_aStarCostMatrix`"
msgstr ":doc:`pgr_aStarCostMatrix`"

msgid ":doc:`pgr_bdAstarCostMatrix`"
msgstr ":doc:`pgr_bdAstarCostMatrix`"

msgid ":doc:`pgr_bdDijkstraCostMatrix`"
msgstr ":doc:`pgr_bdDijkstraCostMatrix`"

msgid ":doc:`pgr_dijkstraCostMatrix`"
msgstr ":doc:`pgr_dijkstraCostMatrix`"

msgid "proposed"
msgstr "建议的"

msgid ":doc:`pgr_withPointsCostMatrix`"
msgstr ":doc:`pgr_withPointsCostMatrix`"

msgid ""
":doc:`TSP-family` needs as input a symmetric cost matrix and no edge `(u, "
"v)` must value :math:`\\infty`."
msgstr ""
":doc:`TSP-family`需要一个对称成本矩阵作为输入，并且没有边 `(u, v)`必须值为:"
"math:`\\infty` 。"

msgid ""
"This collection of functions will return a cost matrix in form of a table."
msgstr "该函数集合将以表格形式返回成本矩阵。"

msgid "Can be used as input to :doc:`pgr_TSP`."
msgstr "可用作 :doc:`pgr_TSP` 的输入。"

msgid ""
"Use directly when the resulting matrix is symmetric and there is no :math:`"
"\\infty` value."
msgstr "当得到的矩阵是对称且没有 :math:`\\infty`值时直接使用。"

msgid "It will be the users responsibility to make the matrix symmetric."
msgstr "用户有责任使矩阵对称。"

msgid "By using geometric or harmonic average of the non symmetric values."
msgstr "通过使用非对称值的几何平均或调和平均。"

msgid "By using max or min the non symmetric values."
msgstr "通过使用 max 或 min 非对称值。"

msgid ""
"By setting the upper triangle to be the mirror image of the lower triangle."
msgstr "通过将上三角形设置为下三角形的镜像。"

msgid ""
"By setting the lower triangle to be the mirror image of the upper triangle."
msgstr "通过将下三角形设置为上三角形的镜像。"

msgid "It is also the users responsibility to fix an :math:`\\infty` value."
msgstr "确定:math:`\\infty`值也是用户的责任。"

msgid ""
"Returns the sum of the costs of the shortest path for pair combination of "
"nodes in the graph."
msgstr "返回图中节点对组合的最短路径的成本总和。"

msgid ""
"When the starting vertex and ending vertex are the same, there is no path."
msgstr "当起始顶点和结束顶点相同时，就没有路径。"

msgid "The aggregate cost in the non included values `(v, v)` is `0`."
msgstr "未包含值`(v, v)` 中的总成本为`0`。"

msgid ""
"When the starting vertex and ending vertex are the different and there is no "
"path."
msgstr "当起始顶点和结束顶点不同且不存在路径时。"

msgid ""
"The aggregate cost in the non included values `(u, v)` is :math:`\\infty`."
msgstr "未包含值 `(u, v)` 中的总成本为 :math:`\\infty` 。"

msgid "Let be the case the values returned are stored in a table:"
msgstr "假设返回的值存储在表中："

msgid "The unique index would be the pair: ``(start_vid, end_vid)``."
msgstr "唯一索引将是一对： ``(start_vid, end_vid)``。"

msgid "The aggregate cost of `(u, v)` is the same as for `(v, u)`."
msgstr "`(u, v)`的总成本与 `(v, u)`相同。"

msgid "Any duplicated value in the **start vids** are ignored."
msgstr "**start vids**中的任何重复值都会被忽略。"

msgid "Used in:"
msgstr "用于："

msgid "`Edges SQL`_ as described below"
msgstr "`Edges SQL`_ 如下所述"

msgid "**start vids**"
msgstr "**start vids**"

msgid "``ARRAY[BIGINT]``"
msgstr "``ARRAY[BIGINT]``"

msgid "Array of identifiers of starting vertices."
msgstr "起始顶点的标识符数组。"

msgid "`Points SQL`_"
msgstr "`Points SQL`_"

msgid "`Points SQL`_ as described below"
msgstr "`Points SQL`_ 如下所述"

msgid "Points SQL"
msgstr "Points SQL"

msgid "``pid``"
msgstr "``pid``"

msgid "**value**"
msgstr "**value**"

msgid "Identifier of the point."
msgstr "点的标识符。"

msgid ""
"Use with positive value, as internally will be converted to negative value"
msgstr "使用正值，因为内部将转换为负值"

msgid "If column is present, it can not be NULL."
msgstr "如果列存在，则它不能为 NULL。"

msgid ""
"If column is not present, a sequential negative **value** will be given "
"automatically."
msgstr "如果列不存在，将自动给出连续的负**值**。"

msgid "Identifier of the \"closest\" edge to the point."
msgstr "距离该点“最近”的边的标识符。"

msgid "``fraction``"
msgstr "``fraction``"

msgid ""
"Value in <0,1> that indicates the relative postition from the first end "
"point of the edge."
msgstr "<0,1> 中的值指示距边缘第一个端点的相对位置。"

msgid "``side``"
msgstr "``side``"

msgid "``CHAR``"
msgstr "``CHAR``"

msgid "``b``"
msgstr "``b``"

msgid "Value in [``b``, ``r``, ``l``, ``NULL``] indicating if the point is:"
msgstr "[``b``, ``r``, ``l``, ``NULL``] 中的值指示该点是否为："

msgid "In the right ``r``,"
msgstr "``r``在右边，"

msgid "In the left ``l``,"
msgstr "``l``在左边，"

msgid "In both sides ``b``, ``NULL``"
msgstr "``b``, ``NULL``在两边"

msgid ":doc:`TSP-family`"
msgstr ":doc:`TSP-family`"

msgid "Dijkstra - Family of functions"
msgstr "Dijkstra - 函数族"

msgid ":doc:`pgr_dijkstra` - Dijkstra's algorithm for the shortest paths."
msgstr ":doc:`pgr_dijkstra` - Dijkstra 最短路径算法。"

msgid ":doc:`pgr_dijkstraCost` - Get the aggregate cost of the shortest paths."
msgstr ":doc:`pgr_dijkstraCost` - 获取最短路径的总成本。"

msgid ""
":doc:`pgr_dijkstraCostMatrix` - Use pgr_dijkstra to create a costs matrix."
msgstr ":doc:`pgr_dijkstraCostMatrix` - 使用 pgr_dijkstra 创建成本矩阵。"

msgid ""
":doc:`pgr_drivingDistance` - Use pgr_dijkstra to calculate catchament "
"information."
msgstr ":doc:`pgr_drivingDistance` - 使用 pgr_dijkstra 计算流域信息。"

msgid ""
":doc:`pgr_KSP` - Use Yen algorithm with pgr_dijkstra to get the K shortest "
"paths."
msgstr ":doc:`pgr_KSP` - 使用 Yen 算法和 pgr_dijkstra 来获得 K 条最短路径。"

msgid ":doc:`pgr_dijkstraVia` - Get a route of a seuence of vertices."
msgstr ":doc:`pgr_dijkstraVia` - 获取一系列顶点的路径。"

msgid ":doc:`pgr_dijkstraNear` - Get the route to the nearest vertex."
msgstr ":doc:`pgr_dijkstraNear` - 获取到最近顶点的路线。"

msgid ":doc:`pgr_dijkstraNearCost` - Get the cost to the nearest vertex."
msgstr ":doc:`pgr_dijkstraNearCost` - 获取最近顶点的成本。"

msgid ""
"Dijkstra's algorithm, conceived by Dutch computer scientist Edsger Dijkstra "
"in 1956. It is a graph search algorithm that solves the shortest path "
"problem for a graph with non-negative edge path costs, producing a shortest "
"path from a starting vertex to an ending vertex. This implementation can be "
"used with a directed graph and an undirected graph."
msgstr ""
"Dijkstra算法，由荷兰计算机科学家Edsger Dijkstra于1956年提出。它是一种图搜索算"
"法，解决具有非负边路径成本的图的最短路径问题，产生从起始顶点到结束顶点的最短"
"路径。 该实现可以与有向图和无向图一起使用。"

msgid "Running time: :math:`O(| start\\ vids | * (V \\log V + E))`"
msgstr "运行时间：:math:`O(| start\\ vids | * (V \\log V + E))`"

msgid "The Dijkstra family functions are based on the Dijkstra algorithm."
msgstr "Dijkstra 系列函数基于 Dijkstra 算法。"

msgid "`Combinations SQL`_"
msgstr "`Combinations SQL`_"

msgid "`Combinations SQL`_ as described below"
msgstr "`Combinations SQL`_如下所述"

msgid "**start vid**"
msgstr "**start vid**"

msgid "Identifier of the starting vertex of the path."
msgstr "路径起始顶点的标识符。"

msgid "**end vid**"
msgstr "**end vid**"

msgid "Identifier of the ending vertex of the path."
msgstr "路径结束顶点的标识符。"

msgid "**end vids**"
msgstr "**end vids**"

msgid "Array of identifiers of ending vertices."
msgstr "结束顶点的标识符数组。"

msgid "Combinations SQL"
msgstr "分量 SQL"

msgid "Identifier of the departure vertex."
msgstr "出发顶点的标识符。"

msgid "Identifier of the arrival vertex."
msgstr "到达顶点的标识符。"

msgid "The problem definition (Advanced documentation)"
msgstr "问题定义（高级文档）"

msgid "Given the following query:"
msgstr "给出以下查询："

msgid "pgr_dijkstra(:math:`sql, start_{vid}, end_{vid}, directed`)"
msgstr "pgr_dijkstra(:math:`sql, start_{vid}, end_{vid}, directed`)"

msgid ""
"where  :math:`sql = \\{(id_i, source_i, target_i, cost_i, reverse"
"\\_cost_i)\\}`"
msgstr ""
"where  :math:`sql = \\{(id_i, source_i, target_i, cost_i, reverse"
"\\_cost_i)\\}`"

msgid "and"
msgstr "和"

msgid ":math:`source = \\bigcup source_i`,"
msgstr ":math:`source = \\bigcup source_i`,"

msgid ":math:`target = \\bigcup target_i`,"
msgstr ":math:`target = \\bigcup target_i`,"

msgid "The graphs are defined as follows:"
msgstr "图定义如下："

msgid "Directed graph"
msgstr "有向图"

msgid "The weighted directed graph, :math:`G_d(V,E)`, is definied by:"
msgstr "加权有向图， :math:`G_d(V,E)`的定义如下："

msgid "the set of vertices  :math:`V`"
msgstr "顶点集:math:`V`"

msgid ":math:`V = source \\cup target \\cup {start_{vid}} \\cup  {end_{vid}}`"
msgstr ":math:`V = source \\cup target \\cup {start_{vid}} \\cup  {end_{vid}}`"

msgid "the set of edges :math:`E`"
msgstr "边集:math:`E`"

msgid ""
":math:`E = \\begin{cases} \\text{ }  \\{(source_i, target_i, cost_i) "
"\\text{ when } cost >=0 \\} & \\quad \\text{if } reverse\\_cost = "
"\\varnothing \\\\ \\text{ }  \\text{ }  & \\quad \\text{ } \\\\ \\text{ }  "
"\\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\} &  \\quad "
"\\text{ } \\\\ \\cup      \\{(target_i, source_i, reverse\\_cost_i) "
"\\text{ when } reverse\\_cost_i>=0 \\} & \\quad \\text{if } reverse\\_cost "
"\\neq \\varnothing \\\\ \\end{cases}`"
msgstr ""
":math:`E = \\begin{cases} \\text{ }  \\{(source_i, target_i, cost_i) "
"\\text{ when } cost >=0 \\} & \\quad \\text{if } reverse\\_cost = "
"\\varnothing \\\\ \\text{ }  \\text{ }  & \\quad \\text{ } \\\\ \\text{ }  "
"\\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\} &  \\quad "
"\\text{ } \\\\ \\cup      \\{(target_i, source_i, reverse\\_cost_i) "
"\\text{ when } reverse\\_cost_i>=0 \\} & \\quad \\text{if } reverse\\_cost "
"\\neq \\varnothing \\\\ \\end{cases}`"

msgid "Undirected graph"
msgstr "无向图"

msgid "The weighted undirected graph, :math:`G_u(V,E)`, is definied by:"
msgstr "加权无向图，:math:`G_u(V,E)`的定义如下："

msgid ":math:`V = source \\cup target \\cup {start_v{vid}} \\cup  {end_{vid}}`"
msgstr ""
":math:`V = source \\cup target \\cup {start_v{vid}} \\cup  {end_{vid}}`"

msgid ""
":math:`E = \\begin{cases} \\text{ }  \\{(source_i, target_i, cost_i) "
"\\text{ when } cost >=0 \\}  & \\quad \\text{ } \\\\ \\cup      "
"\\{(target_i, source_i, cost_i) \\text{ when } cost >=0 \\}  & \\quad "
"\\text{ if } reverse\\_cost = \\varnothing \\\\ \\text{ }  \\text{ }  & "
"\\text{ } \\\\ \\text{ }  \\{(source_i, target_i, cost_i) \\text{ when } "
"cost >=0 \\} & \\text{ } \\\\ \\cup  \\{(target_i, source_i, cost_i) "
"\\text{ when } cost >=0 \\} & \\text{ } \\\\ \\cup  \\{(target_i, source_i, "
"reverse\\_cost_i) \\text{ when } reverse\\_cost_i >=0)\\} & \\text{ } \\\\ "
"\\cup  \\{(source_i, target_i, reverse\\_cost_i) \\text{ when } reverse"
"\\_cost_i >=0)\\} & \\quad \\text{ if } reverse\\_cost \\neq \\varnothing \\"
"\\ \\end{cases}`"
msgstr ""
":math:`E = \\begin{cases} \\text{ }  \\{(source_i, target_i, cost_i) "
"\\text{ when } cost >=0 \\}  & \\quad \\text{ } \\\\ \\cup      "
"\\{(target_i, source_i, cost_i) \\text{ when } cost >=0 \\}  & \\quad "
"\\text{ if } reverse\\_cost = \\varnothing \\\\ \\text{ }  \\text{ }  & "
"\\text{ } \\\\ \\text{ }  \\{(source_i, target_i, cost_i) \\text{ when } "
"cost >=0 \\} & \\text{ } \\\\ \\cup  \\{(target_i, source_i, cost_i) "
"\\text{ when } cost >=0 \\} & \\text{ } \\\\ \\cup  \\{(target_i, source_i, "
"reverse\\_cost_i) \\text{ when } reverse\\_cost_i >=0)\\} & \\text{ } \\\\ "
"\\cup  \\{(source_i, target_i, reverse\\_cost_i) \\text{ when } reverse"
"\\_cost_i >=0)\\} & \\quad \\text{ if } reverse\\_cost \\neq \\varnothing \\"
"\\ \\end{cases}`"

msgid "The problem"
msgstr "问题"

msgid "Given:"
msgstr "给定："

msgid ":math:`start_{vid} \\in V` a starting vertex"
msgstr ":math:`start_{vid} \\in V` a starting vertex"

msgid ":math:`end_{vid} \\in V` an ending vertex"
msgstr ":math:`end_{vid} \\in V` an ending vertex"

msgid ""
":math:`G(V,E) = \\begin{cases} G_d(V,E) & \\quad \\text{ if6 } directed = "
"true \\\\ G_u(V,E) & \\quad \\text{ if5 } directed = false \\\\ \\end{cases}`"
msgstr ""
":math:`G(V,E) = \\begin{cases} G_d(V,E) & \\quad \\text{ if6 } directed = "
"true \\\\ G_u(V,E) & \\quad \\text{ if5 } directed = false \\\\ \\end{cases}`"

msgid "Then:"
msgstr "然后："

msgid ""
":math:`\\boldsymbol{\\pi} = \\{(path\\_seq_i, node_i, edge_i, cost_i, agg"
"\\_cost_i)\\}`"
msgstr ""
":math:`\\boldsymbol{\\pi} = \\{(path\\_seq_i, node_i, edge_i, cost_i, agg"
"\\_cost_i)\\}`"

msgid "where:"
msgstr "其中："

msgid ":math:`path\\_seq_i = i`"
msgstr ":math:`path\\_seq_i = i`"

msgid ":math:`path\\_seq_{| \\pi |} = | \\pi |`"
msgstr ":math:`path\\_seq_{| \\pi |} = | \\pi |`"

msgid ":math:`node_i \\in V`"
msgstr ":math:`node_i \\in V`"

msgid ":math:`node_1 = start_{vid}`"
msgstr ":math:`node_1 = start_{vid}`"

msgid ":math:`node_{| \\pi |}  = end_{vid}`"
msgstr ":math:`node_{| \\pi |}  = end_{vid}`"

msgid ""
":math:`\\forall i \\neq | \\pi |, \\quad (node_i, node_{i+1}, cost_i) \\in E`"
msgstr ""
":math:`\\forall i \\neq | \\pi |, \\quad (node_i, node_{i+1}, cost_i) \\in E`"

msgid ""
":math:`edge_i  = \\begin{cases}  id_{(node_i, node_{i+1},cost_i)}  &\\quad  "
"\\text{when } i \\neq | \\pi | \\\\ -1 &\\quad  \\text{when } i = | \\pi | \\"
"\\ \\end{cases}`"
msgstr ""
":math:`edge_i  = \\begin{cases}  id_{(node_i, node_{i+1},cost_i)}  &\\quad  "
"\\text{when } i \\neq | \\pi | \\\\ -1 &\\quad  \\text{when } i = | \\pi | \\"
"\\ \\end{cases}`"

msgid ":math:`cost_i = cost_{(node_i, node_{i+1})}`"
msgstr ":math:`cost_i = cost_{(node_i, node_{i+1})}`"

msgid ""
":math:`agg\\_cost_i  = \\begin{cases}  0   &\\quad  \\text{when } i = 1  \\"
"\\ \\displaystyle\\sum_{k=1}^{i}  cost_{(node_{k-1}, node_k)}  &\\quad  "
"\\text{when } i \\neq 1 \\\\ \\end{cases}`"
msgstr ""
":math:`agg\\_cost_i  = \\begin{cases}  0   &\\quad  \\text{when } i = 1  \\"
"\\ \\displaystyle\\sum_{k=1}^{i}  cost_{(node_{k-1}, node_k)}  &\\quad  "
"\\text{when } i \\neq 1 \\\\ \\end{cases}`"

msgid ""
"In other words: The algorithm returns a the shortest path between :math:"
"`start_{vid}` and :math:`end_{vid}`, if it exists, in terms of a sequence of "
"nodes  and of edges,"
msgstr ""
"换句话说：该算法返回 :math:`start_{vid}` 和:math:`end_{vid}` 之间的最短路径"
"（如果存在），以节点和边的序列表示，"

msgid ""
":math:`path\\_seq` indicates the relative position in the path of the :math:"
"`node` or :math:`edge`."
msgstr ":math:`path\\_seq`表示 :math:`node`或:math:`edge`的路径中的相对位置。"

msgid ":math:`cost` is the cost of the edge to be used to go to the next node."
msgstr ":math:`cost`是用于转到下一个节点的边的成本。"

msgid ""
":math:`agg\\_cost` is the cost from the :math:`start_{vid}` up to the node."
msgstr ":math:`agg\\_cost`是从 :math:`start_{vid}`到节点的成本。"

msgid "If there is no path, the resulting set is empty."
msgstr "如果没有路径，则结果集为空。"

msgid "Driving Distance - Category"
msgstr "驾驶距离 - 类别"

msgid ""
":doc:`pgr_drivingDistance` - Driving Distance based on Dijkstra's algorithm"
msgstr ":doc:`pgr_drivingDistance` - 基于 Dijkstra 算法的行驶距离"

msgid ":doc:`pgr_primDD` - Driving Distance based on Prim's algorithm"
msgstr ":doc:`pgr_primDD` - 基于Prim算法的行驶距离"

msgid ":doc:`pgr_kruskalDD` - Driving Distance based on Kruskal's algorithm"
msgstr ":doc:`pgr_kruskalDD` - 基于Kruskal算法的行驶距离"

msgid "Post pocessing"
msgstr "后期处理"

msgid ":doc:`pgr_alphaShape` - Alpha shape computation"
msgstr ":doc:`pgr_alphaShape` - Alpha 形状计算"

msgid ":doc:`pgr_withPointsDD` - Driving Distance based on pgr_withPoints"
msgstr ":doc:`pgr_withPointsDD` - 基于 pgr_withPoints 的行驶距离"

msgid "Calculate nodes that are within a distance."
msgstr "计算一定距离内的节点。"

msgid ""
"Extracts all the nodes that have costs less than or equal to the value "
"distance."
msgstr "提取成本小于或等于距离值的所有节点。"

msgid "The edges extracted will conform to the corresponding spanning tree."
msgstr "提取的边将符合相应的生成树。"

msgid "Edge :math:`(u, v)` will not be included when:"
msgstr "在以下情况下，边:math:`(u, v)`将不包括在内："

msgid "The distance from the **root** to :math:`u` > limit distance."
msgstr "从 **root**到 :math:`u`的距离>限制距离。"

msgid "The distance from the **root** to :math:`v` > limit distance."
msgstr "从 **root**到 :math:`v`的距离>限制距离。"

msgid ""
"No new nodes are created on the graph, so when is within the limit and is "
"not within the limit, the edge is not included."
msgstr "图上不会创建新的节点，因此当 位于限制内和不在限制内时，不包含边。"

msgid "Edges SQL as described below."
msgstr "Edges SQL如下所述。"

msgid "**Root vid**"
msgstr "**Root vid**"

msgid "**Root vids**"
msgstr "**Root vids**"

msgid "``ARRAY[ANY-INTEGER]``"
msgstr "``ARRAY[ANY-INTEGER]``"

msgid "**distance**"
msgstr "**distance**"

msgid "Upper limit for the inclusion of a node in the result."
msgstr "结果中包含节点的上限。"

msgid "Returns SET OF |result-spantree|"
msgstr "返回 |result-spantree| 的一组结果"

msgid ":math:`depth-1` is the depth of ``pred``"
msgstr ":math:`depth-1` is the depth of ``pred``"

msgid "``pred``"
msgstr "``pred``"

msgid "Predecessor of ``node``."
msgstr "``node``的前驱。"

msgid "When ``node`` = ``start_vid`` then has the value ``node``."
msgstr "当 `node` 等于 `start_vid` 时，它的值就是 `node`。"

msgid "Identifier of the ``edge`` used to arrive from ``pred`` to ``node``."
msgstr "从``pred`` 到达``node``所使用的 ``edge``的标识符。"

msgid ""
"Column ``pred`` only applies to :doc:`pgr_drivingDistance` and :doc:"
"`pgr_withPointsDD`."
msgstr ""
"列``pred``仅适用于 :doc:`pgr_drivingDistance` 和:doc:`pgr_withPointsDD`。"

msgid "Experimental Functions"
msgstr "实验函数"

msgid "Families"
msgstr "族"

msgid ":doc:`flow-family`"
msgstr ":doc:`flow-family`"

msgid ":doc:`pgr_maxFlowMinCost` - Details of flow and cost on edges."
msgstr ":doc:`pgr_maxFlowMinCost` - 边缘上的流量和成本详细信息。"

msgid ":doc:`pgr_maxFlowMinCost_Cost` - Only the Min Cost calculation."
msgstr ":doc:`pgr_maxFlowMinCost_Cost` -仅最小成本计算。"

msgid ":doc:`chinesePostmanProblem-family`"
msgstr ":doc:`chinesePostmanProblem-family`"

msgid ":doc:`coloring-family`"
msgstr ":doc:`coloring-family`"

msgid ":doc:`transformation-family`"
msgstr ":doc:`transformation-family`"

msgid ""
":doc:`pgr_lineGraph` - Transformation algorithm for generating a Line Graph."
msgstr ":doc:`pgr_lineGraph` - 用于生成折线图的转换算法。"

msgid ""
":doc:`pgr_lineGraphFull` - Transformation algorithm for generating a Line "
"Graph out of each vertex in the input graph."
msgstr ""
":doc:`pgr_lineGraphFull` - 用于从输入图中的每个顶点生成线图的变换算法。"

msgid ":doc:`traversal-family`"
msgstr ":doc:`traversal-family`"

msgid ""
":doc:`pgr_breadthFirstSearch` - Breath first search traversal of the graph."
msgstr ":doc:`pgr_breadthFirstSearch` - 图的广度优先搜索遍历。"

msgid ""
":doc:`pgr_binaryBreadthFirstSearch` - Breath first search traversal of the "
"graph."
msgstr ":doc:`pgr_binaryBreadthFirstSearch` -图的广度优先搜索遍历。"

msgid ":doc:`components-family`"
msgstr ":doc:`components-family`"

msgid ":doc:`ordering-family`"
msgstr ":doc:`ordering-family`"

msgid ""
":doc:`pgr_cuthillMckeeOrdering` - Return reverse Cuthill-McKee ordering of "
"an undirected graph."
msgstr ":doc:`pgr_cuthillMckeeOrdering` -返回无向图的反向 Cuthill-McKee 排序。"

msgid ":doc:`TRSP-family`"
msgstr ":doc:`TRSP-family`"

msgid "categories"
msgstr "类别"

msgid ":doc:`VRP-category`"
msgstr ":doc:`VRP-category`"

msgid "Not classified"
msgstr "未分类"

msgid ":doc:`pgr_bellmanFord`"
msgstr ":doc:`pgr_bellmanFord`"

msgid ":doc:`pgr_dagShortestPath`"
msgstr ":doc:`pgr_dagShortestPath`"

msgid ":doc:`pgr_edwardMoore`"
msgstr ":doc:`pgr_edwardMoore`"

msgid ":doc:`pgr_isPlanar`"
msgstr ":doc:`pgr_isPlanar`"

msgid ":doc:`pgr_stoerWagner`"
msgstr ":doc:`pgr_stoerWagner`"

msgid ":doc:`pgr_topologicalSort`"
msgstr ":doc:`pgr_topologicalSort`"

msgid ":doc:`pgr_transitiveClosure`"
msgstr ":doc:`pgr_transitiveClosure`"

msgid ":doc:`pgr_lengauerTarjanDominatorTree`"
msgstr ":doc:`pgr_lengauerTarjanDominatorTree`"

msgid ":doc:`pgr_hawickCircuits`"
msgstr ":doc:`pgr_hawickCircuits`"

msgid "Flow - Family of functions"
msgstr "Flow - 函数族"

msgid ""
":doc:`pgr_maxFlow` - Only the Max flow calculation using Push and Relabel "
"algorithm."
msgstr ":doc:`pgr_maxFlow` - 仅使用 Push 和 Relabel 算法进行最大流量计算。"

msgid ""
":doc:`pgr_boykovKolmogorov` - Boykov and Kolmogorov with details of flow on "
"edges."
msgstr ":doc:`pgr_boykovKolmogorov` - Boykov 和 Kolmogorov 的边流动细节。"

msgid ""
":doc:`pgr_edmondsKarp` - Edmonds and Karp algorithm with details of flow on "
"edges."
msgstr ":doc:`pgr_edmondsKarp` - 带有边流量详细信息的 Edmonds 和 Karp 算法"

msgid ""
":doc:`pgr_pushRelabel` - Push and relabel algorithm with details of flow on "
"edges."
msgstr ":doc:`pgr_pushRelabel` - 推送和重新标记算法以及边流量的详细信息"

msgid "Applications"
msgstr "应用"

msgid ""
":doc:`pgr_edgeDisjointPaths` - Calculates edge disjoint paths between two "
"groups of vertices."
msgstr ":doc:`pgr_edgeDisjointPaths` - 计算两组顶点之间的边不相交路径。"

msgid ""
":doc:`pgr_maxCardinalityMatch` - Calculates a maximum cardinality matching "
"in a graph."
msgstr ":doc:`pgr_maxCardinalityMatch` - 计算图中的最大基数匹配。"

msgid "Flow Functions General Information"
msgstr "流函数一般信息"

msgid "The graph is **directed**."
msgstr "该图是**有向**的。"

msgid "Process is done only on edges with positive capacities."
msgstr "仅在具有正容量的边缘上进行处理。"

msgid ""
"When the maximum flow is 0 then there is no flow and **EMPTY SET** is "
"returned."
msgstr "当最大流量为0时则没有流量并返回**EMPTY SET**。"

msgid "There is no flow when a **source** is the same as a **target**."
msgstr "当 **source**与 **target**相同时，就没有流量。"

msgid "Any duplicated value in the source(s) or target(s) are ignored."
msgstr "source(s)或target(s) 中的任何重复值都将被忽略。"

msgid "Calculates the flow/residual capacity for each edge. In the output"
msgstr "计算每条边的流量/剩余容量。 在输出中"

msgid "Edges with zero flow are omitted."
msgstr "流量为零的边被忽略。"

msgid ""
"Creates a **super source** and edges to all the source(s), and a **super "
"target** and the edges from all the targets(s)."
msgstr ""
"创建**super source**和所有源的边，以及 **super target** 和所有目标的边。"

msgid ""
"The maximum flow through the graph is guaranteed to be the value returned "
"by :doc:`pgr_maxFlow <pgr_maxFlow>` when executed with the same parameters "
"and can be calculated:"
msgstr ""
"当使用相同参数执行时，通过图表的最大流量保证是:doc:`pgr_maxFlow "
"<pgr_maxFlow>` 返回的值，并且可以计算："

msgid "By aggregation of the outgoing flow from the sources"
msgstr "通过聚合来自源的传出流量"

msgid "By aggregation of the incoming flow to the targets"
msgstr "通过聚合到达目标的传入流量"

msgid ""
":doc:`pgr_maxFlow` is the maximum Flow and that maximum is guaranteed to be "
"the same on the functions :doc:`pgr_pushRelabel`, :doc:`pgr_edmondsKarp`, :"
"doc:`pgr_boykovKolmogorov`, but the actual flow through each edge may vary."
msgstr ""
":doc:`pgr_maxFlow` 是最大流量，并且该最大值保证在函数 :doc:"
"`pgr_pushRelabel`, :doc:`pgr_edmondsKarp`, :doc:`pgr_boykovKolmogorov`, 上相"
"同，但通过每条边的实际流量可能会有所不同。"

msgid "Capacity edges"
msgstr "容量边缘"

msgid ":doc:`pgr_pushRelabel`"
msgstr ":doc:`pgr_pushRelabel`"

msgid ":doc:`pgr_edmondsKarp`"
msgstr ":doc:`pgr_edmondsKarp`"

msgid ":doc:`pgr_boykovKolmogorov`"
msgstr ":doc:`pgr_boykovKolmogorov`"

msgid "``reverse_capacity``"
msgstr "``reverse_capacity``"

msgid "Capacity-Cost edges"
msgstr "容量-成本边"

msgid ":doc:`pgr_maxFlowMinCost`"
msgstr ":doc:`pgr_maxFlowMinCost`"

msgid ":doc:`pgr_maxFlowMinCost_Cost`"
msgstr ":doc:`pgr_maxFlowMinCost_Cost`"

msgid "Capacity of the edge  (``source``, ``target``)"
msgstr "边 (``source``, ``target``)的容量"

msgid "Capacity of the edge (``target``, ``source``)"
msgstr "边 (``target``, ``source``)的容量"

msgid "Weight of the edge  (``source``, ``target``) if it exist"
msgstr "边 (``source``, ``target``)的权重（如果存在）"

msgid "Weight of the edge (``target``, ``source``) if it exist"
msgstr "边(``target``, ``source``)的权重（如果存在）"

msgid "Cost edges"
msgstr "成本边"

msgid ":doc:`pgr_edgeDisjointPaths`"
msgstr ":doc:`pgr_edgeDisjointPaths`"

msgid "Used in"
msgstr "用于"

msgid "**seq**"
msgstr "**seq**"

msgid "``INT``"
msgstr "``INT``"

msgid "**edge**"
msgstr "**edge**"

msgid "Identifier of the edge in the original query (edges_sql)."
msgstr "原始查询中边的标识符 (edges_sql)。"

msgid "**start_vid**"
msgstr "**start_vid**"

msgid "**end_vid**"
msgstr "**end_vid**"

msgid "**flow**"
msgstr "**flow**"

msgid "Flow through the edge in the direction (``start_vid``, ``end_vid``)."
msgstr "沿 (``start_vid``, ``end_vid``)方向流经边缘。"

msgid "**residual_capacity**"
msgstr "**residual_capacity**"

msgid ""
"Residual capacity of the edge in the direction (``start_vid``, ``end_vid``)."
msgstr "(``start_vid``, ``end_vid``)方向上边缘的剩余容量。"

msgid "For :doc:`pgr_maxFlowMinCost`"
msgstr "对于 :doc:`pgr_maxFlowMinCost`"

msgid "**source**"
msgstr "**source**"

msgid "**target**"
msgstr "**target**"

msgid "Flow through the edge in the direction (source, target)."
msgstr "沿方向 (source, target)流经边缘。"

msgid "Residual capacity of the edge in the direction (source, target)."
msgstr "方向 (source, target)上边缘的剩余容量。"

msgid "**cost**"
msgstr "**cost**"

msgid ""
"The cost of sending this flow through the edge in the direction (source, "
"target)."
msgstr "在方向 (source, target)上通过边缘发送此流的成本。"

msgid "**agg_cost**"
msgstr "**agg_cost**"

msgid "The aggregate cost."
msgstr "总成本。"

msgid "Advanced Documentation"
msgstr "高级文档"

msgid ""
"A flow network is a directed graph where each edge has a capacity and a "
"flow. The flow through an edge must not exceed the capacity of the edge. "
"Additionally, the incoming and outgoing flow of a node must be equal except "
"for source which only has outgoing flow, and the destination(sink) which "
"only has incoming flow."
msgstr ""
"流网络是一个有向图，其中每条边都有容量和流量。通过一条边的流量不能超过边的容"
"量。此外，节点的流入流出必须相等，除了源节点只有流出流量，以及目标（汇点）节"
"点只有流入流量。"

msgid ""
"Maximum flow algorithms calculate the maximum flow through the graph and the "
"flow of each edge."
msgstr "最大流量算法计算通过图的最大流量以及每条边的流量。"

msgid ""
"The maximum flow through the graph is guaranteed to be the same with all "
"implementations, but the actual flow through each edge may vary."
msgstr ""
"所有实现中通过图表的最大流量保证相同，但通过每条边的实际流量可能会有所不同。"

msgid "pgr_maxFlow :math:`(edges\\_sql, source\\_vertex, sink\\_vertex)`"
msgstr "pgr_maxFlow:math:`(edges\\_sql, source\\_vertex, sink\\_vertex)`"

msgid ""
"where :math:`edges\\_sql = \\{(id_i, source_i, target_i, capacity_i, reverse"
"\\_capacity_i)\\}`"
msgstr ""
"其中:math:`edges\\_sql = \\{(id_i, source_i, target_i, capacity_i, reverse"
"\\_capacity_i)\\}`"

msgid "Graph definition"
msgstr "图定义"

msgid "The weighted directed graph, :math:`G(V,E)`, is defined as:"
msgstr "加权有向图， :math:`G(V,E)` 定义为："

msgid ""
":math:`source\\_vertex  \\cup  sink\\_vertex  \\bigcup  source_i  \\bigcup  "
"target_i`"
msgstr ""
":math:`source\\_vertex  \\cup  sink\\_vertex  \\bigcup  source_i  \\bigcup  "
"target_i`"

msgid ""
":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, capacity_i) "
"\\text{ when } capacity > 0 \\} & \\quad  \\text{ if } reverse\\_capacity = "
"\\varnothing \\\\ \\text{ } & \\quad \\text{ } \\\\ \\{(source_i, target_i, "
"capacity_i) \\text{ when } capacity > 0 \\} & \\text{ } \\\\ \\cup "
"\\{(target_i, source_i, reverse\\_capacity_i) \\text{ when } reverse"
"\\_capacity_i > 0)\\} & \\quad \\text{ if } reverse\\_capacity \\neq "
"\\varnothing \\\\ \\end{cases}`"
msgstr ""
":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, capacity_i) "
"\\text{ when } capacity > 0 \\} & \\quad  \\text{ if } reverse\\_capacity = "
"\\varnothing \\\\ \\text{ } & \\quad \\text{ } \\\\ \\{(source_i, target_i, "
"capacity_i) \\text{ when } capacity > 0 \\} & \\text{ } \\\\ \\cup "
"\\{(target_i, source_i, reverse\\_capacity_i) \\text{ when } reverse"
"\\_capacity_i > 0)\\} & \\quad \\text{ if } reverse\\_capacity \\neq "
"\\varnothing \\\\ \\end{cases}`"

msgid "Maximum flow problem"
msgstr "最大流量问题"

msgid ":math:`G(V,E)`"
msgstr ":math:`G(V,E)`"

msgid ":math:`source\\_vertex \\in V` the source vertex"
msgstr ":math:`source\\_vertex \\in V` the source vertex"

msgid ":math:`sink\\_vertex \\in V` the sink vertex"
msgstr ":math:`sink\\_vertex \\in V` the sink vertex"

msgid ":math:`pgr\\_maxFlow(edges\\_sql, source, sink) = \\boldsymbol{\\Phi}`"
msgstr ":math:`pgr\\_maxFlow(edges\\_sql, source, sink) = \\boldsymbol{\\Phi}`"

msgid ""
":math:`\\boldsymbol{\\Phi} = {(id_i, edge\\_id_i, source_i, target_i, "
"flow_i, residual\\_capacity_i)}`"
msgstr ""
":math:`\\boldsymbol{\\Phi} = {(id_i, edge\\_id_i, source_i, target_i, "
"flow_i, residual\\_capacity_i)}`"

msgid ""
":math:`\\boldsymbol{\\Phi}` is a subset of the original edges with their "
"residual capacity and flow. The maximum flow through the graph can be "
"obtained by aggregating on the source or sink and summing the flow from/to "
"it. In particular:"
msgstr ""
":math:`\\boldsymbol{\\Phi}`是原始边及其剩余容量和流量的子集。 通过图的最大流"
"量可以通过在源或汇上聚合并对来自/到它的流量求和来获得。 尤其："

msgid ":math:`id_i = i`"
msgstr ":math:`id_i = i`"

msgid ":math:`edge\\_id = id_i` in edges_sql"
msgstr ":math:`edge\\_id = id_i`在edges_sql中"

msgid ":math:`residual\\_capacity_i = capacity_i - flow_i`"
msgstr ":math:`residual\\_capacity_i = capacity_i - flow_i`"

msgid "https://en.wikipedia.org/wiki/Maximum_flow_problem"
msgstr "https://en.wikipedia.org/wiki/Maximum_flow_problem"

msgid ""
"pgRouting extends the `PostGIS <https://postgis.net>`__/`PostgreSQL <https://"
"www.postgresql.org>`__ geospatial database to provide geospatial routing and "
"other network analysis functionality."
msgstr ""
"pgRouting 扩展了 `PostGIS <https://postgis.net>`__/`PostgreSQL <https://www."
"postgresql.org>`__ 地理空间数据库，以提供地理空间路由和其他网络分析功能。"

msgid "This is the manual for pgRouting |release|."
msgstr "这是pgRouting|release|的手册"

msgid "Creative Commons Attribution-Share Alike 3.0 License"
msgstr "知识共享署名 - 相同方式共享 3.0 许可证。"

msgid ""
"The pgRouting Manual is licensed under a `Creative Commons Attribution-Share "
"Alike 3.0 License <https://creativecommons.org/licenses/by-sa/3.0/>`_. Feel "
"free to use this material any way you like, but we ask that you attribute "
"credit to the pgRouting Project and wherever possible, a link back to "
"https://pgrouting.org. For other licenses used in pgRouting see the :ref:"
"`license` page."
msgstr ""
"pgRouting 手册根据`知识共享署名-相同方式共享3.0许可证 <https://"
"creativecommons.org/licenses/by-sa/3.0/>`_。 您可以随意使用本材料，但我们要求"
"您将功劳归功于 pgRouting 项目，并尽可能提供返回 https://pgrouting.org 的链"
"接。 有关 pgRouting 中使用的其他许可证，请参阅:ref:`license` page.。"

msgid "General"
msgstr "常规"

msgid ":doc:`sampledata` that is used in the examples of this manual."
msgstr "本手册示例中使用的 :doc:`sampledata`"

msgid "Pgrouting Concepts"
msgstr "Pgrouting概念"

msgid ":doc:`routingFunctions`"
msgstr ":doc:`routingFunctions`"

msgid ":doc:`allpairs-family`"
msgstr ":doc:`allpairs-family`"

msgid ":doc:`bdDijkstra-family`"
msgstr ":doc:`bdDijkstra-family`"

msgid ":doc:`contraction-family`"
msgstr ":doc:`contraction-family`"

msgid ":doc:`dijkstra-family`"
msgstr ":doc:`dijkstra-family`"

msgid ":doc:`kruskal-family`"
msgstr ":doc:`kruskal-family`"

msgid ":doc:`pgr_kruskal`"
msgstr ":doc:`pgr_kruskal`"

msgid ":doc:`pgr_kruskalDD`"
msgstr ":doc:`pgr_kruskalDD`"

msgid ":doc:`prim-family`"
msgstr ":doc:`prim-family`"

msgid ":doc:`pgr_prim`"
msgstr ":doc:`pgr_prim`"

msgid ":doc:`pgr_primDD`"
msgstr ":doc:`pgr_primDD`"

msgid ":doc:`reference`"
msgstr ":doc:`reference`"

msgid ":doc:`pgr_version`"
msgstr ":doc:`pgr_version`"

msgid ":doc:`pgr_full_version`"
msgstr ":doc:`pgr_full_version`"

msgid ":doc:`topology-functions`"
msgstr ":doc:`topology-functions`"

msgid ""
"The following functions modify the database directly therefore the user must "
"have special permissions given by the administrators to use them."
msgstr ""
"以下函数直接修改数据库，因此用户必须具有管理员授予的特殊权限才能使用它们。"

msgid ":doc:`pgr_createTopology` -  create a topology based on the geometry."
msgstr ":doc:`pgr_createTopology` - 根据几何形状创建拓扑。"

msgid ""
":doc:`pgr_createVerticesTable` - reconstruct the vertices table based on the "
"source and target information."
msgstr ":doc:`pgr_createVerticesTable` - 根据源和目标信息重建顶点表。"

msgid ""
":doc:`pgr_analyzeGraph`  - to analyze the edges and vertices of the edge "
"table."
msgstr ":doc:`pgr_analyzeGraph` - 分析边表的边和顶点。"

msgid ":doc:`pgr_analyzeOneWay` - to analyze directionality of the edges."
msgstr ":doc:`pgr_analyzeOneWay` - 分析边的方向性。"

msgid ":doc:`pgr_nodeNetwork`  -to create nodes to a not noded edge table."
msgstr ":doc:`pgr_nodeNetwork` -为无节点边表创建节点。"

msgid ":doc:`pgr_trsp` - Turn Restriction Shortest Path (TRSP)"
msgstr ":doc:`pgr_trsp` - 转弯限制最短路径 (TRSP)"

msgid "Functions by categories"
msgstr "按类别划分的函数"

msgid ":doc:`cost-category`"
msgstr ":doc:`cost-category`"

msgid ":doc:`costMatrix-category`"
msgstr ":doc:`costMatrix-category`"

msgid ":doc:`drivingDistance-category`"
msgstr ":doc:`drivingDistance-category`"

msgid ":doc:`KSP-category`"
msgstr ":doc:`KSP-category`"

msgid ":doc:`spanningTree-family`"
msgstr ":doc:`spanningTree-family`"

msgid ":doc:`BFS-category`"
msgstr ":doc:`BFS-category`"

msgid ":doc:`DFS-category`"
msgstr ":doc:`DFS-category`"

msgid "Available Functions but not official pgRouting functions"
msgstr "可用函数，但不是官方 pgRouting 函数"

msgid ":doc:`proposed`"
msgstr ":doc:`proposed`"

msgid ":doc:`experimental`"
msgstr ":doc:`experimental`"

msgid ":doc:`release_notes`"
msgstr ":doc:`release_notes`"

msgid "Kruskal - Family of functions"
msgstr "Kruskal - 函数族"

msgid "Boost Graph Inside"
msgstr "Boost 图内部"

msgid ""
"Kruskal's algorithm is a greedy minimum spanning tree algorithm that in each "
"cycle finds and adds the edge of the least possible weight that connects any "
"two trees in the forest."
msgstr ""
"克鲁斯卡尔算法是一种贪婪的最小生成树算法，它在每个循环中查找并添加连接森林中"
"任意两棵树的最小可能权重的边。"

msgid "**The main Characteristics are:**"
msgstr "**主要特点是：**"

msgid "The total weight of all the edges in the tree or forest is minimized."
msgstr "树或森林中所有边的总权重最小化。"

msgid "Kruskal's running time: :math:`O(E * log E)`"
msgstr "克鲁斯卡尔的运行时间： :math:`O(E * log E)`"

msgid "Migration guide"
msgstr "迁移指南"

msgid ""
"Several functions are having changes on the signatures, and/or have been "
"replaced by new functions."
msgstr "多个函数的签名发生了变化，和/或已被新函数取代。"

msgid "Results can be different because of the changes."
msgstr "结果可能会因变化而不同。"

msgid "All deprecated functions will be removed on next mayor version 4.0.0"
msgstr "所有已弃用的函数将在下一个主要版本 4.0.0 中被移除"

msgid "Migration of functions"
msgstr "函数迁移"

msgid "Migrating functions"
msgstr "迁移函数"

msgid "Migration of ``pgr_aStar``"
msgstr "``pgr_aStar``迁移"

msgid ""
"Starting from `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__"
msgstr "开始从 `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__"

msgid "Signatures to be migrated:"
msgstr "要迁移的签名："

msgid "``pgr_aStar`` (`One to One`)"
msgstr "``pgr_aStar`` (`一对一`)"

msgid "``pgr_aStar`` (`One to Many`)"
msgstr "``pgr_aStar`` (`一对多`)"

msgid "``pgr_aStar`` (`Many to One`)"
msgstr "``pgr_aStar`` (`多对一`)"

msgid "Before Migration"
msgstr "迁移前"

msgid "Output columns were |old-generic-result|"
msgstr "输出列是 |old-generic-result|"

msgid ""
"Depending on the overload used, the columns ``start_vid`` and ``end_vid`` "
"might be missing:"
msgstr "根据所使用的重载， ``start_vid`` 和``end_vid``列可能会丢失："

msgid ""
"``pgr_aStar`` (`One to One`) does not have ``start_vid`` and ``end_vid``."
msgstr "``pgr_aStar`` (`一对一`)没有``start_vid`` 和``end_vid``。"

msgid "``pgr_aStar`` (`One to Many`) does not have ``start_vid``."
msgstr "``pgr_aStar`` (`一对多`) 没有 ``start_vid``。"

msgid "``pgr_aStar`` (`Many to One`) does not have ``end_vid``."
msgstr "``pgr_aStar`` (`多对一`)没有 ``end_vid``。"

msgid "Migration"
msgstr "迁移"

msgid "Be aware of the existance of the additional columns."
msgstr "请注意附加列的存在。"

msgid "In ``pgr_aStar`` (`One to One`)"
msgstr "在``pgr_aStar`` (`一对一`)中"

msgid "``start_vid`` contains the **start vid** parameter value."
msgstr "``start_vid`` 包含**起始 vid **参数值。"

msgid "``end_vid`` contains the **end vid** parameter value."
msgstr "``end_vid`` 包含**结束 vid** 参数值。"

msgid "In ``pgr_aStar`` (`One to Many`)"
msgstr "在``pgr_aStar`` (`一对多`)中"

msgid "In ``pgr_aStar`` (`Many to One`)"
msgstr "在``pgr_aStar`` (`多对一`)中"

msgid "If needed filter out the added columns, for example:"
msgstr "如果需要，过滤掉添加的列，例如："

msgid ""
"If needed add the new columns, similar to the following example where "
"``pgr_dijkstra`` is used, and the function had to be modified to be able to "
"return the new columns:"
msgstr ""
"如果需要添加新列，类似于以下使用 ``pgr_dijkstra`` 的示例，并且必须修改该函数"
"才能返回新列："

msgid ""
"In `v3.0 <https://docs.pgrouting.org/3.0/en/contraction-family.html#case-1-"
"both-source-and-target-belong-to-the-contracted-graph>`__ the function "
"``my_dijkstra`` uses ``pgr_dijkstra``."
msgstr ""
"在`v3.0 <https://docs.pgrouting.org/3.0/en/contraction-family.html#case-1-"
"both-source-and-target-belong-to-the-contracted-graph>`__ 中，函数"
"``my_dijkstra`` 使用 ``pgr_dijkstra``。"

msgid ""
"Starting from `v3.5 <https://docs.pgrouting.org/3.5/en/contraction-family."
"html#case-1-both-source-and-target-belong-to-the-contracted-graph>`__ the "
"function ``my_dijkstra`` returns the new additional columns of "
"``pgr_dijkstra``."
msgstr ""
"从 `v3.5 <https://docs.pgrouting.org/3.5/en/contraction-family.html#case-1-"
"both-source-and-target-belong-to-the-contracted-graph>`__开始，函数 "
"``my_dijkstra`` 返回 ``pgr_dijkstra``的新附加列。"

msgid "Migration of ``pgr_bdAstar``"
msgstr "迁移``pgr_bdAstar``"

msgid "``pgr_bdAstar`` (`One to One`)"
msgstr "``pgr_bdAstar`` (`一对一`)"

msgid "``pgr_bdAstar`` (`One to Many`)"
msgstr "``pgr_bdAstar`` (`一对多`)"

msgid "``pgr_bdAstar`` (`Many to One`)"
msgstr "``pgr_bdAstar`` (`多对一`)"

msgid ""
"``pgr_bdAstar`` (`One to One`) does not have ``start_vid`` and ``end_vid``."
msgstr "``pgr_bdAstar`` (`一对一`)没有 ``start_vid`` 和 ``end_vid``。"

msgid "``pgr_bdAstar`` (`One to Many`) does not have ``start_vid``."
msgstr "``pgr_bdAstar`` (`一对多`) 没有 ``start_vid``。"

msgid "``pgr_bdAstar`` (`Many to One`) does not have ``end_vid``."
msgstr "``pgr_bdAstar`` (`多对一`) 没有 ``end_vid``。"

msgid "In ``pgr_bdAstar`` (`One to One`)"
msgstr "在``pgr_bdAstar`` (`一对一`)中"

msgid "In ``pgr_bdAstar`` (`One to Many`)"
msgstr "在``pgr_bdAstar`` (`一对多`)中"

msgid "In ``pgr_bdAstar`` (`Many to One`)"
msgstr "在``pgr_bdAstar`` (`多对一`)中"

msgid "Migration of ``pgr_dijkstra``"
msgstr "迁移``pgr_dijkstra``"

msgid ""
"Starting from `v3.5.0 <https://docs.pgrouting.org/3.5/en/migration.html>`__"
msgstr ""
"从`v3.5.0 <https://docs.pgrouting.org/3.5/en/migration.html>`__版本开始"

msgid "``pgr_dijkstra`` (`One to One`)"
msgstr "``pgr_dijkstra`` (`一对一`)"

msgid "``pgr_dijkstra`` (`One to Many`)"
msgstr "``pgr_dijkstra`` (`一对多`)"

msgid "``pgr_dijkstra`` (`Many to One`)"
msgstr "``pgr_dijkstra`` (`多对一`)"

msgid ""
"``pgr_dijkstra`` (`One to One`) does not have ``start_vid`` and ``end_vid``."
msgstr "``pgr_dijkstra`` (`一对一`)没有``start_vid`` 和 ``end_vid``。"

msgid "``pgr_dijkstra`` (`One to Many`) does not have ``start_vid``."
msgstr "``pgr_dijkstra`` (`一对多`) 没有 ``start_vid``。"

msgid "``pgr_dijkstra`` (`Many to One`) does not have ``end_vid``."
msgstr "``pgr_dijkstra`` (`多对一`) 没有``end_vid``。"

msgid "In ``pgr_dijkstra`` (`One to One`)"
msgstr "在``pgr_dijkstra`` (`一对一`)中"

msgid "In ``pgr_dijkstra`` (`One to Many`)"
msgstr "在``pgr_dijkstra`` (`一对多`)中"

msgid "In ``pgr_dijkstra`` (`Many to One`)"
msgstr "在``pgr_dijkstra`` (`多对一`)中"

msgid "If needed add the new columns, for example:"
msgstr "如果需要，过滤掉添加的列，例如："

msgid "Migration of ``pgr_drivingdistance``"
msgstr "迁移``pgr_drivingdistance``"

msgid ""
"Starting from `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__ :"
"doc:`pgr_drivingDistance` result columns are being standarized."
msgstr ""
"从 `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__开始， :doc:"
"`pgr_drivingDistance`结果列正在标准化。"

msgid "from"
msgstr "从"

msgid "|result-dij-dd|"
msgstr "|result-dij-dd|"

msgid "to"
msgstr "到"

msgid "|result-spantree|"
msgstr "|result-spantree|"

msgid "``pgr_drivingdistance`` (Single vertex)"
msgstr "``pgr_drivingdistance`` (单个顶点)"

msgid "``pgr_drivingdistance`` (Multiple vertices)"
msgstr "``pgr_drivingdistance`` (多个顶点)"

msgid "Output columns were |result-dij-dd|"
msgstr "输出列是 |result-dij-dd|"

msgid "Does not have ``start_vid`` and ``depth`` result columns."
msgstr "没有``start_vid``和 ``depth``结果列。"

msgid "Has ``from_v`` instead of ``start_vid`` result column."
msgstr "有 ``from_v`` 而不是 ``start_vid``结果列。"

msgid "does not have ``depth`` result column."
msgstr "没有``depth``结果列。"

msgid "Be aware of the existance and name change of the result columns."
msgstr "请注意结果列的存在和名称更改。"

msgid ""
"Using `this <https://docs.pgrouting.org/3.5/en/pgr_drivingDistance."
"html#single-vertex>`__ example."
msgstr ""
"使用`这个 <https://docs.pgrouting.org/3.5/en/pgr_drivingDistance.html#single-"
"vertex>`__示例。"

msgid "``depth`` contains the depth of the ``node``."
msgstr "``depth``包含``node``的深度。"

msgid "``pred`` contains the predecessor of the ``node``."
msgstr "``pred`` 包含``node``的前驱。"

msgid ""
"If needed filter out the added columns, for example, to return the original "
"columns"
msgstr "如果需要，过滤掉添加的列，例如返回原始列"

msgid ""
"Using `this <https://docs.pgrouting.org/3.5/en/pgr_drivingDistance."
"html#multiple-vertices>`__ example."
msgstr ""
"使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_drivingDistance."
"html#multiple-vertices>`__ 示例。"

msgid "The ``from_v`` result column name changes to ``start_vid``."
msgstr "``from_v`结果列名称更改为 ``start_vid``。"

msgid ""
"If needed filter out and rename colums, for example, to return the original "
"columns:"
msgstr "如果需要，过滤掉并重命名列，例如，返回原始列："

msgid "Migration of ``pgr_KSP``"
msgstr "迁移``pgr_KSP``"

msgid ""
"Starting from `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__ :"
"doc:`pgr_KSP` result columns are being standarized."
msgstr ""
"从 `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__ 开始， :doc:"
"`pgr_KSP`结果列正在标准化。"

msgid "|ksp-result|"
msgstr "|ksp-result|"

msgid "|nksp-result|"
msgstr "|nksp-result|"

msgid "``pgr_KSP`` (One to One)"
msgstr "``pgr_KSP`` (一对一)"

msgid "Output columns were |ksp-result|"
msgstr "输出列是 |ksp-result|"

msgid "the columns ``start_vid`` and ``end_vid`` do not exist."
msgstr "``start_vid``和 ``end_vid``列不存在。"

msgid "``pgr_KSP`` (One to One) does not have ``start_vid`` and ``end_vid``."
msgstr "``pgr_KSP`` (一对一) 没有 ``start_vid`` 和``end_vid``。"

msgid ""
"Using `this <https://docs.pgrouting.org/3.5/en/pgr_KSP.html#signatures>`__ "
"example."
msgstr ""
"使用`这个<https://docs.pgrouting.org/3.5/en/pgr_KSP.html#signatures>`__示例。"

msgid ""
"If needed filter out the added columns, for example, to return the original "
"columns:"
msgstr "如果需要，过滤掉添加的列，例如，返回原始列："

msgid "Migration of ``pgr_maxCardinalityMatch``"
msgstr "迁移 ``pgr_maxCardinalityMatch``"

msgid ""
":doc:`pgr_maxCardinalityMatch` works only for undirected graphs, therefore "
"the ``directed`` flag has been removed."
msgstr ""
":doc:`pgr_maxCardinalityMatch` 仅适用于无向图，因此``有向``标志已被删除。"

msgid ""
"Starting from `v3.4.0 <https://docs.pgrouting.org/3.4/en/migration.html>`__"
msgstr "从`v3.4.0 <https://docs.pgrouting.org/3.4/en/migration.html>`__开始"

msgid "Signature to be migrated:"
msgstr "待迁移签名："

msgid "Migration is needed, because:"
msgstr "需要迁移，因为："

msgid "Use ``cost`` and ``reverse_cost`` on the inner query"
msgstr "在内部查询上使用``cost``和 ``reverse_cost``"

msgid "Results are ordered"
msgstr "结果已排序"

msgid "Works for undirected graphs."
msgstr "适用于无向图。"

msgid "New signature"
msgstr "新签名"

msgid "``pgr_maxCardinalityMatch(text)`` returns only ``edge`` column."
msgstr "``pgr_maxCardinalityMatch(text)`` 仅仅返回``边``列."

msgid "The optional flag ``directed`` is removed."
msgstr "可选的 ``directed``标志被删除。"

msgid "Before migration"
msgstr "迁移前"

msgid ""
"Columns used are ``going`` and ``coming`` to represent the existence of an "
"edge."
msgstr "所使用的列是 ``going`` 和 ``coming``，用于表示边的存在。"

msgid ""
"Flag ``directed`` was used to indicate if it was for a **directed** or "
"**undirected** graph."
msgstr "``directed``标志用于指示是**有向**图还是 **无向**图。"

msgid "The flag ``directed`` is ignored."
msgstr "``directed``标志被忽略。"

msgid ""
"Regardless of it's value it gives the result considering the graph as "
"**undirected**."
msgstr "无论它的值如何，它都会给出将图视为**无向**的结果。"

msgid ""
"Use the columns ``cost`` and ``reverse_cost`` to represent the existence of "
"an edge."
msgstr "使用 ``cost``和 ``reverse_cost``列来表示边的存在。"

msgid "Do not use the flag ``directed``."
msgstr "不要使用``directed``标志。"

msgid "In the query returns only ``edge`` column."
msgstr "查询中仅返回``边``列。"

msgid "Migration of ``pgr_withPointsDD``"
msgstr "迁移``pgr_withPointsDD``"

msgid ""
"Starting from `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__ :"
"doc:`pgr_withPointsDD` result columns are being standarized."
msgstr ""
"从`v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__开始 :doc:"
"`pgr_withPointsDD`结果列正在标准化。"

msgid "|result-generic-no-seq|"
msgstr "|result-generic-no-seq|"

msgid ""
"And ``driving_side`` parameter changed from named optional to unnamed "
"compulsory **driving side** and its validity differ for directed and "
"undirected graphs."
msgstr ""
"并且 ``driving_side`` 参数从命名可选变为未命名强制**driving side**，其有效性"
"对于有向图和无向图是不同的。"

msgid "``pgr_withPointsDD`` (Single vertex)"
msgstr "``pgr_withPointsDD`` (单个顶点)"

msgid "``pgr_withPointsDD`` (Multiple vertices)"
msgstr "``pgr_withPointsDD`` (多个顶点)"

msgid "Output columns were |result-1-1-no-seq|"
msgstr "输出列为|result-1-1-no-seq|"

msgid "Does not have ``start_vid``, ``pred`` and ``depth`` result columns."
msgstr "没有``start_vid``，``pred``和``depth``结果列。"

msgid ""
"``driving_side`` parameter was named optional now it is compulsory unamed."
msgstr "``driving_side`` 参数被命名为可选，现在强制未命名。"

msgid "``pgr_withPointsDD`` (`Multiple vertices`)"
msgstr "``pgr_withPointsDD`` (`多个顶点`)"

msgid "Output columns were |result-m-1-no-seq|"
msgstr "输出列为|result-m-1-no-seq|"

msgid "Does not have ``depth`` and ``pred`` result columns."
msgstr "没有 ``depth``和``pred``结果列。"

msgid "Driving side was optional"
msgstr "驾驶侧是可选的"

msgid "The default values on this query are:"
msgstr "此查询的默认值为："

msgid "directed"
msgstr "directed"

msgid "true"
msgstr "true"

msgid "driving_side"
msgstr "driving_side"

msgid "'b'"
msgstr "'b'"

msgid "details"
msgstr "details"

msgid "false"
msgstr "false"

msgid "Driving side was named optional"
msgstr "驾驶侧被命名为可选"

msgid "On directed graph ``b`` could be used as **driving side**"
msgstr "在有向图上 ``b``可以用作 **行驶方向**"

msgid "On undirected graph ``r`` could be used as **driving side**"
msgstr "在无向图上``r``可以用作**行驶方向**"

msgid "Also ``l`` could be used as  **driving side**"
msgstr "``l`` 也可用作**行驶方向**"

msgid "After Migration"
msgstr "迁移后"

msgid "Be aware of the existance of the additional return columns."
msgstr "请注意附加返回列的存在。"

msgid "New output columns are |result-spantree|"
msgstr "新的输出列是 |result-spantree|"

msgid ""
"**driving side** parameter is unnamed compulsory, and valid values differ "
"for directed and undirected graphs."
msgstr "**driving side**参数是未命名的强制参数，有向图和无向图的有效值不同。"

msgid "Does not have a default value."
msgstr "没有默认值。"

msgid "In directed graph: valid values are [``r``, ``R``, ``l``, ``L``]"
msgstr "在有向图中：有效值为 [``r``, ``R``, ``l``, ``L``]"

msgid "In undirected graph: valid values are [``b``, ``B``]"
msgstr "在无向图中：有效值为 [``b``, ``B``]"

msgid "Using an invalid value throws an ``ERROR``."
msgstr "使用无效值会引发 ``ERROR``。"

msgid ""
"Using `this <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-"
"vertex>`__ example."
msgstr ""
"使用`这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-"
"vertex>`__ 示例。"

msgid ""
"``depth`` contains the **depth** from the ``start_vid`` vertex to the "
"``node``."
msgstr "``depth``包含从``start_vid``顶点到``node``的 **深度**。"

msgid ""
"To migrate, use an unnamed valid value for **driving side** after the "
"**distance** parameter:"
msgstr ""
"要进行迁移，请在 **distance**参数之后使用一个未命名的有效值作为 **行驶方向"
"**："

msgid "To get results from previous versions:"
msgstr "要获取以前版本的结果："

msgid "filter out the additional columns, for example;"
msgstr "过滤掉额外的列，例如；"

msgid ""
"When ``details => false`` to remove the points use ``WHERE node >= 0 OR cost "
"= 0``"
msgstr ""
"当设置``details => false`` 以移除点时，请使用 ``WHERE node >= 0 OR cost = 0``"

msgid ""
"Using `this <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD."
"html#multiple-vertices>`__ example."
msgstr ""
"使用`这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#multiple-"
"vertices>`__ 示例。"

msgid "Filter out the additional columns"
msgstr "过滤掉额外的列"

msgid "Migration of ``pgr_withPointsKSP``"
msgstr "迁移``pgr_withPointsKSP``"

msgid ""
"Starting from `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__ :"
"doc:`pgr_withPointsKSP` result columns are being standarized."
msgstr ""
"从`v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__ 开始 ，:doc:"
"`pgr_withPointsKSP`结果列正在标准化。"

msgid ""
"And ``driving side`` parameter changed from named optional to unnamed "
"compulsory **driving side** and its validity differ for directed and "
"undirected graphs."
msgstr ""
"而且 `driving side` 参数从命名的可选参数变为未命名的必选参数 **行驶方向**，其"
"有效性对于有向图和无向图有所不同。"

msgid "``pgr_withPointsKSP`` (`One to One`)"
msgstr "``pgr_withPointsKSP`` (`一对一`)"

msgid "Output columns were |old-pid-result|"
msgstr "输出列是 |old-pid-result|"

msgid "New output columns are |nksp-result|"
msgstr "新的输出列是 |nksp-result|"

msgid ""
"Using `this <https://docs.pgrouting.org/3.5/en/pgr_withPointsKSP."
"html#signatures>`__ example."
msgstr ""
"使用 `这个 <https://docs.pgrouting.org/3.5/en/pgr_withPointsKSP."
"html#signatures>`__示例。"

msgid ""
"If needed filter out the additional columns, for example, to return the "
"original columns:"
msgstr "如果需要，过滤掉附加列，例如，返回原始列："

msgid "Migration of turn restrictions"
msgstr "转弯限制的迁移"

msgid "Migration of restrictions"
msgstr "限制迁移"

msgid "The structure of the restrictions have changed:"
msgstr "限制的结构发生了变化："

msgid "Old restrictions structure"
msgstr "旧的限制结构"

msgid "On the deprecated signatures:"
msgstr "关于已弃用的签名："

msgid "Column ``rid`` is ignored"
msgstr "列 ``rid``被忽略"

msgid "``via_path``"
msgstr "``via_path``"

msgid "Must be in reverse order."
msgstr "必须是相反的顺序。"

msgid "Is of type ``TEXT``."
msgstr "属于 ``TEXT``类型。"

msgid "When more than one via edge must be separated with ``,``."
msgstr "当多个过孔边必须用``,``分隔时。"

msgid "``target_id``"
msgstr "``target_id``"

msgid "Is the last edge of the forbidden path."
msgstr "是禁止路径的最后一条边。"

msgid "Is of type ``INTEGER``."
msgstr "类型为 ``INTEGER``。"

msgid "``to_cost``"
msgstr "``to_cost``"

msgid "Is of type ``FLOAT``."
msgstr "类型为``FLOAT``。"

msgid "Creation of the old restrictions table"
msgstr "创建旧限制表"

msgid "Old restrictions fill up"
msgstr "旧限制已满"

msgid "Old restrictions contents"
msgstr "旧限制内容"

msgid ""
"The restriction with ``rid = 2`` is representing :math:`3 \\rightarrow 5 "
"\\rightarrow9`"
msgstr "``rid = 2``的限制表示的是路径 :math:`3 \\rightarrow 5 \\rightarrow9`"

msgid ":math:`3\\rightarrow5`"
msgstr ":math:`3\\rightarrow5`"

msgid "is on column ``via_path`` in reverse order"
msgstr "以相反的顺序位于 ``via_path`` 列上"

msgid "is of type ``TEXT``"
msgstr "类型为``TEXT``"

msgid ":math:`9`"
msgstr ":math:`9`"

msgid "is on column ``target_id``"
msgstr "位于``target_id`` 列上"

msgid "is of type ``INTEGER``"
msgstr "类型为``INTEGER``"

msgid "New restrictions structure"
msgstr "新的限制结构"

msgid "Column ``id`` is ignored"
msgstr "列 ``id``被忽略"

msgid "Column ``path``"
msgstr "列 ``path``"

msgid "Is of type ``ARRAY[ANY-INTEGER]``."
msgstr "类型为 ``ARRAY[ANY-INTEGER]``。"

msgid "Contains all the edges involved on the restriction."
msgstr "包含限制所涉及的所有边。"

msgid "The array has the ordered edges of the restriction."
msgstr "该数组具有限制的有序边。"

msgid "Column ``cost``"
msgstr "列 ``cost``"

msgid "Is of type ``ANY-NUMERICAL``"
msgstr "类型为 ``ANY-NUMERICAL``"

msgid "The creation of the restrictions table"
msgstr "限制表的创建"

msgid "Adding the restrictions"
msgstr "添加限制"

msgid "Restrictions data"
msgstr "限制数据"

msgid ""
"The restriction with ``rid = 2`` represents the path :math:`3 \\rightarrow5 "
"\\rightarrow9`."
msgstr "``rid = 2`` 的限制表示的是路径 :math:`3 \\rightarrow5 \\rightarrow9`。"

msgid "By inspection the path is clear."
msgstr "通过检查，路径是清晰的。"

msgid ""
"To transform the old restrictions table to the new restrictions structure,"
msgstr "要将旧的限制表转换为新的限制结构，"

msgid "Create a new table with the new restrictions structure."
msgstr "使用新的限制结构创建一个新表。"

msgid "In this migration guide ``new_restrictions`` is been used."
msgstr "在此迁移指南中使用了 ``new_restrictions``。"

msgid ""
"For this migration pgRouting supplies an auxiliary function for reversal of "
"an array ``_pgr_array_reverse`` needed for the migration."
msgstr ""
"为了进行这次迁移，pgRouting 提供了一个用于反转数组的辅助函数 "
"``_pgr_array_reverse``，这在迁移过程中是必需的。"

msgid "``_pgr_array_reverse``:"
msgstr "``_pgr_array_reverse``:"

msgid "Was created temporally for this migration"
msgstr "是为此迁移临时创建的"

msgid "Is not documented."
msgstr "没有记录。"

msgid "Will be removed on the next mayor version 4.0.0"
msgstr "将在下一个正式版本 4.0.0 中删除"

msgid "The migrated table contents:"
msgstr "迁移后的表内容："

msgid "Migration of ``pgr_trsp`` (Vertices)"
msgstr "迁移``pgr_trsp``（顶点）"

msgid ""
":doc:`pgr_trsp` signatures have changed and many issues have been fixed in "
"the new signatures. This section will show how to migrate from the old "
"signatures to the new replacement functions. This also affects the "
"restrictions."
msgstr ""
":doc:`pgr_trsp` 的签名已更改，并且新签名中已修复许多问题。 本节将展示如何从旧"
"签名迁移到新的替换函数。 这也会影响限制。"

msgid "The integral type of the ``Edges SQL`` can only be ``INTEGER``."
msgstr "``Edges SQL`` 的整数类型只能是 ``INTEGER``。"

msgid "The floating point type of the ``Edges SQL`` can only be ``FLOAT``."
msgstr "``Edges SQL`` 的浮点类型只能是 ``FLOAT``。"

msgid "``directed`` flag is compulsory."
msgstr "``directed``标志是强制性的。"

msgid "Does not autodetect if ``reverse_cost`` column exist."
msgstr "不自动检测 ``reverse_cost``列是否存在。"

msgid ""
"User must be careful to match the existence of the column with the value of "
"``has_rcost`` parameter."
msgstr "用户必须小心地将列的存在与``has_rcost`` 参数的值相匹配。"

msgid "The restrictions inner query is optional."
msgstr "内部查询的限制是可选的。"

msgid "The output column names are meaningless"
msgstr "输出列名没有意义"

msgid "Migrate by using:"
msgstr "使用以下方式迁移："

msgid ":doc:`pgr_dijkstra` when there are no restrictions,"
msgstr ":doc:`pgr_dijkstra`当没有限制时，"

msgid ":doc:`pgr_trsp` (One to One) when there are restrictions."
msgstr ":doc:`pgr_trsp` (一对一)当有限制时。"

msgid "Migrating ``pgr_trsp`` (Vertices) using ``pgr_dijkstra``"
msgstr "使用 ``pgr_dijkstra`` 迁移 ``pgr_trsp``（顶点）"

msgid "The following query does not have restrictions."
msgstr "以下查询没有限制。"

msgid "A message about deprecation is shown"
msgstr "显示有关弃用的消息"

msgid "Deprecated functions will be removed on the next mayor version 4.0.0"
msgstr "已弃用的功能将在下一个正式版本 4.0.0 中删除"

msgid "Use :doc:`pgr_dijkstra` instead."
msgstr "请改用 :doc:`pgr_dijkstra`。"

msgid "The types casting has been removed."
msgstr "类型强制转换已被删除。"

msgid ":doc:`pgr_dijkstra`:"
msgstr ":doc:`pgr_dijkstra`:"

msgid "Autodetects if ``reverse_cost`` column is in the edges SQL."
msgstr "自动检测``reverse_cost``列是否在边SQL中。"

msgid "Accepts ``ANY-INTEGER`` on integral types"
msgstr "接受整数类型``ANY-INTEGER``"

msgid "Accepts ``ANY-NUMERICAL`` on floating point types"
msgstr "接受浮点类型``ANY-NUMERICAL``"

msgid "``directed`` flag has a default value of ``true``."
msgstr "``directed`` 标志的默认值为``true``。"

msgid "Use the same value that on the original query."
msgstr "使用与原始查询相同的值。"

msgid "In this example it is ``true`` which is the default value."
msgstr "在此示例中，默认值为``true``。"

msgid "The flag has been omitted and the default is been used."
msgstr "该标志已被省略，并使用默认值。"

msgid ""
"When the need of using strictly the same (meaningless) names and types of "
"the function been migrated then:"
msgstr "当需要使用严格相同（无意义）的函数名称和类型进行迁移时："

msgid "``id1`` is the node"
msgstr "``id1``是节点"

msgid "``id2`` is the edge"
msgstr "``id2``是边"

msgid "Migrating ``pgr_trsp`` (Vertices) using ``pgr_trsp``"
msgstr "使用``pgr_trsp``迁移 ``pgr_trsp``（顶点）"

msgid "The following query has restrictions."
msgstr "以下查询有限制。"

msgid "The restrictions are the last parameter of the function"
msgstr "限制是函数的最后一个参数"

msgid "Using the old structure of restrictions"
msgstr "使用旧的限制结构"

msgid "Use :doc:`pgr_trsp` (One to One) instead."
msgstr "请改用:doc:`pgr_trsp` (一对一）。"

msgid "The new structure of restrictions is been used."
msgstr "使用了新的限制结构。"

msgid "It is the second parameter."
msgstr "这是第二个参数。"

msgid ":doc:`pgr_trsp`:"
msgstr ":doc:`pgr_trsp`:"

msgid "Migration of ``pgr_trsp`` (Edges)"
msgstr "迁移``pgr_trsp``（边）"

msgid "The integral types of the ``sql`` can only be ``INTEGER``."
msgstr "``sql``的整型类型只能是``INTEGER``。"

msgid "The floating point type of the ``sql`` can only be ``FLOAT``."
msgstr "``sql``的浮点类型只能是``FLOAT``。"

msgid "For these migration guide the following points will be used:"
msgstr "对于这些迁移指南，将使用以下几点："

msgid ":doc:`pgr_withPoints` when there are no restrictions,"
msgstr ":doc:`pgr_withPoints`当没有任何限制的时候，"

msgid ":doc:`pgr_trsp_withPoints` (One to One) when there are restrictions."
msgstr ":doc:`pgr_trsp_withPoints` (一对一) 当有限制时。"

msgid "Migrating ``pgr_trsp`` (Edges) using ``pgr_withPoints``"
msgstr "使用 ``pgr_withPoints``迁移 ``pgr_trsp``（边）"

msgid "Use :doc:`pgr_withPoints` instead."
msgstr "请使用 :doc:`pgr_withPoints`。"

msgid "Do not show details, as the deprecated function does not show details."
msgstr "不显示详细信息，因为已弃用的函数不显示详细信息。"

msgid ":doc:`pgr_withPoints`:"
msgstr ":doc:`pgr_withPoints`:"

msgid "On the points query do not include the ``side`` column."
msgstr "在点查询中不包括 ``side``列。"

msgid ""
"When the need of using strictly the same (meaningless) names and types, and "
"node values of the function been migrated then:"
msgstr "当需要使用严格相同（无意义）的名称和类型，并且函数的节点值被迁移时："

msgid "Migrating ``pgr_trsp`` (Edges) using ``pgr_trsp_withPoints``"
msgstr "使用 ``pgr_trsp_withPoints`` 迁移 ``pgr_trsp`` （边）"

msgid "Use :doc:`pgr_trsp_withPoints` instead."
msgstr "请使用 :doc:`pgr_trsp_withPoints`。"

msgid ":doc:`pgr_trsp_withPoints`:"
msgstr ":doc:`pgr_trsp_withPoints`:"

msgid "Migration of ``pgr_trspViaVertices``"
msgstr "迁移``pgr_trspViaVertices``"

msgid "The integral types of the ``Edges SQL`` can only be ``INTEGER``."
msgstr "``Edges SQL``的整数类型只能是 ``INTEGER``。"

msgid ":doc:`pgr_dijkstraVia` when there are no restrictions,"
msgstr ":doc:`pgr_dijkstraVia`当无限制时，"

msgid ":doc:`pgr_trspVia` when there are restrictions."
msgstr ":doc:`pgr_trspVia`当有限制时。"

msgid "Migrating ``pgr_trspViaVertices`` using ``pgr_dijkstraVia``"
msgstr "使用 ``pgr_dijkstraVia``迁移 ``pgr_trspViaVertices``"

msgid "Use :doc:`pgr_dijkstraVia` instead."
msgstr "请使用:doc:`pgr_dijkstraVia`。"

msgid ":doc:`pgr_dijkstraVia`:"
msgstr ":doc:`pgr_dijkstraVia`:"

msgid "``id1`` is the path identifier"
msgstr "``id1``是路径标识符"

msgid "``id2`` is the node"
msgstr "``id2``是节点"

msgid "``id3`` is the edge"
msgstr "``id3``是边"

msgid "Migrating ``pgr_trspViaVertices`` using ``pgr_trspVia``"
msgstr "使用``pgr_trspVia``迁移 ``pgr_trspViaVertices``"

msgid "Use :doc:`pgr_trspVia` instead."
msgstr "使用 :doc:`pgr_trspVia`。"

msgid ":doc:`pgr_trspVia`:"
msgstr ":doc:`pgr_trspVia`:"

msgid "Migration of ``pgr_trspViaEdges``"
msgstr "迁移``pgr_trspViaEdges``"

msgid ""
"And will travel thru the following Via points :math:"
"`4\\rightarrow3\\rightarrow6`"
msgstr "并将途经以下途经点： :math:`4\\rightarrow3\\rightarrow6`"

msgid ":doc:`pgr_withPointsVia` when there are no restrictions,"
msgstr ":doc:`pgr_withPointsVia`当没有限制时，"

msgid ":doc:`pgr_trspVia_withPoints` when there are restrictions."
msgstr ":doc:`pgr_trspVia_withPoints`当有限制时。"

msgid "Migrating ``pgr_trspViaEdges`` using ``pgr_withPointsVia``"
msgstr "使用``pgr_withPointsVia``迁移``pgr_trspViaEdges``"

msgid "Use :doc:`pgr_withPointsVia` instead."
msgstr "请使用 :doc:`pgr_withPointsVia`。"

msgid ":doc:`pgr_withPointsVia`:"
msgstr ":doc:`pgr_withPointsVia`:"

msgid "Migrating ``pgr_trspViaEdges`` using ``pgr_trspVia_withPoints``"
msgstr "使用``pgr_trspVia_withPoints``迁移``pgr_trspViaEdges``"

msgid "Use :doc:`pgr_trspVia_withPoints` instead."
msgstr "使用 :doc:`pgr_trspVia_withPoints`代替。"

msgid ":doc:`pgr_trspVia_withPoints`:"
msgstr ":doc:`pgr_trspVia_withPoints`:"

msgid ":doc:`withPoints-category`"
msgstr ":doc:`withPoints-category`"

msgid "Ordering - Family of functions"
msgstr "排序 - 函数族"

msgid "pgRouting Concepts"
msgstr "pgRouting 基本概念"

msgid ""
"This is a simple guide that go through some of the steps for getting started "
"with pgRouting. This guide covers:"
msgstr "这是一个简单的指南，介绍了 pgRouting 入门的一些步骤。 本指南涵盖："

msgid "Graphs"
msgstr "图"

msgid "A graph is an ordered pair :math:`G = (V ,E)` where:"
msgstr "图是一个有序对 :math:`G = (V ,E)` ，其中："

msgid ":math:`V` is a set of vertices, also called nodes."
msgstr ":math:`V`是一组顶点，也称为节点。"

msgid ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V \\}`"
msgstr ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V \\}`"

msgid "There are different kinds of graphs:"
msgstr "有不同类型的图："

msgid ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V\\}`"
msgstr ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V\\}`"

msgid "Undirected simple graph"
msgstr "无向简单图"

msgid ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V, u \\neq v\\}`"
msgstr ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V, u \\neq v\\}`"

msgid ":math:`E \\subseteq \\{( u, v ) \\mid (u , v) \\in (V X V) \\}`"
msgstr ":math:`E \\subseteq \\{( u, v ) \\mid (u , v) \\in (V X V) \\}`"

msgid "Directed simple graph"
msgstr "有向简单图"

msgid ""
":math:`E \\subseteq \\{( u, v ) \\mid (u , v) \\in (V X V), u \\neq v\\}`"
msgstr ""
":math:`E \\subseteq \\{( u, v ) \\mid (u , v) \\in (V X V), u \\neq v\\}`"

msgid "Graphs:"
msgstr "图："

msgid "Do not have geometries."
msgstr "没有几何图形。"

msgid ""
"Some graph theory problems require graphs to have weights, called **cost** "
"in pgRouting."
msgstr "一些图论问题需要图具有权重，在 pgRouting 中称为**成本**。"

msgid ""
"In pgRouting there are several ways to represent a graph on the database:"
msgstr "在 pgRouting 中，有多种方法来表示数据库上的图："

msgid "With ``cost``"
msgstr "使用``cost``"

msgid "(``id``, ``source``, ``target``, ``cost``)"
msgstr "(``id``, ``source``, ``target``, ``cost``)"

msgid "With ``cost`` and ``reverse_cost``"
msgstr "使用 ``cost`` 和 ``reverse_cost``"

msgid "(``id``, ``source``, ``target``, ``cost``, ``reverse_cost``)"
msgstr "(``id``, ``source``, ``target``, ``cost``, ``reverse_cost``)"

msgid ""
"Identifier of the edge. Requirement to use the database in a consistent. "
"manner."
msgstr "边的标识符。要求在数据库中以一致的方式使用。"

msgid "Identifier of a vertex."
msgstr "顶点的标识符。"

msgid "Weight of the edge (``source``, ``target``):"
msgstr "边 (``source``, ``target``)的权重："

msgid ""
"When negative the edge (``source``, ``target``) do not exist on the graph."
msgstr "当为负时，图上不存在边(``source``, ``target``)。"

msgid "``cost`` must exist in the query."
msgstr "查询中必须存在``cost``。"

msgid ""
"When negative the edge (``target``, ``source``) do not exist on the graph."
msgstr "当为负时，图上不存在边(``target``, ``source``)。"

msgid ""
"The decision of the graph to be **directed** or **undirected** is done when "
"executing a pgRouting algorithm."
msgstr "图是**有向**图还是**无向**图的决定是在执行 pgRouting 算法时完成的。"

msgid "Graph with ``cost``"
msgstr "``成本``图"

msgid "The weighted directed graph, :math:`G_d(V,E)`:"
msgstr "加权有向图， :math:`G_d(V,E)`:"

msgid "Graph data is obtained with a query"
msgstr "通过查询获取图数据"

msgid "``SELECT id, source, target, cost FROM edges``"
msgstr "``SELECT id, source, target, cost FROM edges``"

msgid ""
":math:`E = \\{(source_{id}, target_{id}, cost_{id}) \\text{ when } cost_{id} "
"\\ge 0 \\}`"
msgstr ""
":math:`E = \\{(source_{id}, target_{id}, cost_{id}) \\text{ when } cost_{id} "
"\\ge 0 \\}`"

msgid "Edges where ``cost`` is non negative are part of the graph."
msgstr "成本非负的边是图的一部分。"

msgid ":math:`V = \\{source_{id} \\cup target_{id}\\}`"
msgstr ":math:`V = \\{source_{id} \\cup target_{id}\\}`"

msgid "All vertices in ``source`` and ``target`` are part of the graph."
msgstr "``source`` 和``target``中的所有顶点都是图的一部分。"

msgid ""
"In a directed graph the edge :math:`(source_{id}, target_{id}, cost_{id})` "
"has directionality: :math:`source_{id} \\rightarrow target_{id}`"
msgstr ""
"在有向图中，边 :math:`(source_{id}, target_{id}, cost_{id})` 具有方向性：:"
"math:`source_{id} \\rightarrow target_{id}`"

msgid "For the following data:"
msgstr "对于以下数据："

msgid "Edge :math:`2` (:math:`1 \\rightarrow 3`) is not part of the graph."
msgstr "边 :math:`2` (:math:`1 \\rightarrow 3`) 不是图的一部分。"

msgid "The data is representing the following graph:"
msgstr "数据代表下图："

msgid ""
"In an undirected graph the edge :math:`(source_{id}, target_{id}, "
"cost_{id})` does not have directionality: :math:`source_{id} \\frac{\\;\\;\\;"
"\\;\\;}{} target_{id}`"
msgstr ""
"在无向图中，边 :math:`(source_{id}, target_{id}, cost_{id})` 没有方向性：:"
"math:`source_{id} \\frac{\\;\\;\\;\\;\\;}{} target_{id}`"

msgid ""
"In terms of a directed graph is like having two edges: :math:`source_{id} "
"\\leftrightarrow target_{id}`"
msgstr ""
"在有向图的术语中，这相当于有两条边：:math:`source_{id} \\leftrightarrow "
"target_{id}`"

msgid ""
"Edge :math:`2` (:math:`1  \\frac{\\;\\;\\;\\;\\;}{} 3`) is not part of the "
"graph."
msgstr "边 :math:`2` (:math:`1  \\frac{\\;\\;\\;\\;\\;}{} 3`) 不是图的一部分。"

msgid "Graph with ``cost`` and ``reverse_cost``"
msgstr "带有 ``cost``和``reverse_cost``的图"

msgid "The weighted directed graph, :math:`G_d(V,E)`, is defined by:"
msgstr "加权有向图， :math:`G_d(V,E)`， 定义如下："

msgid "``SELECT id, source, target, cost, reverse_cost FROM edges``"
msgstr "``SELECT id, source, target, cost, reverse_cost FROM edges``"

msgid "The set of edges :math:`E`:"
msgstr "边的集合 :math:`E`："

msgid ""
":math:`E = \\begin{split} \\begin{align} & {\\{(source_{id}, target_{id}, "
"cost_{id}) \\text{ when } cost_{id} >=0 \\}} \\\\ & \\cup \\\\ & "
"{\\{(target_{id}, source_{id}, reverse\\_cost_{id}) \\text{ when } reverse"
"\\_cost_{id} >=0 \\}} \\end{align} \\end{split}`"
msgstr ""
":math:`E = \\begin{split} \\begin{align} & {\\{(source_{id}, target_{id}, "
"cost_{id}) \\text{ when } cost_{id} >=0 \\}} \\\\ & \\cup \\\\ & "
"{\\{(target_{id}, source_{id}, reverse\\_cost_{id}) \\text{ when } reverse"
"\\_cost_{id} >=0 \\}} \\end{align} \\end{split}`"

msgid ""
"Edges :math:`(source \\rightarrow target)` where ``cost`` is non negative "
"are part of the graph."
msgstr ""
"边 :math:`(source \\rightarrow target)` 中的 ``cost`` 是非负数的都属于图的一"
"部分。"

msgid ""
"Edges :math:`(target \\rightarrow source)` where ``reverse_cost`` is non "
"negative are part of the graph."
msgstr ""
"边 :math:`(target \\rightarrow source)` 中的 ``reverse_cost`` 是非负数的都属"
"于图的一部分。"

msgid "The set of vertices  :math:`V`:"
msgstr "顶点 :math:`V`的集合："

msgid "In a directed graph both edges have directionality"
msgstr "在有向图中，两条边都有方向性"

msgid ""
"edge :math:`(source_{id}, target_{id}, cost_{id})` has directionality: :math:"
"`source_{id} \\rightarrow target_{id}`"
msgstr ""
"边 :math:`(source_{id}, target_{id}, cost_{id})` 具有方向性：:math:"
"`source_{id} \\rightarrow target_{id}`"

msgid ""
"edge :math:`(target_{id}, source_{id}, reverse\\_cost_{id})` has "
"directionality: :math:`target_{id} \\rightarrow source_{id}`"
msgstr ""
"边 :math:`(target_{id}, source_{id}, reverse\\_cost_{id})` 具有方向性：:math:"
"`target_{id} \\rightarrow source_{id}`"

msgid "Edges not part of the graph:"
msgstr "边不是图的一部分："

msgid ":math:`2` (:math:`1  \\rightarrow 3`)"
msgstr ":math:`2` (:math:`1  \\rightarrow 3`)"

msgid ":math:`3` (:math:`3  \\rightarrow 2`)"
msgstr ":math:`3` (:math:`3  \\rightarrow 2`)"

msgid "In a directed graph both edges do not have directionality"
msgstr "在有向图中，两条边都没有方向性"

msgid ""
"Edge :math:`(source_{id}, target_{id}, cost_{id})` is :math:`source_{id} "
"\\frac{\\;\\;\\;\\;\\;}{} target_{id}`"
msgstr ""
"边 :math:`(source_{id}, target_{id}, cost_{id})` 是 :math:`source_{id} "
"\\frac{\\;\\;\\;\\;\\;}{} target_{id}`"

msgid ""
"Edge :math:`(target_{id}, source_{id}, reverse\\_cost_{id})` is :math:"
"`target_{id} \\frac{\\;\\;\\;\\;\\;}{} source_{id}`"
msgstr ""
"边:math:`(target_{id}, source_{id}, reverse\\_cost_{id})`是 :math:"
"`target_{id} \\frac{\\;\\;\\;\\;\\;}{} source_{id}`"

msgid "In terms of a directed graph is like having four edges:"
msgstr "就有向图而言，就像有四个边："

msgid ":math:`source_i \\leftrightarrow target_i`"
msgstr ":math:`source_i \\leftrightarrow target_i`"

msgid ":math:`target_i \\leftrightarrow source_i`"
msgstr ":math:`target_i \\leftrightarrow source_i`"

msgid ":math:`2` (:math:`1  \\frac{\\;\\;\\;\\;\\;}{} 3`)"
msgstr ":math:`2` (:math:`1  \\frac{\\;\\;\\;\\;\\;}{} 3`)"

msgid ":math:`3` (:math:`3  \\frac{\\;\\;\\;\\;\\;}{} 2`)"
msgstr ":math:`3` (:math:`3  \\frac{\\;\\;\\;\\;\\;}{} 2`)"

msgid "Graphs without geometries"
msgstr "没有几何信息的图"

msgid ""
"Personal relationships, genealogy, file dependency problems can be solved "
"using pgRouting. Those problems, normally,  do not come with geometries "
"associated with the graph."
msgstr ""
"人际关系、家谱、文件依赖问题都可以使用pgRouting来解决。 通常，这些问题不会与"
"与图形相关的几何图形相关。"

msgid "Wiki example"
msgstr "维基示例"

msgid ""
"Solve the example problem taken from `wikipedia <https://en.wikipedia.org/"
"wiki/Dijkstra%27s_algorithm>`__):"
msgstr ""
"解决来自 `维基百科<https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm>`__）"
"的示例问题 ："

msgid "Problem is to find the shortest path from :math:`1` to :math:`5`."
msgstr "问题是找到从 :math:`1`到:math:`5` 的最短路径。"

msgid "Is an undirected graph."
msgstr "是一个无向图。"

msgid ""
"Although visually looks like to have geometries, the drawing is not to scale."
msgstr "虽然视觉上看起来有几何形状，但该图并不是按比例绘制的。"

msgid "No geometries associated to the vertices or edges"
msgstr "没有与顶点或边关联的几何图形"

msgid "Has 6 vertices :math:`\\{1,2,3,4,5,6\\}`"
msgstr "有6个顶点 :math:`\\{1,2,3,4,5,6\\}`"

msgid "Has 9 edges:"
msgstr "有九个边："

msgid ""
":math:`\\begin{split} \\begin{align} E = & \\{(1,2,7), (1,3,9), (1,6,14), \\"
"\\ & (2,3,10), (2,4,13), \\\\ & (3,4,11), (3,6,2), \\\\ & (4,5,6), \\\\ & "
"(5,6,9) \\} \\end{align} \\end{split}`"
msgstr ""
":math:`\\begin{split} \\begin{align} E = & \\{(1,2,7), (1,3,9), (1,6,14), \\"
"\\ & (2,3,10), (2,4,13), \\\\ & (3,4,11), (3,6,2), \\\\ & (4,5,6), \\\\ & "
"(5,6,9) \\} \\end{align} \\end{split}`"

msgid "The graph can be represented in many ways for example:"
msgstr "该图可以用多种方式表示，例如："

msgid "Prepare the database"
msgstr "准备数据库"

msgid ""
"Create a database for the example, access the database and install "
"pgRouting: ::"
msgstr "为示例创建一个数据库，访问数据库并安装 pgRouting：::"

msgid "Create a table"
msgstr "创建表"

msgid ""
"The basic elements needed to perform basic routing on an undirected graph "
"are:"
msgstr "在无向图上执行基本路由所需的基本元素是："

msgid "SMALLINT, INTEGER, BIGINT, REAL, FLOAT"
msgstr "SMALLINT, INTEGER, BIGINT, REAL, FLOAT"

msgid "Using this table design for this example:"
msgstr "本示例使用此表设计："

msgid "Insert the data"
msgstr "插入数据"

msgid "Find the shortest path"
msgstr "寻找最短路径"

msgid "To solve this example :doc:`pgr_dijkstra` is used:"
msgstr "为了解决这个例子，使用了 :doc:`pgr_dijkstra`："

msgid ""
"To go from :math:`1` to :math:`5` the path goes thru the following "
"vertices: :math:`1 \\rightarrow 3 \\rightarrow 6 \\rightarrow 5`"
msgstr ""
"从 :math:`1` 到 :math:`5`的路径要经过以下顶点： :math:`1 \\rightarrow 3 "
"\\rightarrow 6 \\rightarrow 5`"

msgid "Vertex information"
msgstr "顶点信息"

msgid "To obtain the vertices information, use :doc:`pgr_extractVertices`"
msgstr "要获取顶点信息，请使用 :doc:`pgr_extractVertices`"

msgid "Graphs with geometries"
msgstr "具有几何图形的图"

msgid "Create a routing Database"
msgstr "创建路由数据库"

msgid ""
"The first step is to create a database and load pgRouting in the database."
msgstr "第一步是创建数据库并在数据库中加载 pgRouting。"

msgid "Typically create a database for each project."
msgstr "通常为每个项目创建一个数据库。"

msgid ""
"Once having the database to work in, load your data and build the routing "
"application in that database."
msgstr "一旦数据库可以工作，加载数据并在该数据库中构建路由应用程序。"

msgid "Load Data"
msgstr "加载数据"

msgid "There are several ways to load your data into pgRouting."
msgstr "有多种方法可以将数据加载到 pgRouting 中。"

msgid "Manually creating a database."
msgstr "手动创建数据库。"

msgid "`Graphs without geometries`_"
msgstr "`没有几何形状的图`_"

msgid ":doc:`sampledata`: a small graph used on the documentation examples"
msgstr ":doc:`sampledata`: 文档示例中使用的小图"

msgid ""
"Using `osm2pgrouting <https://workshop.pgrouting.org/latest/en/basic/data."
"html>`__"
msgstr ""
"使用 `osm2pgrouting <https://workshop.pgrouting.org/latest/en/basic/data."
"html>`__"

msgid "There are various open source tools that can help, like:"
msgstr "有多种开源工具可以提供帮助，例如："

msgid "shp2pgsql"
msgstr "shp2pgsql"

msgid "postgresql shapefile loader"
msgstr "postgresql shapefile 加载器"

msgid "ogr2ogr"
msgstr "ogr2ogr"

msgid "vector data conversion utility"
msgstr "矢量数据转换实用程序"

msgid "osm2pgsql"
msgstr "osm2pgsql"

msgid "load OSM data into postgresql"
msgstr "将OSM数据加载到postgresql中"

msgid ""
"Please note that these tools will **not** import the data in a structure "
"compatible with pgRouting and when this happens the topology needs to be "
"adjusted."
msgstr ""
"请注意，这些工具**不会**导入与 pgRouting 兼容的结构中的数据，当发生这种情况"
"时，需要调整拓扑。"

msgid "Breakup a segments on each segment-segment intersection"
msgstr "在每个线段-线段交叉点上分解线段"

msgid ""
"When missing, add columns and assign values to ``source``, ``target``, "
"``cost``, ``reverse_cost``."
msgstr ""
"如果缺少，请添加列并为``source``, ``target``, ``cost``, ``reverse_cost``分配"
"值。"

msgid "Connect a disconnected graph."
msgstr "连接断开的图。"

msgid "Create the complete graph topology"
msgstr "创建完整的图拓扑"

msgid "Create one or more graphs based on the application to be developed."
msgstr "根据要开发的应用程序创建一个或多个图。"

msgid "Create a contracted graph for the high speed roads"
msgstr "为高速道路创建收缩图"

msgid "Create graphs per state/country"
msgstr "创建每个州/国家的图"

msgid "In few words:"
msgstr "简而言之："

msgid "Prepare the graph"
msgstr "准备图"

msgid ""
"What and how to prepare the graph, will depend on the application and/or on "
"the quality of the data and/or on how close the information is to have a "
"topology usable by pgRouting and/or some other factors not mentioned."
msgstr ""
"准备什么以及如何准备图将取决于应用程序和/或数据质量和/或信息与 pgRouting 可用"
"的拓扑的接近程度和/或未提及的一些其他因素。"

msgid ""
"The steps to prepare the graph involve geometry operations using `PostGIS "
"<https://postgis.net/>`__ and some others involve graph operations like :doc:"
"`pgr_contraction` to contract a graph."
msgstr ""
"准备图的步骤涉及使用`PostGIS <https://postgis.net/>`__进行几何操作，其他一些"
"步骤涉及诸如:doc:`pgr_contraction` 之类的图操作来收缩图。"

msgid ""
"The `workshop <https://workshop.pgrouting.org/latest>`__ has a step by step "
"on how to prepare a graph using Open Street Map data, for a small "
"application."
msgstr ""
"该 `workshop <https://workshop.pgrouting.org/latest>`__逐步介绍了如何使用开放"
"街道地图数据为小型应用程序准备图。"

msgid "The use of indexes on the database design in general:"
msgstr "数据库设计上索引的使用一般："

msgid "Have the geometries indexed."
msgstr "对几何图形进行索引。"

msgid "Have the identifiers columns indexed."
msgstr "对标识符列建立索引。"

msgid ""
"Please consult the `PostgreSQL <https://www.postgresql.org/docs/>`__ "
"documentation and the `PostGIS <https://postgis.net/>`__ documentation."
msgstr ""
"请查阅`PostgreSQL <https://www.postgresql.org/docs/>`__ 文档和 `PostGIS "
"<https://postgis.net/>`__文档。"

msgid "Build a routing topology"
msgstr "构建路由拓扑"

msgid ""
"The basic information to use the majority of the pgRouting functions ``id, "
"source, target, cost, [reverse_cost]`` is what in pgRouting is called the "
"routing topology."
msgstr ""
"使用大多数 pgRouting 函数的基本信息``id, source, target, cost, "
"[reverse_cost]`` 在 pgRouting 中被称为路由拓扑。"

msgid ""
"``reverse_cost`` is optional but strongly recommended to have in order to "
"reduce the size of the database due to the size of the geometry columns. "
"Having said that, in this documentation ``reverse_cost`` is used in this "
"documentation."
msgstr ""
"``reverse_cost`` 是可选的，但强烈建议使用，以便由于几何列的大小而减小数据库的"
"大小。 话虽如此，在本文档中使用了``reverse_cost`` 。"

msgid ""
"When the data comes with geometries and there is no routing topology, then "
"this step is needed."
msgstr "当数据带有几何图形并且没有路由拓扑时，则需要此步骤。"

msgid ""
"All the start and end vertices of the geometries need an identifier that is "
"to be stored in a ``source`` and ``target`` columns of the table of the "
"data. Likewise, ``cost`` and ``reverse_cost`` need to have the value of "
"traversing the edge in both directions."
msgstr ""
"几何图的所有开始和结束顶点都需要一个标识符，该标识符将存储在数据表的"
"``source``列和``target``列中。 同样，``cost``和 ``reverse_cost``需要具有在两"
"个方向上遍历边的值。"

msgid ""
"If the columns do not exist they need to be added to the table in question. "
"(see `ALTER TABLE <https://www.postgresql.org/docs/current/sql-altertable."
"html>`__)"
msgstr ""
"如果这些列不存在，则需要将它们添加到相关表中。 （参见`ALTER TABLE <https://"
"www.postgresql.org/docs/current/sql-altertable.html>`__）"

msgid ""
"The function :doc:`pgr_extractVertices` is used to create a vertices table "
"based on the edge identifier and the geometry of the edge of the graph."
msgstr ""
"函数 :doc:`pgr_extractVertices` 用于根据边标识符和图边的几何形状创建顶点表。"

msgid ""
"Finally using the data stored on the vertices tables the ``source`` and "
"``target`` are filled up."
msgstr "最后使用存储在顶点表上的数据填充 ``source``和``target`` 。"

msgid "See :doc:`sampledata` for an example for building a topology."
msgstr "有关构建拓扑的示例，请参阅 :doc:`示例数据`。"

msgid ""
"Data coming from OSM and using `osm2pgrouting <https://github.com/pgRouting/"
"osm2pgrouting>`__ as an import tool, comes with the routing topology. See an "
"example of using ``osm2pgrouting`` on the `workshop <https://workshop."
"pgrouting.org/latest/en/basic/data.html>`__."
msgstr ""
"来自 OSM 并使用 `osm2pgrouting <https://github.com/pgRouting/"
"osm2pgrouting>`__ 作为导入工具的数据附带路由拓扑。 请参阅`workshop <https://"
"workshop.pgrouting.org/latest/en/basic/data.html>`__上使用``osm2pgrouting`` "
"的示例。"

msgid "Adjust costs"
msgstr "调整成本"

msgid ""
"For this example the ``cost`` and ``reverse_cost`` values are going to be "
"the double of the length of the geometry."
msgstr "对于本示例，``cost`` 和``reverse_cost``值将是几何体长度的两倍。"

msgid "Update costs to length of geometry"
msgstr "将成本更新为几何形状的长度"

msgid ""
"Suppose that ``cost`` and ``reverse_cost`` columns in the sample data "
"represent:"
msgstr "假设样本数据中的 ``cost`` 和``reverse_cost``列表示："

msgid ":math:`1` when the edge exists in the graph"
msgstr "当边存在于图中时为:math:`1`"

msgid ":math:`-1` when the edge does not exist in the graph"
msgstr "当图中不存在边时为:math:`-1`"

msgid "Using that information updating to the length of the geometries:"
msgstr "使用该信息更新几何形状的长度："

msgid "Which gives the following results:"
msgstr "给出以下结果："

msgid ""
"Note that to be able to follow the documentation examples, everything is "
"based on the original graph."
msgstr "请注意，为了能够遵循文档示例，一切都基于原始图。"

msgid "Returning to the original data:"
msgstr "回到原始数据："

msgid "Update costs based on codes"
msgstr "根据代码更新成本"

msgid "Other datasets, can have a column with values like"
msgstr "其他数据集可以有一列包含如下值"

msgid "``FT`` vehicle flow on the direction of the geometry"
msgstr "``FT``几何方向上的车流"

msgid "``TF`` vehicle flow opposite of the direction of the geometry"
msgstr "``TF`` 车流与几何方向相反"

msgid "``B`` vehicle flow on both directions"
msgstr "``B``双向车流"

msgid "Preparing a code column for the example:"
msgstr "为示例准备代码列："

msgid "Adjusting the costs based on the codes:"
msgstr "根据代码调整成本："

msgid "Check the Routing Topology"
msgstr "检查路由拓扑"

msgid "There are lots of possible problems in a graph."
msgstr "图中可能存在很多问题。"

msgid "The data used may not have been designed with routing in mind."
msgstr "使用的数据在设计时可能没有考虑路由。"

msgid "A graph has some very specific requirements."
msgstr "图有一些非常具体的要求。"

msgid "The graph is disconnected."
msgstr "该图已断开连接。"

msgid "There are unwanted intersections."
msgstr "存在不需要的交叉点。"

msgid "The graph is too large and needs to be contracted."
msgstr "图太大，需要收缩。"

msgid "A sub graph is needed for the application."
msgstr "该应用程序需要一个子图。"

msgid ""
"and many other problems that the pgRouting user, that is the application "
"developer might encounter."
msgstr "以及 pgRouting 用户（即应用程序开发人员）可能遇到的许多其他问题。"

msgid "Crossing edges"
msgstr "交叉边"

msgid "To get the crossing edges:"
msgstr "要获取交叉边："

msgid ""
"That information is correct, for example, when in terms of vehicles, is it a "
"tunnel or bride crossing over another road."
msgstr ""
"这些信息是正确的，例如，在车辆方面，它是一个穿越另一条道路的隧道或桥梁。"

msgid "It might be incorrect, for example:"
msgstr "它可能是不正确的，例如："

msgid ""
"When it is actually an intersection of roads, where vehicles can make turns."
msgstr "当它实际上是道路交叉口时，车辆可以转弯。"

msgid ""
"When in terms of electrical lines, the electrical line is able to switch "
"roads even on a tunnel or bridge."
msgstr "在电力线路方面，电力线能够在隧道或桥梁上甚至切换道路。"

msgid "When it is incorrect, it needs fixing:"
msgstr "当不正确时，需要修复："

msgid "For vehicles and pedestrians"
msgstr "对于车辆和行人"

msgid ""
"If the data comes from OSM and was imported to the database using "
"``osm2pgrouting``, the fix needs to be done in the `OSM portal <https://www."
"openstreetmap.org>`__ and the data imported again."
msgstr ""
"如果数据来自 OSM 并使用 ``osm2pgrouting`` 导入到数据库，则需要在 `OSM portal "
"<https://www.openstreetmap.org>`__ 中完成修复并再次导入数据。"

msgid ""
"In general when the data comes from a supplier that has the data prepared "
"for routing vehicles, and there is a problem, the data is to be fixed from "
"the supplier"
msgstr ""
"一般来说，当数据来自为车辆路线准备数据的供应商时，并且出现问题时，需要从供应"
"商处修复数据"

msgid "For very specific applications"
msgstr "对于非常具体的应用"

msgid ""
"The data is correct when from the point of view of routing vehicles or "
"pedestrians."
msgstr "从路线车辆或行人的角度来看，数据是正确的。"

msgid "The data needs a local fix for the specific application."
msgstr "数据需要针对特定应用程序进行本地修复。"

msgid ""
"Once analyzed one by one the crossings, for the ones that need a local fix, "
"the edges need to be `split <https://postgis.net/docs/ST_Split.html>`__."
msgstr ""
"对交叉点进行一一分析后，对于需要局部修复的交叉点，需要 `分割 <https://"
"postgis.net/docs/ST_Split.html>`__边。"

msgid ""
"The new edges need to be added to the edges table, the rest of the "
"attributes need to be updated in the new edges, the old edges need to be "
"removed and the routing topology needs to be updated."
msgstr ""
"需要将新边添加到边表中，需要更新新边中的其余属性，需要删除旧边并需要更新路由"
"拓扑。"

msgid "Adding split edges"
msgstr "添加分割边"

msgid ""
"For each pair of crossing edges a process similar to this one must be "
"performed."
msgstr "对于每一对交叉边，必须执行与此类似的过程。"

msgid ""
"The columns inserted and the way are calculated are based on the "
"application. For example, if the edges have a trait **name**, then that "
"column is to be copied."
msgstr ""
"插入的列和计算方式取决于应用程序。 例如，如果边具有特征**名称**，则将复制该"
"列。"

msgid "For pgRouting calculations"
msgstr "用于 pgRouting 计算"

msgid ""
"**factor** based on the position of the intersection of the edges can be "
"used to adjust the ``cost`` and ``reverse_cost`` columns."
msgstr "基于边相交位置的**因子**可用于调整``cost`` 和``reverse_cost`` 列。"

msgid ""
"Capacity information, used on the :doc:`flow-family` functions does not need "
"to change when splitting edges."
msgstr "分割边时， :doc:`flow-family` 函数上使用的容量信息不需要更改。"

msgid "Adding new vertices"
msgstr "添加新的顶点"

msgid ""
"After adding all the split edges required by the application, the newly "
"created vertices need to be added to the vertices table."
msgstr "添加应用程序所需的所有分割边后，需要将新创建的顶点添加到顶点表中。"

msgid "Updating edges topology"
msgstr "更新边拓扑"

msgid "Removing the surplus edges"
msgstr "去除多余的边"

msgid ""
"Once all significant information needed by the application has been "
"transported to the new edges, then the crossing edges can be deleted."
msgstr "一旦应用程序所需的所有重要信息都已传输到新边，则可以删除交叉边。"

msgid ""
"There are other options to do this task, like creating a view, or a "
"materialized view."
msgstr "还有其他选项可以完成此任务，例如创建视图或物化视图。"

msgid "Updating vertices topology"
msgstr "更新顶点拓扑"

msgid "To keep the graph consistent, the vertices topology needs to be updated"
msgstr "为了保持图的一致性，需要更新顶点拓扑"

msgid "Checking for crossing edges"
msgstr "检查交叉边"

msgid "There are no crossing edges on the graph."
msgstr "图上没有交叉边。"

msgid "Disconnected graphs"
msgstr "断开连接的图"

msgid "To get the graph connectivity:"
msgstr "要获取图的连通性："

msgid ""
"In this example, the component :math:`2` consists of vertices :math:`\\{2, "
"4\\}` and both vertices are also part of the dead end result set."
msgstr ""
"在此示例中，组件 :math:`2`由顶点 :math:`\\{2, 4\\}` 组成，并且两个顶点也是死"
"端结果集的一部分。"

msgid "This graph needs to be connected."
msgstr "这个图需要连接起来。"

msgid ""
"With the original graph of this documentation, there would be 3 components "
"as the crossing edge in this graph is a different component."
msgstr "对于本文档的原始图，将有 3 个组件，因为该图中的交叉边是不同的组件。"

msgid "Prepare storage for connection information"
msgstr "为连接信息准备存储"

msgid "Save the vertices connection information"
msgstr "保存顶点连接信息"

msgid "Save the edges connection information"
msgstr "保存边连接信息"

msgid "Get the closest vertex"
msgstr "获取最近的顶点"

msgid ""
"Using :doc:`pgr_findCloseEdges` the closest vertex to component :math:`1` is "
"vertex :math:`4`. And the closest edge to vertex :math:`4` is edge :math:"
"`14`."
msgstr ""
"使用 :doc:`pgr_findCloseEdges` 距离组件 :math:`1` 最近的顶点是顶点 :math:"
"`4` 。 距离顶点:math:`4`最近的边是 边 :math:`14`。"

msgid ""
"The ``edge`` can be used to connect the components, using the ``fraction`` "
"information about the edge :math:`14` to split the connecting edge."
msgstr ""
"``edge``可用于连接组件，利用边 :math:`14`的``fraction`` 信息来分割连接边。"

msgid "Connecting components"
msgstr "连接组件"

msgid "There are three basic ways to connect the components"
msgstr "连接组件有三种基本方法"

msgid "From the vertex to the starting point of the edge"
msgstr "从顶点到边的起点"

msgid "From the vertex to the ending point of the edge"
msgstr "从顶点到边的终点"

msgid "From the vertex to the closest vertex on the edge"
msgstr "从边上的顶点到最近的顶点"

msgid "This solution requires the edge to be split."
msgstr "该解决方案需要将边缘分割。"

msgid "The following query shows the three ways to connect the components:"
msgstr "以下查询显示了连接组件的三种方式："

msgid "Checking components"
msgstr "检查组件"

msgid ""
"Ignoring the edge that requires further work. The graph is now fully "
"connected as there is only one component."
msgstr "忽略需要进一步工作的边缘。 该图现在已完全连接，因为只有一个组件。"

msgid "Contraction of a graph"
msgstr "图的收缩"

msgid "The graph can be reduced in size using :doc:`contraction-family`"
msgstr "可以使用:doc:`contraction-family`来减小图形的大小"

msgid ""
"When to contract will depend on the size of the graph, processing times, "
"correctness of the data, on the final application, or any other factor not "
"mentioned."
msgstr ""
"何时收缩将取决于图的大小、处理时间、数据的正确性、最终应用程序或任何其他未提"
"及的因素。"

msgid ""
"A fairly good method of finding out if contraction can be useful is because "
"of the number of dead ends and/or the number of linear edges."
msgstr "确定收缩是否有用的一个相当好的方法是根据死端的数量和/或线性边的数量。"

msgid ""
"A complete method on how to contract and how to use the contracted graph is "
"described on :doc:`contraction-family`"
msgstr ""
"有关如何收缩以及如何使用收缩图的完整方法在 :doc:`contraction-family`中进行了"
"描述"

msgid "Dead ends"
msgstr "死端"

msgid "To get the dead ends:"
msgstr "获取死端："

msgid ""
"That information is correct, for example, when the dead end is on the limit "
"of the imported graph."
msgstr "例如，当死端位于导入图的极限时，该信息是正确的。"

msgid ""
"Visually node :math:`4` looks to be as start/ending of 3 edges, but it is "
"not."
msgstr ""
"从视觉上看，节点 :math:`4` 看起来是 3 条边的开始/结束，但事实并非如此。"

msgid "Is that correct?"
msgstr "那是对的吗？"

msgid "Is there such a small curb:"
msgstr "有这么小的路边吗："

msgid "That does not allow a vehicle to use that visual intersection?"
msgstr "这不允许车辆使用该视觉交叉路口？"

msgid ""
"Is the application for pedestrians and therefore the pedestrian can easily "
"walk on the small curb?"
msgstr "是否适用于行人，因此行人可以轻松地在小路边行走？"

msgid ""
"Is the application for the electricity and the electrical lines than can "
"easily be extended on top of the small curb?"
msgstr "电力和电线的应用是否可以轻松地延伸到小路边顶部？"

msgid ""
"Is there a big cliff and from eagles view look like the dead end is close to "
"the segment?"
msgstr "是否有一个大悬崖，从鹰的角度看，死胡同靠近该路段？"

msgid ""
"When there are many dead ends, to speed up, the :doc:`contraction-family` "
"functions can be used to divide the problem."
msgstr ""
"当有很多死端时，为了加快速度，可以使用 :doc:`contraction-family` 函数来划分问"
"题。"

msgid "Linear edges"
msgstr "线性边"

msgid "To get the linear edges:"
msgstr "要获得线性边："

msgid ""
"This information is correct, for example, when the application is taking "
"into account speed bumps, stop signals."
msgstr "例如，当应用程序考虑减速带、停止信号时，此信息是正确的。"

msgid ""
"When there are many linear edges, to speed up, the :doc:`contraction-family` "
"functions can be used to divide the problem."
msgstr ""
"当线性边较多时，为了加快速度，可以使用:doc:`contraction-family`函数来划分问"
"题。"

msgid "Function's structure"
msgstr "函数的结构"

msgid ""
"Once the graph preparation work has been done above, it is time to use a"
msgstr "完成上述图准备工作后，就可以使用"

msgid "The general form of a pgRouting function call is:"
msgstr "pgRouting 函数调用的一般形式是："

msgid "\\ \\"
msgstr "\\ \\"

msgid "pgr_<name>(`Inner queries`_, **parameters**, [ ``Optional parameters``)"
msgstr ""
"pgr_<name>(`Inner queries`_, **parameters**, [ ``Optional parameters``)"

msgid ""
"`Inner queries`_: Are compulsory parameters that are ``TEXT`` strings "
"containing SQL queries."
msgstr "`Inner queries`_：是强制参数，是包含 SQL 查询的``TEXT``字符串。"

msgid ""
"**parameters**: Additional compulsory parameters needed by the function."
msgstr "**parameters**：函数需要的附加强制参数。"

msgid ""
"``Optional parameters``: Are non compulsory **named** parameters that have a "
"default value when omitted."
msgstr "``Optional parameters``：是非强制命名参数，省略时具有默认值。"

msgid ""
"The compulsory parameters are positional parameters, the optional parameters "
"are named parameters."
msgstr "强制参数是位置参数，可选参数是命名参数。"

msgid "For example, for this :doc:`pgr_dijkstra` signature:"
msgstr "例如，对于这个 :doc:`pgr_dijkstra`签名："

msgid ""
"pgr_dijkstra(`Edges SQL`_, **start vid**, **end vid**  [, ``directed``])"
msgstr ""
"pgr_dijkstra(`Edges SQL`_, **start vid**, **end vid**  [, ``directed``])"

msgid "`Edges SQL`_:"
msgstr "`Edges SQL`_:"

msgid "Is the first parameter."
msgstr "是第一个参数。"

msgid "It is compulsory."
msgstr "这是强制性的。"

msgid "It is an inner query."
msgstr "这是一个内部查询。"

msgid ""
"It has no name, so **Edges SQL** gives an idea of what kind of inner query "
"needs to be used"
msgstr "它没有名称，因此 **Edges SQL**给出了需要使用哪种内部查询的想法"

msgid "**start vid**:"
msgstr "**start vid**:"

msgid "Is the second parameter."
msgstr "是第二个参数。"

msgid ""
"It has no name, so **start vid** gives an idea of what the second "
"parameter's value should contain."
msgstr "它没有名称，因此 **start vid** 给出了第二个参数的值应包含的内容。"

msgid "Is the third parameter."
msgstr "是第三个参数。"

msgid ""
"It has no name, so **end vid** gives an idea of what the third parameter's "
"value should contain"
msgstr "它没有名称，因此 **end vid**给出了第三个参数的值应包含的内容"

msgid "Is the fourth parameter."
msgstr "是第四个参数。"

msgid "It is optional."
msgstr "是可选的。"

msgid "It has a name."
msgstr "它有一个名字。"

msgid ""
"The full description of the parameters are found on the `Parameters`_ "
"section of each function."
msgstr "参数的完整描述可以在每个函数的 `Parameters`_部分找到。"

msgid "Function's overloads"
msgstr "函数的重载"

msgid "A function might have different overloads. The most common are called:"
msgstr "一个函数可能有不同的重载。 最常见的是："

msgid "`One to One`_"
msgstr "`一对一`_"

msgid "`One to Many`_"
msgstr "`一对多`_"

msgid "`Many to One`_"
msgstr "`多对一`_"

msgid "`Many to Many`_"
msgstr "`多对多`_"

msgid "`Combinations`_"
msgstr "`组合`_"

msgid "Depending on the overload the parameters types change."
msgstr "根据过载，参数类型会发生变化。"

msgid "**One**: **ANY-INTEGER**"
msgstr "**一**: **ANY-INTEGER**"

msgid "**Many**: ``ARRAY`` [**ANY-INTEGER**]"
msgstr "**多**: ``ARRAY`` [**ANY-INTEGER**]"

msgid ""
"Depending of the function the overloads may vary. But the concept of "
"parameter type change remains the same."
msgstr "根据函数的不同，重载可能会有所不同。 但参数类型改变的概念保持不变。"

msgid "One to One"
msgstr "一对一"

msgid "When routing from:"
msgstr "当路由来自："

msgid "From **one** starting vertex"
msgstr "从**一**起始顶点"

msgid "to **one** ending vertex"
msgstr "到**一**结束顶点"

msgid "One to Many"
msgstr "一对多"

msgid "to **many** ending vertices"
msgstr "到**多**结束顶点"

msgid "Many to One"
msgstr "多对一"

msgid "From **many** starting vertices"
msgstr "从**多**起始顶点"

msgid "Many to Many"
msgstr "多对多"

msgid "Combinations"
msgstr "组合"

msgid "From **many** different starting vertices"
msgstr "从**多个**不同的起始顶点"

msgid "to **many** different ending vertices"
msgstr "到**多个**不同的结束顶点"

msgid "Every tuple specifies a pair of a start vertex and an end vertex"
msgstr "每个元组指定一对起始顶点和结束顶点"

msgid "Users can define the combinations as desired."
msgstr "用户可以根据需要定义组合。"

msgid "Needs a `Combinations SQL`_"
msgstr "需要`Combinations SQL`_"

msgid ""
"There are several kinds of valid inner queries and also the columns returned "
"are depending of the function. Which kind of inner query will depend on the "
"function(s) requirements. To simplify variety of types, **ANY-INTEGER** and "
"**ANY-NUMERICAL** is used."
msgstr ""
"有多种有效的内部查询，返回的列也取决于函数。 哪种内部查询取决于函数的要求。 "
"为了简化各种类型，使用 **ANY-INTEGER** 和 **ANY-NUMERICAL** 。"

msgid "Edges SQL for"
msgstr "边 SQL"

msgid ":doc:`withPoints-family`"
msgstr ":doc:`withPoints-family`"

msgid "Some uncategorised functions"
msgstr "一些未分类的函数"

msgid "General without ``id``"
msgstr "一般没有``id``"

msgid "General with (X,Y)"
msgstr "通常带有（X,Y)"

msgid ""
"When negative: edge (``source``, ``target``) does not exist, therefore it's "
"not part of the graph."
msgstr "当为负时：边（``source``, ``target``）不存在，因此它不是图的一部分。"

msgid "Weight of the edge (``target``, ``source``),"
msgstr "边 (``target``, ``source``)的权重，"

msgid "``x1``"
msgstr "``x1``"

msgid "X coordinate of ``source`` vertex."
msgstr "``source`` 顶点的X坐标。"

msgid "``y1``"
msgstr "``y1``"

msgid "Y coordinate of ``source`` vertex."
msgstr "``source``顶点的Y坐标。"

msgid "``x2``"
msgstr "``x2``"

msgid "X coordinate of ``target`` vertex."
msgstr "``target``顶点的X坐标。"

msgid "``y2``"
msgstr "``y2``"

msgid "Y coordinate of ``target`` vertex."
msgstr "``target``顶点的Y坐标。"

msgid "Flow"
msgstr "流"

msgid "Edges SQL for :doc:`flow-family`"
msgstr "用于流数据系列 ( :doc:`flow-family`) 的Edges SQL"

msgid "Edges SQL for the following functions of :doc:`flow-family`"
msgstr "Edges SQL 适用于:doc:`flow-family`的以下函数"

msgid "Used on combination signatures"
msgstr "用于组合签名"

msgid "Points SQL for"
msgstr "用于Points SQL"

msgid ""
"The main parameter of the majority of the pgRouting functions is a query "
"that selects the edges of the graph."
msgstr "大多数 pgRouting 函数的主要参数是选择图的边的查询。"

msgid ""
"Depending on the family or category of a function it will have additional "
"parameters, some of them are compulsory and some are optional."
msgstr ""
"根据函数的族或类别，它将具有附加参数，其中一些是强制性的，一些是可选的。"

msgid ""
"The compulsory parameters are nameless and must be given in the required "
"order. The optional parameters are named parameters and will have a default "
"value."
msgstr ""
"强制参数是无名的，并且必须按要求的顺序给出。 可选参数是命名参数，并且具有默认"
"值。"

msgid "Parameters for the Via functions"
msgstr "Via 函数的参数"

msgid ":doc:`pgr_dijkstraVia`"
msgstr ":doc:`pgr_dijkstraVia`"

msgid "SQL query as described."
msgstr "如所述的 SQL 查询。"

msgid "When ``true`` Graph is considered `Directed`"
msgstr "当为``true``时，图被视为`有向`图"

msgid "When ``false`` the graph is considered as Undirected."
msgstr "当为``false``时，图被视为无向图。"

msgid "``strict``"
msgstr "``strict``"

msgid "``false``"
msgstr "``false``"

msgid "When ``true`` if a path is missing stops and returns **EMPTY SET**"
msgstr "当为 ``true`` 时，如果路径丢失，则停止并返回 **EMPTY SET**"

msgid "When ``false`` ignores missing paths returning all paths found"
msgstr "当``false``忽略丢失的路径时，返回找到的所有路径"

msgid "``U_turn_on_edge``"
msgstr "``U_turn_on_edge``"

msgid ""
"When ``true`` departing from a visited vertex will not try to avoid using "
"the edge used to reach it.  In other words, U turn using the edge with same "
"identifier is allowed."
msgstr ""
"当 为``true``时，从已访问的顶点出发，不会试图避免使用用于到达它的边。换句话"
"说，允许使用具有相同标识符的边来进行掉头。"

msgid ""
"When ``false`` when a departing from a visited vertex tries to avoid using "
"the edge used to reach it.  In other words, U turn using the edge with same "
"identifier is used when no other path is found."
msgstr ""
"当为``false``时，从已访问的顶点出发，尝试避免使用用于到达它的边。换句话说，只"
"有在找不到其他路径时才使用具有相同标识符的边来进行掉头。"

msgid "For the TRSP functions"
msgstr "对于 TRSP 函数"

msgid ":doc:`pgr_trsp`"
msgstr ":doc:`pgr_trsp`"

msgid "Array of identifiers of destination vertices."
msgstr "目标顶点的标识符数组。"

msgid ""
"There are several kinds of columns returned are depending of the function."
msgstr "根据函数的不同，返回的列有多种。"

msgid "Return columns for a path"
msgstr "返回路径的列"

msgid "Used on functions that return one path solution"
msgstr "用于返回单路径解决方案的函数"

msgid ""
"Returns set of ``(seq, path_seq [, start_vid] [, end_vid], node, edge, cost, "
"agg_cost)``"
msgstr ""
"返回``(seq, path_seq [, start_vid] [, end_vid], node, edge, cost, "
"agg_cost)``的集合"

msgid "``path_seq``"
msgstr "``path_seq``"

msgid ""
"Relative position in the path. Has value **1** for the beginning of a path."
msgstr "路径中的相对位置。 路径开头的值为 **1**。"

msgid ""
"Identifier of the starting vertex. Returned when multiple starting vetrices "
"are in the query."
msgstr "起始顶点的标识符。 当查询中有多个起始向量时返回。"

msgid ""
"Identifier of the ending vertex. Returned when multiple ending vertices are "
"in the query."
msgstr "结束顶点的标识符。 当查询中有多个结束顶点时返回。"

msgid "Identifier of the node in the path from ``start_vid`` to ``end_vid``."
msgstr "从``start_vid``到 ``end_vid``路径中节点的标识符。"

msgid ""
"Identifier of the edge used to go from ``node`` to the next node in the path "
"sequence. **-1** for the last node of the path."
msgstr ""
"用于从路径序列中的``node`` 到下一个节点的边的标识符。**-1** 表示路径的最后一"
"个节点。"

msgid ""
"Cost to traverse from ``node`` using ``edge`` to the next node in the path "
"sequence."
msgstr "从使用``edge``的 ``node`` 遍历到路径序列中的下一个节点的成本。"

msgid "Used on functions the following:"
msgstr "用于以下函数："

msgid ":doc:`pgr_withPoints`"
msgstr ":doc:`pgr_withPoints`"

msgid ""
"Returns set of ``(seq, path_seq [, start_pid] [, end_pid], node, edge, cost, "
"agg_cost)``"
msgstr ""
"返回``(seq, path_seq [, start_pid] [, end_pid], node, edge, cost, "
"agg_cost)``的集合"

msgid "Relative position in the path."
msgstr "路径中的相对位置。"

msgid "**1** For the first row of the path."
msgstr "**1 **对于路径的第一行。"

msgid "``start_pid``"
msgstr "``start_pid``"

msgid "Identifier of a starting vertex/point of the path."
msgstr "路径起始顶点/点的标识符。"

msgid "When positive is the identifier of the starting vertex."
msgstr "当正数时是起始顶点的标识符。"

msgid "When negative is the identifier of the starting point."
msgstr "当负数时是起点的标识符。"

msgid "Returned on `Many to One`_  and `Many to Many`_"
msgstr "返回`多对一`_和`多对多`_"

msgid "``end_pid``"
msgstr "``end_pid``"

msgid "Identifier of an ending vertex/point of the path."
msgstr "路径结束顶点/点的标识符。"

msgid "When positive is the identifier of the ending vertex."
msgstr "当正数时是结束顶点的标识符。"

msgid "When negative is the identifier of the ending point."
msgstr "当负数时是终点的标识符。"

msgid "Returned on `One to Many`_ and `Many to Many`_"
msgstr "返回`一对多`_和`多对多`_"

msgid "Identifier of the node in the path from ``start_pid`` to ``end_pid``."
msgstr "从``start_pid`` 到``end_pid``路径中节点的标识符。"

msgid "When positive is the identifier of the a vertex."
msgstr "当正数时是顶点的标识符。"

msgid "When negative is the identifier of the a point."
msgstr "当负数时是a点的标识符。"

msgid ""
"Identifier of the edge used to go from ``node`` to the next node in the path "
"sequence."
msgstr "用于从路径序列中的 ``node``到下一个节点的边的标识符。"

msgid "**-1** for the last row of the path."
msgstr "**-1 **表示路径的最后一行。"

msgid "**0** For the first row of the path."
msgstr "**0** 表示路径的第一行。"

msgid ":doc:`pgr_dijkstraNear`"
msgstr ":doc:`pgr_dijkstraNear`"

msgid ""
"Returns ``(seq, path_seq, start_vid, end_vid, node, edge, cost, agg_cost)``"
msgstr ""
"返回``(seq, path_seq, start_vid, end_vid, node, edge, cost, agg_cost)``"

msgid "Identifier of the starting vertex of the current path."
msgstr "当前路径起始顶点的标识符。"

msgid "Identifier of the ending vertex of the current path."
msgstr "当前路径结束顶点的标识符。"

msgid "Multiple paths"
msgstr "多条路径"

msgid "Selective for multiple paths."
msgstr "多路径选择性。"

msgid "The columns depend on the function call."
msgstr "这些列取决于函数调用。"

msgid ""
"Set of ``(seq, path_id, path_seq [, start_vid] [, end_vid], node, edge, "
"cost, agg_cost)``"
msgstr ""
"``(seq, path_id, path_seq [, start_vid] [, end_vid], node, edge, cost, "
"agg_cost)``集合"

msgid "``path_id``"
msgstr "``path_id``"

msgid "Path identifier."
msgstr "路径标识符。"

msgid ""
"Has value **1** for the first of a path from ``start_vid`` to ``end_vid``."
msgstr "从``start_vid`` 到 ``end_vid``的第一个路径的值为** 1**。"

msgid "Non selective for multiple paths"
msgstr "多路径非选择性"

msgid "Regardless of the call, al the columns are returned."
msgstr "无论调用如何，都会返回所有列。"

msgid ""
"Returns set of ``(seq, path_id, path_seq, start_vid, end_vid, node, edge, "
"cost, agg_cost)``"
msgstr ""
"返回集合``(seq, path_id, path_seq, start_vid, end_vid, node, edge, cost, "
"agg_cost)``"

msgid "Return columns for cost functions"
msgstr "返回成本函数的列"

msgid "Used in the following"
msgstr "用于以下函数"

msgid ""
"When start_vid or end_vid columns have negative values, the identifier is "
"for a Point."
msgstr "当 start_vid 或 end_vid 列具有负值时，标识符用于点。"

msgid "Return columns for flow functions"
msgstr "流函数的返回列"

msgid "Edges SQL for the following"
msgstr "Edges SQL 适用于以下内容"

msgid "Return columns for spanning tree functions"
msgstr "返回生成树函数的列"

msgid "Returns SET OF ``(edge, cost)``"
msgstr "返回集合``(edge, cost)``"

msgid "Cost to traverse the edge."
msgstr "穿越边的成本。"

msgid "Performance Tips"
msgstr "性能技巧"

msgid "For the Routing functions"
msgstr "对于路由功能"

msgid ""
"To get faster results bound the queries to an area of interest of routing."
msgstr "为了获得更快的结果，将查询绑定到路由感兴趣的区域。"

msgid ""
"In this example Use an inner query SQL that does not include some edges in "
"the routing function and is within the area of the results."
msgstr ""
"在此示例中，使用内部查询 SQL，该 SQL 不包括路由函数中的某些边并且位于结果区域"
"内。"

msgid "How to contribute"
msgstr "如何贡献"

msgid "Wiki"
msgstr "维基"

msgid ""
"Edit an existing  `pgRouting Wiki <https://github.com/pgRouting/pgrouting/"
"wiki>`__ page."
msgstr ""
"编辑现有的 `pgRouting 维基 <https://github.com/pgRouting/pgrouting/wiki>`__ "
"页面。"

msgid "Or create a new Wiki page"
msgstr "或者创建一个新的维基 页面"

msgid ""
"Create a page on the `pgRouting Wiki <https://github.com/pgRouting/pgrouting/"
"wiki>`__"
msgstr ""
"在 `pgRouting 维基<https://github.com/pgRouting/pgrouting/wiki>`__上创建页面"

msgid "Give the title an appropriate name"
msgstr "给标题起一个合适的名称"

msgid ""
"`Example <https://github.com/pgRouting/pgrouting/wiki/How-to:-Handle-"
"parallel-edges-(KSP)>`__"
msgstr ""
"`示例 <https://github.com/pgRouting/pgrouting/wiki/How-to:-Handle-parallel-"
"edges-(KSP)>`__"

msgid "Adding Functionaity to pgRouting"
msgstr "向 pgRouting 添加功能"

msgid ""
"Consult the `developer's documentation <https://docs.pgrouting.org/doxy/2.4/"
"index.html>`__"
msgstr "查阅`开发者文档 <https://docs.pgrouting.org/doxy/2.4/index.html>`__"

msgid "Installation"
msgstr "安装"

msgid ":ref:`install-short`"
msgstr ":ref:`install-short`"

msgid ":ref:`install_get_sources`"
msgstr ":ref:`install_get_sources`"

msgid ":ref:`install_enable_db`"
msgstr ":ref:`install_enable_db`"

msgid ":ref:`install_dependencies`"
msgstr ":ref:`install_dependencies`"

msgid ":ref:`install_configuring`"
msgstr ":ref:`install_configuring`"

msgid ":ref:`install_build`"
msgstr ":ref:`install_build`"

msgid ":ref:`install_testing`"
msgstr ":ref:`install_testing`"

msgid ""
"Instructions for downloading and installing binaries for different operating "
"systems, additional notes and corrections not included in this documentation "
"can be found in `Installation wiki <https://github.com/pgRouting/pgrouting/"
"wiki/Notes-on-Download%2C-Installation-and-building-pgRouting>`__"
msgstr ""
"有关下载和安装适用于不同操作系统的二进制文件的说明、本文档中未包含的其他注释"
"和更正，可以在 `安装维基<https://github.com/pgRouting/pgrouting/wiki/Notes-"
"on-Download%2C-Installation-and-building-pgRouting>`__中找到"

msgid ""
"To use pgRouting PostGIS needs to be installed, please read the information "
"about installation in this `Install Guide <https://www.postgis.us/"
"presentations/postgis_install_guide_22.html>`__"
msgstr ""
"使用pgRouting需要安装PostGIS，请阅读本`安装指南 <https://www.postgis.us/"
"presentations/postgis_install_guide_22.html>`__中有关安装的信息"

msgid "Short Version"
msgstr "简洁版本"

msgid "Extracting the tar ball"
msgstr "解压 tar 压缩文件"

msgid "To compile assuming you have all the dependencies in your search path:"
msgstr "假设您的搜索路径中有所有依赖项，则进行编译："

msgid ""
"Once pgRouting is installed, it needs to be enabled in each individual "
"database you want to use it in."
msgstr "安装 pgRouting 后，需要在您想要使用它的每个数据库中启用它。"

msgid "Get the sources"
msgstr "获取来源"

msgid ""
"The pgRouting latest release can be found in https://github.com/pgRouting/"
"pgrouting/releases/latest"
msgstr ""
"pgRouting 最新版本可以在 https://github.com/pgRouting/pgrouting/releases/"
"latest 中找到"

msgid "wget"
msgstr "wget"

msgid "To download this release:"
msgstr "要下载此版本："

msgid ""
"Go to :ref:`install-short` for more instructions on extracting tar ball and "
"compiling pgRouting."
msgstr ""
"转到:ref:`install-short`以获取有关提取 tar 包和编译 pgRouting 的更多说明。"

msgid "git"
msgstr "git"

msgid "To download the repository"
msgstr "下载存储库"

msgid ""
"Go to :ref:`install-short` for more instructions on compiling pgRouting "
"(there is no tar ball involved while downloading pgRouting repository from "
"GitHub)."
msgstr ""
"请参阅 :ref:`install-short` 获取有关编译 pgRouting 的更多说明（从 GitHub 下"
"载 pgRouting 存储库时不涉及 tar 文件）。"

msgid "Enabling and upgrading in the database"
msgstr "在数据库中启用和升级"

msgid "Enabling the database"
msgstr "启用数据库"

msgid ""
"pgRouting is a PostgreSQL extension and depends on PostGIS to provide "
"functionalities to end user. Below given code demonstrates enabling PostGIS "
"and pgRouting in the database."
msgstr ""
"pgRouting 是 PostgreSQL 扩展，依赖 PostGIS 向最终用户提供功能。 下面给出的代"
"码演示了在数据库中启用 PostGIS 和 pgRouting。"

msgid ""
"Checking PostGIS and pgRouting version after enabling them in the database."
msgstr "在数据库中启用 PostGIS 和 pgRouting 后检查它们的版本。"

msgid "Upgrading the database"
msgstr "升级数据库"

msgid ""
"To upgrade pgRouting in the database to version 3.6.0 use the following "
"command:"
msgstr "要将数据库中的 pgRouting 升级到版本 3.5.1，请使用以下命令："

msgid ""
"More information can be found in https://www.postgresql.org/docs/current/sql-"
"createextension.html"
msgstr ""
"更多信息可以在 https://www.postgresql.org/docs/current/sql-createextension."
"html 中找到"

msgid "Dependencies"
msgstr "依赖"

msgid "Compilation Dependencies"
msgstr "编译依赖"

msgid ""
"To be able to compile pgRouting, make sure that the following dependencies "
"are met:"
msgstr "为了能够编译 pgRouting，请确保满足以下依赖项："

msgid "C and C++0x compilers"
msgstr "C 和 C++0x编译器"

msgid ""
"Compiling with Boost 1.56 up to Boost 1.74 requires C++ Compiler with C++03 "
"or C++11 standard support"
msgstr ""
"使用 Boost 1.56 到 Boost 1.74 进行编译需要具有 C++03 或 C++ 11 标准支持的 C +"
"+编译器"

msgid ""
"Compiling with Boost 1.75 requires C++ Compiler with C++14 standard support"
msgstr "使用 Boost 1.75 进行编译需要具有 C++ 14 标准支持的 C++ 编译器"

msgid "Postgresql version = Supported versions by PostgreSQL"
msgstr "Postgresql 版本 = PostgreSQL 支持的版本"

msgid "The Boost Graph Library (BGL). Version >= 1.56"
msgstr "Boost 图库 (BGL)。 版本 >= 1.56"

msgid "CMake >= 3.2"
msgstr "CMake >= 3.2"

msgid "optional dependencies"
msgstr "可选的依赖项"

msgid "For user's documentation"
msgstr "用于用户文档"

msgid "Sphinx >= 1.1"
msgstr "Sphinx >= 1.1"

msgid "Latex"
msgstr "Latex"

msgid "For developer's documentation"
msgstr "对于开发者文档"

msgid "Doxygen >= 1.7"
msgstr "Doxygen >= 1.7"

msgid "For testing"
msgstr "供测试用"

msgid "pgtap"
msgstr "pgtap"

msgid "pg_prove"
msgstr "pg_prove"

msgid "For using:"
msgstr "用于使用："

msgid "PostGIS version >= 2.2"
msgstr "PostGIS版本 >= 2.2"

msgid "Example: Installing dependencies on linux"
msgstr "示例：在 Linux 上安装依赖项"

msgid "Installing the compilation dependencies"
msgstr "安装编译依赖项"

msgid "Database dependencies"
msgstr "数据库依赖"

msgid "Configuring PostgreSQL"
msgstr "配置 PostgreSQL"

msgid "Entering psql console"
msgstr "进入psql控制台"

msgid "To exit psql console"
msgstr "退出 psql 控制台"

msgid ""
"Entering psql console directly without switching roles can be done by the "
"following commands"
msgstr "直接进入psql控制台，无需切换角色，可以通过以下命令完成"

msgid "Then use the above given method to exit out of the psql console"
msgstr "然后使用上面给出的方法退出psql控制台"

msgid "Checking PostgreSQL version"
msgstr "检查 PostgreSQL 版本"

msgid "or"
msgstr "或者"

msgid "Enter the psql console using above given method and then enter"
msgstr "使用上面给定的方法进入psql控制台，然后输入"

msgid "Creating PostgreSQL role"
msgstr "创建 PostgreSQL 角色"

msgid ""
"Default role provided by PostgreSQL is postgres. To create new roles you can "
"use the above provided commands. The prompt will ask the user to type name "
"of the role and then provide affirmation. Proceed with the steps and you "
"will succeed in creating PostgreSQL role successfully."
msgstr ""
"PostgreSQL 提供的默认角色是 postgres。 要创建新角色，您可以使用上面提供的命"
"令。 提示将要求用户输入角色名称，然后提供确认。 继续执行这些步骤，您将成功创"
"建 PostgreSQL 角色。"

msgid ""
"To add password to the role or change previously created password of the "
"role use the following commands"
msgstr "要向角色添加密码或更改之前创建的角色密码，请使用以下命令"

msgid ""
"To get additional details on the flags associated with ``createuser`` below "
"given command can be used"
msgstr ""
"要获取与下面的 ``createuser``相关的标志的更多详细信息，可以使用给定的命令"

msgid "Creating Database in PostgreSQL"
msgstr "在 PostgreSQL 中创建数据库"

msgid "Connecting to a PostgreSQL Database"
msgstr "连接到 PostgreSQL 数据库"

msgid "Enter the psql console and type the following commands"
msgstr "进入psql控制台，输入以下命令"

msgid "Build dependencies"
msgstr "构建依赖关系"

msgid "Optional dependencies"
msgstr "可选依赖项"

msgid "For documentation and testing"
msgstr "用于文档和测试"

msgid "Configuring"
msgstr "配置"

msgid "pgRouting uses the `cmake` system to do the configuration."
msgstr "pgRouting 使用 `cmake`系统进行配置。"

msgid "The build directory is different from the source directory"
msgstr "构建目录与源目录不同"

msgid "Create the build directory"
msgstr "创建构建目录"

msgid "Configurable variables"
msgstr "可配置变量"

msgid "To see the variables that can be configured"
msgstr "查看可以配置的变量"

msgid "Configuring The Documentation"
msgstr "配置文档"

msgid ""
"Most of the effort of the documentation has been on the HTML files. Some "
"variables for building documentation:"
msgstr "文档的大部分工作都集中在 HTML 文件上。 构建文档的一些变量："

msgid "Variable"
msgstr "变量"

msgid "Comment"
msgstr "解释"

msgid "WITH_DOC"
msgstr "WITH_DOC"

msgid "BOOL=OFF"
msgstr "BOOL=OFF"

msgid "Turn on/off building the documentation"
msgstr "打开/关闭构建文档"

msgid "BUILD_HTML"
msgstr "BUILD_HTML"

msgid "BOOL=ON"
msgstr "BOOL=ON"

msgid "If ON, turn on/off building HTML for user's documentation"
msgstr "如果打开，则打开/关闭为用户文档构建 HTML"

msgid "BUILD_DOXY"
msgstr "BUILD_DOXY"

msgid "If ON, turn on/off building HTML for developer's documentation"
msgstr "如果打开，则打开/关闭为开发人员文档构建 HTML"

msgid "BUILD_LATEX"
msgstr "BUILD_LATEX"

msgid "If ON, turn on/off building PDF"
msgstr "如果打开，则打开/关闭构建 PDF"

msgid "BUILD_MAN"
msgstr "BUILD_MAN"

msgid "If ON, turn on/off building MAN pages"
msgstr "如果为 ON，则打开/关闭构建 MAN 页面"

msgid "DOC_USE_BOOTSTRAP"
msgstr "DOC_USE_BOOTSTRAP"

msgid "If ON, use sphinx-bootstrap for HTML pages of the users documentation"
msgstr "如果打开，则对用户文档的 HTML 页面使用 sphinx-bootstrap"

msgid "Configuring cmake to create documentation before building pgRouting"
msgstr "在构建 pgRouting 之前配置 cmake 创建文档"

msgid "Most of the effort of the documentation has been on the html files."
msgstr "文档的大部分工作都集中在 html 文件上。"

msgid "Building"
msgstr "构建"

msgid "Using ``make`` to build the code and the documentation"
msgstr "使用 ``make`` 构建代码和文档"

msgid "The following instructions start from *path/to/pgrouting/build*"
msgstr "以下说明从*path/to/pgrouting/build*开始"

msgid ""
"We have tested on several platforms, For installing or reinstalling all the "
"steps are needed."
msgstr "我们已经在多个平台上进行了测试，安装或重新安装需要所有步骤。"

msgid "The sql signatures are configured and build in the ``cmake`` command."
msgstr "SQL签名是在``cmake``命令中配置和构建的。"

msgid "MinGW on Windows"
msgstr "Windows 上的 MinGW"

msgid "Linux"
msgstr "Linux"

msgid "The following instructions start from *path/to/pgrouting*"
msgstr "以下说明从 *path/to/pgrouting*开始"

msgid ""
"To remove the build when the configuration changes, use the following code:"
msgstr "要在配置更改时删除构建，请使用以下代码："

msgid "and start the build process as mentioned previously."
msgstr "并开始前面提到的构建过程。"

msgid "Testing"
msgstr "测试"

msgid "Currently there is no :code:`make test` and testing is done as follows"
msgstr "目前没有:code:`make test`，测试如下"

msgid "The following instructions start from *path/to/pgrouting/*"
msgstr "以下指令从*path/to/pgrouting/*开始"

msgid ""
"pgRouting is an extension of `PostGIS <https://postgis.net>`__ and "
"`PostgreSQL <https://www.postgresql.org>`__ geospatial database and adds "
"routing and other network analysis functionality. A predecessor of pgRouting "
"– pgDijkstra, written by Sylvain Pasche from `Camptocamp <https://camptocamp."
"com>`__, was later extended by Orkney and renamed to pgRouting. The project "
"is now supported and maintained by `Georepublic <https://georepublic."
"info>`__, `Paragon Corporation <https://www.paragoncorporation.com/>`__ and "
"a broad user community."
msgstr ""
"pgRouting 是 `PostGIS <https://postgis.net>`__ 和 `PostgreSQL <https://www."
"postgresql.org>`__ 地理空间数据库的扩展，并添加了路由和其他网络分析功能。 "
"pgRouting的前身——pgDijkstra，由`Camptocamp <https://camptocamp.com>`__的"
"Sylvain Pasche编写，后来被Orkney扩展并更名为pgRouting。 该项目现在得到了 "
"`Georepublic <https://georepublic.info>`__、`Paragon Corporation <https://"
"www.paragoncorporation.com/>`__ 和广大用户社区的支持和维护。"

msgid ""
"pgRouting is part of `OSGeo Community Projects <https://wiki.osgeo.org/wiki/"
"OSGeo_Community_Projects>`__ from the `OSGeo Foundation <https://www.osgeo."
"org>`__ and included on `OSGeoLive <http://live.osgeo.org/>`__."
msgstr ""
"pgRouting 是 `OSGeo 基金会 <https://www.osgeo.org>`__ `OSGeo 社区项目 "
"<https://wiki.osgeo.org/wiki/OSGeo_Community_Projects>`__ 的一部分，并包含在 "
"`OSGeoLive <http://live.osgeo.org/>`__中。"

msgid "Licensing"
msgstr "许可"

msgid "The following licenses can be found in pgRouting:"
msgstr "可以在 pgRouting 中找到以下许可证："

msgid "**License**"
msgstr "**许可**"

msgid "GNU General Public License v2.0 or later"
msgstr "GNU 通用公共许可证 v2.0 或更高版本"

msgid ""
"Most features of pgRouting are available under `GNU General Public License "
"v2.0 or later <https://spdx.org/licenses/GPL-2.0-or-later.html>`_."
msgstr ""
"pgRouting 的大多数功能都可以在` GNU 通用公共许可证 v2.0 或更高版本<https://"
"spdx.org/licenses/GPL-2.0-or-later.html>`_下使用。"

msgid "Boost Software License - Version 1.0"
msgstr "Boost 软件许可证 - 版本 1.0"

msgid ""
"Some Boost extensions are available under `Boost Software License - Version "
"1.0 <https://www.boost.org/LICENSE_1_0.txt>`_."
msgstr ""
"一些 Boost 扩展可根据` Boost 软件许可证 - 版本 1.0 获得<https://www.boost."
"org/LICENSE_1_0.txt>`_。"

msgid "MIT-X License"
msgstr "MIT-X License"

msgid ""
"Some code contributed by iMaptools.com is available under MIT-X license."
msgstr "iMaptools.com 贡献的一些代码可在 MIT-X 许可证下使用。"

msgid ""
"The pgRouting Manual is licensed under a `Creative Commons Attribution-Share "
"Alike 3.0 License <https://creativecommons.org/licenses/by-sa/3.0/>`_."
msgstr ""
"pgRouting 手册根据`知识共享署名-相同方式共享 3.0 许可证获得许可 <https://"
"creativecommons.org/licenses/by-sa/3.0/>`_。"

msgid ""
"In general license information should be included in the header of each "
"source file."
msgstr "一般来说，许可证信息应包含在每个源文件的标头中。"

msgid "Contributors"
msgstr "贡献者"

msgid "This Release Contributors"
msgstr "此版本贡献者"

msgid "Individuals in this release (in alphabetical order)"
msgstr "本版本的个人贡献者 (按字母顺序)"

msgid ""
"Aniket Agarwal, Aryan Gupta, Ashish Kumar, Cayetano Benavent, Daniel Kastl, "
"Nitish Chauhan, Rajat Shinde, Regina Obe, Shobhit Chaurasia, Swapnil Joshi, "
"Virginia Vergara, Yige Huang"
msgstr ""
"Aniket Agarwal, Aryan Gupta, Ashish Kumar, Cayetano Benavent, Daniel Kastl, "
"Nitish Chauhan, Rajat Shinde, Regina Obe, Shobhit Chaurasia, Swapnil Joshi, "
"Virginia Vergara, Yige Huang"

msgid ""
"And all the people that give us a little of their time making comments, "
"finding issues, making pull requests etc.  in any of our products: "
"osm2pgrouting, pgRouting, pgRoutingLayer, workshop."
msgstr ""
"并且所有那些花一点时间为我们的任何产品提供评论、发现问题、提交请求等的人们，"
"包括 osm2pgrouting、pgRouting、pgRoutingLayer 和 workshop。"

msgid "Corporate Sponsors in this release (in alphabetical order)"
msgstr "本次发布中的企业赞助商（按字母顺序排列）"

msgid ""
"These are corporate entities that have contributed developer time, hosting, "
"or direct monetary funding to the pgRouting project:"
msgstr ""
"这些是为 pgRouting 项目贡献了开发人员时间、托管或直接货币资金的公司实体："

msgid "`Georepublic <https://georepublic.info/en/>`__"
msgstr "`Georepublic <https://georepublic.info/en/>`__"

msgid "`Google Summer of Code <https://summerofcode.withgoogle.com>`__"
msgstr "`Google Summer of Code <https://summerofcode.withgoogle.com>`__"

msgid "`Paragon Corporation <https://www.paragoncorporation.com/>`__"
msgstr "`Paragon Corporation <https://www.paragoncorporation.com/>`__"

msgid "Contributors Past & Present:"
msgstr "过去与现在的贡献者："

msgid "Individuals (in alphabetical order)"
msgstr "个人贡献者（按字母排序）"

msgid ""
"Aasheesh Tiwari, Abhinav Jain, Aditya Pratap Singh, Adrien Berchet, Akio "
"Takubo, Andrea Nardelli, Anthony Tasca, Anton Patrushev, Aryan Gupta, Ashraf "
"Hossain, Ashish Kumar, Cayetano Benavent, Christian Gonzalez, Daniel Kastl, "
"Dave Potts, David Techer, Denis Rykov, Ema Miyawaki, Esteban Zimanyi, "
"Florian Thurkow, Frederic Junod, Gerald Fenoy, Gudesa Venkata Sai Akhil, "
"Hang Wu, Himanshu Raj, Imre Samu, Jay Mahadeokar, Jinfu Leng, Kai Behncke, "
"Kishore Kumar, Ko Nagase, Mahmoud Sakr, Manikata Kondeti, Mario Basa, Martin "
"Wiesenhaan, Maxim Dubinin, Maoguang Wang, Mohamed Bakli, Mohamed Zia, Mukul "
"Priya, Nitish Chauhan, Rajat Shinde, Razequl Islam, Regina Obe, Rohith "
"Reddy, Sarthak Agarwal, Shobhit Chaurasia, Sourabh Garg, Stephen Woodbridge, "
"Swapnil Joshi, Sylvain Housseman, Sylvain Pasche, Veenit Kumar, Vidhan Jain, "
"Virginia Vergara, Yige Huang"
msgstr ""
"Aasheesh Tiwari, Abhinav Jain, Aditya Pratap Singh, Adrien Berchet, Akio "
"Takubo, Andrea Nardelli, Anthony Tasca, Anton Patrushev, Aryan Gupta, Ashraf "
"Hossain, Ashish Kumar, Cayetano Benavent, Christian Gonzalez, Daniel Kastl, "
"Dave Potts, David Techer, Denis Rykov, Ema Miyawaki, Esteban Zimanyi, "
"Florian Thurkow, Frederic Junod, Gerald Fenoy, Gudesa Venkata Sai Akhil, "
"Hang Wu, Himanshu Raj, Imre Samu, Jay Mahadeokar, Jinfu Leng, Kai Behncke, "
"Kishore Kumar, Ko Nagase, Mahmoud Sakr, Manikata Kondeti, Mario Basa, Martin "
"Wiesenhaan, Maxim Dubinin, Maoguang Wang, Mohamed Bakli, Mohamed Zia, Mukul "
"Priya, Nitish Chauhan, Rajat Shinde, Razequl Islam, Regina Obe, Rohith "
"Reddy, Sarthak Agarwal, Shobhit Chaurasia, Sourabh Garg, Stephen Woodbridge, "
"Swapnil Joshi, Sylvain Housseman, Sylvain Pasche, Veenit Kumar, Vidhan Jain, "
"Virginia Vergara, Yige Huang"

msgid "Corporate Sponsors (in alphabetical order)"
msgstr "企业赞助商（按字母顺序排列）"

msgid "Camptocamp"
msgstr "Camptocamp"

msgid "CSIS (University of Tokyo)"
msgstr "CSIS (University of Tokyo)"

msgid "Georepublic"
msgstr "Georepublic"

msgid "Google Summer of Code"
msgstr "Google Summer of Code"

msgid "iMaptools"
msgstr "iMaptools"

msgid "Leopark"
msgstr "Leopark"

msgid "Orkney"
msgstr "Orkney"

msgid "Paragon Corporation"
msgstr "Paragon Corporation"

msgid "Versaterm Inc."
msgstr "Versaterm Inc."

msgid "More Information"
msgstr "更多信息"

msgid ""
"The latest software, documentation and news items are available at the "
"pgRouting web site https://pgrouting.org."
msgstr ""
"最新的软件、文档和新闻可在 pgRouting 网站 https://pgrouting.org 上获取。"

msgid ""
"PostgreSQL database server at the PostgreSQL main site https://www."
"postgresql.org."
msgstr ""
"PostgreSQL 数据库服务器位于 PostgreSQL 主站点 https://www.postgresql.org。"

msgid "PostGIS extension at the PostGIS project web site https://postgis.net."
msgstr "PostGIS 项目网站 https://postgis.net 上的 PostGIS 扩展。"

msgid "Boost C++ source libraries at https://www.boost.org."
msgstr "Boost C++ 源库位于 https://www.boost.org。"

msgid ""
"The Migration guide from 2.6 can be found at https://github.com/pgRouting/"
"pgrouting/wiki/Migration-Guide."
msgstr ""
"2.6 版的迁移指南可以在 https://github.com/pgRouting/pgrouting/wiki/Migration-"
"Guide 找到。"

msgid "pgr_KSP"
msgstr "pgr_KSP"

msgid "``pgr_KSP`` — Yen's algorithm for K shortest paths using Dijkstra."
msgstr "``pgr_KSP`` — Yen 使用 Dijkstra 计算 K 最短路径的算法。"

msgid "Availability"
msgstr "可用性"

msgid "Version 3.6.0"
msgstr "版本3.6.0"

msgid "Return columns standarized to: |nksp-result|"
msgstr "返回标准化后的列：|nksp-result|"

msgid "``pgr_ksp`` (One to One)"
msgstr "``pgr_ksp`` (一对一)"

msgid "Added ``start_vid`` and ``end_vid`` result columns."
msgstr "增加``start_vid``和``end_vid``结果列。"

msgid "New overload functions:"
msgstr "新的重载函数："

msgid "``pgr_ksp`` (One to Many)"
msgstr "``pgr_ksp`` (一对多)"

msgid "``pgr_ksp`` (Many to One)"
msgstr "``pgr_ksp`` (多对一)"

msgid "``pgr_ksp`` (Many to Many)"
msgstr "``pgr_ksp`` (多对多)"

msgid "``pgr_ksp`` (Combinations)"
msgstr "``pgr_ksp`` (组合)"

msgid "Version 2.1.0"
msgstr "版本2.1.0"

msgid "Signature change"
msgstr "签名变更"

msgid "Old signature no longer supported"
msgstr "不再支持旧签名"

msgid "Version 2.0.0"
msgstr "版本2.0.0"

msgid "**Official** function"
msgstr "**官方** 函数"

msgid ""
"The K shortest path routing algorithm based on Yen's algorithm. \"K\" is the "
"number of shortest paths desired."
msgstr "基于Yen算法的K最短路径路由算法。 “K”是所需的最短路径的数量。"

msgid "Signatures"
msgstr "签名"

msgid "Summary"
msgstr "总结"

msgid "pgr_KSP(`Edges SQL`_, **start vid**, **end vid**, **K**, [**options**])"
msgstr ""
"pgr_KSP(`Edges SQL`_, **start vid**, **end vid**, **K**, [**options**])"

msgid ""
"pgr_KSP(`Edges SQL`_, **start vid**, **end vids**, **K**, [**options**])"
msgstr ""
"pgr_KSP(`Edges SQL`_, **start vid**, **end vids**, **K**, [**options**])"

msgid ""
"pgr_KSP(`Edges SQL`_, **start vids**, **end vid**, **K**, [**options**])"
msgstr ""
"pgr_KSP(`Edges SQL`_, **start vids**, **end vid**, **K**, [**options**])"

msgid ""
"pgr_KSP(`Edges SQL`_, **start vids**, **end vids**, **K**, [**options**])"
msgstr ""
"pgr_KSP(`Edges SQL`_, **start vids**, **end vids**, **K**, [**options**])"

msgid "pgr_KSP(`Edges SQL`_, `Combinations SQL`_, **K**, [**options**])"
msgstr "pgr_KSP(`Edges SQL`_, `Combinations SQL`_, **K**, [**options**])"

msgid "**options:** ``[directed, heap_paths]``"
msgstr "**options:** ``[directed, heap_paths]``"

msgid "RETURNS SET OF |nksp-result|"
msgstr "RETURNS SET OF |nksp-result|"

msgid "OR EMPTY SET"
msgstr "OR EMPTY SET"

msgid "Example"
msgstr "示例"

msgid "Get 2 paths from :math:`6` to :math:`17` on a directed graph."
msgstr "在有向图上获取从 :math:`6` 到 :math:`17`的 2 条路径。"

msgid ""
"Get 2 paths from vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a "
"directed graph."
msgstr "获取有向图上从顶点:math:`6`到顶点 :math:`\\{10, 17\\}`的 2 条路径。"

msgid ""
"Get 2 paths from vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a "
"directed graph."
msgstr "在有向图中得到从顶点 :math:`\\{6, 1\\}`到顶点 :math:`17`的2条路经。"

msgid ""
"Get 2 paths vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 17\\}` on "
"a directed graph."
msgstr ""
"在有向图中得到从顶点 :math:`\\{6, 1\\}`到顶点 :math:`\\{10, 17\\}`的2条路经。"

msgid "Using a combinations table on an directed graph"
msgstr "在有向图上使用组合表"

msgid "The combinations table:"
msgstr "组合表："

msgid "The query:"
msgstr "查询："

msgid "Identifier of the destination vertex."
msgstr "目标顶点的标识符。"

msgid "**K**"
msgstr "**K**"

msgid "Number of required paths."
msgstr "所需路径的数量。"

msgid "KSP Optional parameters"
msgstr "KSP 可选参数"

msgid "``heap_paths``"
msgstr "``heap_paths``"

msgid "When ``false`` Returns at most K paths."
msgstr "当``false``时返回最多 K 条路径。"

msgid "When ``true`` all the calculated paths while processing are returned."
msgstr "当 ``true`` 时，返回处理时的所有计算路径。"

msgid ""
"Roughly, when the shortest path has ``N`` edges, the heap will contain about "
"than ``N * K`` paths for small value of ``K`` and ``K > 5``."
msgstr ""
"粗略地说，当最短路径有 ``N`` 个边时，对于``K``值较小且``K > 5``，堆将包含大"
"约 ``N * K`` 条路径。"

msgid "Returns set of |nksp-result|"
msgstr "返回集合|nksp-result|"

msgid ""
"Has value **1** for the first of a path from ``start_vid`` to ``end_vid``"
msgstr "从``start_vid``到 ``end_vid``的第一个路径的值为 **1**"

msgid "Identifier of the node in the path from ``start_vid`` to ``end_vid``"
msgstr "从``start_vid`` 到 ``end_vid``路径中节点的标识符"

msgid ":math:`0` for the last ``node`` of the path."
msgstr ":math:`0`为路径的最后一个``node``。"

msgid "Aggregate cost from **start vid** to ``node``."
msgstr "从 **start vid**到``node``的总成本。"

msgid "Additional Examples"
msgstr "其他示例"

msgid "Get 2 paths from :math:`6` to :math:`17` on an undirected graph"
msgstr "在无向图中获取从 :math:`6`到:math:`17`的2条路径"

msgid "Also get the paths in the heap."
msgstr "还获取堆中的路径。"

msgid "Get 2 paths using combinations table on an undirected graph"
msgstr "使用无向图上的组合表获取 2 条路径"

msgid ""
"Get 2 paths from vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a "
"undirected graph."
msgstr "在无向图中获取从顶点 :math:`\\{6, 1\\}`到顶点:math:`17`的2条路径。"

msgid "https://en.wikipedia.org/wiki/K_shortest_path_routing"
msgstr "https://en.wikipedia.org/wiki/K_shortest_path_routing"

msgid "``pgr_TSP``"
msgstr "``pgr_TSP``"

msgid "``pgr_TSP`` - Aproximation using *metric* algorithm."
msgstr "``pgr_TSP`` -使用*metric*算法的近似方法。"

msgid "Availability:"
msgstr "可用性："

msgid "Version 3.2.1"
msgstr "版本3.2.1"

msgid ""
"Metric Algorithm from `Boost library <https://www.boost.org/libs/graph/doc/"
"metric_tsp_approx.html>`__"
msgstr ""
"`Boost库 <https://www.boost.org/libs/graph/doc/metric_tsp_approx.html>`__中的"
"度量算法"

msgid "Simulated Annealing Algorithm no longer supported"
msgstr "Simulated Annealing算法不再受支持"

msgid ""
"The Simulated Annealing Algorithm related parameters are ignored: "
"max_processing_time, tries_per_temperature, max_changes_per_temperature, "
"max_consecutive_non_changes, initial_temperature, final_temperature, "
"cooling_factor, randomize"
msgstr ""
"Simulated Annealing算法相关参数被忽略：max_processing_time、"
"tries_per_temper、max_changes_per_tempere、max_consecutive_non_changes、"
"initial_temper、final_temper、cooling_factor、randomize"

msgid "Version 2.3.0"
msgstr "版本2.3.0"

msgid ""
"Can be Used with :doc:`costMatrix-category` functions preferably with "
"`directed => false`."
msgstr ""
"可以与:doc:`costMatrix-category` 函数一起使用，最好使用 `directed => false`。"

msgid "With ``directed => false``"
msgstr "使用``directed => false``"

msgid "Will generate a graph that:"
msgstr "将生成一个图："

msgid "is undirected"
msgstr "是无向的"

msgid "is fully connected (As long as the graph has one component)"
msgstr "是完全连接的（只要图有一个分量）"

msgid "all traveling costs on edges obey the triangle inequality."
msgstr "所有边上的旅行成本都遵循三角不等式。"

msgid "When ``start_vid = 0 OR end_vid = 0``"
msgstr "当``start_vid = 0 OR end_vid = 0``"

msgid ""
"The solutions generated is garanteed to be *twice as long as the optimal "
"tour in the worst case*"
msgstr "生成的解决方案保证是*最坏情况下最优路径时间的两倍*"

msgid "When ``start_vid != 0 AND end_vid != 0 AND start_vid != end_vid``"
msgstr "当 ``start_vid != 0 AND end_vid != 0 AND start_vid != end_vid``"

msgid ""
"It is **not garanteed** that the solution will be, in the worse case, twice "
"as long as the optimal tour, due to the fact that `end_vid` is forced to be "
"in a fixed position."
msgstr ""
"在最坏情况下，**不能保证**解决方案将是最优路径的两倍长，因为 `end_vid` 被强制"
"设置在固定位置。"

msgid "With ``directed => true``"
msgstr "当``directed => true``"

msgid ""
"It is **not garanteed** that the solution will be, in the worse case, twice "
"as long as the optimal tour"
msgstr "**不能保证**在最坏情况下解决方案将是最优路径的两倍长"

msgid "is directed"
msgstr "有向"

msgid ""
"some (or all) traveling costs on edges might not obey the triangle "
"inequality."
msgstr "某些（或全部）边上的旅行成本可能不满足三角不等式。"

msgid ""
"As an undirected graph is required, the directed graph is transformed as "
"follows:"
msgstr "由于需要无向图，有向图变换如下："

msgid ""
"edges `(u, v)` and `(v, u)` is considered to be the same edge (denoted `(u, "
"v)`"
msgstr "边 `(u, v)`和 `(v, u)`被认为是相同的边（表示为 `(u, v)`"

msgid "if ``agg_cost`` differs between one or more instances of edge `(u, v)`"
msgstr "如果 ``agg_cost`` 在边`(u, v)` 的一个或多个实例之间不同"

msgid ""
"The minimum value of the ``agg_cost`` all instances of edge `(u, v)` is "
"going to be considered as the ``agg_cost`` of edge  `(u, v)`"
msgstr ""
"边 `(u, v)` 的所有实例的  ``agg_cost`` 最小值将被视为边`(u, v)`的  "
"``agg_cost``"

msgid ""
"Some (or all) traveling costs on edges will still might not obey the "
"triangle inequality."
msgstr "边上的一些（或全部）旅行成本仍然可能不遵守三角不等式。"

msgid "When the data is incomplete, but it is a connected graph:"
msgstr "当数据不完整，但是是连通图时："

msgid "the missing values will be calculated with dijkstra algorithm."
msgstr "缺失值将使用 dijkstra 算法计算。"

msgid "pgr_TSP(`Matrix SQL`_, ``[start_id, end_id]``)"
msgstr "pgr_TSP(`Matrix SQL`_, ``[start_id, end_id]``)"

msgid "RETURNS SET OF |tsp-result|"
msgstr "RETURNS SET OF |tsp-result|"

msgid "OR EMTPY SET"
msgstr "OR EMTPY SET"

msgid "Using :doc:`pgr_dijkstraCostMatrix` to generate the matrix information"
msgstr "使用:doc:`pgr_dijkstraCostMatrix` 生成矩阵信息"

msgid ""
"**Line 4** Vertices :math:`\\{2, 4, 13, 14\\}` are not included because they "
"are not connected."
msgstr ""
"**Line 4** 顶点 :math:`\\{2, 4, 13, 14\\}` 不包括在内，因为它们未连接。"

msgid "`Matrix SQL`_ as described below"
msgstr "`Matrix SQL`_如下所述"

msgid "``ANY-INTEGER``"
msgstr "``ANY-INTEGER``"

msgid "``ANY-NUMERICAL``"
msgstr "``ANY-NUMERICAL``"

msgid "Cost for going from start_vid to end_vid"
msgstr "从 start_vid 到 end_vid 的成本"

msgid "Returns SET OF ``(seq, node, cost, agg_cost)``"
msgstr "返回集合``(seq, node, cost, agg_cost)``"

msgid "Row sequence."
msgstr "行顺序。"

msgid "**node**"
msgstr "**node**"

msgid "Identifier of the node/coordinate/point."
msgstr "节点/坐标/点的标识符。"

msgid ""
"Cost to traverse from the current ``node`` to the next ``node`` in the path "
"sequence."
msgstr "从路径序列中的当前 ``node``遍历到下一个``node`` 的成本。"

msgid "``0`` for the last row in the tour sequence."
msgstr "``0`` 表示游览序列中的最后一行。"

msgid "Aggregate cost from the ``node`` at ``seq = 1`` to the current node."
msgstr "从``seq = 1``的 ``node``到当前节点的总成本。"

msgid "``0`` for the first row in the tour sequence."
msgstr "``0``表示游览序列中的第一行。"

msgid "Start from vertex :math:`1`"
msgstr "从顶点 :math:`1`开始"

msgid "**Line 6** ``start_vid => 1``"
msgstr "**Line 6** ``start_vid => 1``"

msgid "Using points of interest to generate an asymetric matrix."
msgstr "使用兴趣点生成不对称矩阵。"

msgid "To generate an asymmetric matrix:"
msgstr "生成非对称矩阵："

msgid ""
"**Line 4** The ``side`` information of ``pointsOfInterset`` is ignored by "
"not including it in the query"
msgstr ""
"**Line 4** 通过未在查询中包括 ``pointsOfInterset`` 中的``side`` 信息而被忽略"

msgid "**Line 6** Generating an asymetric matrix with ``directed => true``"
msgstr "**Line 6** 使用``directed => true``生成一个非对称矩阵"

msgid ""
":math:`min(agg\\_cost(u, v), agg\\_cost(v, u))` is going to be considered as "
"the ``agg_cost``"
msgstr ":math:`min(agg\\_cost(u, v), agg\\_cost(v, u))` 将被视为 ``agg_cost``"

msgid ""
"The solution that can be larger than *twice as long as the optimal tour* "
"because:"
msgstr "该解决方案的长度可能是*最佳行程的两倍以上*，因为："

msgid "Triangle inequality might not be satisfied."
msgstr "三角不等式可能不满足。"

msgid "``start_id != 0 AND end_id != 0``"
msgstr "``start_id != 0 AND end_id != 0``"

msgid "Connected incomplete data"
msgstr "连接不完整数据"

msgid ""
"Using selected edges :math:`\\{2, 4, 5, 8, 9, 15\\}` the matrix is not "
"complete."
msgstr "使用选定的边 :math:`\\{2, 4, 5, 8, 9, 15\\}`，矩阵不完整。"

msgid ""
"Cost value for :math:`17 \\rightarrow 10` do not exist on the matrix, but "
"the value used is taken from :math:`10 \\rightarrow 17`."
msgstr ""
"对于 :math:`17 \\rightarrow 10` 的成本值在矩阵中不存在，但使用的值是从 :math:"
"`10 \\rightarrow 17` 中获取的。"

msgid "``pgr_TSPeuclidean``"
msgstr "``pgr_TSPeuclidean``"

msgid "``pgr_TSPeuclidean`` - Aproximation using *metric* algorithm."
msgstr "``pgr_TSPeuclidean`` -使用*metric*算法进行近似。"

msgid ""
"The Simulated Annealing Algorithm related parameters are ignored: "
"`max_processing_time`, `tries_per_temperature`, "
"`max_changes_per_temperature`, `max_consecutive_non_changes`, "
"`initial_temperature`, `final_temperature`, `cooling_factor`, `randomize`"
msgstr ""
"Simulated Annealing 算法相关参数被忽略： `max_processing_time`, "
"`tries_per_temperature`, `max_changes_per_temperature`, "
"`max_consecutive_non_changes`, `initial_temperature`, `final_temperature`, "
"`cooling_factor`, `randomize`"

msgid "Version 3.0.0"
msgstr "版本3.0.0"

msgid "Name change from pgr_eucledianTSP"
msgstr "pgr_eucledianTSP 的名称更改"

msgid "New **Official** function"
msgstr "**官方**新函数"

msgid ""
"Any duplicated identifier will be ignored. The coordinates that will be kept"
msgstr "任何重复的标识符都将被忽略。 将保留的坐标"

msgid "is arbitrarly."
msgstr "是任意的。"

msgid ""
"The coordinates are quite similar for the same identifier, for example ::"
msgstr "对于相同的标识符，坐标非常相似，例如 ::"

msgid ""
"The coordinates are quite different for the same identifier, for example ::"
msgstr "对于相同的标识符，坐标有很大不同，例如::"

msgid "pgr_TSPeuclidean(`Coordinates SQL`_, ``[start_id, end_id]``)"
msgstr "pgr_TSPeuclidean(`Coordinates SQL`_, ``[start_id, end_id]``)"

msgid "With default values"
msgstr "有默认值"

msgid "`Coordinates SQL`_"
msgstr "`Coordinates SQL`_"

msgid "`Coordinates SQL`_ as described below"
msgstr "`Coordinates SQL`_ 如下所述"

msgid "Coordinates SQL"
msgstr "坐标SQL"

msgid "``x``"
msgstr "``x``"

msgid "X value of the coordinate."
msgstr "坐标的X值。"

msgid "``y``"
msgstr "``y``"

msgid "Y value of the coordinate."
msgstr "坐标的Y值。"

msgid "Test 29 cities of Western Sahara"
msgstr "测试西撒哈拉29个城市"

msgid ""
"This example shows how to make performance tests using University of "
"Waterloo's `example data <https://www.math.uwaterloo.ca/tsp/world/countries."
"html>`__ using the 29 cities of `Western Sahara dataset <https://www.math."
"uwaterloo.ca/tsp/world/wi29.tsp>`__"
msgstr ""
"此示例展示了如何使用Waterloo大学的 `示例数据 <https://www.math.uwaterloo.ca/"
"tsp/world/countries.html>`__（使用西撒哈拉 29 个城市的数据集 <https://www."
"math.uwaterloo.ca/tsp/world/wi29.tsp>`__）进行性能测试"

msgid "Creating a table for the data and storing the data"
msgstr "创建数据表并存储数据"

msgid "Adding a geometry (for visual purposes)"
msgstr "添加几何图形（用于视觉目的）"

msgid "Total tour cost"
msgstr "旅游总费用"

msgid ""
"Getting a total cost of the tour, compare the value with the length of an "
"optimal tour is 27603, given on the dataset"
msgstr "获取旅行的总成本，将该值与数据集上给出的最佳旅行长度 27603 进行比较"

msgid "Getting a geometry of the tour"
msgstr "获取游览的几何形状"

msgid "Visual results"
msgstr "视觉效果"

msgid ""
"Visualy, The first image is the `optimal solution <https://www.math."
"uwaterloo.ca/tsp/world/witour.html>`__  and the second image is the solution "
"obtained with ``pgr_TSPeuclidean``."
msgstr ""
"从视觉上看，第一幅图像是 `最优解 <https://www.math.uwaterloo.ca/tsp/world/"
"witour.html>`__ ，第二幅图像是使用 ``pgr_TSPeuclidean``获得的解。"

msgid ":doc:`sampledata` network."
msgstr ":doc:`sampledata` 网络。"

msgid "``pgr_aStar``"
msgstr "``pgr_aStar``"

msgid "``pgr_aStar`` — Shortest path using the A* algorithm."
msgstr "``pgr_aStar`` —使用 A* 算法的最短路径。"

msgid "Standarizing output columns to |short-generic-result|"
msgstr "标准输出列|short-generic-result|"

msgid ""
"``pgr_aStar`` (`One to One`_) added ``start_vid`` and ``end_vid`` columns."
msgstr "``pgr_aStar`` (`一对一`_) 增加 ``start_vid`` 和 ``end_vid`` 列."

msgid "``pgr_aStar`` (`One to Many`_) added ``end_vid`` column."
msgstr "``pgr_aStar`` (`一对多`_) 增加 ``end_vid`` 列."

msgid "``pgr_aStar`` (`Many to One`_) added ``start_vid`` column."
msgstr "``pgr_aStar`` (`多对一`_) 增加 ``start_vid``列."

msgid "Version 3.2.0"
msgstr "版本3.2.0"

msgid "New **proposed** signature:"
msgstr "新 **拟议**的签名："

msgid "``pgr_aStar`` (`Combinations`_)"
msgstr "``pgr_aStar`` (`组合`_)"

msgid "Version 2.4.0"
msgstr "版本2.4.0"

msgid "New **Proposed** signatures:"
msgstr "新**拟议**签名："

msgid "``pgr_aStar`` (`One to Many`_)"
msgstr "``pgr_aStar`` (`一对多`_)"

msgid "``pgr_aStar`` (`Many to One`_)"
msgstr "``pgr_aStar`` (`多对一`_)"

msgid "``pgr_aStar`` (`Many to Many`_)"
msgstr "``pgr_aStar`` (`多对多`_)"

msgid "Signature change on ``pgr_astar`` (`One to One`_)"
msgstr "签名更改``pgr_astar`` (`一对一`_)"

msgid "**Official** ``pgr_aStar`` (`One to One`_)"
msgstr "**官方**``pgr_aStar`` (`一对一`_)"

msgid ""
"The results are equivalent to the union of the results of the `pgr_aStar(` "
"`One to One`_ `)` on the:"
msgstr "结果相当于 `pgr_aStar(` `一对一`_ `)` 结果的并集："

msgid "`pgr_aStar(` `One to Many`_ `)`"
msgstr "`pgr_aStar(` `一对多`_ `)`"

msgid "`pgr_aStar(` `Many to One`_ `)`"
msgstr "`pgr_aStar(` `多对一`_ `)`"

msgid "`pgr_aStar(` `Many to Many`_ `)`"
msgstr "`pgr_aStar(` `多对多`_ `)`"

msgid "`pgr_aStar(` `Combinations`_ `)`"
msgstr "`pgr_aStar(` `组合`_ `)`"

msgid "pgr_aStar(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr "pgr_aStar(`Edges SQL`_, **start vid**, **end vid**, [**options**])"

msgid "pgr_aStar(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr "pgr_aStar(`Edges SQL`_, **start vid**, **end vids**, [**options**])"

msgid "pgr_aStar(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr "pgr_aStar(`Edges SQL`_, **start vids**, **end vid**, [**options**])"

msgid "pgr_aStar(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr "pgr_aStar(`Edges SQL`_, **start vids**, **end vids**, [**options**])"

msgid "pgr_aStar(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr "pgr_aStar(`Edges SQL`_, `Combinations SQL`_, [**options**])"

msgid "**options:** ``[directed, heuristic, factor, epsilon]``"
msgstr "**options:** ``[directed, heuristic, factor, epsilon]``"

msgid "RETURNS SET OF |short-generic-result|"
msgstr "RETURNS SET OF |short-generic-result|"

msgid "Optional parameters are `named parameters` and have a default value."
msgstr "可选参数是`命名参数` 并具有默认值。"

msgid ""
"From vertex :math:`6` to vertex :math:`12` on a **directed** graph with "
"heuristic :math:`2`"
msgstr ""
"在具有heuristic :math:`2` 的**有向**图上，从顶点 :math:`6` 到顶点 :math:`12`"

msgid ""
"From vertex :math:`6` to vertices :math:`\\{10, 12\\}` on a **directed** "
"graph with heuristic :math:`3` and factor :math:`3.5`"
msgstr ""
"在具有heuristic :math:`3` 和factor :math:`3.5` 的**有向**图上，从顶点 :math:"
"`6` 到顶点 :math:`\\{10, 12\\}`"

msgid ""
"From vertices :math:`\\{6, 8\\}` to vertex :math:`10` on an **undirected** "
"graph with heuristic :math:`4`"
msgstr ""
"在具有heuristic :math:`4` 的**无向**图上，从顶点 :math:`\\{6, 8\\}` 到顶点 :"
"math:`10`"

msgid ""
"From vertices :math:`\\{6, 8\\}` to vertices :math:`\\{10, 12\\}` on a "
"**directed** graph with factor :math:`0.5`"
msgstr ""
"在具有factor :math:`0.5` 的**有向**图上，从顶点 :math:`\\{6, 8\\}` 到顶点 :"
"math:`\\{10, 12\\}`"

msgid ""
"Using a combinations table on a **directed** graph with factor :math:`0.5`."
msgstr "在**有向**图上使用组合表，且使用factor :math:`0.5`。"

msgid "Example 1"
msgstr "示例1"

msgid "Demonstration of repeated values are ignored, and result is sorted."
msgstr "演示中重复的值被忽略，且结果被排序。"

msgid "Example 2"
msgstr "示例2"

msgid "Making **start vids** the same as **end vids**."
msgstr "使 **start vids**与**end vids**相同。"

msgid "Example 3"
msgstr "示例3"

msgid "Manually assigned vertex combinations."
msgstr "手动指定的顶点组合。"

msgid "pgr_aStarCost"
msgstr "pgr_aStarCost"

msgid ""
"``pgr_aStarCost`` - Total cost of the shortest path(s) using the A* "
"algorithm."
msgstr "``pgr_aStarCost`` -使用 A* 算法的最短路径的总成本。"

msgid "``pgr_aStarCost`` (`Combinations`_)"
msgstr "``pgr_aStarCost`` (`组合`_)"

msgid "New **proposed** function"
msgstr "新**拟议**函数"

msgid ""
"The ``pgr_aStarCost`` function sumarizes of the cost of the shortest path(s) "
"using the A* algorithm."
msgstr "``pgr_aStarCost`` 函数使用 A* 算法汇总最短路径的成本。"

msgid ""
"Let be the case the values returned are stored in a table, so the unique "
"index would be the pair: `(start_vid, end_vid)`"
msgstr "假设返回的值存储在表中，因此唯一索引将是一对：`(start_vid, end_vid)`"

msgid "For undirected graphs, the results are symmetric."
msgstr "对于无向图，结果是对称的。"

msgid "The returned values are ordered in ascending order:"
msgstr "返回值按升序排列："

msgid "`start_vid` ascending"
msgstr "`start_vid`升序"

msgid "`end_vid` ascending"
msgstr "`end_vid`升序"

msgid "pgr_aStarCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr "pgr_aStarCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"

msgid "pgr_aStarCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""
"pgr_aStarCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"

msgid "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""
"pgr_aStarCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"

msgid ""
"pgr_aStarCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr ""
"pgr_aStarCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"

msgid "pgr_aStarCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr "pgr_aStarCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"

msgid "RETURNS SET OF |matrix-result|"
msgstr "RETURNS SET OF |matrix-result|"

msgid "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vids**, [options])"
msgstr "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vids**, [options])"

msgid "``pgr_aStarCostMatrix``"
msgstr "``pgr_aStarCostMatrix``"

msgid ""
"``pgr_aStarCostMatrix`` - Calculates the a cost matrix using :doc:"
"`pgr_aStar`."
msgstr "``pgr_aStarCostMatrix`` -使用:doc:`pgr_aStar` 计算成本矩阵。"

msgid "Using internaly the :doc:`pgr_aStar` algorithm"
msgstr "内部使用 :doc:`pgr_aStar`算法"

msgid "Returns a cost matrix."
msgstr "返回成本矩阵。"

msgid "No ordering is performed"
msgstr "不进行排序"

msgid "let `v` and `u` are nodes on the graph:"
msgstr "设`v`和 `u` 是图上的节点："

msgid "when there is no path from `v` to `u`:"
msgstr "当没有从`v`到 `u` 的路径时："

msgid "cost from `v` to `u` is :math:`\\inf`"
msgstr "从`v`到 `u`的成本是 :math:`\\inf`"

msgid "when :math:`v = u` then"
msgstr "当 :math:`v = u`时"

msgid "cost from `v` to `u` is :math:`0`"
msgstr "从`v`到`u`的成本是:math:`0`"

msgid "When the graph is **undirected** the cost matrix is symmetric"
msgstr "当图**无向**时，成本矩阵是对称的"

msgid "pgr_aStarCostMatrix(`Edges SQL`_, **start vids**, [**options**])"
msgstr "pgr_aStarCostMatrix(`Edges SQL`_, **start vids**, [**options**])"

msgid ""
"Symmetric cost matrix for vertices :math:`\\{5, 6, 10, 15\\}` on an "
"**undirected** graph using heuristic :math:`2`"
msgstr ""
"在**无向**图上，使用heuristic :math:`2`，对顶点 :math:`\\{5, 6, 10, 15\\}` 创"
"建对称的成本矩阵"

msgid "Use with :doc:`pgr_TSP`"
msgstr "使用 :doc:`pgr_TSP`"

msgid "``pgr_alphaShape``"
msgstr "``pgr_alphaShape``"

msgid "``pgr_alphaShape`` — Polygon part of an alpha shape."
msgstr "``pgr_alphaShape`` — Alpha 形状的多边形部分。"

msgid "Breaking change on signature"
msgstr "签名的重大更改"

msgid "**Boost 1.54** & **Boost 1.55** are supported"
msgstr "**Boost 1.54** & **Boost 1.55**被支持"

msgid "**Boost 1.56+** is preferable"
msgstr "**Boost 1.56+**更好"

msgid "Boost Geometry is stable on Boost 1.56"
msgstr "Boost Geometry 在 Boost 1.56 上保持稳定"

msgid "Added alpha argument with default 0 (use optimal value)"
msgstr "添加了默认值为 0 的 alpha 参数（使用最佳值）"

msgid "Support to return multiple outer/inner ring"
msgstr "支持返回多个外/内圈"

msgid "Renamed from version 1.x"
msgstr "从版本1.X重命名"

msgid "Support"
msgstr "支持"

msgid "Returns the polygon part of an alpha shape."
msgstr "返回 alpha 形状的多边形部分。"

msgid "Input is a *geometry* and returns a *geometry*"
msgstr "输入是*几何图形*并返回*几何图形*"

msgid "Uses PostGis ST_DelaunyTriangles"
msgstr "使用 PostGis ST_DelaunyTriangles"

msgid ""
"Instead of using CGAL's definition of `alpha` it use the ``spoon_radius``"
msgstr "它没有使用 CGAL 的`alpha`定义，而是使用 ``spoon_radius``"

msgid ":math:`spoon\\_radius = \\sqrt alpha`"
msgstr ":math:`spoon\\_radius = \\sqrt alpha`"

msgid ""
"A Triangle area is considered part of the alpha shape when :math:"
"`circumcenter\\ radius < spoon\\_radius`"
msgstr ""
"三角形的面积被认为是 alpha shape 的一部分，当且仅当 :math:`circumcenter\\ "
"radius < spoon\\_radius`"

msgid "The ``alpha`` parameter is the **spoon radius**"
msgstr "``alpha``参数是 **spoon radius**"

msgid ""
"When the total number of points is less than 3, returns an EMPTY geometry"
msgstr "当总点数小于 3 时，返回 EMPTY 几何图形"

msgid "pgr_alphaShape(**geometry**, [alpha])"
msgstr "pgr_alphaShape(**geometry**, [alpha])"

msgid "RETURNS ``geometry``"
msgstr "RETURNS ``geometry``"

msgid ""
"passing a geometry collection with spoon radius :math:`1.5` using the return "
"variable ``geom``"
msgstr "传递一个带有 spoon 半径 :math:`1.5` 的几何集合，使用返回变量 \"geom\""

msgid "**geometry**"
msgstr "**geometry**"

msgid "``geometry``"
msgstr "``geometry``"

msgid "Geometry with at least :math:`3` points"
msgstr "至少包含 :math:`3` 个点的几何形状"

msgid "``alpha``"
msgstr "``alpha``"

msgid "The radius of the spoon."
msgstr "spoon的半径。"

msgid "Return Value"
msgstr "返回值"

msgid "Kind of geometry"
msgstr "几何类型"

msgid "GEOMETRY COLLECTION"
msgstr "GEOMETRY COLLECTION"

msgid "A Geometry collection of Polygons"
msgstr "多边形的几何集合"

msgid ":doc:`pgr_drivingDistance`"
msgstr ":doc:`pgr_drivingDistance`"

msgid "`ST_ConcaveHull <https://postgis.net/docs/ST_ConcaveHull.html>`__"
msgstr "`ST_ConcaveHull <https://postgis.net/docs/ST_ConcaveHull.html>`__"

msgid "pgr_analyzeGraph"
msgstr "pgr_analyzeGraph"

msgid "``pgr_analyzeGraph`` — Analyzes the network topology."
msgstr "``pgr_analyzeGraph`` —分析网络拓扑。"

msgid "The function returns:"
msgstr "函数返回："

msgid "``OK`` after the analysis has finished."
msgstr "``OK``分析完成后。"

msgid "``FAIL`` when the analysis was not completed due to an error."
msgstr "``FAIL``当分析因错误而未完成时。"

msgid "pgr_analyzeGraph(**edge_table**, **tolerance**, [**options**])"
msgstr "pgr_analyzeGraph(**edge_table**, **tolerance**, [**options**])"

msgid "**options:** ``[the_geom, id, source, target, rows_where]``"
msgstr "**options:** ``[the_geom, id, source, target, rows_where]``"

msgid "RETURNS ``VARCHAR``"
msgstr "RETURNS ``VARCHAR``"

msgid "Prerequisites"
msgstr "先决条件"

msgid ""
"The  edge table to be analyzed must contain a source column and a target "
"column filled with id's of the vertices of the segments and the "
"corresponding vertices table <edge_table>_vertices_pgr that stores the "
"vertices information."
msgstr ""
"待分析的边表必须包含源列和目标列，其中填充了线段顶点的id以及对应的存储顶点信"
"息的顶点表<edge_table>_vertices_pgr。"

msgid "Use :doc:`pgr_createVerticesTable` to create the vertices table."
msgstr "使用:doc:`pgr_createVerticesTable`建立顶点表。"

msgid ""
"Use :doc:`pgr_createTopology` to create the topology and the vertices table."
msgstr "使用:doc:`pgr_createTopology`建立拓扑和顶点表。"

msgid "The analyze graph function accepts the following parameters:"
msgstr "分析图函数接受以下参数："

msgid "edge_table"
msgstr "edge_table"

msgid "``text`` Network table name. (may contain the schema name as well)"
msgstr "``text`` 网络表的名称（可能包含模式名称）"

msgid "tolerance"
msgstr "tolerance"

msgid ""
"``float8`` Snapping tolerance of disconnected edges. (in projection unit)"
msgstr "``float8``断开边的捕捉容差。 （以投影单位表示）"

msgid "the_geom"
msgstr "the_geom"

msgid "id"
msgstr "id"

msgid "source"
msgstr "source"

msgid ""
"``text`` Source column name of the network table. Default value is "
"``source``."
msgstr "``text``网络表的Source列名称。 默认值为``source``。"

msgid "target"
msgstr "target"

msgid ""
"``text``  Target column name of the network table.  Default value is "
"``target``."
msgstr "``text``网络表的Target列名称。 默认值为 ``target``。"

msgid "rows_where"
msgstr "rows_where"

msgid ""
"``text``   Condition to select  a subset or rows.  Default value is ``true`` "
"to indicate all rows."
msgstr "``text``选择子集或行的条件。 默认值为``true`` t表示所有行。"

msgid "Uses the vertices table: <edge_table>_vertices_pgr."
msgstr "使用这个顶点表：<edge_table>_vertices_pgr。"

msgid "Fills completely the ``cnt`` and ``chk`` columns of the vertices table."
msgstr "完全填充顶点表的``cnt`` 和``chk`` 列。"

msgid ""
"Returns the analysis of the section of the network defined by  ``rows_where``"
msgstr "返回由``rows_where`` 定义的网络部分的分析结果"

msgid "The vertices table is not found."
msgstr "未找到顶点表。"

msgid ""
"A required column of the Network table is not found or is not of the "
"appropriate type."
msgstr "未找到网络表所需的列或该列的类型不正确。"

msgid "The condition is not well formed."
msgstr "条件尚未形成。"

msgid "The names of source , target or id are the same."
msgstr "source 、 target 或 id 的名称相同。"

msgid "The SRID of the geometry could not be determined."
msgstr "无法确定几何图形的 SRID。"

msgid "The Vertices Table"
msgstr "顶点表"

msgid ""
"The vertices table can be created with :doc:`pgr_createVerticesTable "
"<pgr_createVerticesTable>` or :doc:`pgr_createTopology <pgr_createTopology>`"
msgstr ""
"顶点表可以使用 :doc:`pgr_createVerticesTable <pgr_createVerticesTable>` 或 :"
"doc:`pgr_createTopology <pgr_createTopology>`创建"

msgid "The structure of the vertices table is:"
msgstr "顶点表的结构为："

msgid "``bigint`` Identifier of the vertex."
msgstr "``bigint``顶点的标识符。"

msgid "cnt"
msgstr "cnt"

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex."
msgstr "``integer``edge_table 中引用该顶点的顶点数。"

msgid "chk"
msgstr "chk"

msgid "``integer``  Indicator that the vertex might have a problem."
msgstr "``integer``指示顶点可能有问题。"

msgid "ein"
msgstr "ein"

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"as incoming. See :doc:`pgr_analyzeOneWay <pgr_analyzeOneWay>`."
msgstr ""
"``integer``edge_table 中引用该顶点作为传入的顶点数。 请参阅 :doc:"
"`pgr_analyzeOneWay <pgr_analyzeOneWay>`。"

msgid "eout"
msgstr "eout"

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"as outgoing. See :doc:`pgr_analyzeOneWay <pgr_analyzeOneWay>`."
msgstr ""
"``integer``Edge_table 中引用该顶点作为传出的顶点数。 请参阅 :doc:"
"`pgr_analyzeOneWay <pgr_analyzeOneWay>`。"

msgid "``geometry`` Point geometry of the vertex."
msgstr "``geometry``顶点的点几何。"

msgid "Usage when the edge table's columns MATCH the default values:"
msgstr "当边表的列与默认值匹配时的用法："

msgid "The simplest way to use pgr_analyzeGraph is:"
msgstr "使用 pgr_analyzeGraph 最简单的方法是："

msgid "Arguments are given in the order described in the parameters:"
msgstr "参数按照参数中描述的顺序给出："

msgid "We get the same result as the simplest way to use the function."
msgstr "我们得到与使用该函数的最简单方法相同的结果。"

msgid "An error would occur when"
msgstr "错误将会发生，当"

msgid "the arguments are not given in the appropriate order:"
msgstr "参数未按适当的顺序给出："

msgid ""
"In this example, the column ``id`` of the table ``mytable`` is passed to the "
"function as the geometry column, and the geometry column ``the_geom`` is "
"passed to the function as the id column."
msgstr ""
"在此示例中，表 ``mytable``的列 ``id`` 作为几何列传递给函数，几何列 "
"``the_geom`` 作为 id 列传递给函数。"

msgid "When using the named notation"
msgstr "当使用命名符号时"

msgid "The order of the parameters do not matter:"
msgstr "参数的顺序并不重要："

msgid ""
"Parameters defined with a default value can be omitted, as long as the value "
"matches the default:"
msgstr "定义有默认值的参数可以省略，只要该值与默认值匹配即可："

msgid "Selecting rows using rows_where parameter"
msgstr "使用 rows_where 参数选择行"

msgid ""
"Selecting rows based on the id. Displays the analysis a the section of the "
"network."
msgstr "根据 id 选择行。 显示网络部分的分析。"

msgid ""
"Selecting the rows where the geometry is near the geometry of row with "
"``id`` = 5"
msgstr "选择几何形状接近``id``= 5 的几何形状的行"

msgid ""
"Selecting the rows where the geometry is near the geometry of the row with "
"``gid`` =100 of the table ``othertable``."
msgstr "选择几何形状接近表``othertable`` 的``gid`` = 100 的行的几何形状的行。"

msgid "Usage when the edge table's columns DO NOT MATCH the default values:"
msgstr "当边表的列与默认值不匹配时的用法："

msgid "For the following table"
msgstr "对于下表"

msgid "Using positional notation:"
msgstr "使用位置符号："

msgid ""
"The arguments need to be given in the order described in the parameters:"
msgstr "参数需要按照参数中描述的顺序给出："

msgid ""
"An error would occur when the arguments are not given in the appropriate "
"order: In this example, the column ``gid`` of the table ``mytable`` is "
"passed to the function as the geometry column, and the geometry column "
"``mygeom`` is passed to the function as the id column."
msgstr ""
"如果未按适当的顺序给出参数，则会发生错误：在此示例中，表 ``mytable`` 的列 "
"``gid``作为几何列传递给函数，几何列 ``mygeom`` 作为 id 列传递给函数 。"

msgid ""
"In this scenario omitting a parameter would create an error because the "
"default values for the column names do not match the column names of the "
"table."
msgstr "在这种情况下，省略参数会产生错误，因为列名的默认值与表的列名不匹配。"

msgid "Selecting rows based on the id."
msgstr "根据 id 选择行。"

msgid ""
"Selecting the rows WHERE the geometry is near the geometry of row with "
"``id`` =5 ."
msgstr "选择那些几何与具有``id`` = 5的行的几何接近的行。"

msgid ""
"Selecting the rows WHERE the geometry is near the place='myhouse' of the "
"table ``othertable``. (note the use of quote_literal)"
msgstr ""
"选择几何图形靠近表``othertable``的 place='myhouse' 的行。 （注意 "
"quote_literal 的使用）"

msgid "The examples use the :doc:`sampledata` network."
msgstr "这些示例使用 :doc:`示例数据`网络。"

msgid ":doc:`pgr_analyzeOneWay`"
msgstr ":doc:`pgr_analyzeOneWay`"

msgid ":doc:`pgr_createVerticesTable`"
msgstr ":doc:`pgr_createVerticesTable`"

msgid ":doc:`pgr_nodeNetwork` to create nodes to a not noded edge table."
msgstr ":doc:`pgr_nodeNetwork`创建节点到非节点边表。"

msgid "pgr_analyzeOneWay"
msgstr "pgr_analyzeOneWay"

msgid ""
"``pgr_analyzeOneWay`` — Analyzes oneway Sstreets and identifies flipped "
"segments."
msgstr "``pgr_analyzeOneWay`` — 分析单向街道并识别翻转路段。"

msgid ""
"This function analyzes oneway streets in a graph and identifies any flipped "
"segments."
msgstr "该函数分析图中的单向街道并识别任何翻转的路段。"

msgid ""
"The analyses of one way segments is pretty simple but can be a powerful "
"tools to identifying some the potential problems created by setting the "
"direction of a segment the wrong way. A node is a `source` if it has edges "
"the exit from that node and no edges enter that node. Conversely, a node is "
"a `sink` if all edges enter the node but none exit that node. For a `source` "
"type node it is logically impossible to exist because no vehicle can exit "
"the node if no vehicle and enter the node. Likewise, if you had a `sink` "
"node you would have an infinite number of vehicle piling up on this node "
"because you can enter it but not leave it."
msgstr ""
"单向路段的分析非常简单，但可以成为一种强大的工具，可以识别由于错误地设置路段"
"方向而产生的一些潜在问题。 如果一个节点有从该节点出口的边并且没有边进入该节"
"点，则该节点是`source` 。 相反，如果所有边都进入该节点但没有一条边退出该节"
"点，则该节点是`sink`。 对于`source` 类型节点来说，逻辑上不可能存在，因为如果"
"没有车辆进入该节点，则任何车辆都无法离开该节点。 同样，如果您有一个`sink`节"
"点，那么您将在该节点上堆积无限数量的车辆，因为您可以进入它但不能离开它。"

msgid ""
"So why do we care if the are not feasible? Well if the direction of an edge "
"was reversed by mistake we could generate exactly these conditions. Think "
"about a divided highway and on the north bound lane one segment got entered "
"wrong or maybe a sequence of multiple segments got entered wrong or maybe "
"this happened on a round-about. The result would be potentially a `source` "
"and/or a `sink` node."
msgstr ""
"那么我们为什么要关心这些是否不可行呢？ 如果边的方向被错误地反转，我们就可以准"
"确地生成这些条件。 想象一下一条分开的高速公路，在北行车道上，有一个路段输入错"
"误，或者可能是一系列多个路段输入错误，或者这可能发生在环岛上。 结果可能是 "
"`source` 节点和/或`sink`节点。"

msgid ""
"So by counting the number of edges entering and exiting each node we can "
"identify both `source` and `sink` nodes so that you can look at those areas "
"of your network to make repairs and/or report the problem back to your data "
"vendor."
msgstr ""
"因此，通过计算进入和退出每个节点的边数，我们可以识别 `source`节点和`sink`节"
"点，以便您可以查看网络的这些区域以进行修复和/或将问题报告给数据供应商。"

msgid ""
"pgr_analyzeOneWay(**geom_table**, **s_in_rules**, **s_out_rules**, "
"**t_in_rules**, **t_out_rules**, [**options**])"
msgstr ""
"pgr_analyzeOneWay(**geom_table**, **s_in_rules**, **s_out_rules**, "
"**t_in_rules**, **t_out_rules**, [**options**])"

msgid "**options:** ``[oneway, source, target, two_way_if_null]``"
msgstr "**options:** ``[oneway, source, target, two_way_if_null]``"

msgid "RETURNS ``TEXT``"
msgstr "RETURNS ``TEXT``"

msgid "s_in_rules"
msgstr "s_in_rules"

msgid "``text[]`` source node **in** rules"
msgstr "``text[]``source节点**输入**规则"

msgid "s_out_rules"
msgstr "s_out_rules"

msgid "``text[]`` source node **out** rules"
msgstr "``text[]``source节点**输出**规则"

msgid "t_in_rules"
msgstr "t_in_rules"

msgid "``text[]`` target node **in** rules"
msgstr "``text[]``target节点**输入**规则"

msgid "t_out_rules"
msgstr "t_out_rules"

msgid "``text[]`` target node **out** rules"
msgstr "``text[]``target节点**输出**规则"

msgid "oneway"
msgstr "oneway"

msgid ""
"``text`` oneway column name name of the network table. Default value is "
"``oneway``."
msgstr "``text``oneway 列名，网络表的名称。 默认值为``oneway``。"

msgid "two_way_if_null"
msgstr "two_way_if_null"

msgid ""
"``boolean`` flag to treat oneway NULL values as bi-directional.  Default "
"value is ``true``."
msgstr "``boolean``将单向 NULL 值视为双向的标志。 默认值为  ``true``。"

msgid ""
"It is strongly recommended to use the named notation. See :doc:"
"`pgr_createVerticesTable` or :doc:`pgr_createTopology` for examples."
msgstr ""
"强烈建议使用命名符号。 有关示例，请参阅 :doc:`pgr_createVerticesTable` 或 :"
"doc:`pgr_createTopology`。"

msgid ""
"Fills completely the ``ein`` and ``eout`` columns of the vertices table."
msgstr "完全填充顶点表的 ``ein``和 ``eout`` 列。"

msgid "The names of source , target or oneway are the same."
msgstr "source 、 target 或 oneway 的名称相同。"

msgid ""
"The rules are defined as an array of text strings that if match the "
"``oneway`` value would be counted as ``true`` for the source or target "
"**in** or **out** condition."
msgstr ""
"这些规则被定义为文本字符串数组，如果与 ``oneway``值匹配，则 source或 target**"
"输入**或**输出**条件将被视为``true``。"

msgid ""
"The vertices table can be created with :doc:`pgr_createVerticesTable` or :"
"doc:`pgr_createTopology`"
msgstr ""
"顶点表可以使用 :doc:`pgr_createVerticesTable` 或 :doc:`pgr_createTopology`创"
"建"

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex. "
"See :doc:`pgr_analyzeGgraph <pgr_analyzeGraph>`."
msgstr ""
"``integer``edge_table 中引用该顶点的顶点数。 请参阅 :doc:`pgr_analyzeGgraph "
"<pgr_analyzeGraph>`。"

msgid ""
"``integer``  Indicator that the vertex might have a problem. See :doc:"
"`pgr_analyzeGraph <pgr_analyzeGraph>`."
msgstr ""
"``integer``指示顶点可能有问题。 请参阅 :doc:`pgr_analyzeGraph "
"<pgr_analyzeGraph>`。"

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"as incoming."
msgstr "``integer``edge_table 中引用该顶点作为传入的顶点数。"

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"as outgoing."
msgstr "``integer``Edge_table 中引用该顶点作为传出的顶点数。"

msgid ":doc:`pgr_analyzeGraph`"
msgstr ":doc:`pgr_analyzeGraph`"

msgid "``pgr_articulationPoints``"
msgstr "``pgr_articulationPoints``"

msgid ""
"``pgr_articulationPoints`` - Return the articulation points of an undirected "
"graph."
msgstr "``pgr_articulationPoints`` - 返回无向图的连接点。"

msgid "Return columns change: ``seq`` is removed"
msgstr "返回列更改：``seq``被删除"

msgid "Version 2.5.0"
msgstr "版本2.5.0"

msgid "New **experimental** function"
msgstr "新**实验**函数"

msgid ""
"Those vertices that belong to more than one biconnected component are called "
"articulation points or, equivalently, cut vertices. Articulation points are "
"vertices whose removal would increase the number of connected components in "
"the graph. This implementation can only be used with an undirected graph."
msgstr ""
"那些属于多于一个双连通分量的顶点被称为关节点，或者等效地称为割点。关节点是指"
"那些如果被移除，会增加图中连接分量数量的顶点。这个实现仅适用于无向图。"

msgid "Works for **undirected** graphs."
msgstr "适用于**无向**图。"

msgid "``node`` ascending"
msgstr "``node``升序"

msgid "Running time: :math:`O(V + E)`"
msgstr "运行时间：:math:`O(V + E)`"

msgid "pgr_articulationPoints(`Edges SQL`_)"
msgstr "pgr_articulationPoints(`Edges SQL`_)"

msgid "RETURNS SET OF |result-node|"
msgstr "RETURNS SET OF |result-node|"

msgid "The articulation points of the graph"
msgstr "图表的连接点"

msgid "Nodes in red are the articulation points."
msgstr "红色节点是关节点。"

msgid "Returns set of |result-node|"
msgstr "Returns set of |result-node|"

msgid ""
"Boost: `Biconnected components & articulation points <https://www.boost.org/"
"libs/graph/doc/biconnected_components.html>`__"
msgstr ""
"Boost: `双连通分量和关节点 <https://www.boost.org/libs/graph/doc/"
"biconnected_components.html>`__"

msgid ""
"wikipedia: `Biconnected component <https://en.wikipedia.org/wiki/"
"Biconnected_component>`__"
msgstr ""
"维基百科: `双连通分量 <https://en.wikipedia.org/wiki/"
"Biconnected_component>`__"

msgid "``pgr_bdAstar``"
msgstr "``pgr_bdAstar``"

msgid "``pgr_bdAstar`` — Shortest path using the bidirectional A* algorithm."
msgstr "``pgr_bdAstar`` — 使用双向 A* 算法的最短路径。"

msgid ""
"``pgr_bdAstar`` (`One to One`_) added ``start_vid`` and ``end_vid`` columns."
msgstr "``pgr_bdAstar`` (`一对一`_) 增加``start_vid`` 和 ``end_vid``列。"

msgid "``pgr_bdAstar`` (`One to Many`_) added ``end_vid`` column."
msgstr "``pgr_bdAstar`` (`一对多`_) 增加``end_vid`` 列。"

msgid "``pgr_bdAstar`` (`Many to One`_) added ``start_vid`` column."
msgstr "``pgr_bdAstar`` (`多对一`_) 增加``start_vid``列。"

msgid "``pgr_bdAstar`` (`Combinations`_)"
msgstr "``pgr_bdAstar`` (`组合`_)"

msgid "``pgr_bdAstar`` (`One to Many`_)"
msgstr "``pgr_bdAstar`` (`一对多`_)"

msgid "``pgr_bdAstar`` (`Many to One`_)"
msgstr "``pgr_bdAstar`` (`多对一`_)"

msgid "``pgr_bdAstar`` (`Many to Many`_)"
msgstr "``pgr_bdAstar`` (`多对多`_)"

msgid "Signature change on ``pgr_bdAstar`` (`One to One`_)"
msgstr "在``pgr_bdAstar`` (`一对一`_)上的签名更改"

msgid "**Official** ``pgr_bdAstar`` (`One to One`_)"
msgstr "**官方**``pgr_bdAstar`` (`一对一`_)"

msgid ""
"The results are equivalent to the union of the results of the `pgr_bdAStar(` "
"`One to One`_ `)` on the:"
msgstr "结果相当于`pgr_bdAStar(` `一对一`_ `)` 结果的并集："

msgid "`pgr_bdAstar(` `One to Many`_ `)`"
msgstr "`pgr_bdAstar(` `一对多`_ `)`"

msgid "`pgr_bdAstar(` `Many to One`_ `)`"
msgstr "`pgr_bdAstar(` `多对一`_ `)`"

msgid "`pgr_bdAstar(` `Many to Many`_ `)`"
msgstr "`pgr_bdAstar(` `多对多`_ `)`"

msgid "`pgr_bdAstar(` `Combinations`_ `)`"
msgstr "`pgr_bdAstar(` `组合`_ `)`"

msgid "pgr_bdAstar(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr "pgr_bdAstar(`Edges SQL`_, **start vid**, **end vid**, [**options**])"

msgid "pgr_bdAstar(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr "pgr_bdAstar(`Edges SQL`_, **start vid**, **end vids**, [**options**])"

msgid "pgr_bdAstar(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr "pgr_bdAstar(`Edges SQL`_, **start vids**, **end vid**, [**options**])"

msgid "pgr_bdAstar(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr "pgr_bdAstar(`Edges SQL`_, **start vids**, **end vids**, [**options**])"

msgid "pgr_bdAstar(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr "pgr_bdAstar(`Edges SQL`_, `Combinations SQL`_, [**options**])"

msgid "pgr_bdAstarCost"
msgstr "pgr_bdAstarCost"

msgid ""
"``pgr_bdAstarCost`` - Total cost of the shortest path(s) using the "
"bidirectional A* algorithm."
msgstr "``pgr_bdAstarCost`` -使用双向 A* 算法的最短路径的总成本。"

msgid "``pgr_bdAstarCost`` (`Combinations`_)"
msgstr "``pgr_bdAstarCost`` (`组合`_)"

msgid ""
"The ``pgr_bdAstarCost`` function sumarizes of the cost of the shortest "
"path(s) using the bidirectional A* algorithm."
msgstr "``pgr_bdAstarCost``函数使用双向 A* 算法汇总最短路径的成本。"

msgid ""
"pgr_bdAstarCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr ""
"pgr_bdAstarCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"

msgid ""
"pgr_bdAstarCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""
"pgr_bdAstarCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"

msgid ""
"pgr_bdAstarCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""
"pgr_bdAstarCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"

msgid ""
"pgr_bdAstarCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr ""
"pgr_bdAstarCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"

msgid "pgr_bdAstarCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr "pgr_bdAstarCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"

msgid "``pgr_bdAstarCostMatrix``"
msgstr "``pgr_bdAstarCostMatrix``"

msgid ""
"``pgr_bdAstarCostMatrix`` - Calculates the a cost matrix using :doc:"
"`pgr_aStar`."
msgstr "``pgr_bdAstarCostMatrix`` - 使用:doc:`pgr_aStar` 计算成本矩阵。"

msgid "Using internaly the :doc:`pgr_bdAstar` algorithm"
msgstr "内部使用 :doc:`pgr_bdAstar` 算法"

msgid "pgr_bdAstarCostMatrix(`Edges SQL`_, **start vids**, [**options**])"
msgstr "pgr_bdAstarCostMatrix(`Edges SQL`_, **start vids**, [**options**])"

msgid "``pgr_bdDijkstra``"
msgstr "``pgr_bdDijkstra``"

msgid ""
"``pgr_bdDijkstra`` — Returns the shortest path(s) using Bidirectional "
"Dijkstra algorithm."
msgstr "``pgr_bdDijkstra`` — 使用双向 Dijkstra 算法返回最短路径。"

msgid "pgr_bdDijkstra(`Combinations`_)"
msgstr "pgr_bdDijkstra(`组合`_)"

msgid "New **Proposed** functions:"
msgstr "新**拟议**函数："

msgid "``pgr_bdDijkstra`` (`One to Many`_)"
msgstr "``pgr_bdDijkstra`` (`一对多`_)"

msgid "``pgr_bdDijkstra`` (`Many to One`_)"
msgstr "``pgr_bdDijkstra`` (`多对一`_)"

msgid "``pgr_bdDijkstra`` (`Many to Many`_)"
msgstr "``pgr_bdDijkstra`` (`多对多`_)"

msgid "Signature change on ``pgr_bdDijsktra`` (`One to One`_)"
msgstr "``pgr_bdDijsktra`` (`一对一`_)上的签名更改"

msgid "**Official** ``pgr_bdDijkstra`` (`One to One`_)"
msgstr "**官方** ``pgr_bdDijkstra`` (`一对一`_)"

msgid ""
"pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""
"pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid ""
"pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""
"pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid ""
"pgr_bdDijkstra(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""
"pgr_bdDijkstra(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"

msgid ""
"pgr_bdDijkstra(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr ""
"pgr_bdDijkstra(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_bdDijkstra(`Edges SQL`_, `Combinations SQL`_ , [``directed``])"
msgstr "pgr_bdDijkstra(`Edges SQL`_, `Combinations SQL`_ , [``directed``])"

msgid "RETURNS SET OF |old-generic-result|"
msgstr "RETURNS SET OF |old-generic-result|"

msgid "RETURNS SET OF |result-1-1|"
msgstr "RETURNS SET OF |result-1-1|"

msgid "RETURNS SET OF |result-1-m|"
msgstr "RETURNS SET OF |result-1-m|"

msgid ""
"From vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a **directed** "
"graph"
msgstr "在**有向**图上从顶点:math:`6`到顶点:math:`\\{10, 17\\}`"

msgid "RETURNS SET OF |result-m-1|"
msgstr "RETURNS SET OF |result-m-1|"

msgid ""
"From vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a **directed** graph"
msgstr "在**有向**图上从顶点 :math:`\\{6, 1\\}`到顶点:math:`17`"

msgid ""
"From vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 17\\}` on an "
"**undirected** graph"
msgstr "在**无向**图上从顶点 :math:`\\{6, 1\\}`到顶点 :math:`\\{10, 17\\}`"

msgid "pgr_bdDijkstra(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_bdDijkstra(`Edges SQL`_, `Combinations SQL`_, [``directed``])"

msgid "Using a combinations table on an **undirected** graph"
msgstr "在**无向**图上使用组合表"

msgid ""
"https://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/EPP"
"%20shortest%20path%20algorithms.pdf"
msgstr ""
"https://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/EPP"
"%20shortest%20path%20algorithms.pdf"

msgid "https://en.wikipedia.org/wiki/Bidirectional_search"
msgstr "https://en.wikipedia.org/wiki/Bidirectional_search"

msgid "``pgr_bdDijkstraCost``"
msgstr "``pgr_bdDijkstraCost``"

msgid ""
"``pgr_bdDijkstraCost`` — Returns the shortest path(s)'s cost using "
"Bidirectional Dijkstra algorithm."
msgstr "``pgr_bdDijkstraCost`` — 使用双向 Dijkstra 算法返回最短路径的成本。"

msgid "``pgr_bdDijkstraCost`` (`Combinations`_)"
msgstr "``pgr_bdDijkstraCost`` (`组合`_)"

msgid ""
"The ``pgr_bdDijkstraCost`` function sumarizes of the cost of the shortest "
"path using the bidirectional Dijkstra Algorithm."
msgstr "``pgr_bdDijkstraCost`` 函数使用双向 Dijkstra 算法汇总最短路径的成本。"

msgid ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vid**, **end vid** , [``directed``])"
msgstr ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vid**, **end vid** , [``directed``])"

msgid ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vids**, **end vid** , "
"[``directed``])"
msgstr ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vids**, **end vid** , "
"[``directed``])"

msgid ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"

msgid "pgr_bdDijkstraCost(`Edges SQL`_, `Combinations SQL`_, [ ``directed``])"
msgstr "pgr_bdDijkstraCost(`Edges SQL`_, `Combinations SQL`_, [ ``directed``])"

msgid "pgr_bdDijkstraCost(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_bdDijkstraCost(`Edges SQL`_, `Combinations SQL`_, [``directed``])"

msgid "``pgr_bdDijkstraCostMatrix``"
msgstr "``pgr_bdDijkstraCostMatrix``"

msgid ""
"``pgr_bdDijkstraCostMatrix`` - Calculates a cost matrix using :doc:"
"`pgr_bdDijkstra`."
msgstr ""
"``pgr_bdDijkstraCostMatrix`` - 使用 :doc:`pgr_bdDijkstra` 计算成本矩阵。"

msgid ""
"Using bidirectional Dijkstra algorithm, calculate and return a cost matrix."
msgstr "使用双向Dijkstra算法，计算并返回成本矩阵。"

msgid "pgr_bdDijkstraCostMatrix(`Edges SQL`_, **start vids**, [``directed``])"
msgstr "pgr_bdDijkstraCostMatrix(`Edges SQL`_, **start vids**, [``directed``])"

msgid ""
"Symmetric cost matrix for vertices :math:`\\{5, 6, 10, 15\\}` on an "
"**undirected** graph"
msgstr "在一个**无向**图上的顶点集合:math:`\\{5, 6, 10, 15\\}` 的对称成本矩阵"

msgid "Use with :doc:`pgr_TSP`."
msgstr "与 :doc:`pgr_TSP` 一起使用。"

msgid "``pgr_bellmanFord - Experimental``"
msgstr "``pgr_bellmanFord - 实验``"

msgid "``pgr_bellmanFord`` — Shortest path(s) using Bellman-Ford algorithm."
msgstr "``pgr_bellmanFord`` — 使用 Bellman-Ford 算法的最短路径。"

msgid "New **experimental** signature:"
msgstr "新**实验性**签名："

msgid "``pgr_bellmanFord`` (`Combinations`_)"
msgstr "``pgr_bellmanFord`` (`组合`_)"

msgid "New **experimental** signatures:"
msgstr "新**实验**签名："

msgid "``pgr_bellmanFord`` (`One to One`_)"
msgstr "``pgr_bellmanFord`` (`一对一`_)"

msgid "``pgr_bellmanFord`` (`One to Many`_)"
msgstr "``pgr_bellmanFord`` (`一对多`_)"

msgid "``pgr_bellmanFord`` (`Many to One`_)"
msgstr "``pgr_bellmanFord`` (`多对一`_)"

msgid "``pgr_bellmanFord`` (`Many to Many`_)"
msgstr "``pgr_bellmanFord`` (`多对多`_)"

msgid ""
"Bellman-Ford's algorithm, is named after Richard Bellman and Lester Ford, "
"who first published it in 1958 and 1956, respectively.It is a graph search "
"algorithm that computes shortest paths from a starting vertex "
"(``start_vid``) to an ending vertex (``end_vid``) in a graph where some of "
"the edge weights may be negative. Though it is more versatile, it is slower "
"than Dijkstra's algorithm.This implementation can be used with a directed "
"graph and an undirected graph."
msgstr ""
"Bellman-Ford算法以Richard Bellman和Lester Ford的名字命名，他们分别于1958年和"
"1956年首次发表了这个算法。它是一种图搜索算法，用于计算从起始顶点"
"（``start_vid``）到终点顶点（``end_vid``）的最短路径，其中一些边的权重可以为"
"负数。尽管它更加通用，但比Dijkstra算法更慢。这个实现可以用于有向图和无向图。"

msgid ""
"Process is valid for edges with both positive and negative edge weights."
msgstr "该过程对于具有正边权重和负边权重的边都有效。"

msgid ""
"When the start vertex and the end vertex are the same, there is no path. The "
"agg_cost would be :math:`0`."
msgstr ""
"当起始顶点和结束顶点相同时，不存在路径。聚合成本（agg_cost）将为 :math:`0`。"

msgid ""
"When the start vertex and the end vertex are different, and there exists a "
"path between them without having a *negative cycle*. The agg_cost would be "
"some finite value denoting the shortest distance between them."
msgstr ""
"当起始顶点和结束顶点不同，并且它们之间存在路径且不存在*负循环*时。 agg_cost "
"将是某个有限值，表示它们之间的最短距离。"

msgid ""
"When the start vertex and the end vertex are different, and there exists a "
"path between them, but it contains a *negative cycle*. In such case, "
"agg_cost for those vertices keep on decreasing furthermore, Hence agg_cost "
"can’t be defined for them."
msgstr ""
"当起始顶点和结束顶点不同，并且它们之间存在路径，但包含*负循环*时。 在这种情况"
"下，这些顶点的 agg_cost 继续减少，因此无法为它们定义 agg_cost 。"

msgid ""
"When the start vertex and the end vertex are different, and there is no "
"path. The agg_cost is :math:`\\infty`."
msgstr ""
"当起始顶点和结束顶点不同且不存在路径时，聚合成本（agg_cost）为:math:`"
"\\infty`。"

msgid ""
"For optimization purposes, any duplicated value in the `start_vids` or "
"`end_vids` are ignored."
msgstr "出于优化目的，`start_vids`或 `end_vids` 中的任何重复值都将被忽略。"

msgid "Running time: :math:`O(| start\\_vids | * ( V * E))`"
msgstr "运行时间：:math:`O(| start\\_vids | * ( V * E))`"

msgid ""
"pgr_bellmanFord(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""
"pgr_bellmanFord(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid ""
"pgr_bellmanFord(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""
"pgr_bellmanFord(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid ""
"pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vid** , [``directed``])"
msgstr ""
"pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vid** , [``directed``])"

msgid ""
"pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr ""
"pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_bellmanFord(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_bellmanFord(`Edges SQL`_, `Combinations SQL`_, [``directed``])"

msgid "From vertex :math:`6` to vertex :math:`10` on a **directed** graph"
msgstr "在**有向**图上从顶点 :math:`6`到顶点 :math:`10`"

msgid ""
"From vertex :math:`6` to vertices :math:`\\{ 10, 17\\}` on a **directed** "
"graph"
msgstr "在**有向**图上从顶点 :math:`6` 到顶点 :math:`\\{ 10, 17\\}`"

msgid ""
"pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""
"pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"

msgid "Using a combinations table on an **undirected** graph."
msgstr "在**无向**图上使用组合表。"

msgid "https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm"
msgstr "https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm"

msgid "``pgr_biconnectedComponents``"
msgstr "``pgr_biconnectedComponents``"

msgid ""
"``pgr_biconnectedComponents`` — Biconnected components of an undirected "
"graph."
msgstr "``pgr_biconnectedComponents`` — 无向图的双连通分量。"

msgid "Return columns change:"
msgstr "返回列更改："

msgid "``n_seq`` is removed"
msgstr "``n_seq``被删除"

msgid "``seq`` changed type to ``BIGINT``"
msgstr "``seq`` 将类型更改为``BIGINT``"

msgid ""
"The biconnected components of an undirected graph are the maximal subsets of "
"vertices such that the removal of a vertex from particular component will "
"not disconnect the component. Unlike connected components, vertices may "
"belong to multiple biconnected components. Vertices can be present in "
"multiple biconnected components, but each edge can only be contained in a "
"single biconnected component."
msgstr ""
"无向图的双连通分量是顶点的最大子集，因此从特定分量中删除顶点不会断开该分量。 "
"与连接组件不同，顶点可以属于多个双连接组件。 顶点可以存在于多个双连通分量中，"
"但每条边只能包含在单个双连通分量中。"

msgid "Components are described by edges."
msgstr "组件由边描述。"

msgid "``component`` ascending."
msgstr "``component`` 升序。"

msgid "``edge`` ascending."
msgstr "``edge``升序。"

msgid "pgr_biconnectedComponents(`Edges SQL`_)"
msgstr "pgr_biconnectedComponents(`Edges SQL`_)"

msgid "RETURNS SET OF |result-component-E|"
msgstr "RETURNS SET OF |result-component-E|"

msgid "The biconnected components of the graph"
msgstr "图的双连通分量"

msgid "Returns set of |result-component-E|"
msgstr "Returns set of |result-component-E|"

msgid "``component``"
msgstr "``component``"

msgid "Component identifier."
msgstr "分量标识符。"

msgid "Has the value of the minimum edge identifier in the component."
msgstr "具有组件中最小边标识符的值。"

msgid "Identifier of the edge that belongs to the ``component``."
msgstr "属于该``分量``的边的标识符。"

msgid ""
"Boost: `Biconnected components <https://www.boost.org/libs/graph/doc/"
"biconnected_components.html>`__"
msgstr ""
"Boost: `双连通分量<https://www.boost.org/libs/graph/doc/"
"biconnected_components.html>`__"

msgid "``pgr_binaryBreadthFirstSearch`` - Experimental"
msgstr "``pgr_binaryBreadthFirstSearch`` - 实验"

msgid ""
"``pgr_binaryBreadthFirstSearch`` — Returns the shortest path(s) in a binary "
"graph."
msgstr "``pgr_binaryBreadthFirstSearch`` — 返回二元图中的最短路径。"

msgid ""
"Any graph whose edge-weights belongs to the set {0,X}, where 'X' is any non-"
"negative integer, is termed as a 'binary graph'."
msgstr "任何边权属于集合 {0,X} 的图（其中“X”是任何非负整数）都被称为“二元图”。"

msgid "pgr_binaryBreadthFirstSearch(`Combinations`_)"
msgstr "pgr_binaryBreadthFirstSearch(`组合`_)"

msgid "pgr_binaryBreadthFirstSearch(`One to One`_)"
msgstr "pgr_binaryBreadthFirstSearch(`一对一`_)"

msgid "pgr_binaryBreadthFirstSearch(`One to Many`_)"
msgstr "pgr_binaryBreadthFirstSearch(`一对多`_)"

msgid "pgr_binaryBreadthFirstSearch(`Many to One`_)"
msgstr "pgr_binaryBreadthFirstSearch(`多对一`_)"

msgid "pgr_binaryBreadthFirstSearch(`Many to Many`_)"
msgstr "pgr_binaryBreadthFirstSearch(`多对多`_)"

msgid ""
"It is well-known that the shortest paths between a single source and all "
"other vertices can be found using Breadth First Search in :math:`O(|E|)` in "
"an unweighted graph, i.e. the distance is the minimal number of edges that "
"you need to traverse from the source to another vertex. We can interpret "
"such a graph also as a weighted graph, where every edge has the weight :math:"
"`1`. If not alledges in graph have the same weight, that we need a more "
"general algorithm, like Dijkstra's Algorithm  which runs in :math:`O(|E|log|"
"V|)` time."
msgstr ""
"众所周知，在无权图中，可以使用广度优先搜索（Breadth First Search）找到从单一"
"源点到所有其他顶点的最短路径，其时间复杂度为 :math:`O(|E|)`，其中 |E| 表示图"
"中的边数。也就是说，这里的距离是指从源点到另一个顶点所需穿越的最小边数。我们"
"也可以将这样的图解释为一个带权图，其中每条边的权重都为 :math:`1`。如果图中的"
"边不都具有相同的权重，那么我们就需要使用更通用的算法，比如Dijkstra算法，它的"
"时间复杂度为 :math:`O(|E|log|V|)`，其中 |E| 表示图中的边数，|V| 表示图中的顶"
"点数。"

msgid ""
"However if the weights are more constrained, we can use a faster algorithm. "
"This algorithm, termed as 'Binary Breadth First Search' as well as '0-1 "
"BFS', is a variation of the standard Breadth First Search problem to solve "
"the SSSP (single-source shortest path) problem in :math:`O(|E|)`, if the "
"weights of each edge belongs to the set {0,X}, where 'X' is any non-negative "
"real integer."
msgstr ""
"然而，如果权重受到更多限制，我们可以使用一种更快的算法。这个算法被称为'二进制"
"广度优先搜索'，也称为'0-1 BFS'，它是标准广度优先搜索问题的一种变体，用于解决"
"单源最短路径（SSSP）问题，当每条边的权重属于集合{0，X}，其中'X'是任意非负实数"
"时，其时间复杂度为 :math:`O(|E|)`。"

msgid ""
"Process is done only on 'binary graphs'. ('Binary Graph': Any graph whose "
"edge-weights belongs to the set {0,X}, where 'X' is any non-negative real "
"integer.)"
msgstr ""
"过程仅在“二元图”上完成。 （“二元图”：边权重属于集合 {0,X} 的任何图，其中“X”是"
"任何非负实整数。）"

msgid "Running time: :math:`O(| start\\_vids | * |E|)`"
msgstr "运行时间： :math:`O(| start\\_vids | * |E|)`"

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vid**, **end vid**, "
"[``directed``])"
msgstr ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vid**, **end vid**, "
"[``directed``])"

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vid**, **end vids**, "
"[``directed``])"
msgstr ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vid**, **end vids**, "
"[``directed``])"

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vids**, **end vid**, "
"[``directed``])"
msgstr ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vids**, **end vid**, "
"[``directed``])"

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, `Combinations SQL`_, "
"[``directed``])"
msgstr ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, `Combinations SQL`_, "
"[``directed``])"

msgid ""
"**Note:** Using the :doc:`sampledata` Network as all weights are same (i.e :"
"math:`1``)"
msgstr ""
"**注意:** 使用 :doc:`示例数据`网络，因为所有权重都相同（即为 :math:`1``）"

msgid "Optional Parameters"
msgstr "可选参数"

msgid "https://cp-algorithms.com/graph/01_bfs.html"
msgstr "https://cp-algorithms.com/graph/01_bfs.html"

msgid ""
"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Specialized_variants"
msgstr ""
"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Specialized_variants"

msgid "pgr_bipartite -Experimental"
msgstr "pgr_bipartite -实验"

msgid ""
"``pgr_bipartite`` — Disjoint sets of vertices such that no two vertices "
"within the same set are adjacent."
msgstr "`pgr_bipartite` - 不相邻的顶点集合，同一集合中没有两个顶点相邻。"

msgid "New **experimental** signature"
msgstr "新的**实验**签名"

msgid ""
"A bipartite graph is a graph with two sets of vertices which are connected "
"to each other, but not within themselves. A bipartite graph is possible if "
"the graph coloring is possible using two colors such that vertices in a set "
"are colored with the same color."
msgstr ""
"二方图是指有两组顶点的图，这两组顶点相互连接，但内部没有连接。如果可以使用两"
"种颜色对图形着色，从而使一个集合中的顶点着色为相同的颜色，那么就可能是一个二"
"方图。"

msgid "The algorithm works in undirected graph only."
msgstr "该算法只适用于无向图。"

msgid "The returned values are not ordered."
msgstr "返回值没有排序。"

msgid ""
"The algorithm checks graph is bipartite or not. If it is bipartite then it "
"returns the node along with two    colors `0` and `1` which represents two "
"different sets."
msgstr "该算法检查图是否是二分图。如果是二分图，它将返回节点以及分别代表两个不同集合"
"的两种颜色，分别为 `0` 和 `1`。"

msgid "If graph is not bipartite then algorithm returns empty set."
msgstr "如果图不是两部分的，那么算法会返回空集。"

msgid "pgr_bipartite(`Edges SQL`_)"
msgstr "pgr_bipartite(`Edges SQL`_)"

msgid "When the graph is bipartite"
msgstr "当图形为两方时"

msgid "Additional Example"
msgstr "附加示例"

msgid "The odd length cyclic graph can not be bipartite."
msgstr "奇长循环图不可能是两部分的。"

msgid ""
"The edge :math:`5 \\rightarrow 1` will make subgraph with vertices :math:`"
"\\{1, 3, 7, 6, 5\\}` an odd length cyclic graph, as the cycle has 5 vertices."
msgstr ""
"边 :math:`5 \\rightarrow 1` 将使顶点为 :math:`\\{1, 3, 7, 6, 5\\}` "
"的子图成为奇数长度的循环图，因为循环有 5 个顶点。"

msgid "Edges in blue represent odd length cycle subgraph."
msgstr "蓝色边代表奇数长度循环子图。"

msgid "``pgr_boykovKolmogorov``"
msgstr "``pgr_boykovKolmogorov``"

msgid ""
"``pgr_boykovKolmogorov`` — Calculates the flow on the graph edges that "
"maximizes the flow from the sources to the targets using Boykov Kolmogorov "
"algorithm."
msgstr "`pgr_boykovKolmogorov`` - 使用 Boykov Kolmogorov "
"算法计算图边的流量，使从源到目标的流量最大。"

msgid "New **proposed** signature"
msgstr "新的**拟议**签名"

msgid "``pgr_boykovKolmogorov`` (`Combinations`_)"
msgstr "``pgr_boykovKolmogorov`` (`组合`_)"

msgid "Renamed from ``pgr_maxFlowBoykovKolmogorov``"
msgstr "由 ``pgr_maxFlowBoykovKolmogorov`` 重命名"

msgid "**Proposed** function"
msgstr "**拟议**函数"

msgid "New **Experimental** function"
msgstr "新的**实验**函数"

msgid "Running time: Polynomial"
msgstr "运行时间：多项式时间"

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_boykovKolmogorov(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_boykovKolmogorov(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_boykovKolmogorov(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_boykovKolmogorov(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_boykovKolmogorov(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_boykovKolmogorov(`Edges SQL`_, `Combinations SQL`_)"

msgid "From vertex :math:`11` to vertex :math:`12`"
msgstr "从顶点:math:`11`到顶点 :math:`12`"

msgid "From vertex :math:`11` to vertices :math:`\\{5, 10, 12\\}`"
msgstr "从顶点:math:`11`到顶点 :math:`\\{5, 10, 12\\}`"

msgid "From vertices :math:`\\{11, 3, 17\\}` to vertex :math:`12`"
msgstr "从顶点:math:`\\{11, 3, 17\\}`到顶点:math:`12`"

msgid ""
"From vertices :math:`\\{11, 3, 17\\}` to vertices :math:`\\{5, 10, 12\\}`"
msgstr "从顶点:math:`\\{11, 3, 17\\}`到顶点:math:`\\{5, 10, 12\\}`"

msgid ""
"Using a combinations table, equivalent to calculating result from vertices :"
"math:`\\{5, 6\\}` to vertices :math:`\\{10, 15, 14\\}`."
msgstr ""
"使用组合表，相当于计算从顶点:math:`{5, 6\\}` 到顶点:math:`{10, 15, 14\\}` 的"
"结果。"

msgid "https://www.boost.org/libs/graph/doc/boykov_kolmogorov_max_flow.html"
msgstr "https://www.boost.org/libs/graph/doc/boykov_kolmogorov_max_flow.html"

msgid "``pgr_breadthFirstSearch`` - Experimental"
msgstr "``pgr_breadthFirstSearch`` - 实验"

msgid ""
"``pgr_breadthFirstSearch`` — Returns the traversal order(s) using Breadth "
"First Search algorithm."
msgstr "``pgr_breadthFirstSearch`` —使用广度优先搜索算法返回遍历顺序。"

msgid "``pgr_breadthFirstSearch`` (`Single Vertex`_)"
msgstr "``pgr_breadthFirstSearch`` (`单个顶点`_)"

msgid "``pgr_breadthFirstSearch`` (`Multiple Vertices`_)"
msgstr "``pgr_breadthFirstSearch`` (`多个顶点`_)"

msgid ""
"Provides the Breadth First Search traversal order from a root vertex to a "
"particular depth."
msgstr "提供从根顶点到特定深度的广度优先搜索遍历顺序。"

msgid "The implementation will work on any type of graph."
msgstr "该实现适用于任何类型的图。"

msgid ""
"Provides the Breadth First Search traversal order from a source node to a "
"target depth level."
msgstr "提供从源节点到目标深度级别的广度优先搜索遍历顺序。"

msgid "Running time: :math:`O(E + V)`"
msgstr "运行时间：:math:`O(E + V)`"

msgid "pgr_breadthFirstSearch(`Edges SQL`_, **root vid**, [**options**])"
msgstr "pgr_breadthFirstSearch(`Edges SQL`_, **root vid**, [**options**])"

msgid "pgr_breadthFirstSearch(`Edges SQL`_, **root vids**, [**options**])"
msgstr "pgr_breadthFirstSearch(`Edges SQL`_, **root vids**, [**options**])"

msgid "**options:** ``[max_depth, directed]``"
msgstr "**options:** ``[max_depth, directed]``"

msgid "Single vertex"
msgstr "单顶点"

msgid ""
"From root vertex :math:`6` on a **directed** graph with edges in ascending "
"order of ``id``"
msgstr ""
"从根顶点:math:`6` 开始，该顶点位于一个**有向**图中，其边按 ``id``升序排列"

msgid "Multiple vertices"
msgstr "多点"

msgid ""
"From root vertices :math:`\\{12, 6\\}` on an **undirected** graph with "
"**depth** :math:`<= 2` and edges in ascending order of ``id``"
msgstr ""
"从根顶点 :math:`\\{12, 6\\}` 开始，在一个**无向**图中，**深度**限制为 :math:"
"`<= 2`，并且边按 ``id`` 升序排列"

msgid "DFS optional parameters"
msgstr "DFS可选参数"

msgid "Same as `Single vertex`_ with edges in ascending order of ``id``."
msgstr "与 `单个顶点`_ 相同，边按 ``id`` 升序排列。"

msgid "Same as `Single vertex`_ with edges in descending order of ``id``."
msgstr "与 `单个顶点`_ 相同，边按 ``id`` 降序排列。"

msgid "The resulting traversal is different."
msgstr "由此产生的遍历是不同的。"

msgid ""
"The left image shows the result with ascending order of ids and the right "
"image shows with descending order of the edge identifiers."
msgstr ""
"左侧图像显示了按id升序排列的结果，右侧图像显示了按边标识降序排列的结果。"

msgid "|ascending| |descending|"
msgstr "|ascending| |descending|"

msgid "ascending"
msgstr "升序"

msgid "descending"
msgstr "降序"

msgid ""
"`Boost: Breadth First Search algorithm documentation <https://www.boost.org/"
"libs/graph/doc/breadth_first_search.html>`__"
msgstr ""
"`Boost: 广度优先搜索算法文档 <https://www.boost.org/libs/graph/doc/"
"breadth_first_search.html>`__"

msgid ""
"`Wikipedia: Breadth First Search algorithm <https://en.wikipedia.org/wiki/"
"Breadth-first_search>`__"
msgstr ""
"`维基百科: 广度优先搜索算法<https://en.wikipedia.org/wiki/Breadth-"
"first_search>`__"

msgid "``pgr_bridges``"
msgstr "``pgr_bridges``"

msgid "``pgr_bridges`` - Return the bridges of an undirected graph."
msgstr "``pgr_bridges`` - 返回无向图的桥。"

msgid ""
"A bridge is an edge of an undirected graph whose deletion increases its "
"number of connected components. This implementation can only be used with an "
"undirected graph."
msgstr ""
"桥是指一个无向图中的边，如果删除它会增加该图的连通分量数量。此实现仅适用于无"
"向图。"

msgid "``edge`` ascending"
msgstr "``edge``升序"

msgid "Running time: :math:`O(E * (V + E))`"
msgstr "运行时间：:math:`O(E * (V + E))`"

msgid "pgr_bridges(`Edges SQL`_)"
msgstr "pgr_bridges(`Edges SQL`_)"

msgid "The bridges of the graph"
msgstr "图的桥"

msgid "Returns set of |result-edge|"
msgstr "Returns set of |result-edge|"

msgid "Identifier of the edge that is a bridge."
msgstr "作为桥的边的标识符。"

msgid "https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29"
msgstr "https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29"

msgid "**Supported versions**"
msgstr "**支持版本**"

msgid "``pgr_chinesePostman`` - Experimental"
msgstr "``pgr_chinesePostman`` - 实验"

msgid ""
"``pgr_chinesePostman`` — Calculates the shortest circuit path which contains "
"every edge in a directed graph and starts and ends on the same vertex."
msgstr ""
"`pgr_chinesePostman` — 计算包含有向图中的每条边并从同一顶点开始和结束的最短回"
"路路径。"

msgid "Returns ``EMPTY SET`` on a disconnected graph"
msgstr "在一个不连通的图上返回 ``EMPTY SET``"

msgid "pgr_chinesePostman(`Edges SQL`_)"
msgstr "pgr_chinesePostman(`Edges SQL`_)"

msgid "Returns set of ``(seq, node, edge, cost, agg_cost)``"
msgstr "Returns set of ``(seq, node, edge, cost, agg_cost)``"

msgid "Sequential value starting from ``1``"
msgstr "从 ``1``开始的顺序值"

msgid ""
"Identifier of the edge used to go from ``node`` to the next node in the path "
"sequence. ``-1`` for the last node of the path."
msgstr ""
"用于从路径序列中的``节点``到下一个节点的边的标识符。``-1`` 表示路径的最后一个"
"节点。"

msgid "Aggregate cost from ``start_v`` to ``node``."
msgstr "从``start_v``到``node``的总成本。"

msgid "``pgr_chinesePostmanCost`` - Experimental"
msgstr "``pgr_chinesePostmanCost`` - 实验"

msgid ""
"``pgr_chinesePostmanCost`` — Calculates the minimum costs of a circuit path "
"which contains every edge in a directed graph and starts and ends on the "
"same vertex."
msgstr ""
"``pgr_chinesePostmanCost`` — 计算一个包含有向图中的每条边、以同一顶点为起点和"
"终点的最短成本的回路路径。"

msgid "Return value when the graph if disconnected"
msgstr "当图是不连通的时候返回的数值"

msgid "pgr_chinesePostmanCost(`Edges SQL`_)"
msgstr "pgr_chinesePostmanCost(`Edges SQL`_)"

msgid "RETURNS ``FLOAT``"
msgstr "RETURNS ``FLOAT``"

msgid "``pgr_chinesepostmancost``"
msgstr "``pgr_chinesepostmancost``"

msgid "Minimum costs of a circuit path."
msgstr "一个回路路径的最小成本。"

msgid "pgr_connectedComponents"
msgstr "pgr_connectedComponents"

msgid ""
"``pgr_connectedComponents`` — Connected components of an undirected graph "
"using a DFS-based approach."
msgstr ""
"``pgr_connectedComponents`` — 使用基于深度优先搜索（DFS）的方法计算无向图的连"
"通分量。"

msgid ""
"A connected component of an undirected graph is a set of vertices that are "
"all reachable from each other."
msgstr "无向图的一个连通分量是一组顶点，它们之间都可以相互到达。"

msgid "Components are described by vertices"
msgstr "连通分量由顶点描述"

msgid "``component`` ascending"
msgstr "``component`` 升序"

msgid "pgr_connectedComponents(`Edges SQL`_)"
msgstr "pgr_connectedComponents(`Edges SQL`_)"

msgid "The connected components of the graph"
msgstr "图的连通分量"

msgid "Returns set of |result-component-V|"
msgstr "Returns set of |result-component-V|"

msgid "Has the value of the minimum node identifier in the component."
msgstr "具有组件中的最小节点标识符值。"

msgid "Identifier of the vertex that belongs to the ``component``."
msgstr "属于该 ``组件``的顶点的标识符。"

msgid "Connecting disconnected components"
msgstr "连接不连通的组件"

msgid ""
"Boost: `Connected components <https://www.boost.org/libs/graph/doc/"
"connected_components.html>`__"
msgstr ""
"Boost: `连接组件 <https://www.boost.org/libs/graph/doc/connected_components."
"html>`__"

msgid ""
"wikipedia: `Connected component <https://en.wikipedia.org/wiki/"
"Connected_component_(graph_theory)>`__"
msgstr ""
"维基百科: `连通分量 <https://en.wikipedia.org/wiki/"
"Connected_component_(graph_theory)>`__"

msgid "``pgr_contraction``"
msgstr "``pgr_contraction``"

msgid ""
"``pgr_contraction`` — Performs graph contraction and returns the contracted "
"vertices and edges."
msgstr "``pgr_contraction`` — 执行图收缩操作并返回收缩后的顶点和边。"

msgid "Name change from ``pgr_contractGraph``"
msgstr "``pgr_contractGraph`` 的名称更改"

msgid "Bug fixes"
msgstr "Bug修复"

msgid ""
"Contraction reduces the size of the graph by removing some of the vertices "
"and edges and, for example, might add edges that represent a sequence of "
"original edges decreasing the total time and space used in graph algorithms."
msgstr ""
"收缩通过移除一些顶点和边来减小图的规模，例如，可能添加表示原始边序列的边，从"
"而减少了在图算法中使用的总时间和空间。"

msgid "Does not return the full contracted graph"
msgstr "不返回完整的收缩图"

msgid "Only changes on the graph are returned"
msgstr "仅返回图上的更改"

msgid "Currnetly there are two types of contraction methods"
msgstr "目前有两种类型的收缩方法"

msgid "Dead End Contraction"
msgstr "死端收缩"

msgid "Linear Contraction"
msgstr "线性收缩"

msgid "The returned values include"
msgstr "返回值包括"

msgid "the added edges by linear contraction."
msgstr "由线性收缩添加的边。"

msgid "the modified vertices by dead end contraction."
msgstr "通过死端收缩修改顶点。"

msgid "The returned values are ordered as follows:"
msgstr "返回值的排序如下："

msgid "column ``id`` ascending when type is ``v``"
msgstr "当类型为 ``v``时，按列 ``id`` 升序"

msgid "column ``id`` descending when type is ``e``"
msgstr "当类型为 ``e`` 时，按列``id``降序"

msgid "The pgr_contraction function has the following signature:"
msgstr "pgr_contraction 函数具有以下签名："

msgid "pgr_contraction(`Edges SQL`_, **contraction order**, [**options**])"
msgstr "pgr_contraction(`Edges SQL`_, **contraction order**, [**options**])"

msgid "**options:** ``[ max_cycles, forbidden_vertices, directed]``"
msgstr "**options:** ``[ max_cycles, forbidden_vertices, directed]``"

msgid ""
"Making a dead end and linear contraction in that order on an undirected "
"graph."
msgstr "在无向图上按顺序进行死端和线性收缩。"

msgid "**contraction Order**"
msgstr "**contraction Order**"

msgid "Ordered contraction operations."
msgstr "有序收缩操作。"

msgid "1 = Dead end contraction"
msgstr "1=死端收缩"

msgid "2 = Linear contraction"
msgstr "2=线性收缩"

msgid "Contraction optional parameters"
msgstr "可选收缩参数"

msgid "``forbidden_vertices``"
msgstr "``forbidden_vertices``"

msgid "**Empty**"
msgstr "**Empty**"

msgid "Identifiers of vertices forbidden for contraction."
msgstr "禁止收缩的顶点标识符。"

msgid ":math:`1`"
msgstr ":math:`1`"

msgid ""
"Number of times the contraction operations on ``contraction_order`` will be "
"performed."
msgstr "对于 ``contraction_order`` 上的收缩操作将执行的次数。"

msgid "Returns set of  |result-contract|"
msgstr "返回集合 |result-contract|"

msgid "The function returns a single row. The columns of the row are:"
msgstr "该函数返回一行数据。该行的列包括："

msgid "``type``"
msgstr "``type``"

msgid "Type of the ``id``."
msgstr "``id``的类型。"

msgid "``v`` when the row is a vertex."
msgstr "当该行表示一个顶点时，列为``v``。"

msgid "Column ``id`` has a positive value"
msgstr "列``id`` 具有正值"

msgid "``e`` when the row is an edge."
msgstr "``e`` 当该行是一条边时。"

msgid "Column ``id`` has a negative value"
msgstr "列 ``id`` 具有负值"

msgid "All numbers on this column are ``DISTINCT``"
msgstr "此列中的所有数字都是``DISTINCT``"

msgid "When ``type`` = **'v'**."
msgstr "当``type`` = **'v'**时。"

msgid "Identifier of the modified vertex."
msgstr "修改顶点的标识符。"

msgid "When ``type`` = **'e'**."
msgstr "当 ``type`` = **'e'**时。"

msgid "Decreasing sequence starting from **-1**."
msgstr "从**-1**开始递减序列。"

msgid ""
"Representing a pseudo `id` as is not incorporated in the set of original "
"edges."
msgstr "将一个伪 `id` 表示为不包括在原始边集中。"

msgid "Array of contracted vertex identifiers."
msgstr "收缩的顶点标识符数组。"

msgid "When ``type`` = **'v'**: :math:`-1`"
msgstr "当 ``type`` = **'v'**: :math:`-1`时"

msgid ""
"When ``type`` = **'e'**: Identifier of the source vertex of the current edge "
"(``source``, ``target``)."
msgstr ""
"当 ``type`` = **'e'**时：当前边（``source``，``target``）的source顶点标识符。"

msgid ""
"When ``type`` = **'e'**: Identifier of the target vertex of the current edge "
"(``source``, ``target``)."
msgstr ""
"当 ``type`` = **'e'** 时：当前边(``source``, ``target``)的target 顶点标识符。"

msgid ""
"When ``type`` = **'e'**: Weight of the current edge (``source``, ``target``)."
msgstr "当 ``type`` = **'e'** 时：当前边(``source``, ``target``)的权重。"

msgid "Only dead end contraction"
msgstr "仅死端收缩"

msgid "Only linear contraction"
msgstr "仅线性收缩"

msgid "pgr_createTopology"
msgstr "pgr_createTopology"

msgid ""
"``pgr_createTopology`` — Builds a network topology based on the geometry "
"information."
msgstr "``pgr_createTopology`` — 根据几何信息构建网络拓扑。"

msgid ""
"``OK`` after the network topology has been built and the vertices table "
"created."
msgstr "``OK``在网络拓扑建立完成并且顶点表创建后。"

msgid "``FAIL`` when the network topology was not built due to an error."
msgstr "``FAIL``当由于错误原因未能构建网络拓扑时。"

msgid "pgr_createTopology(edge_table, tolerance, [**options**])"
msgstr "pgr_createTopology(edge_table, tolerance, [**options**])"

msgid "**options:** ``[the_geom, id, source, target, rows_where, clean]``"
msgstr "**options:** ``[the_geom, id, source, target, rows_where, clean]``"

msgid "The topology creation function accepts the following parameters:"
msgstr "拓扑创建函数接受以下参数："

msgid ""
"``text``   Condition to SELECT a subset or rows.  Default value is ``true`` "
"to indicate all rows that where ``source`` or ``target`` have a null value, "
"otherwise the condition is used."
msgstr ""
"``text``  用于选择一组行的条件。默认值为 ``true``，表示选择所有具有空值的 "
"``source`` 或 ``target`` 的行，否则将使用条件。"

msgid "clean"
msgstr "clean"

msgid "``boolean`` Clean any previous topology.  Default value is ``false``."
msgstr "``boolean`` 清除任何先前的拓扑信息。默认值为 ``false``。"

msgid "The ``edge_table`` will be affected"
msgstr "``edge_table`` 将受到影响"

msgid "The ``source`` column values will change."
msgstr "``source`` 列的值将发生改变。"

msgid "The ``target`` column values will change."
msgstr "``target``列的值将发生改变。"

msgid ""
"An index will be created, if it doesn't exists, to speed up the process to "
"the following columns:"
msgstr "如果索引不存在，则会创建一个索引，以加快以下列的处理速度："

msgid "``the_geom``"
msgstr "``the_geom``"

msgid "``OK`` after the network topology has been built."
msgstr "``OK``在网络拓扑建立完成后。"

msgid "Creates a vertices table: <edge_table>_vertices_pgr."
msgstr "创建一个顶点表：<edge_table>_vertices_pgr。"

msgid "Fills ``id`` and ``the_geom`` columns of the vertices table."
msgstr "填充顶点表的``id`` 和 ``the_geom`` 列。"

msgid ""
"Fills the source and target columns of the edge table referencing the ``id`` "
"of the vertices table."
msgstr "引用顶点表的``id``填充边表的 source列和target列。"

msgid "``FAIL`` when the network topology was not built due to an error:"
msgstr "``FAIL``当由于错误原因未能构建网络拓扑时："

msgid ""
"The vertices table is a requirement of the :doc:`pgr_analyzeGraph` and the :"
"doc:`pgr_analyzeOneWay` functions."
msgstr ""
"顶点表是 :doc:`pgr_analyzeGraph` 和 :doc:`pgr_analyzeOneWay`函数的必需条件。"

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex. "
"See :doc:`pgr_analyzeGraph`."
msgstr ""
"``integer``edge_table 中引用该顶点的顶点数。 参见:doc:`pgr_analyzeGraph`。"

msgid ""
"``integer``  Indicator that the vertex might have a problem. See :doc:"
"`pgr_analyzeGraph`."
msgstr "``integer`` 表示该顶点可能存在问题的指标。请参阅 :doc:`pgr_analyzeGraph`。"

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"AS incoming. See :doc:`pgr_analyzeOneWay`."
msgstr ""
"``integer``边表中引用此顶点作为入边的顶点数量。请参考 :doc:"
"`pgr_analyzeOneWay`。"

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"AS outgoing. See :doc:`pgr_analyzeOneWay`."
msgstr ""
"``integer``边表中引用此顶点作为出边的顶点数量。请参考 :doc:"
"`pgr_analyzeOneWay`。"

msgid "The simplest way to use pgr_createTopology is:"
msgstr "使用 pgr_createTopology 最简单的方法是："

msgid ""
"An error would occur when the arguments are not given in the appropriate "
"order: In this example, the column ``id`` of the table ``ege_table`` is "
"passed to the function as the geometry column, and the geometry column "
"``the_geom`` is passed to the function as the id column."
msgstr ""
"当参数未按适当顺序给出时会导致错误：在此示例中，表格 ``ege_table`` 的列"
"``id`` 被错误地传递给函数作为几何列，而几何列 ``the_geom``被错误地传递给函数"
"作为 id 列。"

msgid ""
"Parameters defined with a default value can be omitted, as long as the value "
"matches the default And The order of the parameters would not matter."
msgstr ""
"定义有默认值的参数可以省略，只要该值与默认值匹配并且参数的顺序无关紧要。"

msgid ""
"Selecting the rows where the geometry is near the geometry of row with ``id "
"= 5``."
msgstr "选择与具有 ``id = 5`` 的行的几何图形接近的行。"

msgid ""
"The arguments need to be given in the order described in the parameters."
msgstr "参数需要按照参数中描述的顺序给出。"

msgid ""
"Note that this example uses clean flag. So it recreates the whole vertices "
"table."
msgstr "请注意，此示例使用 clean 标志。 所以它重新创建了整个顶点表。"

msgid ""
"An error would occur when the arguments are not given in the appropiriate "
"order: In this example, the column ``gid`` of the table ``mytable`` is "
"passed to the function AS the geometry column, and the geometry column "
"``mygeom`` is passed to the function AS the id column."
msgstr ""
"当参数未按适当的顺序给出时，会导致错误。在这个示例中，表``mytable``的列 "
"``gid`` 被错误地传递给函数作为几何列，而几何列``mygeom`` 被错误地传递给函数作"
"为 id 列。"

msgid ""
"In this scenario omitting a parameter would create an error because the "
"default values for the column names do not match the column names of the "
"table. The order of the parameters do not matter:"
msgstr ""
"在这种情况下，省略参数会产生错误，因为列名的默认值与表的列名不匹配。 参数的顺"
"序并不重要："

msgid "Based on id:"
msgstr "基于id："

msgid "Create a routing topology"
msgstr "创建路由拓扑"

msgid ""
"An alternate method to create a routing topology use :doc:"
"`pgr_extractVertices`"
msgstr "使用 :doc:`pgr_extractVertices`创建路由拓扑的替代方法"

msgid "Make sure the database does not have the ``vertices_table``"
msgstr "确保数据库没有 ``vertices_table``"

msgid "Clean up the columns of the routing topology to be created"
msgstr "清理要创建的路由拓扑的列"

msgid "Create the vertices table"
msgstr "创建顶点表"

msgid ""
"When the ``LINESTRING`` has a SRID then use ``geom::geometry(POINT, <SRID>)``"
msgstr ""
"当 ``LINESTRING``具有 SRID 时，请使用 ``geom::geometry(POINT, <SRID>)``"

msgid "For big edge tables that are been prepared,"
msgstr "对于已经准备好的大型边表，"

msgid "Create it as ``UNLOGGED`` and"
msgstr "创建它为 ``UNLOGGED`` 并"

msgid "After the table is created ``ALTER TABLE .. SET LOGGED``"
msgstr "创建表后，执行 ``ALTER TABLE .. SET LOGGED`` 操作"

msgid "Inspect the vertices table"
msgstr "检查顶点表"

msgid "Create the routing topology on the edge table"
msgstr "在边表上创建路由拓扑"

msgid "Updating the ``source`` information"
msgstr "更新``source``信息"

msgid "Updating the ``target`` information"
msgstr "更新``target``信息"

msgid "Inspect the routing topology"
msgstr "检查路由拓扑"

msgid "**Generated topology**"
msgstr "**生成的拓扑结构**"

msgid "With full output"
msgstr "带有完整输出"

msgid ""
"This example start a clean topology, with 5 edges, and then its incremented "
"to the rest of the edges."
msgstr ""
"这个例子开始一个干净的拓扑结构，包括 5 条边，然后将其逐渐扩展到其余的边。"

msgid "The example uses the :doc:`sampledata` network."
msgstr "本例使用 :doc:`sampledata` 网络。"

msgid "pgr_createVerticesTable"
msgstr "pgr_createVerticesTable"

msgid ""
"``pgr_createVerticesTable`` — Reconstructs the vertices table based on the "
"source and target information."
msgstr "``pgr_createVerticesTable`` — 根据 source和target信息重建顶点表。"

msgid "``OK`` after the vertices table has been reconstructed."
msgstr "``OK``重建顶点表后。"

msgid "``FAIL`` when the vertices table was not reconstructed due to an error."
msgstr "``FAIL``当由于错误而未重建顶点表时。"

msgid ""
"pgr_createVerticesTable(edge_table, [``the_geom, source, target, "
"rows_where``])"
msgstr ""
"pgr_createVerticesTable(edge_table, [``the_geom, source, target, "
"rows_where``])"

msgid ""
"The reconstruction of the vertices table  function accepts the following "
"parameters:"
msgstr "顶点表的重建函数接受以下参数："

msgid ""
"``text``   Condition to SELECT a subset or rows.  Default value is ``true`` "
"to indicate all rows."
msgstr "``text``  用于选择行的子集的条件。默认值为 ``true``，表示选择所有行。"

msgid ""
"Fills ``id`` and ``the_geom`` columns of the vertices table based on the "
"source and target columns of the edge table."
msgstr ""
"根据边表的源点（source）和目标点（target）列，填充顶点表的``id``和"
"``the_geom``列。"

msgid "The names of source, target are the same."
msgstr "source, target的名称相同。"

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"as incoming. See :doc:`pgr_analyzeOneWay`."
msgstr ""
"``integer``edge_table 中引用该顶点作为传入的顶点数。 请参阅 :doc:"
"`pgr_analyzeOneWay`。"

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"as outgoing. See :doc:`pgr_analyzeOneWay`."
msgstr ""
"``integer``Edge_table 中引用该顶点作为传出的顶点数。 请参阅 :doc:"
"`pgr_analyzeOneWay`。"

msgid "The simplest way to use pgr_createVerticesTable"
msgstr "使用 pgr_createVerticesTable 最简单的方法"

msgid "When the arguments are given in the order described in the parameters:"
msgstr "当参数按照参数中描述的顺序给出时："

msgid ""
"An error would occur when the arguments are not given in the appropriate "
"order: In this example, the column source column ``source`` of the table "
"``mytable`` is passed to the function as the geometry column, and the "
"geometry column ``the_geom`` is passed to the function as the source column."
msgstr ""
"当参数没有按照适当的顺序提供时，将会发生错误：在这个例子中，表``mytable``的源"
"列``source``被错误地传递给函数作为几何列，而几何列``the_geom``被错误地传递给"
"函数作为源列。"

msgid "Example 4"
msgstr "示例4"

msgid "Using a different ordering"
msgstr "使用不同的排序"

msgid "Example 5"
msgstr "示例5"

msgid "Example 6"
msgstr "示例6"

msgid "Example 7"
msgstr "示例7"

msgid ""
"Selecting the rows where the geometry is near the geometry of row with "
"``id`` =5 ."
msgstr "选择几何与具有``id``=5的行的几何接近的行。"

msgid "Example 8"
msgstr "示例8"

msgid "Using the following table"
msgstr "使用下表"

msgid "Example 9"
msgstr "示例9"

msgid ""
"An error would occur when the arguments are not given in the appropriate "
"order: In this example, the column ``src`` of the table ``mytable`` is "
"passed to the function as the geometry column, and the geometry column "
"``mygeom`` is passed to the function as the source column."
msgstr ""
"当参数没有按照适当的顺序提供时，会发生错误。在这个例子中，表 ``mytable`` 的"
"``src``列被错误地传递给函数作为几何列，而几何列``mygeom``被错误地传递给函数作"
"为源列。"

msgid "Example 10"
msgstr "示例10"

msgid "Example 11"
msgstr "示例11"

msgid "Example 12"
msgstr "示例12"

msgid "Selecting rows based on the gid. (positional notation)"
msgstr "根据 gid 选择行（使用位置表示法）"

msgid "Example 13"
msgstr "示例13"

msgid "Selecting rows based on the gid. (named notation)"
msgstr "根据 gid 选择行。（使用命名表示法）"

msgid "Example 14"
msgstr "示例14"

msgid ""
"Selecting the rows where the geometry is near the geometry of row with "
"``gid`` = 5."
msgstr "选择几何与具有``gid``=5的行的几何接近的行。"

msgid "Example 15"
msgstr "示例15"

msgid "TBD"
msgstr "TBD"

msgid "Example 16"
msgstr "示例16"

msgid "Example 17"
msgstr "示例17"

msgid ""
":doc:`topology-functions`  for an overview of a topology for routing "
"algorithms."
msgstr ":doc:`topology-functions`  用于路由算法拓扑的概述。"

msgid ""
":doc:`pgr_createTopology` <pgr_create_topology>` to create a topology based "
"on the geometry."
msgstr ":doc:`pgr_createTopology` <pgr_create_topology>`根据几何图形创建拓扑。"

msgid ""
":doc:`pgr_analyzeGraph` to analyze the edges and vertices of the edge table."
msgstr ":doc:`pgr_analyzeGraph`分析边表的边和顶点。"

msgid ":doc:`pgr_analyzeOneWay` to analyze directionality of the edges."
msgstr ":doc:`pgr_analyzeOneWay`分析边方向性的方法。"

msgid "``pgr_cuthillMckeeOrdering`` - Experimental"
msgstr "``pgr_cuthillMckeeOrdering`` - 实验"

msgid ""
"``pgr_cuthillMckeeOrdering`` — Returns the reverse Cuthill-Mckee ordering of "
"an undirected graphs"
msgstr "``pgr_cuthillMckeeOrdering`` — 返回无向图的反向 Cuthill-Mckee 排序"

msgid "Version 3.4.0"
msgstr "版本3.4.0"

msgid ""
"In numerical linear algebra, the Cuthill-McKee algorithm (CM), named after "
"Elizabeth Cuthill and James McKee, is an algorithm to permute a sparse "
"matrix that has a symmetric sparsity pattern into a band matrix form with a "
"small bandwidth."
msgstr ""
"在数值线性代数中，Cuthill-McKee算法（CM），以Elizabeth Cuthill和James McKee的"
"名字命名，是一种用于对具有对称稀疏模式的稀疏矩阵进行置换的算法，以使其转化为"
"带状矩阵形式，带宽较小。"

msgid ""
"The vertices are basically assigned a breadth-first search order, except "
"that at each step, the adjacent vertices are placed in the queue in order of "
"increasing degree."
msgstr ""
"顶点基本上按照广度优先搜索的顺序进行分配，不过在每一步中，相邻的顶点按照递增"
"的度数顺序排列放入队列。"

msgid "The implementation is for **undirected** graphs."
msgstr "该实现适用于**无向**图。"

msgid ""
"The bandwidth minimization problems are considered NP-complete problems."
msgstr "带宽最小化问题被认为是NP完全问题。"

msgid "The running time complexity is: :math:`O(m log(m)|V|)`"
msgstr "运行时间复杂度为：:math:`O(m log(m)|V|)`"

msgid "where :math:`|V|` is the number of vertices,"
msgstr "其中 :math:`|V|`是顶点数，"

msgid ":math:`m` is the maximum degree of the vertices in the graph."
msgstr ":math:`m`是图中顶点的最大度数。"

msgid "pgr_cuthillMckeeOrdering(`Edges SQL`_)"
msgstr "pgr_cuthillMckeeOrdering(`Edges SQL`_)"

msgid "Graph ordering of pgRouting :doc:`sampledata`"
msgstr "pgRouting :doc:`sampledata` 的图形排序"

msgid "Returns SET OF ``(seq, node)``"
msgstr "Returns SET OF ``(seq, node)``"

msgid "Sequence of the order starting from 1."
msgstr "从1开始的顺序序列。"

msgid "New ordering in reverse order."
msgstr "新的逆序排列。"

msgid ""
"`Boost: Cuthill-McKee Ordering <https://www.boost.org/libs/graph/doc/"
"cuthill_mckee_ordering.html>`__"
msgstr ""
"`Boost: Cuthill-McKee 排序 <https://www.boost.org/libs/graph/doc/"
"cuthill_mckee_ordering.html>`__"

msgid ""
"`Wikipedia: Cuthill-McKee Ordering <https://en.wikipedia.org/wiki/Cuthill"
"%E2%80%93McKee_algorithm>`__"
msgstr ""
"`Wikipedia: Cuthill-McKee 排序 <https://en.wikipedia.org/wiki/Cuthill"
"%E2%80%93McKee_algorithm>`__"

msgid "pgr_dagShortestPath - Experimental"
msgstr "pgr_dagShortestPath - 实验"

msgid ""
"``pgr_dagShortestPath`` — Returns the shortest path(s) for weighted directed "
"acyclic graphs(DAG). In particular, the DAG shortest paths algorithm "
"implemented by Boost.Graph."
msgstr ""
"``pgr_dagShortestPath`` — 返回加权有向无环图（DAG）的最短路径（path）。特别"
"是，由Boost.Graph实现的DAG最短路径算法。"

msgid "New **experimental** function:"
msgstr "新**实验**函数："

msgid "pgr_dagShortestPath(Combinations)"
msgstr "pgr_dagShortestPath(组合)"

msgid ""
"Shortest Path for Directed Acyclic Graph(DAG) is a graph search algorithm "
"that solves the shortest path problem for weighted directed acyclic graph, "
"producing a shortest path from a starting vertex (``start_vid``) to an "
"ending vertex (``end_vid``)."
msgstr ""
"有向无环图（DAG）的最短路径是一种图搜索算法，用于解决加权有向无环图的最短路径"
"问题，找到从起始顶点（``start_vid``）到结束顶点（``end_vid``）的最短路径。"

msgid ""
"This implementation can only be used with a **directed** graph with no "
"cycles i.e. directed acyclic graph."
msgstr "这个实现只能用于**有向**图，且没有循环，即有向无环图。"

msgid ""
"The algorithm relies on topological sorting the dag to impose a linear "
"ordering on the vertices, and thus is more efficient for DAG's than either "
"the Dijkstra or Bellman-Ford algorithm."
msgstr ""
"该算法依靠对 DAG 进行拓扑排序来对顶点进行线性排序，因此对于 DAG 来说比 "
"Dijkstra 或 Bellman-Ford 算法更有效。"

msgid ""
"Process is valid for weighted directed acyclic graphs only. otherwise it "
"will throw warnings."
msgstr "该过程仅对加权有向无环图有效。 否则它会抛出警告。"

msgid "The `agg_cost` the non included values `(v, v)` is `0`"
msgstr "`agg_cost`中未包括的值`(v, v)`的成本为`0`"

msgid "The `agg_cost` the non included values `(u, v)` is :math:`\\infty`"
msgstr "`agg_cost`中未包括的值 `(u, v)`是数学符号中的:math:`\\infty`"

msgid "Running time: :math:`O(| start\\_vids | * (V + E))`"
msgstr "运行时间：:math:`O(| start\\_vids | * (V + E))`"

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vid**,  **end vid**)"
msgstr "pgr_dagShortestPath(`Edges SQL`_, **start vid**,  **end vid**)"

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vid**,  **end vids**)"
msgstr "pgr_dagShortestPath(`Edges SQL`_, **start vid**,  **end vids**)"

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_dagShortestPath(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_dagShortestPath(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_dagShortestPath(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_dagShortestPath(`Edges SQL`_, `Combinations SQL`_)"

msgid "From vertex :math:`5` to vertex  :math:`11` on a **directed** graph"
msgstr "在**有向**图上，从顶点:math:`5`到顶点 :math:`11`"

msgid "From vertex :math:`5` to vertices :math:`\\{7, 11\\}`"
msgstr "从顶点:math:`5`到顶点 :math:`\\{7, 11\\}`"

msgid "From vertices :math:`\\{5, 10\\}` to vertex :math:`11`"
msgstr "从顶点:math:`\\{5, 10\\}`到顶点 :math:`11`"

msgid ""
"From vertices :math:`\\{5, 15\\}` to vertices :math:`\\{11, 17\\}` on an "
"**undirected** graph"
msgstr "在**无向**图上，从顶点:math:`\\{5, 15\\}`到顶点:math:`\\{11, 17\\}`"

msgid "Resturn Columns"
msgstr "返回列"

msgid "Making **start_vids** the same as **end_vids**"
msgstr "使 **start_vids** 与 **end_vids** 相同"

msgid "https://en.wikipedia.org/wiki/Topological_sorting"
msgstr "https://en.wikipedia.org/wiki/Topological_sorting"

msgid "``pgr_degree`` -- Proposed"
msgstr "``pgr_degree`` -- 拟议"

msgid ""
"``pgr_degree`` — For each vertex in an undirected graph, return the count of "
"edges incident to the vertex."
msgstr "``pgr_degree`` —对于无向图中的每个顶点，返回与该顶点关联的边的计数。"

msgid "Calculates the degree of the vertices of an **undirected** graph"
msgstr "计算**无向**图顶点的度数"

msgid "pgr_degree(`Edges SQL`_ , `Vertex SQL`_, [``dryrun``])"
msgstr "pgr_degree(`Edges SQL`_ , `Vertex SQL`_, [``dryrun``])"

msgid "RETURNS SETOF |result-degree|"
msgstr "RETURNS SETOF |result-degree|"

msgid "Extracting the vertex information"
msgstr "提取顶点信息"

msgid ""
"pgr_degree can utilize output from `pgr_extractVertices` or can have "
"`pgr_extractVertices` embedded in the call. For decent size networks, it is "
"best to prep your vertices table before hand and use that vertices table for "
"pgr_degree calls."
msgstr ""
"`pgr_degree`可以利用`pgr_extractVertices`的输出，或者可以在调用中嵌入"
"`pgr_extractVertices`。对于较大规模的网络，最好提前准备好顶点表并在"
"`pgr_degree`调用中使用该顶点表。"

msgid "`Vertex SQL`_"
msgstr "`Vertex SQL`_"

msgid "`Vertex SQL`_ as described below"
msgstr "`Vertex SQL`_如下所述"

msgid "``dryrun``"
msgstr "``dryrun``"

msgid "When true do not process and get in a NOTICE the resulting query."
msgstr "当为真时，不要处理查询，而是获取一个通知（NOTICE）来显示查询的结果。"

msgid "Vertex SQL"
msgstr "Vertex SQL"

msgid "``in_edges``"
msgstr "``in_edges``"

msgid "``BIGINT[]``"
msgstr "``BIGINT[]``"

msgid ""
"Array of identifiers of the edges that have the vertex ``id`` as *first end "
"point*."
msgstr "以顶点``id``作为*第一个端点*的边的标识符数组。"

msgid "When missing, ``out_edges`` must exist."
msgstr "当缺失时，``out_edges``必须存在。"

msgid "``out_edges``"
msgstr "``out_edges``"

msgid ""
"Array of identifiers of the edges that have the vertex ``id`` as *second end "
"point*."
msgstr "以顶点``id``作为*第二个端点*的边的标识符数组。"

msgid "When missing, ``in_edges`` must exist."
msgstr "缺失时，``in_edges`` 必须存在。"

msgid "Vertex identifier"
msgstr "顶点标识符"

msgid "``degree``"
msgstr "``degree``"

msgid "Number of edges that are incident to the vertex ``id``"
msgstr "与顶点 ``id`` 关联的边数"

msgid "Degree of a sub graph"
msgstr "子图的度数"

msgid "Dry run execution"
msgstr "试运行执行"

msgid ""
"To get the query generated used to get the vertex information, use ``dryrun "
"=> true``."
msgstr "要获取生成的用于获取顶点信息的查询，请使用 ``dryrun => true``。"

msgid "Degree from an existing table"
msgstr "来自现有表的度数"

msgid ""
"If you have a vertices table already built using ``pgr_extractVertices`` and "
"want the degree of the whole graph rather than a subset, you can forgo using "
"pgr_degree and work with the ``in_edges`` and ``out_edges`` columns directly."
msgstr ""
"如果您已经使用 ``pgr_extractVertices``构建了一个顶点表，并且想要整个图的度而"
"不是子集，则可以放弃使用 pgr_ Degree 并直接使用 ``in_edges`` 和 ``out_edges``"
"列。"

msgid ":doc:`pgr_extractVertices`"
msgstr ":doc:`pgr_extractVertices`"

msgid "``pgr_depthFirstSearch`` - Proposed"
msgstr "``pgr_depthFirstSearch`` - 拟议"

msgid ""
"``pgr_depthFirstSearch`` — Returns a depth first search traversal of the "
"graph. The graph can be directed or undirected."
msgstr ""
"``pgr_depthFirstSearch`` — 返回图的深度优先搜索遍历。 该图可以是有向图或无向"
"图。"

msgid "Version 3.3.0"
msgstr "版本3.3.0"

msgid "Promoted to **proposed** function"
msgstr "升级至**拟议**函数"

msgid "``pgr_depthFirstSearch`` (`Single Vertex`_)"
msgstr "``pgr_depthFirstSearch`` (`单个顶点`_)"

msgid "``pgr_depthFirstSearch`` (`Multiple Vertices`_)"
msgstr "``pgr_depthFirstSearch`` (`多个顶点`_)"

msgid ""
"Depth First Search algorithm is a traversal algorithm which starts from a "
"root vertex, goes as deep as possible, and backtracks once a vertex is "
"reached with no adjacent vertices or with all visited adjacent vertices. The "
"traversal continues until all the vertices reachable from the root vertex "
"are visited."
msgstr ""
"深度优先搜索算法是一种遍历算法，从根顶点开始，尽可能深入探索，一旦到达一个没"
"有相邻顶点或所有相邻顶点都已访问的顶点，就会回溯。遍历会一直持续，直到从根顶"
"点可达的所有顶点都被访问。"

msgid ""
"The implementation works for both **directed** and **undirected** graphs."
msgstr "该实现适用于**有向**图和**无向**图。"

msgid ""
"Provides the Depth First Search traversal order from a root vertex or from a "
"set of root vertices."
msgstr "提供从根顶点或一组根顶点开始的深度优先搜索遍历顺序。"

msgid ""
"An optional non-negative maximum depth parameter to limit the results up to "
"a particular depth."
msgstr "可选的非负最大深度参数，用于限制结果的深度到特定的深度。"

msgid ""
"For optimization purposes, any duplicated values in the `Root vids` are "
"ignored."
msgstr "为了优化的目的，`Root vids` 中的任何重复值都会被忽略。"

msgid ""
"It does not produce the shortest path from a root vertex to a target vertex."
msgstr "它不会生成从根顶点到目标顶点的最短路径。"

msgid "The aggregate cost of traversal is not guaranteed to be minimal."
msgstr "不保证遍历的总成本最小。"

msgid "The returned values are ordered in ascending order of `start_vid`."
msgstr "返回值按 `start_vid` 升序排列。"

msgid "Depth First Search Running time: :math:`O(E + V)`"
msgstr "深度优先搜索运行时间： :math:`O(E + V)`"

msgid "pgr_depthFirstSearch(`Edges SQL`_, **root vid**, [**options**])"
msgstr "pgr_depthFirstSearch(`Edges SQL`_, **root vid**, [**options**])"

msgid "pgr_depthFirstSearch(`Edges SQL`_, **root vids**, [**options**])"
msgstr "pgr_depthFirstSearch(`Edges SQL`_, **root vids**, [**options**])"

msgid "**options:** ``[directed, max_depth]``"
msgstr "**options:** ``[directed, max_depth]``"

msgid "Same as `Single vertex`_ but with edges in descending order of ``id``."
msgstr "与 `单顶点`_相同，但边按``id``降序排列。"

msgid ""
"`Boost: Depth First Search algorithm documentation <https://www.boost.org/"
"libs/graph/doc/depth_first_search.html>`__"
msgstr ""
"`Boost: 深度优先搜索算法文档 <https://www.boost.org/libs/graph/doc/"
"depth_first_search.html>`__"

msgid ""
"`Boost: Undirected DFS algorithm documentation <https://www.boost.org/libs/"
"graph/doc/undirected_dfs.html>`__"
msgstr ""
"`Boost：非定向 DFS 算法文档 <https://www.boost.org/libs/graph/doc/"
"undirected_dfs.html>`__"

msgid ""
"`Wikipedia: Depth First Search algorithm <https://en.wikipedia.org/wiki/"
"Depth-first_search>`__"
msgstr ""
"`维基百科：深度优先搜索算法 <https://en.wikipedia.org/wiki/Depth-"
"first_search>`__"

msgid "``pgr_dijkstra``"
msgstr "`pgr_dijkstra```"

msgid "``pgr_dijkstra`` — Shortest path(s) using Dijkstra algorithm."
msgstr "`pgr_dijkstra`` - 使用 Dijkstra 算法的最短路径。"

msgid "Version 3.5.0"
msgstr "版本 3.5.0"

msgid ""
"``pgr_dijkstra`` (`One to One`_) added ``start_vid`` and ``end_vid`` columns."
msgstr "``pgr_dijkstra`` (`一对一`_)增加``start_vid``和``end_vid``列。"

msgid "``pgr_dijkstra`` (`One to Many`_) added ``end_vid`` column."
msgstr "``pgr_dijkstra`` (`一对多`_) 增加``end_vid`` 列。"

msgid "``pgr_dijkstra`` (`Many to One`_) added ``start_vid`` column."
msgstr "``pgr_dijkstra`` (`多对一`_) 增加 ``start_vid``列。"

msgid "Version 3.1.0"
msgstr "版本 3.1.0"

msgid "``pgr_dijkstra`` (`Combinations`_)"
msgstr "``pgr_dijkstra`` (`组合`_)"

msgid "**Official** functions"
msgstr "**官方**函数"

msgid "Version 2.2.0"
msgstr "版本 2.2.0"

msgid "New **proposed** functions:"
msgstr "新的**拟议**函数："

msgid "``pgr_dijkstra`` (`One to Many`_)"
msgstr "``pgr_dijkstra`` (`一对多`_)"

msgid "``pgr_dijkstra`` (`Many to One`_)"
msgstr "``pgr_dijkstra`` (`多对一`_)"

msgid "``pgr_dijkstra`` (`Many to Many`_)"
msgstr "``pgr_dijkstra`` (`多对多`_)"

msgid "Signature change on ``pgr_dijkstra`` (`One to One`_)"
msgstr "``pgr_dijkstra`` (`一对一`_)的签名更改"

msgid "**Official** ``pgr_dijkstra`` (`One to One`_)"
msgstr "**官方**``pgr_dijkstra`` (`一对一`_)"

msgid "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""
"pgr_dijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid "pgr_dijkstra(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid ""
"pgr_dijkstra(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr ""
"pgr_dijkstra(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_dijkstra(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_dijkstra(`Edges SQL`_,`Combinations SQL`_, [``directed`])"

msgid "Breaking change on 3.5.0"
msgstr "3.5.0 上的重大变更"

msgid ""
"Read the :doc:`migration` about how to migrate from the old result columns "
"to the new result columns."
msgstr "请阅读 :doc:`migration` 关于如何从旧的结果列迁移到新的结果列。"

msgid ""
"From vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a **directed**"
msgstr "在**有向**图上，从顶点 :math:`6`到顶点 :math:`\\{10, 17\\}`"

msgid ""
"The examples of this section are based on the :doc:`sampledata` network."
msgstr "本节的示例基于 :doc:`示例数据` 网络。"

msgid "For **directed** graphs with ``cost`` and ``reverse_cost`` columns"
msgstr "对于带有 ``cost``和``reverse_cost``列的**有向**图"

msgid "Directed graph with cost and reverse cost columns"
msgstr "带成本列和反向成本列的有向图"

msgid "1) Path from :math:`6` to :math:`10`"
msgstr "1) 从 :math:`6` 到 :math:`10` 的路径"

msgid "2) Path from :math:`6` to :math:`7`"
msgstr "2) 从 :math:`6` 到 :math:`7` 的路径"

msgid "3) Path from :math:`12` to :math:`10`"
msgstr "3) 从 :math:`12` 到 :math:`10` 的路径"

msgid "4) Path from :math:`12` to :math:`7`"
msgstr "4) 从 :math:`12` 到 :math:`7` 的路径"

msgid "5) Using `One to Many`_ to get the solution of examples 1 and 2"
msgstr "5) 使用 `一对多`_ 来获取示例1和示例2的解决方案"

msgid "Paths :math:`\\{6\\}\\rightarrow\\{10, 7\\}`"
msgstr "路径 :math:`\\{6\\}\\rightarrow\\{10, 7\\}`"

msgid "6) Using `Many to One`_ to get the solution of examples 2 and 4"
msgstr "6) 使用 `多对一`_ 来获取示例2和示例4的解决方案"

msgid "Paths :math:`\\{6, 12\\}\\rightarrow\\{7\\}`"
msgstr "路径 :math:`\\{6, 12\\}\\rightarrow\\{7\\}`"

msgid "7) Using `Many to Many`_ to get the solution of examples 1 to 4"
msgstr "7) 使用 `多对多`_ 来获取示例1到4的解决方案"

msgid "Paths :math:`\\{6, 12\\}\\rightarrow\\{10, 7\\}`"
msgstr "路径 :math:`\\{6, 12\\}\\rightarrow\\{10, 7\\}`"

msgid "8) Using `Combinations`_ to get the solution of examples 1 to 3"
msgstr "8) 使用 `组合`_ 来获取示例1到3的解决方案"

msgid ""
"Paths :math:`\\{6\\}\\rightarrow\\{10, 7\\}\\cup\\{12\\}\\rightarrow\\{10\\}`"
msgstr ""
"路径 :math:`\\{6\\}\\rightarrow\\{10, 7\\}\\cup\\{12\\}\\rightarrow\\{10\\}`"

msgid "For **undirected** graphs with ``cost`` and ``reverse_cost`` columns"
msgstr "对于带有 ``cost``和``reverse_cost``列的**无向**图"

msgid "Undirected graph with cost and reverse cost columns"
msgstr "带成本列和反向成本列的无向图"

msgid "9) Path from :math:`6` to :math:`10`"
msgstr "9)从 :math:`6` 到 :math:`10` 的路径"

msgid "10) Path from :math:`6` to :math:`7`"
msgstr "10) 从 :math:`6` 到 :math:`7` 的路径"

msgid "11) Path from :math:`12` to :math:`10`"
msgstr "11)从 :math:`12` 到 :math:`10` 的路径"

msgid "12) Path from :math:`12` to :math:`7`"
msgstr "12)从 :math:`12` 到 :math:`7` 的路径"

msgid "13) Using `One to Many`_ to get the solution of examples 9 and 10"
msgstr "13) 使用 `一对多`_ 来获取示例9和10的解决方案"

msgid "14) Using `Many to One`_ to get the solution of examples 10 and 12"
msgstr "14) 使用 `多对一`_ 来获取示例10和12的解决方案"

msgid "15) Using `Many to Many`_ to get the solution of examples 9 to 12"
msgstr "15) 使用 `多对多`_ 来获取示例9到12的解决方案"

msgid "16) Using `Combinations`_ to get the solution of examples 9 to 11"
msgstr "16) 使用 `组合`_ 来获取示例9到11的解决方案"

msgid "For **directed** graphs only with ``cost`` column"
msgstr "仅适用于**有向**图，且仅包含``cost``列"

msgid "Directed graph only with cost column"
msgstr "仅有成本列的有向图"

msgid "17) Path from :math:`6` to :math:`10`"
msgstr "17)从 :math:`6` 到 :math:`10` 的路径"

msgid "18) Path from :math:`6` to :math:`7`"
msgstr "18) 从 :math:`6` 到 :math:`7` 的路径"

msgid "19) Path from :math:`12` to :math:`10`"
msgstr "19)从 :math:`12` 到 :math:`10` 的路径"

msgid "20) Path from :math:`12` to :math:`7`"
msgstr "20) 从 :math:`12` 到 :math:`7` 的路径"

msgid "21) Using `One to Many`_ to get the solution of examples 17 and 18"
msgstr "21) 使用 `一对多`_ 来获取示例17和18的解决方案"

msgid "22) Using `Many to One`_ to get the solution of examples 18 and 20"
msgstr "22) 使用 `多对一`_ 来获取示例18和20的解决方案"

msgid "23) Using `Many to Many`_ to get the solution of examples 17 to 20"
msgstr "23) 使用 `多对多`_ 来获取示例17到20的解决方案"

msgid "24) Using `Combinations`_ to get the solution of examples 17 to 19"
msgstr "24) 使用 `组合`_ 来获取示例17到19的解决方案"

msgid "For **undirected** graphs only with ``cost`` column"
msgstr "仅适用于带有``cost``列的**无向**图"

msgid "Undirected graph only with cost column"
msgstr "仅有成本列的无向图"

msgid "25) Path from :math:`6` to :math:`10`"
msgstr "25) 从 :math:`6` 到 :math:`10` 的路径"

msgid "26) Path from :math:`6` to :math:`7`"
msgstr "26) 从 :math:`6` 到 :math:`7` 的路径"

msgid "27) Path from :math:`12` to :math:`10`"
msgstr "27)从 :math:`12` 到 :math:`10` 的路径"

msgid "28) Path from :math:`12` to :math:`7`"
msgstr "28) 从 :math:`12` 到 :math:`7` 的路径"

msgid "29) Using `One to Many`_ to get the solution of examples 25 and 26"
msgstr "29) 使用 `一对多`_ 来获取示例25和26的解决方案"

msgid "30) Using `Many to One`_ to get the solution of examples 26 and 28"
msgstr "30) 使用 `多对一`_ 来获取示例26和28的解决方案"

msgid "31) Using `Many to Many`_ to get the solution of examples 25 to 28"
msgstr "31) 使用 `多对多`_ 来获取示例25到28的解决方案"

msgid "32) Using `Combinations`_ to get the solution of examples 25 to 27"
msgstr "32) 使用 `组合`_ 来获取示例25到27的解决方案"

msgid "Equvalences between signatures"
msgstr "签名之间的等价性"

msgid ""
"The following examples find the path for :math:`\\{6\\}\\rightarrow\\{10\\}`"
msgstr "下面的示例可以找到 :math:`\\{6}\\rightarrow\\{10\\}` 的路径"

msgid "33) Using `One to One`_"
msgstr "33) 使用 `一对一`_"

msgid "34) Using `One to Many`_"
msgstr "34)使用 `一对多`_"

msgid "35) Using `Many to One`_"
msgstr "35) 使用 `多对一`_"

msgid "36) Using `Many to Many`_"
msgstr "36) 使用 `多对多`_"

msgid "37) Using `Combinations`_"
msgstr "37) 使用 `组合`_"

msgid "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
msgstr "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"

msgid "``pgr_dijkstraCost``"
msgstr "`pgr_dijkstraCost``"

msgid ""
"``pgr_dijkstraCost`` - Total cost of the shortest path(s) using Dijkstra "
"algorithm."
msgstr "`pgr_dijkstraCost`` - 使用 Dijkstra 算法计算的最短路径总成本。"

msgid "``pgr_dijkstraCost`` (`Combinations`_)"
msgstr "``pgr_dijkstraCost`` (`组合`_)"

msgid ""
"The ``pgr_dijkstraCost`` function sumarizes of the cost of the shortest "
"path(s) using Dijkstra Algorithm."
msgstr "``pgr_dijkstraCost`` 函数总结了使用Dijkstra算法的最短路径的成本。"

msgid ""
"pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""
"pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid ""
"pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""
"pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid ""
"pgr_dijkstraCost(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""
"pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid ""
"pgr_dijkstraCost(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr ""
"pgr_dijkstraCost(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_dijkstraCost(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_dijkstraCost(`Edges SQL`_,`Combinations SQL`_, [`directed`])"

msgid "``pgr_dijkstraCostMatrix``"
msgstr "``pgr_dijkstraCostMatrix``"

msgid ""
"``pgr_dijkstraCostMatrix`` - Calculates a cost matrix using :doc:"
"`pgr_dijkstra`."
msgstr "``pgr_dijkstraCostMatrix`` - 使用 :doc:`pgr_dijkstra` 计算成本矩阵。"

msgid "Using Dijkstra algorithm, calculate and return a cost matrix."
msgstr "使用 Dijkstra 算法，计算并返回成本矩阵。"

msgid "pgr_dijkstraCostMatrix(`Edges SQL`_, **start vids**, [``directed``])"
msgstr "pgr_dijkstraCostMatrix(`Edges SQL`_, **start vids**, [``directed`])"

msgid "``pgr_dijkstraNear`` - Proposed"
msgstr "``pgr_dijkstraNear`` - 拟议"

msgid ""
"``pgr_dijkstraNear`` — Using Dijkstra's algorithm, finds the route that "
"leads to the nearest vertex."
msgstr "``pgr_dijkstraNear`` - 使用 Dijkstra 算法，找到通往最近顶点的路径。"

msgid ""
"Given a graph, a starting vertex and a set of ending vertices, this function "
"finds the shortest path from the starting vertex to the nearest ending "
"vertex."
msgstr ""
"给定一个图、一个起始顶点和一组终止顶点，该函数会找出从起始顶点到最近的终止顶"
"点的最短路径。"

msgid "Uses Dijkstra algorithm."
msgstr "使用 Dijkstra 算法。"

msgid "Works for **directed** and **undirected** graphs."
msgstr "适用于**有向**和**无向**图。"

msgid "When there are more than one path to the same vertex with same cost:"
msgstr "当有多条路径通向同一顶点且成本相同时："

msgid "The algorithm will return just one path"
msgstr "算法将只返回一条路径"

msgid "Optionally allows to find more than one path."
msgstr "可选择查找多条路径。"

msgid "When more than one path is to be returned:"
msgstr "当需要返回多条路径时："

msgid "Results are sorted in increasing order of:"
msgstr "结果按以下顺序递增排序："

msgid "aggregate cost"
msgstr "总成本"

msgid "Within the same value of aggregate costs:"
msgstr "在总成本相同值范围内："

msgid "results are sorted by (source, target)"
msgstr "结果按 (source, target)排序"

msgid "Running time: Dijkstra running time: :math:`drt = O((|E| + |V|)log|V|)`"
msgstr "运行时间：Dijkstra 运行时间： :math:`drt = O((|E| + |V|)log|V|)`"

msgid "One to Many; :math:`drt`"
msgstr "一对多； :math:`drt`"

msgid "Many to One: :math:`drt`"
msgstr "多对一： :math:`drt`"

msgid "Many to Many: :math:`drt * |Starting vids|`"
msgstr "多对多： :math:`drt * |Starting vids|`"

msgid "Combinations: :math:`drt * |Starting vids|`"
msgstr "组合： :math:`drt * |Starting vids|`"

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vid**, **end vids**, [**options A**])"
msgstr ""
"pgr_dijkstraNear(`Edges SQL`_, **start vid**, **end vids**, [**options A**])"

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vid**, [**options A**])"
msgstr ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vid**, [**options A**])"

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vids**, [**options B**])"
msgstr ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vids**, [**options B**])"

msgid "pgr_dijkstraNear(`Edges SQL`_, `Combinations SQL`_, [**options B**])"
msgstr "pgr_dijkstraNear(`Edges SQL`_,`Combinations SQL`_, [**options B**])"

msgid "**options A:** ``[directed, cap]``"
msgstr "**选项A：** ``[directed, cap]``"

msgid "**options B:** ``[directed, cap, global]``"
msgstr "**选项B：** ``[directed, cap, global]``"

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""
"pgr_dijkstraNear(`Edges SQL`_, **start vid**, **end vids**, [**options**])"

msgid "**options:** ``[directed, cap]``"
msgstr "**选项：** ``[directed, cap]``"

msgid "Departing on car from vertex :math:`6` find the nearest subway station."
msgstr "从顶点:math:`6`乘车出发，找到最近的地铁站。"

msgid "Using a **directed** graph for car routing."
msgstr "使用**有向**图进行汽车路线规划。"

msgid ""
"The subway stations are on the following vertices :math:`\\{1, 10, 11\\}`"
msgstr "地铁站位于以下顶点上 :math:``{1, 10, 11\\}`"

msgid "The defaults used:"
msgstr "使用的默认值："

msgid "`directed => true`"
msgstr "`directed => true`"

msgid "`cap => 1`"
msgstr "`cap => 1`"

msgid "The result shows that station at vertex :math:`11` is the nearest."
msgstr "结果显示，位于顶点 :math:`11` 的站最近。"

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vid**, [**options**])"

msgid ""
"Departing on a car from a subway station find the nearest **two** stations "
"to vertex :math:`2`"
msgstr "从地铁站开车出发，找到距离顶点 :math:`2`最近的**两个**车站"

msgid "On line `4`: using the positional parameter: `directed` set to ``true``"
msgstr "第`4`行：使用位置参数：`directed`设置为`true`"

msgid "In line `5`: using named parameter `cap => 2`"
msgstr "第 `5` 行：使用命名参数 `cap => 2`"

msgid ""
"The result shows that station at vertex :math:`10` is the nearest and the "
"next best is :math:`11`."
msgstr "结果显示，位于顶点 :math:`10` 的站点最近，其次是 :math:`11`。"

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vids**, [**options**])"

msgid "**options:** ``[directed, cap, global]``"
msgstr "**选项：** ``[定向、上限、全局]```"

msgid "Find the best pedestrian connection between two lines of buses"
msgstr "在两条公交线路之间寻找最佳的行人通道"

msgid "Unsing an **undirected** graph for pedestrian routing"
msgstr "使用**无向**图进行行人路线规划"

msgid "The first subway line stations are at :math:`\\{15, 16\\}`"
msgstr "第一条地铁线的站点位于 :math:`\\{15, 16\\}`"

msgid "The second subway line stations stops are at :math:`\\{1, 10, 11\\}`"
msgstr "地铁二号线的站点是:math:`\\{1, 10, 11\\}`"

msgid "On line `4`: using the named parameter: `directed => false`"
msgstr "第 `4` 行：使用命名参数：`directed => false`"

msgid "`global => true`"
msgstr "`global => true`"

msgid ""
"For a pedestrian the best connection is to get on/off is at vertex :math:"
"`15` of the first subway line and at vertex :math:`10` of the second subway "
"line."
msgstr ""
"对于行人来说，上下车的最佳连接点是第一条地铁线的顶点 :math:`15` 和第二条地铁"
"线的顶点 :math:`10`。"

msgid ""
"Only `one` route is returned because `global` is ``true`` and `cap` is ``1``"
msgstr "只返回 `一条`路由，因为 `global` 为 `true` 且 `cap` 为 `1"

msgid "pgr_dijkstraNear(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr "pgr_dijkstraNear(`Edges SQL`_,`Combinations SQL`_, [**options**])"

msgid ""
"Find the best car connection between all the stations of two subway lines"
msgstr "查找两条地铁线所有站点之间的最佳汽车连接线路"

msgid "The first subway line stations stops are at :math:`\\{1, 10, 11\\}`"
msgstr "第一条地铁线的站点是:math:`\\{1, 10, 11\\}`"

msgid "The second subway line stations are at :math:`\\{15, 16\\}`"
msgstr "地铁二号线站点位于 :math:`\\{15, 16\\}`"

msgid "The combinations contents:"
msgstr "组合内容："

msgid ""
"lines `3~4` sets the start vertices to be from the first subway line and the "
"ending vertices to be from the second subway line"
msgstr ""
"行 `3~4` 将起始顶点设置为第一条地铁线上的顶点，将终点顶点设置为第二条地铁线上"
"的顶点"

msgid ""
"lines `6~7` sets the start vertices to be from the first subway line and the "
"ending vertices to be from the first subway line"
msgstr ""
"行 `6~7` 将起始顶点设置为第一条地铁线上的顶点，将终点顶点设置为第一条地铁线上"
"的顶点"

msgid "On line `8`: using the named parameter is `global => false`"
msgstr "第 `8` 行：使用名为 `global => false` 的参数"

msgid "From the results:"
msgstr "从结果来看："

msgid ""
"making a connection from the first subway line :math:`\\{1, 10, 11\\}` to "
"the second :math:`\\{15, 16\\}`:"
msgstr ""
"将第一条地铁线:math:`{1, 10, 11\\}` 连接到第二条地铁线:math:`{15, 16\\}`："

msgid ""
"The best connections from all the stations from the first line are: :math:"
"`{(1 \\rightarrow 16) (10 \\rightarrow 16) (11 \\rightarrow 16)}`"
msgstr ""
"从第一条线路的所有站点出发的最佳连接是： :math:`{(1 \\rightarrow 16) (10 "
"\\rightarrow 16) (11 \\rightarrow 16)}`"

msgid ""
"The best one is :math:`(11 \\rightarrow 16)` with a cost of :math:`1` "
"(lines: `11` and `12`)"
msgstr ""
"最好的方法是 :math:`(11/rightarrow 16)`，成本是 :math:`1`（行：`11`和`12`）"

msgid ""
"making a connection from the second subway line :math:`\\{15, 16\\}` to the "
"first :math:`\\{1, 10, 11\\}`:"
msgstr ""
"将第二条地铁线:math:`{15, 16\\}` 连接到第一条地铁线:math:`{1, 10, 11\\}`："

msgid ""
"The best connections from all the stations from the second line are: :math:"
"`{(15 \\rightarrow 10) (16 \\rightarrow 11)}`"
msgstr ""
"从二号线所有站点出发的最佳连接是： :math:`{(15 ／rightarrow 10) (16 ／"
"rightarrow 11)}`"

msgid ""
"Both are equaly good as they have the same cost. (lines: `13` and `14` and "
"lines: `15` and `16`)"
msgstr ""
"它们都一样好，因为它们具有相同的成本（线路：`13`和`14`以及线路：`15`和`16`）"

msgid "Dijkstra optional parameters"
msgstr "Dijkstra 可选参数"

msgid "Near optional parameters"
msgstr "接近可选参数"

msgid "``cap``"
msgstr "`cap``"

msgid "Find at most ``cap`` number of nearest shortest paths"
msgstr "查找最多 ``cap`` 条最近的最短路径"

msgid "``global``"
msgstr "``global``"

msgid "When ``true``: only ``cap`` limit results will be returned"
msgstr "``true``时：仅返回``cap``结果"

msgid "When ``false``: ``cap`` limit per ``Start vid`` will be returned"
msgstr "当 ``false` 时：将返回每个 ``Start vid` 的 ``cap` 限值"

msgid "boost: https://www.boost.org/libs/graph/doc/table_of_contents.html"
msgstr "boost: https://www.boost.org/libs/graph/doc/table_of_contents.html"

msgid "Wikipedia: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
msgstr "维基百科：https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"

msgid "``pgr_dijkstraNearCost`` - Proposed"
msgstr "``pgr_dijkstraNearCost`` - 拟议"

msgid ""
"``pgr_dijkstraNearCost`` — Using dijkstra algorithm, finds the route that "
"leads to the nearest vertex."
msgstr "`pgr_dijkstraNearCost`` - 使用 dijkstra 算法，找到通往最近顶点的路径。"

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vids**, [**options "
"A**])"
msgstr ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vids**, [**options "
"A**])"

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vid**, [**options "
"A**])"
msgstr ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vid**, [**options "
"A**])"

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vids**, [**options "
"B**])"
msgstr ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vids**, [**options "
"B**])"

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, `Combinations SQL`_, [**options B**])"
msgstr ""
"pgr_dijkstraNearCost(`Edges SQL`_,`Combinations SQL`_, [**options B**])"

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vids**, "
"[**options**])"
msgstr ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vids**, "
"[**options**])"

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vid**, "
"[**options**])"
msgstr ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"

msgid ""
"Departing on a car from a subway station find the nearest **two** stations "
"to vertex :math:`6`"
msgstr "从地铁站开车出发找到距离顶点:math:`6`最近的**两个**车站"

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vids**, "
"[**options**])"
msgstr ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vids**, "
"[**options**])"

msgid "pgr_dijkstraNearCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr "pgr_dijkstraNearCost(`Edges SQL`_,`Combinations SQL`_, [**options**])"

msgid ""
"lines `3~4` sets the start vertices to be from the fisrt subway line and the "
"ending vertices to be from the second subway line"
msgstr "行 `3~4` 设置地铁三号线的起始顶点和地铁二号线的终点顶点"

msgid ""
"The best one is :math:`(11 \\rightarrow 16)` with a cost of :math:`1` "
"(lines: `1`)"
msgstr "最好的方法是 :math:`(11/rightarrow 16)`，成本是 :math:`1` (lines: `1`)"

msgid "Both are equaly good as they have the same cost. (lines: `12` and `13`)"
msgstr "由于成本相同，所以两者同样好。(线路：`12`和 `13`）"

msgid "``pgr_dijkstraVia`` - Proposed"
msgstr "``pgr_dijkstraVia`` -拟议"

msgid "``pgr_dijkstraVia`` — Route that goes through a list of vertices."
msgstr "`pgr_dijkstraVia` - 经过顶点列表的路径。"

msgid ""
"Given a list of vertices and a graph, this function is equivalent to finding "
"the shortest path between :math:`vertex_i` and :math:`vertex_{i+1}` for all :"
"math:`i < size\\_of(via\\;vertices)`."
msgstr ""
"给定一个顶点列表和一个图，该函数等价于为所有 :math:`i < size\\of(via\\;"
"vertices)` 的 :math:`vertex_i` 和 :math:`vertex_{i+1}` 之间找到最短路径。"

msgid "Route"
msgstr "路线"

msgid "is a sequence of paths."
msgstr "是一个路径序列。"

msgid "Path"
msgstr "路径"

msgid "is a section of the route."
msgstr "是路线的一段。"

msgid "One Via"
msgstr "一次通过"

msgid "pgr_dijkstraVia(`Edges SQL`_, **via vertices**, [**options**])"
msgstr "pgr_dijkstraVia(`Edges SQL`_, **via vertices**, [**options**])"

msgid "**options:** ``[directed, strict, U_turn_on_edge]``"
msgstr "**选项：** ``[directed, strict, U_turn_on_edge]``"

msgid ""
"Find the route that visits the vertices :math:`\\{5, 1, 8\\}` in that order "
"on an **directed** graph."
msgstr ""
"在一个**有向**图上，找出按此顺序访问顶点 :math:`\\{5, 1, 8\\}` 的路径。"

msgid "Via optional parameters"
msgstr "Via可选参数"

msgid "When ``true`` departing from a visited vertex will not try to avoid"
msgstr "为 `true` 时，从访问过的顶点出发时不会试图避开"

msgid "Identifier of a path. Has value **1** for the first path."
msgstr "路径的标识符。 第一条路径的值为 **1**。"

msgid "-1 for the last node of the path."
msgstr "-1，表示路径的最后一个节点。"

msgid "-2 for the last node of the route."
msgstr "路由的最后一个节点为 -2。"

msgid "``route_agg_cost``"
msgstr "``route_agg_cost``"

msgid ""
"Total cost from ``start_vid`` of ``seq = 1`` to ``end_vid`` of the current "
"``seq``."
msgstr "从 `seq = 1` 的 ``start_vid`` 到当前 `seq` 的 ``end_vid` 的总费用。"

msgid ""
"All this examples are about the route that visits the vertices :math:`\\{5, "
"7, 1, 8, 15\\}` in that order on a **directed** graph."
msgstr ""
"所有这些示例都是关于在**有向**图上按顺序访问顶点 :math:`\\{5, 7, 1, 8, 15\\}"
"` 的路径。"

msgid "The main query"
msgstr "主查询"

msgid "Aggregate cost of the third path."
msgstr "第三条路径的总成本。"

msgid "Route's aggregate cost of the route at the end of the third path."
msgstr "第三条路径末端的路径总成本。"

msgid "Nodes visited in the route."
msgstr "路由中访问的节点。"

msgid "The aggregate costs of the route when the visited vertices are reached."
msgstr "到达所访问顶点时的路线总成本。"

msgid "Status of \"passes in front\" or \"visits\" of the nodes."
msgstr "节点的 \"前方通过 \"或 \"访问 \"状态。"

msgid ":doc:`via-category`."
msgstr ":doc:`via-category`."

msgid ":doc:`dijkstra-family`."
msgstr ":doc:`dijkstra-family`."

msgid "``pgr_drivingDistance``"
msgstr "驾驶距离"

msgid ""
"``pgr_drivingDistance`` - Returns the driving distance from a start node."
msgstr "``pgr_drivingDistance`` - 返回起始节点的行驶距离。"

msgid "Standarizing output columns to |result-spantree|"
msgstr "将输出列标准化为 |result-spantree|"

msgid "Added ``depth`` and ``start_vid`` result columns."
msgstr "添加了 ``depth`` 和 ``start_vid`` 结果列。"

msgid "Result column name change: ``from_v`` to ``start_vid``."
msgstr "结果列名称更改：``from_v``改为 ``start_vid``。"

msgid "Added ``depth`` and ``pred`` result columns."
msgstr "添加了 ``depth``和``pred``结果列。"

msgid "Signature change pgr_drivingDistance(single vertex)"
msgstr "签名更改 pgr_drivingDistance（单顶点）"

msgid "New **Official** pgr_drivingDistance(multiple vertices)"
msgstr "新**官方** pgr_drivingDistance(多顶点)"

msgid "Official:: pgr_drivingDistance(single vertex)"
msgstr "官方:: pgr_drivingDistance(单顶点)"

msgid ""
"Using the Dijkstra algorithm, extracts all the nodes that have costs less "
"than or equal to the value ``distance``. The edges extracted will conform to "
"the corresponding spaning tree."
msgstr ""
"使用Dijkstra算法，提取所有成本小于或等于值``distance``的节点。提取的边将符合"
"相应的生成树。"

msgid ""
"pgr_drivingDistance(`Edges SQL`_, **Root vid**,  **distance**, "
"[``directed``])"
msgstr ""
"pgr_drivingDistance(`Edges SQL`_, **Root vid**,  **distance**, "
"[``directed``])"

msgid ""
"pgr_drivingDistance(`Edges SQL`_, **Root vids**, **distance**, [**options**])"
msgstr ""
"pgr_drivingDistance(`Edges SQL`_, **Root vids**, **distance**, [**options**])"

msgid "**options:** [directed, equicost]"
msgstr "**options:** [directed, equicost]"

msgid "Single Vertex"
msgstr "单顶点"

msgid "From vertex :math:`11` for a distance of :math:`3.0`"
msgstr "从顶点:math:`11`到:math:`3.0`的距离"

msgid "Multiple Vertices"
msgstr "多顶点"

msgid ""
"From vertices :math:`\\{11, 16\\}` for a distance of :math:`3.0` with equi-"
"cost on a directed graph"
msgstr ""
"从顶点 :math:`{11, 16\\}` 出发，距离为 :math:`3.0` 且有向图上的成本相等"

msgid "Driving distance optional parameters"
msgstr "行驶距离可选参数"

msgid "``equicost``"
msgstr "``equicost``"

msgid ""
"When ``true`` the node will only appear in the closest ``start_vid`` list. "
"Tie brakes are arbitrary."
msgstr ""
"``true``时，节点只会出现在最近的 ``start_vid``列表中。绑定制动是任意的。"

msgid ""
"When ``false`` which resembles several calls using the single vertex "
"signature."
msgstr "``false``时，类似于使用单顶点签名的多次调用。"

msgid ""
"From vertices :math:`\\{11, 16\\}` for a distance of :math:`3.0` on an "
"undirected graph"
msgstr "在无向图上，从顶点:math:`{11, 16\\}` 开始的距离为:math:`3.0`"

msgid "pgr_edgeColoring - Experimental"
msgstr "pgr_edgeColoring - 实验"

msgid ""
"``pgr_edgeColoring`` — Returns the edge coloring of undirected and loop-free "
"graphs"
msgstr "``pgr_edgeColoring`` - 返回无向图和无环图的边着色"

msgid ""
"Edge Coloring is an algorithm used for coloring of the edges for the "
"vertices in the graph. It is an assignment of colors to the edges of the "
"graph so that no two adjacent edges have the same color."
msgstr ""
"边着色是一种用于为图形中顶点的边着色的算法。它为图中的边分配颜色，使相邻的两"
"条边没有相同的颜色。"

msgid "The implementation is for **undirected** and **loop-free** graphs"
msgstr "针对**无向**和**无环**图实施"

msgid "loop free"
msgstr "无环"

msgid "no self-loops and no parallel edges."
msgstr "无自循环，无平行边。"

msgid ""
"Provides the color to be assigned to all the edges present in the graph."
msgstr "指定要分配给图中所有边的颜色。"

msgid ""
"At most :math:`\\Delta + 1` colors are used, where :math:`\\Delta` is the "
"degree of the graph."
msgstr "最多使用 :math:`\\Delta + 1` 种颜色，其中 :math:`\\Delta` 是图的度数。"

msgid ""
"This is optimal for some graphs, and by Vizing's theorem it uses at most one "
"color more than the optimal for all others."
msgstr ""
"这对于某些图是最优的，根据Vizing定理，对于所有其他图，它使用的颜色最多比最优"
"解多一种。"

msgid ""
"the chromatic number :math:`x'(G)` (minimum number of colors needed for "
"proper edge coloring of graph)  is equal to the degree :math:`\\Delta + 1` "
"of the graph, (:math:`x'(G) = \\Delta`)"
msgstr ""

msgid "The algorithm tries to assign the least possible color to every edge."
msgstr "该算法尝试为每条边分配尽可能少的颜色。"

msgid "Does not always produce optimal coloring."
msgstr "并不总是产生最佳的着色。"

msgid ""
"The returned rows are ordered in ascending order of the edge identifier."
msgstr "返回的行按边标识符的升序排列。"

msgid "Efficient graph coloring is an NP-Hard problem, and therefore:"
msgstr "高效图形着色是一个 NP-Hard问题，因此："

msgid "In this implelentation the running time: :math:`O(|E|*|V|)`"
msgstr "在此实现中，运行时间为： :math:`O(|E|*|V||)`"

msgid "where :math:`|E|` is the number of edges in the graph,"
msgstr "其中 :math:`|E|` 是图中的边数、"

msgid ":math:`|V|` is the number of vertices in the graph."
msgstr ":math:`|V|` 是图中的顶点数。"

msgid "pgr_edgeColoring(`Edges SQL`_)"
msgstr "pgr_edgeColoring(`Edges SQL`_)"

msgid "RETURNS SET OF |result-edge-color|"
msgstr "RETURNS SET OF |result-edge-color|"

msgid "Graph coloring of pgRouting :doc:`sampledata`"
msgstr "pgRouting :doc:`示例数据`的图着色"

msgid "``pgr_edgeDisjointPaths``"
msgstr "``pgr_edgeDisjointPaths``"

msgid ""
"``pgr_edgeDisjointPaths`` — Calculates edge disjoint paths between two "
"groups of vertices."
msgstr "``pgr_edgeDisjointPaths`` - 计算两组顶点之间的边不相交路径。"

msgid "New **proposed** function:"
msgstr "新的**拟议**函数："

msgid "pgr_edgeDisjointPaths(Combinations)"
msgstr "pgr_edgeDisjointPaths(组合)"

msgid ""
"Calculates the edge disjoint paths between two groups of vertices. Utilizes "
"underlying maximum flow algorithms to calculate the paths."
msgstr "计算两组顶点之间的边不相交路径。 利用底层最大流量算法来计算路径。"

msgid "The main characterics are:"
msgstr "主要特点是："

msgid "Calculates the edge disjoint paths between any two groups of vertices."
msgstr "计算任意两组顶点之间的边相交路径。"

msgid ""
"Returns EMPTY SET when source and destination are the same, or cannot be "
"reached."
msgstr "当源和目标相同或无法到达时，返回 EMPTY SET。"

msgid "The graph can be directed or undirected."
msgstr "图可以是有向或无向的。"

msgid "Uses :doc:`pgr_boykovKolmogorov` to calculate the paths."
msgstr "使用 :doc:`pgr_boykovKolmogorov` 计算路径。"

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vid**, "
"[``directed``])"
msgstr ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vid**, "
"[``directed``])"

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vids**, "
"[``directed``])"
msgstr ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vids**, "
"[``directed``])"

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vids**, **end vid**, "
"[``directed``])"
msgstr ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vid**, "
"[``directed``])"

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_edgeDisjointPaths(`Edges SQL`_,`Combinations SQL`_, [``directed`])"

msgid "RETURNS SET OF |result-disjoint|"
msgstr "返回 |result-disjoint| 的集合"

msgid "RETURNS SET OF |result-disjoint-1-1|"
msgstr "返回|result-disjoint-1-1|集合"

msgid "RETURNS SET OF |result-disjoint-1-m|"
msgstr "返回 |result-disjoint-1-m|集合"

msgid "RETURNS SET OF |result-disjoint-m-1|"
msgstr "返回|result-disjoint-m-1|集合"

msgid "RETURNS SET OF |result-disjoint-m-m|"
msgstr "返回 |result-disjoint-m-m|集合"

msgid ""
"Using a combinations table, equivalent to calculating result from vertices :"
"math:`\\{5, 6\\}` to vertices :math:`\\{10, 15, 14\\}` on an undirected "
"graph."
msgstr "使用组合表，相当于计算无向图上从顶点 :math:`\\{5, 6\\}`到顶点 :math:`\\{10, "
"15, 14\\}`的结果。"

msgid "Manually assigned vertex combinations on an undirected graph."
msgstr "在无向图上手动分配顶点组合。"

msgid "``pgr_edmondsKarp``"
msgstr "``pgr_edmondsKarp``"

msgid ""
"``pgr_edmondsKarp`` — Calculates the flow on the graph edges that maximizes "
"the flow from the sources to the targets using Edmonds Karp Algorithm."
msgstr "``pgr_edmondsKarp`` —使用 Edmonds Karp "
"算法计算图边上的流量，以最大化从源到目标的流量。"

msgid "``pgr_edmondsKarp`` (`Combinations`_)"
msgstr "``pgr_edmondsKarp`` (`组合`_)"

msgid "Renamed from ``pgr_maxFlowEdmondsKarp``"
msgstr "由 ``pgr_maxFlowEdmondsKarp`` 重命名"

msgid "Running time: :math:`O( V * E ^ 2)`"
msgstr "运行时间：:math:`O( V * E ^ 2)`"

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_edmondsKarp(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_edmondsKarp(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_edmondsKarp(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_edmondsKarp(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_edmondsKarp(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_edmondsKarp(`Edges SQL`_, `Combinations SQL`_)"

msgid "https://www.boost.org/libs/graph/doc/edmonds_karp_max_flow.html"
msgstr "https://www.boost.org/libs/graph/doc/edmonds_karp_max_flow.html"

msgid "https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm"
msgstr "https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm"

msgid "``pgr_edwardMoore - Experimental``"
msgstr "``pgr_edwardMoore -实验``"

msgid ""
"``pgr_edwardMoore`` —  Returns the shortest path using Edward-Moore "
"algorithm."
msgstr "``pgr_edwardMoore`` - 使用 Edward-Moore 算法返回最短路径。"

msgid "``pgr_edwardMoore`` (`Combinations`_)"
msgstr "``pgr_edwardMoore`` (`组合`_)"

msgid "``pgr_edwardMoore`` (`One to One`_)"
msgstr "``pgr_edwardMoore`` (`一对一`_)"

msgid "``pgr_edwardMoore`` (`One to Many`_)"
msgstr "``pgr_edwardMoore`` (`一对多`_)"

msgid "``pgr_edwardMoore`` (`Many to One`_)"
msgstr "``pgr_edwardMoore`` (`多对一`_)"

msgid "``pgr_edwardMoore`` (`Many to Many`_)"
msgstr "``pgr_edwardMoore`` (`多对多`_)"

msgid ""
"Edward Moore’s Algorithm is an improvement of the Bellman-Ford Algorithm. It "
"can compute the shortest paths from a single source vertex to all other "
"vertices in a weighted directed graph. The main difference between Edward "
"Moore's Algorithm and Bellman Ford's Algorithm lies in the run time."
msgstr ""
"Edward Moore算法是Bellman-Ford算法的改进。 "
"它可以计算加权有向图中从单个源顶点到所有其他顶点的最短路径。 Edward "
"Moore算法和Bellman-Ford算法之间的主要区别在于运行时间。"

msgid ""
"The worst-case running time of the algorithm is :math:`O(| V | * | E |)` "
"similar to the time complexity of Bellman-Ford algorithm. However, "
"experiments suggest that this algorithm has an average running time "
"complexity of :math:`O( | E | )` for random graphs. This is significantly "
"faster in terms of computation speed."
msgstr ""
"该算法的最坏运行时间为:math:`O(| V | * | E |)` ，类似于Bellman-"
"Ford算法的时间复杂度。然而，实验表明，对于随机图，"
"该算法的平均运行时间复杂度为 :math:`O( | E | )`。这在计算速度上明显更快。"

msgid ""
"Thus, the algorithm is at-best, significantly faster than Bellman-Ford "
"algorithm and is at-worst,as good as Bellman-Ford algorithm"
msgstr "因此，该算法在最好的情况下，明显快于 Bellman-Ford 算法，在最差的情况下，与 "
"Bellman-Ford 算法一样好"

msgid "The `agg_cost` the non included values `(v, v)` is :math:`0`"
msgstr "未包含值 `(v, v)` 的 `agg_cost` 为 :math:`0`"

msgid ""
"For optimization purposes, any duplicated value in the `start vids` or `end "
"vids` are ignored."
msgstr "出于优化目的， `start vids` 或`end vids`中的任何重复值都将被忽略。"

msgid "`start vid` ascending"
msgstr "`start vid`升序"

msgid "`end vid` ascending"
msgstr "`end vid`升序"

msgid "Running time:"
msgstr "运行时间："

msgid "Worst case: :math:`O(| V | * | E |)`"
msgstr "最坏的情况：:math:`O(| V | * | E |)`"

msgid "Average case: :math:`O( | E | )`"
msgstr "平均情况：:math:`O( | E | )`"

msgid ""
"pgr_edwardMoore(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""
"pgr_edwardMoore(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"

msgid ""
"pgr_edwardMoore(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""
"pgr_edwardMoore(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid ""
"pgr_edwardMoore(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""
"pgr_edwardMoore(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"

msgid ""
"pgr_edwardMoore(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr ""
"pgr_edwardMoore(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"

msgid "pgr_edwardMoore(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr "pgr_edwardMoore(`Edges SQL`_, `Combinations SQL`_, [``directed``])"

msgid "https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm"
msgstr "https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm"

msgid "pgr_extractVertices -- Proposed"
msgstr "pgr_extractVertices -- 拟议"

msgid "``pgr_extractVertices`` — Extracts the vertices information"
msgstr "``pgr_extractVertices`` — 提取顶点信息"

msgid "Classified as **proposed** function"
msgstr "列为**拟议**函数"

msgid ""
"This is an auxiliary function for extracting the vertex information of the "
"set of edges of a graph."
msgstr "这是一个用于提取图的边集的顶点信息的辅助函数。"

msgid ""
"When the edge identifier is given, then it will also calculate the in and "
"out edges"
msgstr "当给出边标识符时，它也会计算出入边"

msgid "pgr_extractVertices(`Edges SQL`_, [``dryrun``])"
msgstr "pgr_extractVertices(`Edges SQL`_, [``dryrun``])"

msgid "RETURNS SETOF |result-extract|"
msgstr "RETURNS SETOF |result-extract|"

msgid "When line geometry is known"
msgstr "当线的几何形状已知时"

msgid "(Optional) identifier of the edge."
msgstr "（可选）边的标识符。"

msgid "``geom``"
msgstr "``geom``"

msgid "``LINESTRING``"
msgstr "``LINESTRING``"

msgid "Geometry of the edge."
msgstr "边的几何形状。"

msgid ""
"This inner query takes precedence over the next two inner query, therefore "
"other columns are ignored when ``geom`` column appears."
msgstr "该内部查询优先于接下来的两个内部查询，因此当``geom`` "
"列出现时，其他列将被忽略。"

msgid "Ignored columns:"
msgstr "忽略的列："

msgid "``startpoint``"
msgstr "``startpoint``"

msgid "``endpoint``"
msgstr "``endpoint``"

msgid "When vertex geometry is known"
msgstr "当顶点几何形状已知时"

msgid ""
"To use this inner query the column ``geom`` should not be part of the set of "
"columns."
msgstr "要使用此内部查询，列 ``geom`` 不应成为列集的一部分。"

msgid "``POINT``"
msgstr "``POINT``"

msgid "POINT geometry of the starting vertex."
msgstr "POINT 起始顶点的几何图形。"

msgid "POINT geometry of the ending vertex."
msgstr "POINT结束顶点的几何图形。"

msgid ""
"This inner query takes precedence over the next inner query, therefore other "
"columns are ignored when ``startpoint`` and ``endpoint`` columns appears."
msgstr "此内部查询优先于下一个内部查询，因此当出现``startpoint`` 和 "
"``endpoint``列时，其他列将被忽略。"

msgid "When identifiers of vertices are known"
msgstr "当顶点的标识符已知时"

msgid ""
"To use this inner query the columns ``geom``, ``startpoint`` and "
"``endpoint`` should not be part of the set of columns."
msgstr "要使用此内部查询，列 "
"``geom``、``startpoint``和``endpoint``不应成为列集的一部分。"

msgid "``NULL`` When the ``id`` is not part of the inner query"
msgstr "``NULL`` 当 ``id``不是内部查询的一部分时"

msgid "X value of the point geometry"
msgstr "点几何的X值"

msgid "``NULL`` When no geometry is provided"
msgstr "``NULL``当没有提供几何图形时"

msgid "Geometry of the point"
msgstr "点几何"

msgid "Dryrun execution"
msgstr "试运行执行"

msgid ""
"To get the query generated used to get the vertex information, use ``dryrun :"
"= true``."
msgstr "要获取用于生成顶点信息的查询，请使用 ``dryrun := true``。"

msgid ""
"The results can be used as base code to make a refinement based on the "
"backend development needs."
msgstr "结果可以作为基础代码，根据后端开发需求进行细化。"

msgid "``pgr_findCloseEdges``"
msgstr "``pgr_findCloseEdges``"

msgid "``pgr_findCloseEdges`` - Finds the close edges to a point geometry."
msgstr ""

msgid "New **proposed** signatures:"
msgstr ""

msgid "``pgr_findCloseEdges`` (`One point`_)"
msgstr ""

msgid "``pgr_findCloseEdges`` (`Many points`_)"
msgstr ""

msgid ""
"``pgr_findCloseEdges`` - An utility function that finds the closest edge to "
"a point geometry."
msgstr ""

msgid ""
"The geometries must be in the same coordinate system (have the same SRID)."
msgstr ""

msgid ""
"The code to do the calculations can be obtained for further specific "
"adjustments needed by the application."
msgstr ""

msgid "``EMTPY SET`` is returned on dryrun executions"
msgstr ""

msgid ""
"pgr_findCloseEdges(`Edges SQL`_, **point**, **tolerance**, [**options**])"
msgstr ""

msgid ""
"pgr_findCloseEdges(`Edges SQL`_, **points**, **tolerance**, [**options**])"
msgstr ""

msgid "**options:** ``[cap, partial, dryrun]``"
msgstr ""

msgid "RETURNS SET OF |result-find|"
msgstr ""

msgid "One point"
msgstr ""

msgid "Default: ``cap => 1``"
msgstr ""

msgid "Maximum one row answer."
msgstr ""

msgid "Default: ``partial => true``"
msgstr ""

msgid "With less calculations as possible."
msgstr ""

msgid "Default: ``dryrun => false``"
msgstr ""

msgid "Process query"
msgstr ""

msgid "Returns"
msgstr ""

msgid "values on ``edge_id``, ``fraction``, ``side`` columns."
msgstr ""

msgid "``NULL`` on ``distance``, ``geom``, ``edge`` columns."
msgstr ""

msgid "Many points"
msgstr ""

msgid ""
"Find at most :math:`2` edges close to all vertices on the points of interest "
"table."
msgstr ""

msgid "One answer per point, as small as possible."
msgstr ""

msgid ""
"Columns ``edge_id``, ``fraction``, ``side`` and ``geom`` are returned with "
"values."
msgstr ""

msgid ""
"``geom`` contains the original point geometry to assist on deterpartialing "
"to which point geometry the row belongs to."
msgstr ""

msgid "**point**"
msgstr ""

msgid "The point geometry"
msgstr ""

msgid "**points**"
msgstr ""

msgid "``POINT[]``"
msgstr ""

msgid "An array of point geometries"
msgstr ""

msgid "**tolerance**"
msgstr ""

msgid "Max distance between geometries"
msgstr ""

msgid "Limit output rows"
msgstr ""

msgid "``partial``"
msgstr ""

msgid ""
"When ``true`` only columns needed for :doc:`withPoints-category` are "
"calculated."
msgstr ""

msgid "When ``false`` all columns are calculated"
msgstr ""

msgid "When ``false`` calculations are performed."
msgstr ""

msgid ""
"When ``true`` calculations are not performed and the query to do the "
"calculations is exposed in a PostgreSQL ``NOTICE``."
msgstr ""

msgid "The ``LINESTRING`` geometry of the edge."
msgstr ""

msgid "Returns set of |result-find|"
msgstr ""

msgid "When :math:`cap = 1`, it is the closest edge."
msgstr ""

msgid ""
"Value in <0,1> that indicates the relative postition from the first end-"
"point of the edge."
msgstr ""

msgid "Value in ``[r, l]`` indicating if the point is:"
msgstr ""

msgid "In the right ``r``."
msgstr ""

msgid "In the left ``l``."
msgstr ""

msgid "When the point is on the line it is considered to be on the right."
msgstr ""

msgid "``distance``"
msgstr ""

msgid "Distance from point to edge."
msgstr ""

msgid "``NULL`` when ``cap = 1`` on the `One point`_ signature"
msgstr ""

msgid "``POINT`` geometry"
msgstr ""

msgid ""
"`One Point`_: Contains the point on the edge that is ``fraction`` away from "
"the starting point of the edge."
msgstr ""

msgid "`Many Points`_: Contains the corresponding **original point**"
msgstr ""

msgid ""
"``LINESTRING`` geometry from the **original point** to the closest point of "
"the edge with identifier ``edge_id``"
msgstr ""

msgid "One point results"
msgstr ""

msgid "The green nodes is the **original point**"
msgstr ""

msgid ""
"The geometry ``geom`` is a point on the :math:`sp \\rightarrow ep` edge."
msgstr ""

msgid ""
"The geometry ``edge`` is a line that connects the **original point** with "
"``geom``"
msgstr ""

msgid "Many point results"
msgstr ""

msgid "The green nodes are the **original points**"
msgstr ""

msgid ""
"The geometry ``geom``, marked as **g1** and **g2**  are the **original "
"points**"
msgstr ""

msgid ""
"The geometry ``edge``, marked as **edge1** and **edge2** is a line that "
"connects the **original point** with the closest point on the :math:`sp "
"\\rightarrow ep` edge."
msgstr ""

msgid "One point examples"
msgstr ""

msgid "At most two answers"
msgstr ""

msgid "``cap => 2``"
msgstr ""

msgid "Maximum two row answer."
msgstr ""

msgid "Understanding the result"
msgstr ""

msgid "``NULL`` on ``geom``, ``edge``"
msgstr ""

msgid "``edge_id`` identifier of the edge close to the **original point**"
msgstr ""

msgid ""
"Two edges are withing :math:`0.5` distance units from the **original "
"point**: :math:`{5, 8}`"
msgstr ""

msgid "For edge :math:`5`:"
msgstr ""

msgid ""
"``fraction``: The closest point from the **original point** is at the :math:"
"`0.8` fraction of the edge :math:`5`."
msgstr ""

msgid ""
"``side``: The **original point** is located to the left side of edge :math:"
"`5`."
msgstr ""

msgid ""
"``distance``: The **original point** is located :math:`0.1` length units "
"from edge :math:`5`."
msgstr ""

msgid "For edge :math:`8`:"
msgstr ""

msgid ""
"``fraction``: The closest point from the **original point** is at the :math:"
"`0.89..` fraction of the edge :math:`8`."
msgstr ""

msgid ""
"``side``: The **original point** is located to the right side of edge :math:"
"`8`."
msgstr ""

msgid ""
"``distance``: The **original point** is located :math:`0.19..` length units "
"from edge :math:`8`."
msgstr ""

msgid "One answer, all columns"
msgstr ""

msgid "``partial => false``"
msgstr ""

msgid "Calculate all columns"
msgstr ""

msgid ""
"``edge_id`` identifier of the edge **closest** to the **original point**"
msgstr ""

msgid ""
"From all edges within :math:`0.5` distance units from the **original "
"point**: :math:`{5}` is the closest one."
msgstr ""

msgid ""
"``geom``: Contains the geometry of the closest point on edge :math:`5` from "
"the **original point**."
msgstr ""

msgid ""
"``edge``: Contains the ``LINESTRING`` geometry of the **original point** to "
"the closest point on on edge :math:`5` ``geom``"
msgstr ""

msgid "At most two answers with all columns"
msgstr ""

msgid "Understanding the result:"
msgstr ""

msgid ""
"``geom``: Contains the geometry of the closest point on edge :math:`8` from "
"the **original point**."
msgstr ""

msgid ""
"``edge``: Contains the ``LINESTRING`` geometry of the **original point** to "
"the closest point on on edge :math:`8` ``geom``"
msgstr ""

msgid "One point dry run execution"
msgstr ""

msgid "Returns ``EMPTY SET``."
msgstr ""

msgid "``partial => true``"
msgstr ""

msgid "Is ignored"
msgstr ""

msgid ""
"Because it is a **dry run** excecution, the code for all calculations are "
"shown on the PostgreSQL ``NOTICE``."
msgstr ""

msgid "``dryrun => true``"
msgstr ""

msgid "Do not process query"
msgstr ""

msgid ""
"Generate a PostgreSQL ``NOTICE`` with the code used to calculate all columns"
msgstr ""

msgid "``cap`` and **original point** are used in the code"
msgstr ""

msgid "Many points examples"
msgstr ""

msgid "At most two answers per point"
msgstr ""

msgid "``NULL`` on ``edge``"
msgstr ""

msgid ""
"``edge_id`` identifier of the edge close to a **original point** (``geom``)"
msgstr ""

msgid ""
"Two edges at most withing :math:`0.5` distance units from each of the "
"**original points**:"
msgstr ""

msgid "For ``POINT(1.8 0.4)`` and ``POINT(0.3 1.8)`` only one edge was found."
msgstr ""

msgid "For the rest of the points two edges were found."
msgstr ""

msgid "For point ``POINT(2.9 1.8)``"
msgstr ""

msgid ""
"Edge :math:`5` is before :math:`8` therefore edge :math:`5` has the shortest "
"distance to ``POINT(2.9 1.8)``."
msgstr ""

msgid "One answer per point, all columns"
msgstr ""

msgid "For the **original point** ``POINT(2.9 1.8)``"
msgstr ""

msgid "Edge :math:`5` is the closest edge to the **original point**"
msgstr ""

msgid ""
"``geom``: Contains the geometry of the **original point** ``POINT(2.9 1.8)``"
msgstr ""

msgid ""
"``edge``: Contains the ``LINESTRING`` geometry of the **original point** "
"(``geom``) to the closest point on on edge."
msgstr ""

msgid "Many points dry run execution"
msgstr ""

msgid "Find at most two routes to a given point"
msgstr ""

msgid "Using :doc:`pgr_withPoints`"
msgstr ""

msgid "A point of interest table"
msgstr ""

msgid "Handling points outside the graph."
msgstr ""

msgid "Points of interest"
msgstr ""

msgid ""
"Some times the applications work \"on the fly\" starting from a location "
"that is not a vertex in the graph. Those locations, in pgRrouting are called "
"points of interest."
msgstr ""

msgid ""
"The information needed in the points of interest is ``pid``, ``edge_id``, "
"``side``, ``fraction``."
msgstr ""

msgid ""
"On this documentation there will be some 6 fixed points of interest and they "
"will be stored on a table."
msgstr ""

msgid "A unique identifier."
msgstr ""

msgid ""
"Identifier of the edge nearest edge that allows an arrival to the point."
msgstr ""

msgid "Is it on the left, right or both sides of the segment ``edge_id``"
msgstr ""

msgid "Where in the segment is the point located."
msgstr ""

msgid "The geometry of the points."
msgstr ""

msgid "``newPoint``"
msgstr ""

msgid "The geometry of the points moved on top of the segment."
msgstr ""

msgid "Points of interest fillup"
msgstr ""

msgid "``pgr_floydWarshall``"
msgstr "``pgr_floydWarshall``"

msgid ""
"``pgr_floydWarshall`` - Returns the sum of the costs of the shortest path "
"for each pair of nodes in the graph using Floyd-Warshall algorithm."
msgstr ""
"``pgr_floydWarshall`` - 使用 Floyd-Warshall 算法返回图中每对节点的最短路径成"
"本之和。"

msgid ""
"The Floyd-Warshall algorithm, also known as Floyd's algorithm, is a good "
"choice to calculate the sum of the costs of the shortest path for each pair "
"of nodes in the graph, for *dense graphs*. We use Boost's implementation "
"which runs in :math:`\\Theta(V^3)` time,"
msgstr ""
"Floyd-Warshall算法，也被称为 Floyd算法，是计算图中每一对节点间最短路径的路径"
"成本总和的一种良好选择，适用于*密集图*。我们使用Boost的实现，其运行时间为： :"
"math:`\\Theta(V^3)`，"

msgid "pgr_floydWarshall(`Edges SQL`_, [``directed``])"
msgstr "pgr_floydWarshall(`Edges SQL`_, [``directed``])"

msgid "For a directed subgraph with edges :math:`\\{1, 2, 3, 4\\}`."
msgstr "对于有边 :math:`\\{1, 2, 3, 4\\}`的有向子图。"

msgid ""
"Boost `floyd-Warshall <https://www.boost.org/libs/graph/doc/"
"floyd_warshall_shortest.html>`_"
msgstr ""
"Boost `floyd-Warshall <https://www.boost.org/libs/graph/doc/"
"floyd_warshall_shortest.html>`_"

msgid "Queries uses the :doc:`sampledata` network."
msgstr "查询使用 :doc:`示例数据`网络。"

msgid "``pgr_full_version``"
msgstr "``pgr_full_version``"

msgid ""
"``pgr_full_version`` — Get the details of pgRouting version information."
msgstr "``pgr_full_version`` — 获取pgRouting版本信息的详细信息。."

msgid "New **official** function"
msgstr "**官方**新功能"

msgid "Get complete details of pgRouting version information"
msgstr "获取 pgRouting 版本信息的完整详细信息"

msgid "pgr_full_version()"
msgstr "pgr_full_version()"

msgid "RETURNS |result-version|"
msgstr "RETURNS |result-version|"

msgid "Information about when this documentation was built"
msgstr "有关此文档何时构建的信息"

msgid "``version``"
msgstr "``version``"

msgid "pgRouting version"
msgstr "pgRouting 版本"

msgid "``build_type``"
msgstr "``build_type``"

msgid "The Build type"
msgstr "构建类型"

msgid "``compile_date``"
msgstr "``compile_date``"

msgid "Compilation date"
msgstr "编译日期"

msgid "``library``"
msgstr "``library``"

msgid "Library name and version"
msgstr "库名称和版本"

msgid "``system``"
msgstr "``system``"

msgid "Operative system"
msgstr "操作系统"

msgid "``postgreSQL``"
msgstr "``postgreSQL``"

msgid "pgsql used"
msgstr "使用pgsql"

msgid "``compiler``"
msgstr "``compiler``"

msgid "Compiler and version"
msgstr "编译器和版本"

msgid "``boost``"
msgstr "``boost``"

msgid "Boost version"
msgstr "Boost 版本"

msgid "``hash``"
msgstr "``hash``"

msgid "Git hash of pgRouting build"
msgstr "pgRouting 构建的 Git 哈希"

msgid "``pgr_hawickCircuits - Experimental``"
msgstr "``pgr_hawickCircuits - 实验``"

msgid ""
"``pgr_hawickCircuits`` —  Returns the list of cirucits using hawick circuits "
"algorithm."
msgstr "``pgr_hawickCircuits`` —  使用 Hawick 回路算法返回回路列表。"

msgid "``pgr_hawickCircuits``"
msgstr "``pgr_hawickCircuits``"

msgid ""
"Hawick Circuit algorithm, is published in 2008 by Ken Hawick and Health A. "
"James. This algorithm solves the problem of detecting and enumerating "
"circuits in graphs. It is capable of circuit enumeration in graphs with "
"directed-arcs, multiple-arcs and self-arcs with a memory efficient and high-"
"performance im-plementation. It is an extension of Johnson's Algorithm of "
"finding all the elementary circuits of a directed graph."
msgstr ""
"Hawick Circuit 算法由 Ken Hawick 和 Health A. James 于 2008 年发表。 该算法解"
"决了图中电路的检测和枚举问题。 它能够在具有有向弧、多弧和自弧的图中进行电路枚"
"举，并具有内存高效和高性能的实现。 它是寻找有向图所有基本电路的约翰逊算法的扩"
"展。"

msgid ""
"There are 2 variations defined in the Boost Graph Library. Here, we have "
"implemented only 2nd as it serves the most suitable and practical usecase. "
"In this variation we get the circuits after filtering out the circuits "
"caused by parallel edges. Parallel edge circuits have more use cases when "
"you want to count the no. of circuits.Maybe in future, we will also "
"implemenent this variation."
msgstr ""
"Boost Graph Library 中定义了 2 个变体。 在这里，我们只实现了第二个，因为它服"
"务于最合适和最实用的用例。 在这个变体中，我们在过滤掉由平行边缘引起的电路后得"
"到电路。 当您想要计算数量时，并行边缘电路有更多用例。 也许将来我们也会实现这"
"种变化。"

msgid "The algorithm implementation works only for directed graph"
msgstr "该算法实现仅适用于有向图"

msgid "It is a variation of Johnson's algorithm for circuit enumeration."
msgstr "这是对于电路枚举的一种格式，基于Johnson的算法。"

msgid "The algorithm outputs the distinct circuits present in the graph."
msgstr "该算法输出图中存在的不同电路。"

msgid "Time Complexity: :math:`O((V + E) (c + 1))`"
msgstr "时间复杂度：:math:`O((V + E) (c + 1))`"

msgid ":math:`|c|` is the number of circuts in the graph."
msgstr ":math:`|c|`是图中的电路数量。"

msgid "pgr_hawickCircuits(`Edges SQL`_)"
msgstr "pgr_hawickCircuits(`Edges SQL`_)"

msgid "RETURNS SET OF |generic-result|"
msgstr "RETURNS SET OF |generic-result|"

msgid "Circuits present in the pgRouting :doc:`sampledata`"
msgstr "pgRouting :doc:`示例数据`中存在的电路"

msgid "Id of the circuit starting from ``1``"
msgstr "电路id从``1``开始"

msgid "Relative postion in the path. Has value ``0`` for beginning of the path"
msgstr "路径中的相对位置。 路径开头的值为 ``0``"

msgid "Identifier of the starting vertex of the circuit."
msgstr "电路起始顶点的标识符。"

msgid "Identifier of the ending vertex of the circuit."
msgstr "电路结束顶点的标识符。"

msgid "Identifier of the node in the path from a vid to next vid."
msgstr "从 vid 到下一个 vid 的路径中节点的标识符。"

msgid ""
"`Boost: Hawick Circuit Algorithm <https://www.boost.org/doc/libs/1_78_0/libs/"
"graph/doc/hawick_circuits.html>`__"
msgstr ""
"`Boost：Hawick 电路算法<https://www.boost.org/doc/libs/1_78_0/libs/graph/doc/"
"hawick_circuits.html>`__"

msgid "``pgr_isPlanar`` - Experimental"
msgstr "``pgr_isPlanar`` - 实验"

msgid ""
"``pgr_isPlanar`` — Returns a boolean depending upon the planarity of the "
"graph."
msgstr "``pgr_isPlanar`` —根据图的平面性返回布尔值."

msgid ""
"A graph is planar if it can be drawn in two-dimensional space with no two of "
"its edges crossing. Such a drawing of a planar graph is called a plane "
"drawing. Every planar graph also admits a straight-line drawing, which is a "
"plane drawing where each edge is represented by a line segment. When a graph "
"has :math:`K_5` or :math:`K_{3, 3}` as subgraph then the graph is not planar."
msgstr ""
"如果一个图可以在二维空间中绘制，使得它的任意两条边都不相交，那么这个图就是平"
"面图。这种平面图的绘制称为平面绘图。每个平面图也可以表示为一个直线绘图，即在"
"平面绘图中，每条边都由一条线段表示。当一个图包含 :math:`K_5` 或 :math:`K_{3, "
"3}` 作为子图时，这个图就不是平面图。"

msgid "This implementation use the Boyer-Myrvold Planarity Testing."
msgstr "此实施使用 Boyer-Myrvold 平面度测试。"

msgid ""
"It will return a boolean value depending upon the planarity of the graph."
msgstr "它将根据图形的平面性返回一个布尔值。"

msgid "Applicable only for **undirected** graphs."
msgstr "仅适用于**无向**图。"

msgid "The algorithm does not considers traversal costs in the calculations."
msgstr "该算法在计算中不考虑遍历成本。"

msgid "Running time: :math:`O(|V|)`"
msgstr "运行时间： :math:`O(|V|)`"

msgid "pgr_isPlanar(`Edges SQL`)"
msgstr "pgr_isPlanar(`Edges SQL`)"

msgid "RETURNS ``BOOLEAN``"
msgstr "RETURNS ``BOOLEAN``"

msgid "Returns a boolean ``(pgr_isplanar)``"
msgstr "返回一个布尔值 ``(pgr_isplanar)``"

msgid "``pgr_isplanar``"
msgstr "``pgr_isplanar``"

msgid "`true` when the graph is planar."
msgstr "当图形是平面时为`true`。"

msgid "`false` when the graph is not planar."
msgstr "当图形不是平面时为`false`。"

msgid ""
"The following edges will make the subgraph with vertices {10, 15, 11, 16, "
"13} a :math:`K_1` graph."
msgstr ""
"以下边将构成具有顶点 {10, 15, 11, 16, 13} 的子图，这个子图是一个 :math:`K_1` "
"图。"

msgid ""
"The new graph is not planar because it has a :math:`K_5` subgraph. Edges in "
"blue represent :math:`K_5` subgraph."
msgstr ""
"新图不是平面图，因为它具有一个 :math:`K_5` 子图。蓝色的边代表 :math:`K_5` 子"
"图。"

msgid "https://www.boost.org/libs/graph/doc/boyer_myrvold.html"
msgstr "https://www.boost.org/libs/graph/doc/boyer_myrvold.html"

msgid "``pgr_johnson``"
msgstr "``pgr_johnson``"

msgid ""
"``pgr_johnson`` - Returns the sum of the costs of the shortest path for each "
"pair of nodes in the graph using Floyd-Warshall algorithm."
msgstr ""
"``pgr_johnson`` - 使用 Floyd-Warshall 算法返回图中每对节点的最短路径成本之"
"和。."

msgid ""
"The Johnson algorithm, is a good choice to calculate the sum of the costs of "
"the shortest path for each pair of nodes in the graph, for *sparse graphs*. "
"It usees the Boost's implementation which runs in :math:`O(V E \\log V)` "
"time,"
msgstr ""
"Johnson算法是计算图中每一对节点的最短路径成本之和的好选择，特别适用于*稀疏图"
"*。它使用了Boost的实现，其运行时间为 :math:`O(V E \\log V)`，"

msgid "pgr johnson(`Edges SQL`_, [``directed``])"
msgstr "pgr johnson(`Edges SQL`_, [``directed``])"

msgid ""
"Boost `Johnson <https://www.boost.org/libs/graph/doc/"
"johnson_all_pairs_shortest.html>`_"
msgstr ""
"Boost `Johnson <https://www.boost.org/libs/graph/doc/"
"johnson_all_pairs_shortest.html>`_"

msgid "``pgr_kruskal``"
msgstr "``pgr_kruskal``"

msgid ""
"``pgr_kruskal`` — Minimum spanning tree of a graph using Kruskal's algorithm."
msgstr "``pgr_kruskal`` — 使用 Kruskal 算法的图的最小生成树。"

msgid ""
"This algorithm finds the minimum spanning forest in a possibly disconnected "
"graph using Kruskal's algorithm."
msgstr "该算法使用 Kruskal 算法在可能断开的图中找到最小生成森林。"

msgid "EMPTY SET is returned when there are no edges in the graph."
msgstr "当图中没有边时，返回 EMPTY SET。"

msgid "pgr_kruskal(`Edges SQL`_)"
msgstr "pgr_kruskal(`Edges SQL`_)"

msgid "RETURNS SET OF |result-mst|"
msgstr "RETURNS SET OF |result-mst|"

msgid "Minimum spanning forest"
msgstr "最小生成森林"

msgid "``pgr_kruskalBFS``"
msgstr "``pgr_kruskalBFS``"

msgid ""
"``pgr_kruskalBFS`` — Kruskal's algorithm for Minimum Spanning Tree with "
"breadth First Search ordering."
msgstr "``pgr_kruskalBFS`` — Kruskal 的最小生成树算法，具有广度优先搜索排序。"

msgid ""
"Visits and extracts the nodes information in Breath First Search ordering of "
"the Minimum Spanning Tree created using Kruskal's algorithm."
msgstr ""
"访问并提取使用 Kruskal 算法创建的最小生成树的呼吸优先搜索排序中的节点信息。"

msgid "Returned tree nodes from a root vertex are on Breath First Search order"
msgstr "从根顶点返回的树节点遵循广度优先搜索顺序"

msgid "Breath First Search Running time: :math:`O(E + V)`"
msgstr "广度优先搜索运行时间：:math:`O(E + V)`"

msgid "pgr_kruskalBFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr "pgr_kruskalBFS(`Edges SQL`_, **root vid**, [``max_depth``])"

msgid "pgr_kruskalBFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr "pgr_kruskalBFS(`Edges SQL`_, **root vids**, [``max_depth``])"

msgid "The Minimum Spanning Tree having as root vertex :math:`6`"
msgstr "以根顶点为 :math:`6` 的最小生成树"

msgid ""
"The Minimum Spanning Tree starting on vertices :math:`\\{9, 6\\}` with :math:"
"`depth \\leq 3`"
msgstr "以顶点 :math:`\\{9, 6\\}` 为起点， :math:`depth \\leq 3` 的最小生成树"

msgid "``pgr_kruskalDD``"
msgstr "``pgr_kruskalDD``"

msgid "``pgr_kruskalDD`` — Catchament nodes using Kruskal's algorithm."
msgstr "``pgr_kruskalDD`` — 使用 Kruskal 算法的汇流节点。"

msgid ""
"Using Kruskal's algorithm, extracts the nodes that have aggregate costs less "
"than or equal to a **distance** from a **root** vertex (or vertices) within "
"the calculated minimum spanning tree."
msgstr ""
"使用 Kruskal 算法，在计算的最小生成树中提取总成本小于或等于距**根**顶点（或多"
"个顶点）**距离**的节点。"

msgid "Returned tree nodes from a root vertex are on Depth First Search order."
msgstr "从根顶点返回的树节点遵循深度优先搜索顺序。"

msgid "Depth First Search running time: :math:`O(E + V)`"
msgstr "深度优先搜索运行时间： :math:`O(E + V)`"

msgid "pgr_kruskalDD(`Edges SQL`_, **root vid**, **distance**)"
msgstr "pgr_kruskalDD(`Edges SQL`_, **root vid**, **distance**)"

msgid "pgr_kruskalDD(`Edges SQL`_, **root vids**, **distance**)"
msgstr "pgr_kruskalDD(`Edges SQL`_, **root vids**, **distance**)"

msgid ""
"The Minimum Spanning Tree starting on vertex :math:`6` with :math:`distance "
"\\leq 3.5`"
msgstr ""
"以顶点 :math:`6` 为起点的，总成本小于或等于 :math:`distance \\leq 3.5` 的最小"
"生成树"

msgid ""
"The Minimum Spanning Tree starting on vertices :math:`\\{9, 6\\}` with :math:"
"`distance \\leq 3.5`"
msgstr ""
"以顶点:math:`\\{9, 6\\}` 为起点， :math:`distance \\leq 3.5`的最小生成树"

msgid "``pgr_kruskalDFS``"
msgstr "``pgr_kruskalDFS``"

msgid ""
"``pgr_kruskalDFS`` — Kruskal's algorithm for Minimum Spanning Tree with "
"Depth First Search ordering."
msgstr "``pgr_kruskalDFS`` — 具有深度优先搜索排序的最小生成树 Kruskal 算法。"

msgid ""
"Visits and extracts the nodes information in Depth First Search ordering of "
"the Minimum Spanning Tree created using Kruskal's algorithm."
msgstr ""
"访问并提取使用 Kruskal 算法创建的最小生成树的深度优先搜索顺序中的节点信息。"

msgid "Returned tree nodes from a root vertex are on Depth First Search order"
msgstr "从根顶点返回的树节点按深度优先搜索顺序"

msgid "pgr_kruskalDFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr "pgr_kruskalDFS(`Edges SQL`_, **root vid**, [``max_depth``])"

msgid "pgr_kruskalDFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr "pgr_kruskalDFS(`Edges SQL`_, **root vids**, [``max_depth``])"

msgid "pgr_lengauerTarjanDominatorTree -Experimental"
msgstr "pgr_lengauerTarjanDominatorTree -实验"

msgid ""
"``pgr_lengauerTarjanDominatorTree`` — Returns the immediate dominator of all "
"vertices."
msgstr "``pgr_lengauerTarjanDominatorTree`` — 返回所有顶点的直接支配者。"

msgid ""
"The algorithm calculates the *immidiate dominator* of each vertex called "
"**idom**, once **idom** of each vertex is calculated then by making every "
"**idom** of each vertex as its parent, the dominator tree can be built."
msgstr ""
"该算法计算每个顶点的**直接支配者**（称为**idom**），一旦计算出每个顶点的"
"**idom**，然后通过将每个顶点的**idom**作为其父节点，可以构建支配树。"

msgid "The algorithm works in directed graph only."
msgstr "该算法仅适用于有向图。"

msgid "The algorithm returns *idom* of each vertex."
msgstr "该算法返回每个顶点的* idom*。"

msgid ""
"If the *root vertex* not present in the graph then it returns empty set."
msgstr "如果图中不存在*根顶点*，则返回空集。"

msgid "Running time: :math:`O((V+E)log(V+E))`"
msgstr "运行时间：:math:`O((V+E)log(V+E))`"

msgid "pgr_lengauerTarjanDominatorTree(`Edges SQL`_, **root vertex**)"
msgstr "pgr_lengauerTarjanDominatorTree(`Edges SQL`_, **root vertex**)"

msgid "RETURNS SET OF |result-idom|"
msgstr "RETURNS SET OF |result-idom|"

msgid "The dominator tree with root vertex :math:`5`"
msgstr "具有根顶点 :math:`5`的支配树"

msgid "SQL query as described above."
msgstr "SQL 查询如上所述。"

msgid "**root vertex**"
msgstr "**root vertex**"

msgid "Returns set of ``(seq, vertex_id, idom)``"
msgstr "返回集合``(seq, vertex_id, idom)``"

msgid "Identifier of vertex ."
msgstr "顶点的标识符。"

msgid "``idom``"
msgstr "``idom``"

msgid "Immediate dominator of vertex."
msgstr "顶点的直接支配者。"

msgid "Dominator tree of another component."
msgstr "另一个组件的支配树。"

msgid ""
"`Boost: Lengauer-Tarjan dominator tree algorithm <https://www.boost.org/libs/"
"graph/doc/lengauer_tarjan_dominator.htm>`__"
msgstr ""
"`BOOST：Languer-Tarzan 支配树算法 <https://www.boost.org/libs/graph/doc/"
"lengauer_tarjan_dominator.htm>`__"

msgid ""
"`Wikipedia: dominator tree <https://en.wikipedia.org/wiki/"
"Dominator_(graph_theory)>`__"
msgstr ""
"`维基百科:支配树<https://en.wikipedia.org/wiki/Dominator_(graph_theory)>`__"

msgid "``pgr_lineGraph`` - Experimental"
msgstr "``pgr_lineGraph`` - 实验"

msgid ""
"``pgr_lineGraph`` — Transforms the given graph into its corresponding edge-"
"based graph."
msgstr "``pgr_lineGraph`` — 将给定图转换为其相应的基于边的图。"

msgid "Given a graph G, its line graph L(G) is a graph such that:"
msgstr "给定一个图 G，它的线图 L(G) 是这样的图："

msgid "Each vertex of L(G) represents an edge of G"
msgstr "L(G)的每个顶点代表G的一条边"

msgid ""
"Two vertices of L(G) are adjacent if and only if their corresponding edges "
"share a common endpoint in G."
msgstr "L(G) 的两个顶点相邻当且仅当它们对应的边共享 G 中的公共端点。"

msgid "pgr_lineGraph(`Edges SQL`_, [``directed``])"
msgstr "pgr_lineGraph(`Edges SQL`_, [``directed``])"

msgid "RETURNS SET OF |result-lineg|"
msgstr "RETURNS SET OF |result-lineg|"

msgid "For a **directed** graph"
msgstr "对于**有向**图"

msgid "Gives a local identifier for the edge"
msgstr "给出边的本地标识符"

msgid "Identifier of the source vertex of the current edge."
msgstr "当前边的源顶点的标识符。"

msgid "When `negative`: the source is the reverse edge in the original graph."
msgstr "为负时：源是原始图中的反向边。"

msgid "Identifier of the target vertex of the current edge."
msgstr "当前边的目标顶点的标识符。"

msgid "When `negative`: the target is the reverse edge in the original graph."
msgstr "为负时：目标是原始图中的反向边。"

msgid "Weight of the edge (``source``, ``target``)."
msgstr "边 (``source``, ``target``)的权重。"

msgid ""
"When `negative`: edge (``source``, ``target``) does not exist, therefore "
"it’s not part of the graph."
msgstr "当为负时：边(``source``, ``target``)不存在，因此它不是图的一部分。"

msgid "Weight of the edge (``target``, ``source``)."
msgstr "边 (``target``, ``source``)的权重。"

msgid ""
"When `negative`: edge (``target``, ``source``) does not exist, therefore "
"it’s not part of the graph."
msgstr "当为负时：边(``target``, ``source``)不存在，因此它不是图的一部分。"

msgid "https://en.wikipedia.org/wiki/Line_graph"
msgstr "https://en.wikipedia.org/wiki/Line_graph"

msgid "``pgr_lineGraphFull`` - Experimental"
msgstr "``pgr_lineGraphFull`` - 实验"

msgid ""
"``pgr_lineGraphFull`` — Transforms a given graph into a new graph where all "
"of the vertices from the original graph are converted to line graphs."
msgstr ""
"``pgr_lineGraphFull`` —将给定图转换为新图，其中原始图的所有顶点都转换为线图。"

msgid "Version 2.6.0"
msgstr "版本2.6.0"

msgid ""
"``pgr_lineGraphFull``, converts original directed graph to a directed line "
"graph by converting each vertex to a complete graph and keeping all the "
"original edges. The new connecting edges have a cost 0 and go between the "
"adjacent original edges, respecting the directionality."
msgstr ""
"``pgr_lineGraphFull``, 通过将每个顶点转换为完全图并保留所有原始边，将原始有向"
"图转换为有向线图。 新的连接边的成本为 0，并位于相邻的原始边之间，尊重方向性。"

msgid ""
"A possible application of the resulting graph is **\"routing with two edge "
"restrictions\"**:"
msgstr "结果图的一个可能的应用是 **\"具有两个边限制的路由\"**："

msgid ""
"Setting a cost of using the vertex when routing between edges on the "
"connecting edge"
msgstr "设置在连接边上的边之间布线时使用顶点的成本"

msgid "Forbid the routing between two edges by removing the connecting edge"
msgstr "通过删除连接边来禁止两条边之间的布线"

msgid ""
"This is possible because each of the intersections (vertices) in the "
"original graph are now complete graphs that have a new edge for each "
"possible turn across that intersection."
msgstr ""
"这是可能的，因为原始图中的每个交叉点（顶点）现在都是完整的图，对于穿过该交叉"
"点的每个可能的转弯都有一条新边。"

msgid "This function is for **directed** graphs."
msgstr "该函数适用于**有向**图。"

msgid ""
"Results are undefined when a negative vertex id is used in the input graph."
msgstr "当输入图中使用负顶点 id 时，结果是不确定的。"

msgid ""
"Results are undefined when a duplicated edge id is used in the input graph."
msgstr "当输入图中使用重复的边 id 时，结果是不确定的。"

msgid "Running time: TBD"
msgstr "运行时间：TBD（待定）"

msgid "pgr_lineGraphFull(`Edges SQL`_)"
msgstr "pgr_lineGraphFull(`Edges SQL`_)"

msgid "RETURNS SET OF |result-linegf|"
msgstr "RETURNS SET OF |result-linegf|"

msgid "Full line graph of subgraph of edges :math:`\\{4, 7, 8, 10\\}`"
msgstr "边:math:`\\{4, 7, 8, 10\\}`子图的全线图"

msgid ""
"The examples of this section are based on the :doc:`sampledata` network. The "
"examples include the subgraph including edges 4, 7, 8, and 10 with "
"``reverse_cost``."
msgstr ""
"本节的示例基于 :doc:`示例数据`网络。 这些示例包括包含具有``reverse_cost``的"
"边 4、7、8 和 10 的子图。"

msgid "The data"
msgstr "数据"

msgid ""
"This example displays how this graph transformation works to create "
"additional edges for each possible turn in a graph."
msgstr "此示例显示此图形转换如何为图形中的每个可能的转弯创建附加边。"

msgid "|first|"
msgstr "|first|"

msgid "first"
msgstr "首先"

msgid "The transformation"
msgstr "转变"

msgid "|second|"
msgstr "|second|"

msgid "second"
msgstr "第二"

msgid ""
"In the transformed graph, all of the edges from the original graph are still "
"present (yellow), but we now have additional edges for every turn that could "
"be made across vertex 7 (orange)."
msgstr ""
"在转换后的图中，原始图中的所有边仍然存在（黄色），但现在我们为跨顶点 7 的每个"
"转弯提供了额外的边（橙色）。"

msgid "Creating table that identifies transformed vertices"
msgstr "创建标识变换顶点的表"

msgid ""
"The vertices in the transformed graph are each created by splitting up the "
"vertices in the original graph. Unless a vertex in the original graph is a "
"leaf vertex, it will generate more than one vertex in the transformed graph. "
"One of the newly created vertices in the transformed graph will be given the "
"same vertex identifier as the vertex that it was created from in the "
"original graph, but the rest of the newly created vertices will have "
"negative vertex ids."
msgstr ""
"变换后的图中的每个顶点都是通过分割原始图中的顶点而创建的。 除非原始图中的某个"
"顶点是叶顶点，否则它将在变换后的图中生成多个顶点。 转换后的图中新创建的顶点之"
"一将被赋予与原始图中创建它的顶点相同的顶点标识符，但新创建的其余顶点将具有负"
"顶点 id。"

msgid ""
"Following is an example of how to generate a table that maps the ids of the "
"newly created vertices with the original vertex that they were created from"
msgstr ""
"以下是如何生成一个表的示例，该表将新创建的顶点的 id 与创建它们的原始顶点进行"
"映射"

msgid "Store edge results"
msgstr "存储边结果"

msgid ""
"The first step is to store the results of the ``pgr_lineGraphFull`` call "
"into a table"
msgstr "第一步是将 ``pgr_lineGraphFull``调用的结果存储到表中"

msgid "Create the mapping table"
msgstr "创建映射表"

msgid "From the original graph's vertex information"
msgstr "从原始图的顶点信息"

msgid "Add the new vertices"
msgstr "增加新的顶点"

msgid "Filling the mapping table"
msgstr "填写映射表"

msgid "The positive vertex identifiers are the original identifiers"
msgstr "正的顶点标识符是原始标识符"

msgid "Inspecting the vertices map"
msgstr "检查顶点图"

msgid ""
"The self loops happen when there is no cost traveling to the ``target`` and "
"the source has an original value."
msgstr "当没有成本到达目标并且源具有原始值时，就会发生自循环。"

msgid "Updating values from self loops"
msgstr "从自循环更新值"

msgid "Inspecting the vertices table"
msgstr "检查顶点表"

msgid "Updating from inner self loops"
msgstr "从内部自我循环更新"

msgid "Adding a soft restriction"
msgstr "添加软限制"

msgid ""
"A soft restriction going from vertex 6 to vertex 3 using edges 4 -> 7 is "
"wanted."
msgstr "需要使用边 4 -> 7 从顶点 6 到顶点 3 的软限制。"

msgid "Idenifying the restriction"
msgstr "识别限制"

msgid ""
"Running a :doc:`pgr_dijkstraNear` the edge with cost 0, edge 8, is where the "
"cost will be increased"
msgstr "运行 :doc:`pgr_dijkstraNear` 时，成本将会增加的地方是边 8，其成本为 0"

msgid ""
"The edge to be altered is ``WHERE cost = 0 AND seq != 1 AND edge != -1`` "
"from the previus query:"
msgstr ""
"要更改的边是上一个查询中的 ``WHERE cost = 0 AND seq != 1 AND edge != -1``："

msgid "Adding a value to the restriction"
msgstr "向限制添加值"

msgid "Updating the cost to the edge:"
msgstr "将成本更新到边："

msgid "Routing from :math:`6` to :math:`3`"
msgstr "路由从 :math:`6`到 :math:`3`"

msgid "Now the route does not use edge 8 and does a U turn on a leaf vertex."
msgstr "现在，该路线不使用边 8，而是在叶顶点上进行 U 形转弯。"

msgid "Simplifying leaf vertices"
msgstr "简化叶顶点"

msgid ""
"In this example, there is no additional cost for traversing a leaf vertex."
msgstr "在这个例子中，遍历叶顶点没有额外的成本。"

msgid "Using the vertex map give the leaf verices their original value."
msgstr "使用顶点图赋予叶顶点其原始值。"

msgid "On the source column"
msgstr "在source 列"

msgid "On the target column"
msgstr "在target列"

msgid "Removing self loops on leaf nodes"
msgstr "删除叶节点上的自循环"

msgid "The self loops of the leaf nodes are"
msgstr "叶节点的自循环为"

msgid "Which can be removed"
msgstr "哪些可以删除"

msgid ""
"Routing can be done now using the original vertices id using :doc:"
"`pgr_dijkstra`"
msgstr "现在可以使用 :doc:`pgr_dijkstra` 使用原始顶点 id 来完成路由"

msgid "Complete routing graph"
msgstr "完整的路由图"

msgid "Add edges from the original graph"
msgstr "从原始图中添加边"

msgid ""
"Add all the edges that are not involved in the line graph process to the new "
"table"
msgstr "将所有不参与折线图过程的边添加到新表中"

msgid "Some administrative tasks to get new identifiers for the edges"
msgstr "一些获取边新标识符的管理任务"

msgid "Add the newly calculated edges"
msgstr "添加新计算的边"

msgid "Using the routing graph"
msgstr "使用路由图"

msgid ""
"When using this method for routing with soft restrictions there will be "
"uturns"
msgstr "当使用这种方法进行具有软限制的路由时，将会出现 uturn"

msgid "Routing from :math:`5` to :math:`1`"
msgstr "路由从 :math:`5` 到:math:`1`"

msgid "https://en.wikipedia.org/wiki/Complete_graph"
msgstr "https://en.wikipedia.org/wiki/Complete_graph"

msgid "``pgr_makeConnected`` - Experimental"
msgstr "``pgr_makeConnected`` - 实验"

msgid "``pgr_makeConnected`` — Set of edges that will connect the graph."
msgstr "``pgr_makeConnected`` — 连接图的边集。"

msgid ""
"Adds the minimum number of edges needed to make the input graph connected. "
"The algorithm first identifies all of the connected components in the graph, "
"then adds edges to connect those components together in a path. For example, "
"if a graph contains three connected components A, B, and C, make_connected "
"will add two edges. The two edges added might consist of one connecting a "
"vertex in A with a vertex in B and one connecting a vertex in B with a "
"vertex in C."
msgstr ""
"添加使输入图连接所需的最小边数。 该算法首先识别图中的所有连接组件，然后添加边"
"以将这些组件在路径中连接在一起。 例如，如果一个图包含三个连通分量 A、B 和 C，"
"则 make_connected 将添加两条边。 添加的两条边可能包括一条连接 A 中的顶点与 B "
"中的顶点的边，以及一条连接 B 中的顶点与 C 中的顶点的边。"

msgid ""
"It will give a minimum list of all edges which are needed in the graph to "
"make connect it."
msgstr "它将给出图中连接它所需的所有边的最小列表。"

msgid ""
"The algorithm does not considers geometric topology in the calculations."
msgstr "该算法在计算中不考虑遍历成本。"

msgid "pgr_makeConnected(`Edges SQL`_)"
msgstr "pgr_makeConnected(`Edges SQL`_)"

msgid "RETURNS SET OF |result-component-make|"
msgstr "RETURNS SET OF |result-component-make|"

msgid ""
"Query done on :doc:`sampledata` network gives the list of edges that are "
"needed to connect the graph."
msgstr "在:doc:`示例数据`网络上完成的查询给出了连接图所需的边列表。"

msgid "Returns set of |result-component-make|"
msgstr "Returns set of |result-component-make|"

msgid "https://www.boost.org/libs/graph/doc/make_connected.html"
msgstr "https://www.boost.org/libs/graph/doc/make_connected.html"

msgid "pgr_maxCardinalityMatch"
msgstr "pgr_maxCardinalityMatch"

msgid ""
"``pgr_maxCardinalityMatch`` — Calculates a maximum cardinality matching in a "
"graph."
msgstr "``pgr_maxCardinalityMatch`` — 计算图中的最大基数匹配。."

msgid "Deprecated signature"
msgstr "已弃用的签名"

msgid "``pgr_maxCardinalityMatch(text,boolean)``"
msgstr "``pgr_maxCardinalityMatch(text,boolean)``"

msgid "``directed => false`` when used."
msgstr "使用时``directed => false``。"

msgid "Renamed from ``pgr_maximumCardinalityMatching``"
msgstr "从 ``pgr_maximumCardinalityMatching`` 重命名"

msgid ""
"A matching or independent edge set in a graph is a set of edges without "
"common vertices."
msgstr "图中的匹配或独立边集是一组没有公共顶点的边。"

msgid ""
"A maximum matching is a matching that contains the largest possible number "
"of edges."
msgstr "最大匹配是包含尽可能多的边的匹配。"

msgid "There may be many maximum matchings."
msgstr "可能有很多最大匹配。"

msgid "Calculates one possible maximum cardinality matching in a graph."
msgstr "计算图中一种可能的最大基数匹配。"

msgid "Running time: :math:`O( E*V * \\alpha(E,V))`"
msgstr "运行时间： :math:`O( E*V * \\alpha(E,V))`"

msgid ":math:`\\alpha(E,V)` is the inverse of the `Ackermann function`_."
msgstr ":math:`\\alpha(E,V)`与`Ackermann function`_相反。"

msgid "pgr_maxCardinalityMatch(`Edges SQL`_)"
msgstr "pgr_maxCardinalityMatch(`Edges SQL`_)"

msgid "Using all edges."
msgstr "使用所有边。"

msgid ""
"SQL query, which should return a set of rows with the following columns:"
msgstr "SQL 查询，应返回一组包含以下列的行："

msgid ""
"A positive value represents the existence of the edge (``source``, "
"``target``)."
msgstr "正值表示存在边(``source``, ``target``)。"

msgid ""
"A positive value represents the existence of the edge (``target``, "
"``source``)"
msgstr "正值表示存在边(``target``, ``source``)"

msgid "Identifier of the edge in the original query."
msgstr "原始查询中边的标识符。"

msgid ":doc:`migration`"
msgstr ":doc:`migration`"

msgid "https://www.boost.org/libs/graph/doc/maximum_matching.html"
msgstr "https://www.boost.org/libs/graph/doc/maximum_matching.html"

msgid "https://en.wikipedia.org/wiki/Matching_%28graph_theory%29"
msgstr "https://en.wikipedia.org/wiki/Matching_%28graph_theory%29"

msgid "https://en.wikipedia.org/wiki/Ackermann_function"
msgstr "https://en.wikipedia.org/wiki/Ackermann_function"

msgid "``pgr_maxFlow``"
msgstr "``pgr_maxFlow``"

msgid ""
"``pgr_maxFlow`` — Calculates the maximum flow in a directed graph from the "
"source(s) to the targets(s) using the Push Relabel algorithm."
msgstr ""
"``pgr_maxFlow`` —使用 Push Relabel 算法计算有向图中从源到目标的最大流量。"

msgid "``pgr_maxFlow`` (`Combinations`_)"
msgstr "``pgr_maxFlow`` (`组合`_)"

msgid "New **Proposed** function"
msgstr "新**拟议** 的函数"

msgid "Calculates the maximum flow from the `source(s)` to the `target(s)`."
msgstr "计算从 `source(s)`到 `target(s)`的最大流量。"

msgid ""
"When the maximum flow is **0** then there is no flow and **0** is returned."
msgstr "当最大流量为**0**时则没有流量，返回**0**。"

msgid "Uses the :doc:`pgr_pushRelabel <pgr_pushRelabel>` algorithm."
msgstr "使用:doc:`pgr_pushRelabel <pgr_pushRelabel>`算法。"

msgid "Running time: :math:`O( V ^ 3)`"
msgstr "运行时间：:math:`O( V ^ 3)`"

msgid "pgr_maxFlow(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_maxFlow(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_maxFlow(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_maxFlow(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_maxFlow(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_maxFlow(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_maxFlow(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_maxFlow(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_maxFlow(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_maxFlow(`Edges SQL`_, `Combinations SQL`_)"

msgid "RETURNS ``BIGINT``"
msgstr "RETURNS ``BIGINT``"

msgid "Maximum flow possible from the source(s) to the target(s)"
msgstr "从 source(s)到 target(s)的可能最大流量"

msgid "https://www.boost.org/libs/graph/doc/push_relabel_max_flow.html"
msgstr "https://www.boost.org/libs/graph/doc/push_relabel_max_flow.html"

msgid ""
"https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm"
msgstr ""
"https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm"

msgid "``pgr_maxFlowMinCost`` - Experimental"
msgstr "``pgr_maxFlowMinCost`` - 实验"

msgid ""
"``pgr_maxFlowMinCost`` — Calculates the edges that minimizes the total cost "
"of the maximum flow on a graph"
msgstr "``pgr_maxFlowMinCost`` — 计算图上最大流的总成本最小化的边"

msgid "``pgr_maxFlowMinCost`` (`Combinations`_)"
msgstr "``pgr_maxFlowMinCost`` (`组合`_)"

msgid "**TODO** check which statement is true:"
msgstr "**TODO **检查哪个陈述是正确的："

msgid "The cost value of all input edges must be nonnegative."
msgstr "所有输入边的成本值必须是非负的。"

msgid "Process is done when the cost value of all input edges is nonnegative."
msgstr "当所有输入边的成本值为非负时，处理完成。"

msgid "Process is done on edges with nonnegative cost."
msgstr "过程是在具有非负成本的边上完成的。"

msgid "Running time: :math:`O(U * (E + V * logV))`"
msgstr "运行时间：:math:`O(U * (E + V * logV))`"

msgid "where :math:`U` is the value of the max flow."
msgstr "其中 :math:`U`是最大流量的值。"

msgid ""
":math:`U` is upper bound on number of iterations. In many real world cases "
"number of iterations is much smaller than :math:`U`."
msgstr ""
":math:`U`是迭代次数的上限。 在许多现实世界的情况下，迭代次数远小于:math:"
"`U` 。"

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_maxFlowMinCost(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_maxFlowMinCost(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_maxFlowMinCost(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_maxFlowMinCost(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_maxFlowMinCost(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_maxFlowMinCost(`Edges SQL`_, `Combinations SQL`_)"

msgid "RETURNS SET OF |result-flow-mincost|"
msgstr "RETURNS SET OF |result-flow-mincost|"

msgid ""
"https://www.boost.org/libs/graph/doc/"
"successive_shortest_path_nonnegative_weights.html"
msgstr ""
"https://www.boost.org/libs/graph/doc/"
"successive_shortest_path_nonnegative_weights.html"

msgid "``pgr_maxFlowMinCost_Cost`` - Experimental"
msgstr "``pgr_maxFlowMinCost_Cost`` - 实验"

msgid ""
"``pgr_maxFlowMinCost_Cost`` — Calculates the minimum total cost of the "
"maximum flow on a graph"
msgstr "``pgr_maxFlowMinCost_Cost`` — 计算图上最大流量的最小总成本"

msgid "``pgr_maxFlowMinCost_Cost`` (`Combinations`_)"
msgstr "``pgr_maxFlowMinCost_Cost`` (`组合`_)"

msgid "**The cost value of all input edges must be nonnegative.**"
msgstr "**所有输入边的成本值必须是非负的。**"

msgid "When the maximum flow is 0 then there is no flow and **0** is returned."
msgstr "当最大流量为0时则没有流量，返回**0**。"

msgid "Uses :doc:`pgr_maxFlowMinCost`."
msgstr "使用:doc:`pgr_maxFlowMinCost`。"

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_maxFlowMinCost_Cost(`Edges SQL`_, `Combinations SQL`_)"

msgid "RETURNS FLOAT"
msgstr "RETURNS FLOAT"

msgid "Minimum Cost Maximum Flow possible from the source(s) to the target(s)"
msgstr "从source(s) 到target(s)的最小成本最大流量"

msgid "pgr_nodeNetwork"
msgstr "pgr_nodeNetwork"

msgid "``pgr_nodeNetwork`` - Nodes an network edge table."
msgstr "``pgr_nodeNetwork`` - 网络边表的节点。"

msgid "Author"
msgstr "作者"

msgid "Nicolas Ribot"
msgstr "Nicolas Ribot"

msgid "Copyright"
msgstr "版权"

msgid "Nicolas Ribot, The source code is released under the MIT-X license."
msgstr "Nicolas Ribot，源代码根据 MIT-X 许可证发布。"

msgid ""
"The function reads edges from a not \"noded\" network table and writes the "
"\"noded\" edges into a new table."
msgstr "该函数从非\"noded\"网络表中读取边，并将\"noded\"边写入新表中。"

msgid ""
"A common problem associated with bringing GIS data into pgRouting is the "
"fact that the data is often not \"noded\" correctly. This will create "
"invalid topologies, which will result in routes that are incorrect."
msgstr ""
"将 GIS 数据引入 pgRouting 的一个常见问题是数据通常没有正确“节点化”。 这将创建"
"无效的拓扑，从而导致路由不正确。"

msgid ""
"What we mean by \"noded\" is that at every intersection in the road network "
"all the edges will be broken into separate road segments. There are cases "
"like an over-pass and under-pass intersection where you can not traverse "
"from the over-pass to the under-pass, but this function does not have the "
"ability to detect and accommodate those situations."
msgstr ""
"我们所说的 \"noded\"是指在道路网络的每个交叉口，所有边缘都将被分成单独的路"
"段。 在某些情况下，例如天桥和地下通道交叉口，您无法从天桥穿越到地下通道，但此"
"功能无法检测和适应这些情况。"

msgid ""
"This function reads the ``edge_table`` table, that has a primary key column "
"``id`` and geometry column named ``the_geom`` and intersect all the segments "
"in it against all the other segments and then creates a table "
"``edge_table_noded``. It uses the ``tolerance`` for deciding that multiple "
"nodes within the tolerance are considered the same node."
msgstr ""
"该函数读取``edge_table``表，该表具有主键列 ``id`` 和名为``the_geom``的几何"
"列，并将其中的所有段与所有其他段相交，然后创建表``edge_table_noded``。 它使用"
"``tolerance``来决定容差内的多个节点被视为同一节点。"

msgid "``float8`` tolerance for coincident points (in projection unit)dd"
msgstr "``float8`` 重合点公差（以投影单位表示）dd"

msgid ""
"``text`` Primary key column name of the network table. Default value is "
"``id``."
msgstr "``text`` 网络表的主键列名称。 默认值为``id``。"

msgid ""
"``text`` Geometry column name of the network table. Default value is "
"``the_geom``."
msgstr "``text``网络表的几何列名称。 默认值为``the_geom``。"

msgid "table_ending"
msgstr "table_ending"

msgid "``text`` Suffix for the new table's. Default value is ``noded``."
msgstr "``text``新表的后缀。 默认值是``noded``。"

msgid "The output table will have for  ``edge_table_noded``"
msgstr "输出表将具有``edge_table_noded``"

msgid "``bigint`` Unique identifier for the table"
msgstr "``bigint`` 表的唯一标识符"

msgid "old_id"
msgstr "old_id"

msgid "``bigint``  Identifier of the edge in original table"
msgstr "``bigint``原表中边的标识符"

msgid "sub_id"
msgstr "sub_id"

msgid "``integer`` Segment number of the original edge"
msgstr "``integer``原边的段号"

msgid ""
"``integer`` Empty source column to be used with :doc:`pgr_createTopology` "
"function"
msgstr "``integer``与 :doc:`pgr_createTopology` 函数一起使用的空source列"

msgid ""
"``integer`` Empty target column to be used with :doc:`pgr_createTopology` "
"function"
msgstr "``integer``与 :doc:`pgr_createTopology` 函数一起使用的空target列"

msgid "the geom"
msgstr "the geom"

msgid "``geometry`` Geometry column of the noded network"
msgstr "``geometry``节点网络的几何列"

msgid "Examples"
msgstr "示例"

msgid "Let's create the topology for the data in :doc:`sampledata`"
msgstr "让我们为 :doc:`示例数据`中的数据创建拓扑"

msgid "Now we can analyze the network."
msgstr "现在我们可以分析网络了。"

msgid ""
"The analysis tell us that the network has a gap and an intersection. We try "
"to fix the problem using:"
msgstr "分析告诉我们，网络存在缺口和交叉点。 我们尝试使用以下方法解决该问题："

msgid ""
"Inspecting the generated table, we can see that edges 13,14 and 18 has been "
"segmented"
msgstr "检查生成的表，我们可以看到边 13,14 和 18 已被分段"

msgid "We can create the topology of the new network"
msgstr "我们可以创建新网络的拓扑"

msgid "Now let's analyze the new topology"
msgstr "现在我们来分析一下新的拓扑"

msgid "Images"
msgstr "图片"

msgid "Before Image"
msgstr "之前的图像"

msgid "before image"
msgstr "之前的图像"

msgid "After Image"
msgstr "后面的图像"

msgid "after image"
msgstr "后面的图像"

msgid "Comparing the results"
msgstr "比较结果"

msgid "Comparing with the Analysis in the original edge_table, we see that."
msgstr "与原始edge_table中的分析相比，我们看到了这一点。"

msgid "Before"
msgstr "前"

msgid "After"
msgstr "后"

msgid "Table name"
msgstr "表名"

msgid "edge_table_noded"
msgstr "edge_table_noded"

msgid "Fields"
msgstr "字段"

msgid "All original fields"
msgstr "所有原始字段"

msgid "Has only basic fields to do a topology analysis"
msgstr "仅具有进行拓扑分析的基本字段"

msgid "Edges with 1 dead end: 1,6,24"
msgstr "有 1 个死端的边：1、6、24"

msgid "Edges with 2 dead ends  17,18"
msgstr "有两个死端的边：17，18"

msgid ""
"Edge 17's right node is a dead end because there is no other edge sharing "
"that same node. (cnt=1)"
msgstr "边 17 的右侧节点是一个死端，因为没有其他边共享同一节点。 （cnt=1）"

msgid "Edges with 1 dead end: 1-1 ,6-1,14-2, 18-1 17-1 18-2"
msgstr "有 1 个死端的边：1-1 ,6-1,14-2, 18-1 17-1 18-2"

msgid "Isolated segments"
msgstr "孤立的片段"

msgid "two isolated segments:  17 and 18 both they have 2 dead ends"
msgstr "两个孤立的段：17 和 18 都有 2 个死端"

msgid "No Isolated segments"
msgstr "无孤立段"

msgid "Edge 17 now shares a node with edges 14-1 and 14-2"
msgstr "边 17 现在与边 14-1 和 14-2 共享一个节点"

msgid "Edges 18-1 and 18-2 share a node with edges 13-1 and 13-2"
msgstr "边 18-1 和 18-2 与边 13-1 和 13-2 共享一个节点"

msgid "Gaps"
msgstr "差距"

msgid ""
"There is a gap between edge 17 and 14 because edge 14 is near to the right "
"node of edge 17"
msgstr "边 17 和边 14 之间有间隙，因为边 14 靠近边 17 的右侧节点"

msgid ""
"Edge 14 was segmented Now edges: 14-1 14-2 17 share the same node The "
"tolerance value was taken in account"
msgstr ""
"边缘14 被分段了，现在边缘14-1、14-2 和 17 共享同一个节点。容差值已被考虑"

msgid "Intersections"
msgstr "交叉口"

msgid "Edges 13 and 18 were intersecting"
msgstr "边 13 和 18 相交"

msgid ""
"Edges were segmented, So, now in the interection's point there is a node and "
"the following edges share it: 13-1 13-2 18-1 18-2"
msgstr ""
"边被分段，所以，现在在交点处有一个节点，并且以下边共享它： 13-1 13-2 18-1 "
"18-2"

msgid ""
"Now, we are going to include the segments 13-1, 13-2 14-1, 14-2 ,18-1 and "
"18-2 into our edge-table, copying the data for dir,cost,and reverse cost "
"with tho following steps:"
msgstr ""
"现在，我们将包括段 13-1、13-2、14-1、14-2、18-1 和 18-2 到我们的边表中，并复"
"制 dir、cost 和 reverse cost 的数据，按照以下步骤进行："

msgid ""
"Add a column old_id into edge_table, this column is going to keep track the "
"id of the original edge"
msgstr "在边表中添加一列old_id，该列将跟踪原始边的id"

msgid "Insert only the segmented edges, that is, the ones whose max(sub_id) >1"
msgstr "仅插入分段边，即 max(sub_id) >1 的边"

msgid "We recreate the topology:"
msgstr "我们重新创建拓扑："

msgid ""
"To get the same analysis results as the topology of edge_table_noded, we do "
"the following query:"
msgstr "为了获得与edge_table_noded的拓扑相同的分析结果，我们执行以下查询："

msgid ""
"To get the same analysis results as the original edge_table, we do the "
"following query:"
msgstr "为了获得与原始edge_table相同的分析结果，我们执行以下查询："

msgid ""
"Or we can analyze everything because, maybe edge 18 is an overpass, edge 14 "
"is an under pass and there is also a street level juction, and the same "
"happens with edges 17 and 13."
msgstr ""
"或者我们可以分析所有内容，因为也许边 18 是立交桥，边 14 是地下通道，还有一个"
"街道水平交汇处，边 17 和 13 也会发生同样的情况。"

msgid ""
":doc:`topology-functions` for an overview of a topology for routing "
"algorithms. :doc:`pgr_analyzeOneWay` to analyze directionality of the "
"edges. :doc:`pgr_createTopology` to create a topology based on the "
"geometry. :doc:`pgr_analyzeGraph` to analyze the edges and vertices of the "
"edge table."
msgstr ""
":doc:`topology-functions`，用于概述路由算法的拓扑。 :doc:`pgr_analyzeOneWay` "
"分析边方向性的方法。:doc:`pgr_createTopology` 根据几何图创建拓扑。 :doc:"
"`pgr_analyzeGraph`分析边表的边和顶点。"

msgid "``pgr_pickDeliver`` - Experimental"
msgstr "``pgr_pickDeliver`` - 实验"

msgid "``pgr_pickDeliver`` - Pickup and delivery Vehicle Routing Problem"
msgstr "``pgr_pickDeliver`` - 接送车辆路径问题"

msgid ""
"Problem: Distribute and optimize the pickup-delivery pairs into a fleet of "
"vehicles."
msgstr "问题：将取货-送货对分配并优化到车队中。"

msgid "Optimization problem is NP-hard."
msgstr "优化问题是NP-hard。"

msgid "pickup and Delivery with time windows."
msgstr "有时间窗口的取货和送货。"

msgid "All vehicles are equal."
msgstr "所有车辆都是平等的。"

msgid "Same Starting location."
msgstr "相同的起始位置。"

msgid "Same Ending location which is the same as Starting location."
msgstr "相同的结束位置与开始位置相同。"

msgid "All vehicles travel at the same speed."
msgstr "所有车辆以相同的速度行驶。"

msgid "A customer is for doing a pickup or doing a deliver."
msgstr "客户负责提货或送货。"

msgid "has an open time."
msgstr "有开放时间。"

msgid "has a closing time."
msgstr "有关闭时间。"

msgid "has a service time."
msgstr "有服务时间。"

msgid "has an (x, y) location."
msgstr "具有 (x, y) 位置。"

msgid "There is a customer where to deliver a pickup."
msgstr "有客户需要送货。"

msgid "travel time between customers is distance / speed"
msgstr "客户之间的旅行时间是距离/速度"

msgid "pickup and delivery pair is done with the same vehicle."
msgstr "取货和送货是使用同一辆车完成的。"

msgid "All trucks depart at time 0."
msgstr "所有卡车均在时间 0 出发。"

msgid "the algorithm will raise an exception when"
msgstr "该算法将在以下情况下引发异常"

msgid "If there is a pickup-deliver pair than violates time window"
msgstr "如果存在违反时间窗口的取货-送货对"

msgid "The speed, max_cycles, ma_capacity have illegal values"
msgstr "speed、max_cycles、ma_capacity 具有非法值"

msgid ""
"Six different initial will be optimized - the best solution found will be "
"result"
msgstr "将优化六个不同的初始值 - 找到的最佳解决方案将是结果"

msgid "Signature"
msgstr "标识"

msgid ""
"pgr_pickDeliver(`Orders SQL`_, `Vehicles SQL`_, `Matrix SQL`_, [**options**])"
msgstr ""
"pgr_pickDeliver(`Orders SQL`_, `Vehicles SQL`_, `Matrix SQL`_, [**options**])"

msgid "**options:** ``[factor, max_cycles, initial_sol]``"
msgstr "**options:** ``[factor, max_cycles, initial_sol]``"

msgid "RETURNS SET OF |result-pickdrop|"
msgstr "RETURNS SET OF |result-pickdrop|"

msgid "Solve the following problem"
msgstr "解决以下问题"

msgid "Given the vehicles:"
msgstr "给定车辆："

msgid "and the orders:"
msgstr "和顺序："

msgid "The parameters are:"
msgstr "参数是："

msgid "A `SELECT` statement that returns the following columns:"
msgstr "返回以下列的 `SELECT` 语句："

msgid "id, demand"
msgstr "id, demand"

msgid "p_node_id, p_open, p_close, [p_service,]"
msgstr "p_node_id, p_open, p_close, [p_service,]"

msgid "d_node_id, d_open, d_close, [d_service,]"
msgstr "d_node_id, d_open, d_close, [d_service,]"

msgid "id, capacity"
msgstr "id, capacity"

msgid "start_node_id, start_open, start_close [, start_service,]"
msgstr "start_node_id, start_open, start_close [, start_service,]"

msgid "[end_node_id, end_open, end_close, end_service]"
msgstr "[end_node_id, end_open, end_close, end_service]"

msgid "``pgr_pickDeliverEuclidean`` - Experimental"
msgstr "``pgr_pickDeliverEuclidean`` - 实验"

msgid ""
"``pgr_pickDeliverEuclidean`` - Pickup and delivery Vehicle Routing Problem"
msgstr "``pgr_pickDeliverEuclidean`` -取货和送货车辆路径问题"

msgid "Replaces ``pgr_gsoc_vrppdtw``"
msgstr "替换 ``pgr_gsoc_vrppdtw``"

msgid "Pickup and Delivery:"
msgstr "取货和送货："

msgid "capacitated"
msgstr "带容量限制的"

msgid "with time windows."
msgstr "有时间窗口的。"

msgid "have (x, y) start and ending locations."
msgstr "有 (x, y) 开始和结束位置。"

msgid "have a start and ending service times."
msgstr "有开始和结束服务时间。"

msgid "An order is for doing a pickup and a a deliver."
msgstr "订单用于取货和送货。"

msgid "has (x, y) pickup and delivery locations."
msgstr "有 (x, y) 个取货和送货地点。"

msgid "has opening and closing times for the pickup and delivery locations."
msgstr "有提货和送货地点的开放和关闭时间。"

msgid "has a pickup and deliver service times."
msgstr "有取货和送货服务时间。"

msgid "Six different optional different initial solutions"
msgstr "六种不同的可选不同初始解决方案"

msgid "the best solution found will be result"
msgstr "找到的最佳解决方案将作为结果"

msgid "pgr_pickDeliverEuclidean(`Orders SQL`_, `Vehicles SQL`_, [**options**])"
msgstr ""
"pgr_pickDeliverEuclidean(`Orders SQL`_, `Vehicles SQL`_, [**options**])"

msgid "p_x, p_y, p_open, p_close, [p_service,]"
msgstr "p_x, p_y, p_open, p_close, [p_service,]"

msgid "d_x, d_y, d_open, d_close, [d_service]"
msgstr "d_x, d_y, d_open, d_close, [d_service]"

msgid "start_x, start_y, start_open, start_close [, start_service, ]"
msgstr "start_x, start_y, start_open, start_close [, start_service, ]"

msgid "[ end_x, end_y, end_open, end_close, end_service ]"
msgstr "[ end_x, end_y, end_open, end_close, end_service ]"

msgid ""
"This data example **lc101** is from data published at https://www.sintef.no/"
"projectweb/top/pdptw/li-lim-benchmark/"
msgstr ""
"此数据示例 **lc101** 来自 https://www.sintef.no/projectweb/top/pdptw/li-lim-"
"benchmark/ 上发布的数据"

msgid "There are 25 vehciles in the problem all with the same characteristics."
msgstr "问题中有 25 辆车都具有相同的特征。"

msgid "The original orders"
msgstr "原始订单"

msgid ""
"The data comes in different rows for the pickup and the delivery of the same "
"order."
msgstr "对于同一订单的取货和配送，数据位于不同的行中。"

msgid "The original data needs to be converted to an appropiate table:"
msgstr "需要将原始数据转换为合适的表格："

msgid "The query"
msgstr "查询"

msgid ""
"Showing only the relevant information to compare with the best solution "
"information published on https://www.sintef.no/projectweb/top/pdptw/100-"
"customers/"
msgstr ""
"仅显示相关信息，以便与 https://www.sintef.no/projectweb/top/pdptw/100-"
"customers/ 上发布的最佳解决方案信息进行比较"

msgid "The best solution found for **lc101** is a travel time: 828.94"
msgstr "找到的 **lc101**的最佳解是行程时间：828.94"

msgid "This implementation's travel time: 854.54"
msgstr "此实施的行程时间：854.54"

msgid "``pgr_prim``"
msgstr "``pgr_prim``"

msgid ""
"``pgr_prim`` — Minimum spanning forest of a graph using Prim's algorithm."
msgstr "``pgr_prim`` — 使用 Prim 算法的图的最小生成森林。"

msgid ""
"This algorithm finds the minimum spanning forest in a possibly disconnected "
"graph using Prim's algorithm."
msgstr "该算法使用 Prim 算法在可能断开的图中找到最小生成森林。"

msgid "Prim's running time: :math:`O(E * log V)`"
msgstr "Prim运行时间：:math:`O(E * log V)`"

msgid "pgr_prim(`Edges SQL`_)"
msgstr "pgr_prim(`Edges SQL`_)"

msgid "Minimum spanning forest of a subgraph"
msgstr "子图的最小生成森林"

msgid ""
"`Boost: Prim's algorithm documentation <https://www.boost.org/libs/graph/doc/"
"prim_minimum_spanning_tree.html>`__"
msgstr ""
"`Boost: Prim算法文档 <https://www.boost.org/libs/graph/doc/"
"prim_minimum_spanning_tree.html>`__"

msgid "``pgr_primBFS``"
msgstr "``pgr_primBFS``"

msgid ""
"``pgr_primBFS`` — Prim's algorithm for Minimum Spanning Tree with Depth "
"First Search ordering."
msgstr "``pgr_primBFS`` — Prim 的深度优先搜索排序最小生成树算法。"

msgid ""
"Visits and extracts the nodes information in Breath First Search ordering of "
"the Minimum Spanning Tree created with Prims's algorithm."
msgstr "访问并提取Prims算法创建的最小生成树的呼吸优先搜索排序中的节点信息。"

msgid "pgr_primBFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr "pgr_primBFS(`Edges SQL`_, **root vid**, [``max_depth``])"

msgid "pgr_primBFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr "pgr_primBFS(`Edges SQL`_, **root vids**, [``max_depth``])"

msgid "``pgr_primDD``"
msgstr "``pgr_primDD``"

msgid "``pgr_primDD`` — Catchament nodes using Prim's algorithm."
msgstr "``pgr_primDD`` — 使用 Prim 算法的集水区节点。"

msgid ""
"Using Prim's algorithm, extracts the nodes that have aggregate costs less "
"than or equal to a **distance** from a **root** vertex (or vertices) within "
"the calculated minimum spanning tree."
msgstr ""
"使用 Prim 算法，在计算的最小生成树中提取总成本小于或等于距根顶点（或多个顶"
"点）距离的节点。"

msgid "pgr_primDD(`Edges SQL`_, **root vid**, **distance**)"
msgstr "pgr_primDD(`Edges SQL`_, **root vid**, **distance**)"

msgid "pgr_primDD(`Edges SQL`_, **root vids**, **distance**)"
msgstr "pgr_primDD(`Edges SQL`_, **root vids**, **distance**)"

msgid "``pgr_primDFS``"
msgstr "``pgr_primDFS``"

msgid ""
"``pgr_primDFS`` — Prim algorithm for Minimum Spanning Tree with Depth First "
"Search ordering."
msgstr "``pgr_primDFS`` — 具有深度优先搜索排序的最小生成树的 Prim 算法。"

msgid ""
"Visits and extracts the nodes information in Depth First Search ordering of "
"the Minimum Spanning Tree created using Prims's algorithm."
msgstr ""
"访问并提取使用 Prims 算法创建的最小生成树的深度优先搜索顺序中的节点信息。"

msgid "pgr_primDFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr "pgr_primDFS(`Edges SQL`_, **root vid**, [``max_depth``])"

msgid "pgr_primDFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr "pgr_primDFS(`Edges SQL`_, **root vids**, [``max_depth``])"

msgid "``pgr_pushRelabel``"
msgstr "``pgr_pushRelabel``"

msgid ""
"``pgr_pushRelabel`` — Calculates the flow on the graph edges that maximizes "
"the flow from the sources to the targets using Push Relabel Algorithm."
msgstr ""
"``pgr_pushRelabel`` — 使用 Push Relabel 算法计算图边上的流量，以最大化从源到"
"目标的流量。"

msgid "``pgr_pushRelabel`` (`Combinations`_)"
msgstr "``pgr_pushRelabel`` (`组合`_)"

msgid "Renamed from ``pgr_maxFlowPushRelabel``"
msgstr "由 ``pgr_maxFlowPushRelabel`` 重命名"

msgid "pgr_pushRelabel(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_pushRelabel(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_pushRelabel(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_pushRelabel(`Edges SQL`_, **start vid**, **end vids**)"

msgid "pgr_pushRelabel(`Edges SQL`_, **start vids**, **end vid**)"
msgstr "pgr_pushRelabel(`Edges SQL`_, **start vids**, **end vid**)"

msgid "pgr_pushRelabel(`Edges SQL`_, **start vids**, **end vids**)"
msgstr "pgr_pushRelabel(`Edges SQL`_, **start vids**, **end vids**)"

msgid "pgr_pushRelabel(`Edges SQL`_, `Combinations SQL`_)"
msgstr "pgr_pushRelabel(`Edges SQL`_, `Combinations SQL`_)"

msgid "pgr_sequentialVertexColoring - Proposed"
msgstr "pgr_sequentialVertexColoring - 拟议"

msgid ""
"``pgr_sequentialVertexColoring`` — Returns the vertex coloring of an "
"undirected graph, using greedy approach."
msgstr "``pgr_sequentialVertexColoring`` — 使用贪婪方法返回无向图的顶点着色。"

msgid "Promoted to **proposed** signature"
msgstr "晋升为 **拟议** 签名"

msgid ""
"Sequential vertex coloring algorithm is a graph coloring algorithm in which "
"color identifiers are assigned to the vertices of a graph in a sequential "
"manner, such that no edge connects two identically colored vertices."
msgstr ""
"顺序顶点着色算法是一种图着色算法，其中颜色标识符以顺序方式分配给图的顶点，使"
"得没有边连接两个相同颜色的顶点。"

msgid "The implementation is applicable only for **undirected** graphs."
msgstr "该实现仅适用于**无向**图。"

msgid ""
"Provides the color to be assigned to all the vertices present in the graph."
msgstr "提供要分配给图中存在的所有顶点的颜色。"

msgid "Color identifiers values are in the Range :math:`[1, |V|]`"
msgstr "颜色标识符值在范围 :math:`[1, |V|]`内"

msgid "The algorithm tries to assign the least possible color to every vertex."
msgstr "该算法尝试为每个顶点分配尽可能少的颜色。"

msgid ""
"Efficient graph coloring is an NP-Hard problem, and therefore, this "
"algorithm does not always produce optimal coloring. It follows a greedy "
"strategy by iterating through all the vertices sequentially, and assigning "
"the smallest possible color that is not used by its neighbors, to each "
"vertex."
msgstr ""
"高效的图着色是一个 NP 困难问题，因此，该算法并不总是产生最佳着色。 它遵循贪婪"
"策略，依次迭代所有顶点，并将其邻居未使用的最小可能颜色分配给每个顶点。"

msgid "The returned rows are ordered in ascending order of the vertex value."
msgstr "返回的行按顶点值的升序排列。"

msgid "Sequential Vertex Coloring Running Time: :math:`O(|V|*(d + k))`"
msgstr "顺序顶点着色运行时间：:math:`O(|V|*(d + k))`"

msgid ":math:`d` is the maximum degree of the vertices in the graph,"
msgstr ":math:`d`是图中顶点的最大度数，"

msgid ":math:`k` is the number of colors used."
msgstr ":math:`k`是使用的颜色数量。"

msgid "pgr_sequentialVertexColoring(`Edges SQL`_)"
msgstr "pgr_sequentialVertexColoring(`Edges SQL`_)"

msgid "pgr_stoerWagner - Experimental"
msgstr "pgr_stoerWagner - 实验"

msgid "``pgr_stoerWagner`` — The min-cut of graph using stoerWagner algorithm."
msgstr "``pgr_stoerWagner`` — 使用 stoerWagner 算法对图进行最小分割。"

msgid "Version 3.0"
msgstr "版本3.0"

msgid ""
"In graph theory, the Stoer–Wagner algorithm is a recursive algorithm to "
"solve the minimum cut problem in undirected weighted graphs with non-"
"negative weights. The essential idea of this algorithm is to shrink the "
"graph by merging the most intensive vertices, until the graph only contains "
"two combined vertex sets. At each phase, the algorithm finds the minimum s-t "
"cut for two vertices s and t chosen as its will. Then the algorithm shrinks "
"the edge between s and t to search for non s-t cuts. The minimum cut found "
"in all phases will be the minimum weighted cut of the graph."
msgstr ""
"在图论中，Stoer-Wagner 算法是一种递归算法，用于解决具有非负权重的无向带权图中"
"的最小割问题。 该算法的基本思想是通过合并最密集的顶点来收缩图，直到图仅包含两"
"个组合的顶点集。 在每个阶段，算法都会找到任意选择的两个顶点 s 和 t 的最小 s-"
"t 割。 然后算法缩小 s 和 t 之间的缘以搜索非 s-t 切割。 在所有阶段中找到的最小"
"割将是图的最小加权割。"

msgid ""
"A cut is a partition of the vertices of a graph into two disjoint subsets. A "
"minimum cut is a cut for which the size or weight of the cut is not larger "
"than the size of any other cut. For an unweighted graph, the minimum cut "
"would simply be the cut with the least edges. For a weighted graph, the sum "
"of all edges' weight on the cut determines whether it is a minimum cut."
msgstr ""
"割是将图的顶点划分为两个不相交的子集。 最小切割是指切割的尺寸或重量不大于任何"
"其他切割的尺寸的切割。 对于未加权的图，最小割只是具有最少边的割。 对于加权"
"图，割线上所有边的权重之和决定了它是否是最小割。"

msgid "Sum of the weights of all edges between the two sets is mincut."
msgstr "两组之间所有边的权重之和是最小割。"

msgid "A **mincut** is a cut having the least weight."
msgstr "**最小切割**是重量最小的切割。"

msgid "Values are returned when graph is connected."
msgstr "连接图形时返回值。"

msgid "When there is no edge in graph then EMPTY SET is return."
msgstr "当图中没有边时，则返回 EMPTY SET。"

msgid "When the graph is unconnected then EMPTY SET is return."
msgstr "当图形未连接时，则返回 EMPTY SET。"

msgid ""
"Sometimes a graph has multiple min-cuts, but all have the same weight. The "
"this function determines exactly one of the min-cuts as well as its weight."
msgstr ""
"有时一个图有多个最小割，但都具有相同的权重。 该函数准确地确定最小切割之一及其"
"权重。"

msgid "Running time: :math:`O(V*E + V^2*log V)`."
msgstr "运行时间： :math:`O(V*E + V^2*log V)`。"

msgid "pgr_stoerWagner(`Edges SQL`_)"
msgstr "pgr_stoerWagner(`Edges SQL`_)"

msgid "RETURNS SET OF |result-mincut|"
msgstr "RETURNS SET OF |result-mincut|"

msgid "min cut of the main subgraph"
msgstr "主子图的最小割"

msgid "Returns set of ``(seq, edge, cost, mincut)``"
msgstr "返回集合``(seq, edge, cost, mincut)``"

msgid "Edges which divides the set of vertices into two."
msgstr "将顶点集一分为二的边。"

msgid "Cost to traverse of edge."
msgstr "遍历边的成本。"

msgid "**mincut**"
msgstr "**mincut**"

msgid "Min-cut weight of a undirected graph."
msgstr "无向图的最小割权。"

msgid "Additional Example:"
msgstr "附加示例："

msgid "min cut of an edge"
msgstr "边的最小割"

msgid "Using :doc:`pgr_connectedComponents`"
msgstr "使用:doc:`pgr_connectedComponents`"

msgid "https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm"
msgstr "https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm"

msgid "``pgr_strongComponents``"
msgstr "``pgr_strongComponents``"

msgid ""
"``pgr_strongComponents`` — Strongly connected components of a directed graph "
"using Tarjan's algorithm based on DFS."
msgstr ""
"``pgr_strongComponents`` — 使用基于 DFS 的 Tarjan 算法构建有向图的强连通分"
"量。"

msgid ""
"A strongly connected component of a directed graph is a set of vertices that "
"are all reachable from each other."
msgstr "有向图的强连接组件是一组彼此可达的顶点。"

msgid "Works for **directed** graphs."
msgstr "适用于**有向**图。"

msgid "Components are described by vertices identifiers."
msgstr "组件由顶点标识符描述。"

msgid "pgr_strongComponents(`Edges SQL`_)"
msgstr "pgr_strongComponents(`Edges SQL`_)"

msgid "The strong components of the graph"
msgstr "图的重要组成部分"

msgid ""
"Boost: `Strong components <https://www.boost.org/libs/graph/doc/"
"strong_components.html>`__"
msgstr ""
"Boost: `强大组件<https://www.boost.org/libs/graph/doc/strong_components."
"html>`__"

msgid ""
"wikipedia: `Strongly connected component <https://en.wikipedia.org/wiki/"
"Strongly_connected_component>`__"
msgstr ""
"维基百科: `强连通分量 <https://en.wikipedia.org/wiki/"
"Strongly_connected_component>`__"

msgid "``pgr_topologicalSort`` - Experimental"
msgstr "``pgr_topologicalSort`` - 实验"

msgid ""
"``pgr_topologicalSort`` — Linear ordering of the vertices for directed "
"acyclic graphs (DAG)."
msgstr "``pgr_topologicalSort`` — 有向无环图 (DAG) 的顶点的线性排序。"

msgid ""
"The topological sort algorithm creates a linear ordering of the vertices "
"such that if edge :math:`(u,v)` appears in the graph, then :math:`v` comes "
"before :math:`u` in the ordering."
msgstr ""
"拓扑排序算法创建了一个顶点的线性排序，使得如果图中存在边 :math:`(u,v)`，则在"
"排序中 :math:`v` 出现在 :math:`u` 之前。"

msgid ""
"Process is valid for directed acyclic graphs only. otherwise it will throw "
"warnings."
msgstr "该过程仅对有向无环图有效。 否则它会抛出警告。"

msgid ""
"For optimization purposes, if there are more than one answer, the function"
msgstr "出于优化目的，如果有多个答案，则该函数"

msgid "will return one of them."
msgstr "将返回其中之一。"

msgid "The returned values are ordered in topological order:"
msgstr "返回的值按拓扑顺序排序："

msgid "pgr_topologicalSort(`Edges SQL`_)"
msgstr "pgr_topologicalSort(`Edges SQL`_)"

msgid "RETURNS SET OF |result-toposort|"
msgstr "RETURNS SET OF |result-toposort|"

msgid "Topologically sorting the graph"
msgstr "对图进行拓扑排序"

msgid "Returns set of |result-toposort|"
msgstr "Returns set of |result-toposort|"

msgid "Sequential value starting from :math:`1`"
msgstr "从 :math:`1` 开始的连续数值"

msgid "``sorted_v``"
msgstr "``sorted_v``"

msgid "Linear topological ordering of the vertices"
msgstr "顶点的线性拓扑排序"

msgid "Additional examples"
msgstr "其他示例"

msgid "Topologically sorting the one way segments"
msgstr "对单向段进行拓扑排序"

msgid "Graph is not a DAG"
msgstr "图不是 DAG"

msgid "``pgr_transitiveClosure`` - Experimental"
msgstr "``pgr_transitiveClosure`` - 实验"

msgid ""
"``pgr_transitiveClosure`` — Transitive closure graph of a directed graph."
msgstr "``pgr_transitiveClosure`` — 有向图的传递闭包图。"

msgid ""
"Transforms the input directed graph into the transitive closure of the graph."
msgstr "将输入有向图转换为图的传递闭包。"

msgid "Process is valid for directed graphs."
msgstr "过程对于有向图有效。"

msgid "The transitive closure of an undirected graph produces a cluster graph"
msgstr "无向图的传递闭包产生簇图"

msgid ""
"Reachability between vertices on an undirected graph happens when they "
"belong to the same connected component. (see :doc:`pgr_connectedComponents`)"
msgstr ""
"当无向图上的顶点属于同一连通分量时，就会发生它们之间的可达性。（参阅:doc:"
"`pgr_connectedComponents`）"

msgid "The returned values are not ordered"
msgstr "返回值未排序"

msgid "The returned graph is compresed"
msgstr "返回的图被压缩"

msgid "Running time: :math:`O(|V||E|)`"
msgstr "运行时间：:math:`O(|V||E|)`"

msgid "The pgr_transitiveClosure function has the following signature:"
msgstr "pgr_transitiveClosure 函数具有以下签名："

msgid "pgr_transitiveClosure(`Edges SQL`_)"
msgstr "pgr_transitiveClosure(`Edges SQL`_)"

msgid "RETURNS SET OF |result-closure|"
msgstr "RETURNS SET OF |result-closure|"

msgid "Rechability of a subgraph"
msgstr "子图的可达性"

msgid "``vid``"
msgstr "``vid``"

msgid "Identifier of the source of the edges"
msgstr "边来源的标识符"

msgid "``target_array``"
msgstr "``target_array``"

msgid "Identifiers of the targets of the edges"
msgstr "边目标的标识符"

msgid "Identifiers of the vertices that are reachable from vertex v."
msgstr "从顶点 v 可到达的顶点的标识符。"

msgid "https://en.wikipedia.org/wiki/Transitive_closure"
msgstr "https://en.wikipedia.org/wiki/Transitive_closure"

msgid "pgr_trsp - Proposed"
msgstr "pgr_trsp - 拟议"

msgid "``pgr_trsp`` - routing vertices with restrictions."
msgstr "``pgr_trsp`` -有限制的路由顶点。"

msgid "New proposed signatures:"
msgstr "新拟议的签名："

msgid "``pgr_trsp`` (`One to One`_)"
msgstr "``pgr_trsp`` (`一对一`_)"

msgid "``pgr_trsp`` (`One to Many`_)"
msgstr "``pgr_trsp`` (`一对多`_)"

msgid "``pgr_trsp`` (`Many to One`_)"
msgstr "``pgr_trsp`` (`多对一`_)"

msgid "``pgr_trsp`` (`Many to Many`_)"
msgstr "``pgr_trsp`` (`多对多`_)"

msgid "``pgr_trsp`` (`Combinations`_)"
msgstr "``pgr_trsp`` (`组合`_)"

msgid "Deprecated signatures:"
msgstr "弃用签名："

msgid "``pgr_trsp(text,integer,integer,boolean,boolean,text)``"
msgstr "``pgr_trsp(text,integer,integer,boolean,boolean,text)``"

msgid "``pgr_trsp(text,integer,float,integer,float,boolean,boolean,text)``"
msgstr "``pgr_trsp(text,integer,float,integer,float,boolean,boolean,text)``"

msgid "``pgr_trspViaVertices(text,anyarray,boolean,boolean,text)``"
msgstr "``pgr_trspViaVertices(text,anyarray,boolean,boolean,text)``"

msgid ""
"``pgr_trspviaedges(text,integer[],double precision[],boolean,boolean,text)``"
msgstr ""
"``pgr_trspviaedges(text,integer[],double precision[],boolean,boolean,text)``"

msgid "New prototypes:"
msgstr "新原型："

msgid "``pgr_trspViaVertices``"
msgstr "``pgr_trspViaVertices``"

msgid "``pgr_trspViaEdges``"
msgstr "``pgr_trspViaEdges``"

msgid ""
"Turn restricted shortest path (TRSP) is an algorithm that receives turn "
"restrictions in form of a query like those found in real world navigable "
"road networks."
msgstr ""
"转弯限制最短路径 (TRSP) 是一种以查询形式接收转弯限制的算法，就像在现实世界的"
"可通航道路网络中发现的那样。"

msgid ""
"It does no guarantee the shortest path as it might contain restriction paths."
msgstr "它不保证最短路径，因为它可能包含限制路径。"

msgid "The general algorithm is as follows:"
msgstr "通用算法如下："

msgid "Execute a Dijkstra."
msgstr "执行 Dijkstra。"

msgid "If the solution passes thru a restriction then."
msgstr "如果解决方案通过了限制。"

msgid "Execute the **TRSP** algorithm with restrictions."
msgstr "有限制地执行 **TRSP** 算法。"

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vid**, "
"[``directed``])"
msgstr ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vid**, "
"[``directed``])"

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vids**, "
"[``directed``])"
msgstr ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vids**, "
"[``directed``])"

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vids**, **end vid**, "
"[``directed``])"
msgstr ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vids**, **end vid**, "
"[``directed``])"

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vids**, **end vids**, "
"[``directed``])"

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, `Combinations SQL`_, "
"[``directed``])"
msgstr ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, `Combinations SQL`_, "
"[``directed``])"

msgid "From vertex :math:`6` to vertex  :math:`10` on an undirected graph."
msgstr "无向图上从一个顶点 :math:`6`到另一个顶点:math:`10`。"

msgid ""
"From vertex :math:`6` to vertices :math:`\\{10, 1\\}` on an undirected graph."
msgstr "无向图上从顶点:math:`6` 到顶点 :math:`\\{10, 1\\}` 。"

msgid ""
"From vertices :math:`\\{6, 1\\}` to vertex :math:`8` on a directed graph."
msgstr "有向图上从顶点 :math:`\\{6, 1\\}`到顶点 :math:`8`。"

msgid ""
"From vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 8\\}` on an "
"undirected graph."
msgstr "无向图上从顶点 :math:`\\{6, 1\\}`到顶点 :math:`\\{10, 8\\}`。"

msgid "Using a combinations table on an undirected graph."
msgstr "在无向图上使用组合表。"

msgid ""
"`Deprecated documentation <https://docs.pgrouting.org/3.3/en/pgr_trsp.html>`_"
msgstr "`已弃用文档 <https://docs.pgrouting.org/3.3/en/pgr_trsp.html>`_"

msgid "``pgr_trspVia`` - Proposed"
msgstr "``pgr_trspVia`` - 拟议"

msgid ""
"``pgr_trspVia`` Route that goes through a list of vertices with restrictions."
msgstr "``pgr_trspVia``穿过有限制的顶点列表的路线。"

msgid "New proposed function:"
msgstr "新提议的函数："

msgid "``pgr_trspVia`` (`One Via`_)"
msgstr "``pgr_trspVia`` (`One Via`_)"

msgid ""
"Given a list of vertices and a graph, this function is equivalent to finding "
"the shortest path between :math:`vertex_i` and :math:`vertex_{i+1}` for all :"
"math:`i < size\\_of(via\\;vertices)` trying not to use restricted paths."
msgstr ""
"给定一个顶点列表和一个图，这个函数等同于在所有:math:`i < size\\_of(via\\;"
"vertices)`的情况下找到从 :math:`vertex_i`到 :math:`vertex_{i+1}`的最短路径，"
"尽量避免使用受限路径。"

msgid "The paths represents the sections of the route."
msgstr "路径代表路线的各个部分。"

msgid "Execute a :doc:`pgr_dijkstraVia`."
msgstr "执行 :doc:`pgr_dijkstraVia`。"

msgid ""
"For the set of sub paths of the solution that pass through a restriction then"
msgstr "对于通过限制的解决方案的子路径集，则"

msgid "Execute the **TRSP** algorithm with restrictions for the paths."
msgstr "执行对路径有限制的 **TRSP** 算法。"

msgid "**NOTE** when this is done, ``U_turn_on_edge`` flag is ignored."
msgstr "**注意**，完成此操作后， ``U_turn_on_edge``标志将被忽略。"

msgid ""
"pgr_trspVia(`Edges SQL`_, `Restrictions SQL`_, **via vertices**, "
"[**options**])"
msgstr ""
"pgr_trspVia(`Edges SQL`_, `Restrictions SQL`_, **via vertices**, "
"[**options**])"

msgid ""
"Find the route that visits the vertices :math:`\\{ 5, 1, 8\\}` in that order "
"on an directed graph."
msgstr "在有向图上查找按顺序访问顶点 :math:`\\{ 5, 1, 8\\}` 的路线。"

msgid ""
"All this examples are about the route that visits the vertices :math:`\\{5, "
"7, 1, 8, 15\\}` in that order on a directed graph."
msgstr ""
"所有这些示例都是关于按有向图上的顺序访问顶点 :math:`\\{5, 7, 1, 8, 15\\}` 的"
"路线。"

msgid "Simulation of how algorithm works."
msgstr "模拟算法的工作原理。"

msgid "The algorithm performs a :doc:`pgr_dijkstraVia`"
msgstr "该算法执行 :doc:`pgr_dijkstraVia`"

msgid ""
"Detects which of the sub paths pass through a restriction in this case is "
"for the ``path_id = 5`` from ``6`` to ``3`` because the path :math:`15 "
"\\rightarrow 1` is restricted."
msgstr ""
"检测哪些子路径通过了限制，本例中是针对``path_id = 5``从``6``到``3`` ，因为该"
"路径 :math:`15 \\rightarrow 1`受到限制。"

msgid "Executes the :doc:`pgr_trsp` algorithm for the conflicting paths."
msgstr "执行 :doc:`pgr_trsp` 针对冲突路径建议的算法。"

msgid ""
"From the :doc:`pgr_dijkstraVia` result it removes the conflicting paths and "
"builds the solution with the results of the :doc:`pgr_trsp` algorithm:"
msgstr ""
"从 :doc:`pgr_dijkstraVia` 提议的结果中，它删除了冲突路径，并使用 :doc:"
"`pgr_trsp` 提议的算法的结果构建解决方案："

msgid "Getting the same result as ``pgr_trspVia``:"
msgstr "得到与 ``pgr_trspVia`` 相同的结果："

msgid "Sometimes ``U_turn_on_edge`` flag is ignored when is set to ``false``."
msgstr "有时，当设置为 ``false`` 时，``U_turn_on_edge`` 标志会被忽略。"

msgid ""
"The first step, doing a :doc:`pgr_dijkstraVia` does consider not making a U "
"turn on the same edge. But the path :math:`16 \\rightarrow 13` (Rows 4 and "
"5) is restricted and the result is using it."
msgstr ""
"第一步，进行 :doc:`pgr_dijkstraVia`不考虑在同一边上掉头。 但路径 :math:`16 "
"\\rightarrow 13`（第 4 行和第 5 行）受到限制，结果正在使用它。"

msgid ""
"When executing the :doc:`pgr_trsp` algorithm for the conflicting path, there "
"is no ``U_turn_on_edge`` flag."
msgstr ""
"当执行 :doc:`pgr_trsp`针对冲突路径的拟议算法时，没有 ``U_turn_on_edge`` 标"
"志。"

msgid ""
"Therefore the result ignores the ``U_turn_on_edge`` flag when set to "
"``false``."
msgstr "因此，当设置为 ``false`` 时，结果会忽略 ``U_turn_on_edge`` 标志。"

msgid ":doc:`via-category`"
msgstr ":doc:`via-category`"

msgid "``pgr_trspVia_withPoints`` - Proposed"
msgstr "``pgr_trspVia_withPoints`` - 拟议"

msgid ""
"``pgr_trspVia_withPoints`` - Route that goes through a list of vertices and/"
"or points with restrictions."
msgstr "``pgr_trspVia_withPoints`` - 经过一系列具有限制的顶点和/或点的路线。"

msgid "``pgr_trspVia_withPoints`` (`One Via`_)"
msgstr "``pgr_trspVia_withPoints`` (`One Via`_)"

msgid ""
"Given a graph, a set of restriction on the graph edges, a set of points on "
"the graphs edges and a list of vertices, this function is equivalent to "
"finding the shortest path between :math:`vertex_i` and :math:`vertex_{i+1}` "
"(where :math:`vertex` can be a vertex or a point on the graph) for all :math:"
"`i < size\\_of(via\\;vertices)` trying not to use restricted paths."
msgstr ""
"给定一个图、对图边的一组限制、图边上的一组点和一个顶点列表，该函数相当于查"
"找 :math:`vertex_i` 和 :math:`vertex_{i+1}`之间的最短路径（其中 :math:"
"`vertex` 可以是图上的顶点或点） ）对于所有 :math:`i < size\\_of(via\\;"
"vertices)`尝试不使用受限路径的人。"

msgid "is a sequence of paths"
msgstr "是一系列路径"

msgid "Build the Graph with the new points."
msgstr "用新点构建图表。"

msgid "The points identifiers will be converted to negative values."
msgstr "点标识符将转换为负值。"

msgid "The vertices identifiers will remain positive."
msgstr "顶点标识符将保持正值。"

msgid "Execute a :doc:`pgr_withPointsVia`."
msgstr "执行 :doc:`pgr_withPointsVia`。"

msgid ""
"For the set of paths of the solution that pass through a restriction then"
msgstr "对于通过限制的解决方案的路径集合，则"

msgid "Execute the **TRSP** algorithm with restrictions for the path."
msgstr "执行对路径有限制的 **TRSP** 算法。"

msgid "Do not use negative values on identifiers of the inner queries."
msgstr "不要在内部查询的标识符上使用负值。"

msgid ""
"pgr_trspVia_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**via vertices**, [**options**])"
msgstr ""
"pgr_trspVia_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**via vertices**, [**options**])"

msgid ""
"Find the route that visits the vertices :math:`\\{-6, 15, -5\\}` in that "
"order on an directed graph."
msgstr "在有向图上查找按顺序访问顶点 :math:`\\{-6, 15, -5\\}`的路线。"

msgid "When positive it is considered a vertex identifier"
msgstr "当为正时，它被视为顶点标识符"

msgid "When negative it is considered a point identifier"
msgstr "当负数时，它被认为是一个点标识符"

msgid "With points optional parameters"
msgstr "带点可选参数"

msgid "``driving_side``"
msgstr "``driving_side``"

msgid "``r``"
msgstr "``r``"

msgid "Value in [``r``, ``l``] indicating if the driving side is:"
msgstr "在 [``r``, ``l``] 中的值表示驾驶方向是："

msgid "``r`` for right driving side"
msgstr "``r`` 代表右驾驶侧"

msgid "``l`` for left driving side"
msgstr "``l``表示左驾驶侧"

msgid "Any other value will be considered as ``r``"
msgstr "任何其他值将被视为 ``r``"

msgid "``details``"
msgstr "``details``"

msgid "When ``true`` the results will include the points that are in the path."
msgstr "如果为 ``true``，结果将包括路径中的点。"

msgid ""
"When ``false`` the results will not include the points that are in the path."
msgstr "如果为``false``，结果将不包括路径中的点。"

msgid ""
"When ``start_vid``, ``end_vid`` and ``node`` columns have negative values, "
"the identifier is for a Point."
msgstr ""
"当 ``start_vid``、 ``end_vid``和``node``列具有负值时，该标识符用于Point。"

msgid "Use ``pgr_findCloseEdges`` for points on the fly"
msgstr "对动态点使用 ``pgr_findCloseEdges``"

msgid "Using :doc:`pgr_findCloseEdges`:"
msgstr "使用:doc:`pgr_findCloseEdges`:"

msgid ""
"Visit from vertex :math:`1` to the two locations on the graph of point "
"`(2.9, 1.8)` in order of closeness to the graph."
msgstr ""
"从顶点 :math:`1` 开始，按照距离图形最近的顺序访问点 `(2.9, 1.8)` 上的两个位"
"置。"

msgid ""
"Point :math:`-1` corresponds to the closest edge from point `(2.9,1.8)`."
msgstr "点 :math:`-1`对应于距离点 `(2.9,1.8)`最近的边。"

msgid ""
"Point :math:`-2` corresponds to the next close edge from point `(2.9,1.8)`."
msgstr "点 :math:`-2`对应于点`(2.9,1.8)` 的下一个闭合边。"

msgid ""
"Point :math:`-2` is visited on the route to from vertex :math:`1` to Point :"
"math:`-1` (See row where :math:`seq = 4`)."
msgstr ""
"点 :math:`-2`在从顶点 :math:`1` 到点 :math:`-1`的路线上被访问（参见行 ，其中:"
"math:`seq = 4`）。"

msgid "Usage variations"
msgstr "用法变化"

msgid ""
"All this examples are about the route that visits the vertices :math:`\\{-6, "
"7, -4, 8, -2\\}` in that order on a directed graph."
msgstr ""
"所有这些示例都是关于按有向图上的顺序访问顶点:math:`\\{-6, 7, -4, 8, -2\\}`的"
"路线。"

msgid "Status of \"passes in front\" or \"visits\" of the nodes and points."
msgstr "节点、点的\"通过\"或\"访问\"状态。"

msgid "The algorithm performs a :doc:`pgr_withPointsVia`"
msgstr "该算法执行:doc:`pgr_withPointsVia`"

msgid ""
"Detects which of the paths pass through a restriction in this case is for "
"the ``path_id = 1`` from ``-6`` to ``15`` because the path :math:`9 "
"\\rightarrow 16` is restricted."
msgstr ""
"检测哪些路径通过了限制，在本例中是针对从 ``-6``到``15`` 的 ``path_id = 1``，"
"因为路径:math:`9 \\rightarrow 16`受到限制。"

msgid ""
"Executes the :ref:`TRSP-family:TRSP algorithm` for the conflicting paths."
msgstr "对冲突路径执行 :ref:`TRSP-family:TRSP 算法`。"

msgid ""
"From the :doc:`pgr_withPointsVia` result it removes the conflicting paths "
"and builds the solution with the results of the :doc:`pgr_trsp` algorithm:"
msgstr "从 :doc:`pgr_withPointsVia` 的结果中移除冲突的路径，并使用 :doc:`pgr_trsp` "
"算法的结果构建解决方案："

msgid "Getting the same result as ``pgr_trspVia_withPoints``:"
msgstr "得到与 ``pgr_trspVia_withPoints``相同的结果："

msgid ""
"The first step, doing a :doc:`pgr_withPointsVia` does consider not making a "
"U turn on the same edge. But the path :math:`9 \\rightarrow 16` (Rows 4 and "
"5) is restricted and the result is using it."
msgstr ""
"第一步，执行 :doc:`pgr_withPointsVia`不考虑在同一边上掉头。 但路径 :math:`9 "
"\\rightarrow 16`（第 4 行和第 5 行）受到限制，结果正在使用它。"

msgid ""
"When executing the :doc:`pgr_trsp_withPoints` algorithm for the conflicting "
"path, there is no ``U_turn_on_edge`` flag."
msgstr ""
"当执行 :doc:`pgr_trsp_withPoints` 针对冲突路径的算法时，没有 "
"``U_turn_on_edge`` 标志。"

msgid ""
"Therefore the result ignores the ``U_turn_on_edge`` flag when set to "
"``false``. From the :doc:`pgr_withPointsVia` result it removes the "
"conflicting paths and builds the solution with the results of the :doc:"
"`pgr_trsp` algorithm. In this case a U turn is been done using the same edge."
msgstr ""
"因此，当设置为 ``false`` 时，结果会忽略 ``U_turn_on_edge`` 标志。 从 "
":doc:`pgr_withPointsVia`结果中，它删除了冲突路径，并使用 :doc:`pgr_trsp` "
"算法的结果构建解决方案。 在这种情况下，使用相同的边缘完成 U 形转弯。"

msgid "pgr_trsp_withPoints - Proposed"
msgstr "pgr_trsp_withPoints - 拟议"

msgid "``pgr_trsp_withPoints`` Routing Vertex/Point with restrictions."
msgstr "``pgr_trsp_withPoints``有限制的路由顶点/点。"

msgid "``pgr_trsp_withPoints`` (`One to One`_)"
msgstr "``pgr_trsp_withPoints`` (`一对一`_)"

msgid "``pgr_trsp_withPoints`` (`One to Many`_)"
msgstr "``pgr_trsp_withPoints`` (`一对多`_)"

msgid "``pgr_trsp_withPoints`` (`Many to One`_)"
msgstr "``pgr_trsp_withPoints`` (`多对一`_)"

msgid "``pgr_trsp_withPoints`` (`Many to Many`_)"
msgstr "``pgr_trsp_withPoints`` (`多对多`_)"

msgid "``pgr_trsp_withPoints`` (`Combinations`_)"
msgstr "``pgr_trsp_withPoints`` (`组合`_)"

msgid ""
"Modify the graph to include points defined by points_sql. Using Dijkstra "
"algorithm, find the shortest path(s)"
msgstr "修改图以包括由points_sql 定义的点。 使用 Dijkstra 算法，找到最短路径"

msgid "Characteristics:"
msgstr "特征："

msgid "Vertices of the graph are:"
msgstr "图的顶点是："

msgid "**positive** when it belongs to the `Edges SQL`_"
msgstr "当它属于`Edges SQL`_ 时为**正**"

msgid "**negative** when it belongs to the `Points SQL`_"
msgstr "当它属于 `Points SQL`_为**负**"

msgid "Driving side can not be ``b``"
msgstr "驾驶侧不可能为 ``b``"

msgid "The agg_cost the non included values (v, v) is 0"
msgstr "不包含的值 (v, v) 的 agg_cost 为 0"

msgid "The agg_cost the non included values (u, v) is ∞"
msgstr "不包含的值 (u, v) 的 agg_cost 为 ∞"

msgid ""
"For optimization purposes, any duplicated value in the start_vids or "
"end_vids are ignored."
msgstr "出于优化目的，start_vid 或 end_vid 中的任何重复值都将被忽略。"

msgid ""
"The returned values are ordered: - start_vid ascending - end_vid ascending"
msgstr "返回值按以下顺序排列： - start_vid 升序 - end_vid 升序"

msgid "Running time: :math:`O(|start\\_vids|\\times(V \\log V + E))`"
msgstr "运行时间： :math:`O(|start\\_vids|\\times(V \\log V + E))`"

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vid**, **end vid**, [**options**])"
msgstr ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vid**, **end vid**, [**options**])"

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vid**, **end vids**, [**options**])"
msgstr ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vid**, **end vids**, [**options**])"

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vids**, **end vid**, [**options**])"
msgstr ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vids**, **end vid**, [**options**])"

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vids**, **end vids**, [**options**])"
msgstr ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vids**, **end vids**, [**options**])"

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Combinations SQL`_, "
"`Points SQL`_, [**options**])"
msgstr ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Combinations SQL`_, "
"`Points SQL`_, [**options**])"

msgid "**options:** ``[directed, driving_side, details]``"
msgstr "**options:** ``[directed, driving_side, details]``"

msgid ""
"From point :math:`1` to vertex :math:`10` with details on a left driving "
"side configuration on a directed graph with details."
msgstr ""
"从点 :math:`1`到顶点 :math:`10`，在有向图上显示左侧驾驶侧配置的详细信息。"

msgid "From point :math:`1` to point :math:`3` and vertex :math:`7`."
msgstr "从点:math:`1`到点 :math:`3`和顶点 :math:`7`。"

msgid "From point :math:`1` and vertex :math:`6` to point :math:`3`."
msgstr "从点:math:`1`和顶点 :math:`6`到点 :math:`3`。"

msgid ""
"From point :math:`1` and vertex :math:`6` to point :math:`3` and vertex :"
"math:`1`."
msgstr "从点:math:`1`和顶点 :math:`6`到点 :math:`3`和顶点:math:`1`。"

msgid ""
"From point :math:`1` to vertex :math:`10` and from vertex :math:`6` to "
"point :math:`3` with right side driving configuration."
msgstr ""
"从点:math:`1`到顶点 :math:`10`以及从顶点 :math:`6`到点 :math:`3`，采用右侧驾"
"驶配置。"

msgid ""
"Find the routes from vertex :math:`1` to the two closest locations on the "
"graph of point `(2.9, 1.8)`."
msgstr "找到从顶点 :math:`1` 到点 `(2.9, 1.8)` 图上两个最近位置的路线。"

msgid ""
"Point :math:`-1` corresponds to the closest edge from point `(2.9, 1.8)`."
msgstr "点:math:`-1`对应于距离点`(2.9, 1.8)` 最近的边。"

msgid ""
"Point :math:`-2` corresponds to the next close edge from point `(2.9, 1.8)`."
msgstr "点 :math:`-2`对应于点`(2.9, 1.8)` 的下一个闭合边。"

msgid "Pass in front or visits."
msgstr "从前面经过或参观。"

msgid ""
"Which path (if any) passes in front of point :math:`6` or vertex :math:`11` "
"with right side driving topology."
msgstr ""
"哪条路径（如果有）通过右侧驱动拓扑的点 :math:`6`或顶点 :math:`11`前面。"

msgid "Show details on undirected graph."
msgstr "显示无向图的详细信息。"

msgid ""
"From point :math:`1` and vertex :math:`6` to point :math:`3` to vertex :math:"
"`1` on an undirected graph, with details."
msgstr ""
"无向图上从点:math:`1`和顶点:math:`6`到点 :math:`3`到顶点 :math:`1` 的详细信"
"息。"

msgid "pgr_turnRestrictedPath - Experimental"
msgstr "pgr_turnRestrictedPath - 实验性"

msgid ""
"``pgr_turnRestrictedPath`` Using Yen's algorithm Vertex -Vertex routing with "
"restrictions"
msgstr "``pgr_turnRestrictedPath``使用 Yen 算法顶点- 带限制的顶点路由"

msgid "New experimental function"
msgstr "新实验功能"

msgid ""
"Using Yen's algorithm to obtain K shortest paths and analyze the paths to "
"select the paths that do not use the restrictions"
msgstr "利用Yen算法获得K条最短路径并对路径进行分析以选择不使用限制的路径"

msgid ""
"pgr_turnRestrictedPath(`Edges SQL`_, `Restrictions SQL`_, **start vid**, "
"**end vid**, **K**, [**options**])"
msgstr ""
"pgr_turnRestrictedPath(`Edges SQL`_, `Restrictions SQL`_, **start vid**, "
"**end vid**, **K**, [**options**])"

msgid "**options:** ``[directed, heap_paths, stop_on_first, strict]``"
msgstr "**options:** ``[directed, heap_paths, stop_on_first, strict]``"

msgid "RETURNS SET OF |ksp-result|"
msgstr "RETURNS SET OF |ksp-result|"

msgid "From vertex :math:`3` to vertex  :math:`8` on a directed graph"
msgstr "有向图上从顶点 :math:`3`到顶点:math:`8`"

msgid "Special optional parameters"
msgstr "特殊可选参数"

msgid "``stop_on_first``"
msgstr "``stop_on_first``"

msgid ""
"When ``true`` stops on first path found that dos not violate restrictions"
msgstr "当 ``true`` 停止在发现不违反限制的第一条路径上时"

msgid "When ``false`` returns at most K paths"
msgstr "当 ``false``时返回最多 K 条路径"

msgid "When ``true`` returns only paths that do not violate restrictions"
msgstr "当 ``true`` 时仅返回不违反限制的路径"

msgid "When ``false`` returns the paths found"
msgstr "当 ``false`` 返回找到的路径"

msgid "From vertex :math:`3` to :math:`8` with ``strict`` flag on."
msgstr "从顶点 :math:`3` 到:math:`8`，并启用 ``strict`` 标志。"

msgid "No results because the only path available follows a restriction."
msgstr "没有结果，因为唯一可用的路径受到限制。"

msgid "From vertex :math:`3` to vertex  :math:`8` on an undirected graph"
msgstr "无向图中从顶点:math:`3`到顶点:math:`8`"

msgid "From vertex :math:`3` to vertex  :math:`8` with more alternatives"
msgstr "从一个顶点 :math:`3`到另一个顶点 :math:`8`有更多的选择"

msgid "``pgr_version``"
msgstr "``pgr_version``"

msgid "``pgr_version`` — Query for pgRouting version information."
msgstr "``pgr_version`` —查询pgRouting版本信息。"

msgid "Breaking change on result columns"
msgstr "结果列的重大变化"

msgid "Support for old signature ends"
msgstr "对旧签名的支持结束"

msgid "Returns pgRouting version information."
msgstr "返回 pgRouting 版本信息。"

msgid "pgr_version()"
msgstr "pgr_version()"

msgid "pgRouting Version for this documentation"
msgstr "本文档的 pgRouting 版本"

msgid "pgr_vrpOneDepot - Experimental"
msgstr "pgr_vrpOneDepot -实验"

msgid "**No documentation available**"
msgstr "**无可用文档**"

msgid "**TBD**"
msgstr "**TBD**"

msgid "``pgr_withPoints`` - Proposed"
msgstr "``pgr_withPoints`` -拟议"

msgid ""
"``pgr_withPoints`` - Returns the shortest path in a graph with additional "
"temporary vertices."
msgstr "``pgr_withPoints`` - 返回图中带有附加临时顶点的最短路径。"

msgid "pgr_withPoints(Combinations)"
msgstr "pgr_withPoints（组合）"

msgid "**positive** when it belongs to the edges_sql"
msgstr "当它属于edges_sql时为**正**"

msgid "**negative** when it belongs to the points_sql"
msgstr "当它属于 points_sql时为**负**"

msgid ""
"When the starting vertex and ending vertex are the same, there is no path. - "
"The agg_cost the non included values (v, v) is 0"
msgstr ""
"当起始顶点和结束顶点相同时，就没有路径。 - 非包含值 (v, v) 的 agg_cost 为 0"

msgid ""
"When the starting vertex and ending vertex are the different and there is no "
"path: - The agg_cost the non included values (u, v) is ∞"
msgstr ""
"当起始顶点和结束顶点不同并且没有路径时： - 不包含的值 (u, v) 的 agg_cost 为 ∞"

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, "
"[**options**])"
msgstr ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, "
"[**options**])"

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, "
"[**options**])"
msgstr ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, "
"[**options**])"

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, "
"[**options**])"
msgstr ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, "
"[**options**])"

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**, "
"[**options**])"
msgstr ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**, "
"[**options**])"

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, "
"[**options**])"
msgstr ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, "
"[**options**])"

msgid "**options:** ``[directed, driving_side, details])``"
msgstr "**options:** ``[directed, driving_side, details])``"

msgid "RETURNS SET OF |old-pid-result|"
msgstr "RETURNS SET OF |old-pid-result|"

msgid "**options:** [directed, driving_side, details])"
msgstr "**options:** [directed, driving_side, details])"

msgid "From point :math:`1` to vertex :math:`10` with details"
msgstr "从点 :math:`1`到顶点:math:`10`的细节"

msgid "RETURNS SET OF |pid-1-m|"
msgstr "RETURNS SET OF |pid-1-m|"

msgid ""
"From point :math:`1` to point :math:`3` and vertex :math:`7` on an "
"undirected graph"
msgstr "无向图上的点:math:`1`到点 :math:`3`和顶点 :math:`7`"

msgid "RETURNS SET OF |pid-m-1|"
msgstr "RETURNS SET OF |pid-m-1|"

msgid "From point :math:`1` and vertex :math:`6` to point :math:`3`"
msgstr "从点 :math:`1`和顶点 :math:`6`到点 :math:`3`"

msgid "RETURNS SET OF |pid-m-m|"
msgstr "RETURNS SET OF |pid-m-m|"

msgid "Two combinations"
msgstr "两种组合"

msgid ""
"From point :math:`1` to vertex :math:`10`, and from vertex :math:`6` to "
"point :math:`3` with **right** side driving."
msgstr ""
"从点 :math:`1`到顶点 :math:`10`，以及从顶点 :math:`6` 到点:math:`3` ，**右侧"
"**行驶。"

msgid ""
"Identifier of the starting vertex of the path. Negative value is for point’s "
"identifier."
msgstr "路径起始顶点的标识符。 负值用于点的标识符。"

msgid ""
"Array of identifiers of starting vertices. Negative values are for point’s "
"identifiers."
msgstr "起始顶点的标识符数组。 负值用于点的标识符。"

msgid ""
"Identifier of the ending vertex of the path. Negative value is for point’s "
"identifier."
msgstr "路径结束顶点的标识符。 负值用于点的标识符。"

msgid ""
"Array of identifiers of ending vertices. Negative values are for point’s "
"identifiers."
msgstr "结束顶点的标识符数组。 负值用于点的标识符。"

msgid "Value in [``r``, ``l``, ``b``] indicating if the driving side is:"
msgstr "[``r``, ``l``, ``b``] 中的值指示驱动侧是否为："

msgid "``r`` for right driving side."
msgstr "``r`` 代表右驾驶侧。"

msgid "``l`` for left driving side."
msgstr "``l``代表左驾驶侧。"

msgid "``b`` for both."
msgstr "``b``对于两者。"

msgid "Use :doc:`pgr_findCloseEdges` in the `Points SQL`_."
msgstr "在 `Points SQL`_ 中使用 :doc:`pgr_findCloseEdges` 。"

msgid ""
"All the examples are about traveling from point :math:`1` and vertex :math:"
"`5` to points :math:`\\{2, 3, 6\\}` and vertices :math:`\\{10, 11\\}`"
msgstr ""
"所有示例都是关于从点:math:`1`和顶点 :math:`5`到点:math:`\\{2, 3, 6\\}`和顶"
"点 :math:`\\{10, 11\\}`的旅行"

msgid "Passes in front or visits with right side driving."
msgstr "从前方超车或右侧行驶来访。"

msgid "For point :math:`6` and vertex :math:`11`."
msgstr "对于点 :math:`6`和顶点 :math:`11`。"

msgid "Passes in front or visits with left side driving."
msgstr "从前方超车或以左侧驾驶方式行驶。"

msgid "``pgr_withPointsCost`` - Proposed"
msgstr "``pgr_withPointsCost`` -拟议"

msgid ""
"``pgr_withPointsCost`` - Calculates the shortest path and returns only the "
"aggregate cost of the shortest path(s) found, for the combination of points "
"given."
msgstr ""
"``pgr_withPointsCost`` -对于给定的点组合，计算最短路径并仅返回找到的最短路径"
"的总成本。"

msgid "pgr_withPointsCost(Combinations)"
msgstr "pgr_withPointsCost（组合）"

msgid ""
"Modify the graph to include points defined by points_sql. Using Dijkstra "
"algorithm, return only the aggregate cost of the shortest path(s) found."
msgstr ""
"修改图以包括由points_sql 定义的点。 使用 Dijkstra 算法，仅返回找到的最短路径"
"的总成本。"

msgid ""
"Returns the sum of the costs of the shortest path for pair combination of "
"vertices in the modified graph."
msgstr "返回修改图中顶点对组合的最短路径成本之和。"

msgid ""
"The returned values are in the form of a set of `(start_vid, end_vid, "
"agg_cost)`."
msgstr "返回值的形式为一组`(start_vid, end_vid, agg_cost)`。"

msgid "The `agg_cost` in the non included values `(v, v)` is `0`"
msgstr "非包含值`(v, v)`中的`agg_cost`为`0`"

msgid "The `agg_cost` in the non included values `(u, v)` is :math:`\\infty`"
msgstr "非包含值 `(u, v)`中的 `agg_cost`为:math:`\\infty`"

msgid ""
"If the values returned are stored in a table, the unique index would be the "
"pair: `(start_vid, end_vid)`."
msgstr ""
"如果返回的值存储在表中，则唯一索引将是这一对：`(start_vid, end_vid)`.。"

msgid "For **undirected** graphs, the results are **symmetric**."
msgstr "对于**无向**图，结果是**对称**的。"

msgid ""
"For optimization purposes, any duplicated value in the `start_vids` or "
"`end_vids` is ignored."
msgstr "出于优化目的， `start_vids`或 `end_vids` 中的任何重复值都将被忽略。"

msgid "Running time: :math:`O(| start\\_vids | * (V \\log V + E))`"
msgstr "运行时间：:math:`O(| start\\_vids | * (V \\log V + E))`"

msgid ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, **start vid**, **end vid**, "
"[**options**])"
msgstr ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, **start vid**, **end vid**, "
"[**options**])"

msgid ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, **start vid**, **end vids**, "
"[**options**])"
msgstr ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, **start vid**, **end vids**, "
"[**options**])"

msgid ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, **start vids**, **end vid**, "
"[**options**])"
msgstr ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, **start vids**, **end vid**, "
"[**options**])"

msgid ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, **start vids**, **end "
"vids**, [**options**])"
msgstr ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, **start vids**, **end "
"vids**, [**options**])"

msgid ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, `Combinations SQL`_, "
"[**options**])"
msgstr ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, `Combinations SQL`_, "
"[**options**])"

msgid "**options:**  ``[directed, driving_side]``"
msgstr "**options:**  ``[directed, driving_side]``"

msgid "RETURNS SET OF |matrix-pid|"
msgstr "RETURNS SET OF |matrix-pid|"

msgid ""
"There is no **details** flag, unlike the other members of the withPoints "
"family of functions."
msgstr "与 withPoints 函数系列的其他成员不同，没有**详细信息**标志。"

msgid "From point :math:`1` to vertex :math:`10` with defaults"
msgstr "使用默认值从点 :math:`1`到顶点:math:`10`"

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, "
"[**options**])"
msgstr ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, "
"[**options**])"

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, "
"[**options**])"
msgstr ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, "
"[**options**])"

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vids**, **end "
"vids**, [**options**])"
msgstr ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vids**, **end "
"vids**, [**options**])"

msgid ""
"From point :math:`15` and vertex :math:`6`  to point :math:`3` and vertex :"
"math:`1`"
msgstr "从点:math:`15`和顶点 :math:`6`到点 :math:`3` 和顶点:math:`1`"

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, "
"[**options**])"
msgstr ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, "
"[**options**])"

msgid "Identifier of the starting vertex or point."
msgstr "起始顶点或点的标识符。"

msgid "When positive: is a vertex’s identifier."
msgstr "当为正时： 是顶点的标识符。"

msgid "When negative: is a point’s identifier."
msgstr "当负数时：是点的标识符。"

msgid "Identifier of the ending vertex or point."
msgstr "结束顶点或点的标识符。"

msgid ""
"Find the cost of the routes from vertex :math:`1` to the two closest "
"locations on the graph of point `(2.9, 1.8)`."
msgstr "求从顶点 :math:`1` 到图中点 `(2.9, 1.8)` 的两个最近位置的路线成本。"

msgid "Being close to the graph does not mean have a shorter route."
msgstr "靠近图表并不意味着路线更短。"

msgid "Right side driving topology"
msgstr "右侧驾驶拓扑"

msgid ""
"Traveling from point :math:`1` and vertex :math:`5` to points :math:`\\{2, "
"3, 6\\}` and vertices :math:`\\{10, 11\\}`"
msgstr ""
"从点 :math:`1` 和顶点 :math:`5` 出发，前往点 :math:`\\{2, 3, 6\\}` 和顶点 :"
"math:`\\{10, 11\\}`"

msgid "Left side driving topology"
msgstr "左侧驾驶拓扑"

msgid "Does not matter driving side driving topology"
msgstr "与驱动端驱动拓扑无关"

msgid "``pgr_withPointsCostMatrix`` - proposed"
msgstr "``pgr_withPointsCostMatrix`` - 拟议"

msgid ""
"``pgr_withPointsCostMatrix`` - Calculates a cost matrix using :doc:"
"`pgr_withPoints`."
msgstr "``pgr_withPointsCostMatrix`` - 使用 :doc:`pgr_withPoints`计算成本矩阵."

msgid ""
"pgr_withPointsCostMatrix(`Edges SQL`_, `Points SQL`_, **start vids**, "
"[**options**])"
msgstr ""
"pgr_withPointsCostMatrix(`Edges SQL`_, `Points SQL`_, **start vids**, "
"[**options**])"

msgid ""
"Cost matrix for points :math:`\\{1, 6\\}` and vertices :math:`\\{10, 11\\}` "
"on an **undirected** graph"
msgstr ""
"**无向**图上的点 :math:`\\{1, 6\\}`和顶点:math:`\\{10, 11\\}`的成本矩阵"

msgid "Returning a **symmetrical** cost matrix"
msgstr "返回**对称**成本矩阵"

msgid "Using the default ``side`` value on the **points_sql** query"
msgstr "在**points_sql**查询上使用默认``side``值"

msgid "Using the default ``driving_side`` value"
msgstr "使用默认``driving_side``值"

msgid ""
"Find the matrix cost of the routes from vertex :math:`1` and the two closest "
"locations on the graph of point `(2.9, 1.8)`."
msgstr ""
"求从顶点:math:`1`到图上点 `(2.9, 1.8)` 的两个最近位置的路线的矩阵成本。"

msgid "``pgr_withPointsDD`` - Proposed"
msgstr "``pgr_withPointsDD`` - 拟议"

msgid ""
"``pgr_withPointsDD`` - Returns the driving **distance** from a starting "
"point."
msgstr "``pgr_withPointsDD`` -返回从起点开始的行驶**距离**。"

msgid ""
"Signature change: ``driving_side`` parameter changed from named optional to "
"unnamed compulsory **driving side**."
msgstr ""

msgid "``pgr_withPointsDD`` (`Single vertex`)"
msgstr ""

msgid "Added ``depth``, ``pred`` and ``start_vid`` column."
msgstr ""

msgid "Added ``depth``, ``pred`` columns."
msgstr ""

msgid "When ``details`` is ``false``:"
msgstr ""

msgid ""
"Only points that are visited are removed, that is, points reached within the "
"distance are included"
msgstr ""

msgid ""
"``pgr_withpointsdd(text,text,bigint,double precision,boolean,character,"
"boolean)``"
msgstr ""

msgid ""
"``pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,"
"boolean,boolean)``"
msgstr ""

msgid ""
"Modify the graph to include points and using Dijkstra algorithm, extracts "
"all the nodes and points that have costs less than or equal to the value "
"``**distance**`` from the starting point. The edges extracted will conform "
"the corresponding spanning tree."
msgstr ""
"修改图以包含点，并使用 Dijkstra 算法，提取成本小于或等于距起点``**距离**``值"
"的所有节点和点。 提取的边将符合相应的生成树。"

msgid ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vid**, **distance**, "
"**driving side**, [**options A**])"
msgstr ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vid**, **distance**, "
"**driving side**, [**options A**])"

msgid ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vids**, **distance**, "
"**driving side**, [**options B**])"
msgstr ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vids**, **distance**, "
"**driving side**, [**options B**])"

msgid "**options A:** ``[directed, details]``"
msgstr "**options A:** ``[directed, details]``"

msgid "**options B:** ``[directed, details, equicost]``"
msgstr "**options B:** ``[directed, details, equicost]``"

msgid ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vid**, **distance**, "
"**driving side**, [**options**])"
msgstr ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vid**, **distance**, "
"**driving side**, [**options**])"

msgid "**options:** ``[directed, details]``"
msgstr "**options:** ``[directed, details]``"

msgid ""
"Right side driving topology, from point :math:`1` within a distance of :math:"
"`3.3` with details."
msgstr ""
"右侧驾驶拓扑，从点 :math:`1` 开始，距离不超过 :math:`3.3`，并提供详细信息。"

msgid ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vids**, **distance**, "
"**driving side**, [**options**])"
msgstr ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vids**, **distance**, "
"**driving side**, [**options**])"

msgid "**options:** ``[directed, details, equicost]``"
msgstr "**options:** ``[directed, details, equicost]``"

msgid ""
"From point :math:`1` and vertex :math:`16` within a distance of :math:`3.3` "
"with ``equicost`` on a directed graph"
msgstr ""
"从点 :math:`1` 和顶点 :math:`16` 出发，在有向图上以 ``equicost`` 模式，在距离"
"不超过 :math:`3.3` 的范围内"

msgid "Negative values represent a point"
msgstr "负值代表一个点"

msgid "**driving side**"
msgstr "**driving side**"

msgid ""
"Value in [``r``, ``R``, ``l``, ``L``, ``b``, ``B``] indicating if the "
"driving side is:"
msgstr "值在 [``r``, ``R``, ``l``, ``L``, ``b``, ``B``] 中表示驾驶的一侧是："

msgid "``r``, ``R`` for right driving side,"
msgstr "``r``, ``R`` 表示右侧驾驶，"

msgid "``l``, ``L`` for left driving side."
msgstr "``l``, ``L`` 表示左侧驾驶。"

msgid "``b``, ``B`` for both."
msgstr "``b``, ``B`` 表示两侧通行（不限制驾驶方向）。"

msgid "Valid values differ for directed and undirected graphs:"
msgstr "有效值因有向图和无向图而异："

msgid "In directed graphs: [``r``, ``R``, ``l``, ``L``]."
msgstr "有向图中：[``r``, ``R``, ``l``, ``L``]。"

msgid "In undirected graphs: [``b``, ``B``]."
msgstr "无向图中：[``b``, ``B``]。"

msgid ""
"Find the driving distance from the two closest locations on the graph of "
"point `(2.9, 1.8)`."
msgstr "求图上点 `(2.9, 1.8)` 距离最近的两个位置的行驶距离。"

msgid ""
"Point :math:`-1` corresponds to the closest edge from point :math:"
"`(2.9,1.8)`."
msgstr "点:math:`-1`对应于距离点 :math:`(2.9,1.8)`最近的边。"

msgid ""
"Point :math:`-2` corresponds to the next close edge from point :math:"
"`(2.9,1.8)`."
msgstr "点:math:`-2`对应于点 :math:`(2.9,1.8)`的下一个闭合边。"

msgid "Driving side does not matter"
msgstr "驾驶侧并不重要"

msgid ""
"From point :math:`1` within a distance of :math:`3.3`, does not matter "
"driving side, with details."
msgstr ""
"从点 :math:`1` 开始，在距离不超过 :math:`3.3` 的范围内，无论驾驶方向如何，提"
"供详细信息。"

msgid ":doc:`pgr_alphaShape`"
msgstr ":doc:`pgr_alphaShape`"

msgid "pgr_withPointsKSP - Proposed"
msgstr "pgr_withPointsKSP -拟议"

msgid ""
"``pgr_withPointsKSP`` — Yen's algorithm for K shortest paths using Dijkstra."
msgstr "``pgr_withPointsKSP`` — Yen 使用 Dijkstra 计算 K 最短路径的算法。"

msgid "Standarizing output columns to |nksp-result|"
msgstr "标准化输出列为 |nksp-result|"

msgid "``pgr_withPointsKSP`` (One to One)"
msgstr "``pgr_withPointsKSP`` (一对一)"

msgid "``pgr_withPointsKSP`` (One to Many)"
msgstr "``pgr_withPointsKSP`` (一对多)"

msgid "``pgr_withPointsKSP`` (Many to One)"
msgstr "``pgr_withPointsKSP`` (多对一)"

msgid "``pgr_withPointsKSP`` (Many to Many)"
msgstr "``pgr_withPointsKSP`` (多对多)"

msgid "``pgr_withPointsKSP`` (Combinations)"
msgstr "``pgr_withPointsKSP`` (组合)"

msgid "Deprecated signature:"
msgstr "已弃用的签名："

msgid ""
"``pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,"
"boolean)``"
msgstr ""
"``pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,"
"boolean)``"

msgid ""
"Modifies the graph to include the points defined in the `Points SQL`_ and "
"using Yen algorithm, finds the :math:`K` shortest paths."
msgstr ""
"修改图以包括`Points SQL`_ 中定义的点并使用 Yen 算法查找 :math:`K`最短路径。"

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, "
"**K**, **driving_side**, [**options**])"
msgstr ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, "
"**K**, **driving_side**, [**options**])"

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, "
"**K**, **driving_side**, [**options**])"
msgstr ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, "
"**K**, **driving_side**, [**options**])"

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, "
"**K**, **driving_side**, [**options**])"
msgstr ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, "
"**K**, **driving_side**, [**options**])"

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**, "
"**K**, **driving_side**, [**options**])"
msgstr ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**, "
"**K**, **driving_side**, [**options**])"

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, **K**, "
"**driving_side**, [**options**])"
msgstr ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, **K**, "
"**driving_side**, [**options**])"

msgid "**options:**  ``[directed, heap_paths, details]``"
msgstr "**options:**  ``[directed, heap_paths, details]``"

msgid ""
"Get 2 paths from Point :math:`1` to point :math:`2` on a directed graph with "
"**left** side driving."
msgstr ""
"在具有**左侧**驾驶的有向图上，从点 :math:`1` 到点 :math:`2` 获取两条路径。"

msgid "For a directed graph."
msgstr "有向图。"

msgid "No details are given about distance of other points of the query."
msgstr "没有给出有关查询的其他点的距离的详细信息。"

msgid "No heap paths are returned."
msgstr "不返回堆路径。"

msgid ""
"Get 2 paths from point :math:`1` to point :math:`3` and vertex :math:`7` on "
"an undirected graph"
msgstr "在无向图上从点 :math:`1` 到点 :math:`3` 和顶点 :math:`7` 获取两条路径"

msgid ""
"Get a path from point :math:`1` and vertex :math:`6` to point :math:`3` on a "
"**directed** graph with **right** side driving and **details** set to "
"**True**"
msgstr ""
"在具有**右侧**驾驶的**有向**图上，从点 :math:`1` 和顶点 :math:`6` 到点 :math:"
"`3` 获取一条路径，且**details** 设置为 **True**"

msgid ""
"Get a path from point :math:`1` and vertex :math:`6` to point :math:`3` and "
"vertex :math:`1` on a **directed** graph with **left** side driving and "
"**heap_paths** set to **True**"
msgstr ""
"在具有**左侧**驾驶的**有向**图上，从点 :math:`1` 和顶点 :math:`6` 到点 :math:"
"`3` 和顶点 :math:`1` 获取一条路径，且**heap_paths** 设置为 **True**"

msgid "Using a combinations table on an **directed** graph"
msgstr "在**有向**图上使用组合表"

msgid "`Points SQL`_ query as described."
msgstr "按照描述的方式执行 `Points SQL`_ 查询。"

msgid "Number of required paths"
msgstr "所需路径的数量"

msgid "**driving_side**"
msgstr "**driving_side**"

msgid "**CHAR**"
msgstr "**CHAR**"

msgid "[``r``, ``R``] for right driving side (for directed graph only)"
msgstr "[``r``, ``R``] 表示右侧驾驶（仅适用于有向图）"

msgid "[``l``, ``L``] for left driving side (for directed graph only)"
msgstr "[``l``, ``L``]表示左侧驾驶（仅适用有向图）"

msgid "[``b``, ``B``] for both (only for undirected graph)"
msgstr "[``b``, ``B``] 表示两侧通行（仅适用于无向图）"

msgid "withPointsKSP optional parameters"
msgstr "withPointsKSP可选参数"

msgid ""
"Get :math:`2` paths using left side driving topology, from vertex :math:`1` "
"to the closest location on the graph of point `(2.9, 1.8)`."
msgstr ""
"使用左侧驾驶拓扑，从顶点 :math:`1` 到离点 `(2.9, 1.8)` 最近的位置获取 :math:"
"`2` 条路径。"

msgid "Left driving side"
msgstr "左驾驶侧"

msgid ""
"Get :math:`2` paths using left side driving topology, from point :math:`1` "
"to point :math:`3` with details."
msgstr ""
"使用左侧驾驶拓扑，从点 :math:`1` 到点 :math:`3` 获取 :math:`2` 条路径，并包含"
"详细信息。"

msgid "Right driving side"
msgstr "右驾驶侧"

msgid ""
"Get :math:`2` paths using right side driving topology from, point :math:`1` "
"to point :math:`2` with heap paths and details."
msgstr ""
"使用右侧驾驶拓扑，从点 :math:`1` 到点 :math:`2` 获取 :math:`2` 条路径，同时使"
"用堆路径（heap paths）并包含详细信息。"

msgid "``pgr_withPointsVia`` - Proposed"
msgstr "``pgr_withPointsVia`` -拟议"

msgid ""
"``pgr_withPointsVia`` - Route that goes through a list of vertices and/or "
"points."
msgstr "``pgr_withPointsVia`` - 经过一系列顶点和/或点的路线。"

msgid "New **proposed** function ``pgr_withPointsVia`` (`One Via`_)"
msgstr "新 **拟议**的函数 ``pgr_withPointsVia`` (`One Via`_)"

msgid ""
"Given a graph, a set of points on the graphs edges and a list of vertices, "
"this function is equivalent to finding the shortest path between :math:"
"`vertex_i` and :math:`vertex_{i+1}` (where :math:`vertex` can be a vertex or "
"a point on the graph) for all :math:`i < size\\_of(via\\;vertices)`."
msgstr ""
"给定一个图、图上边缘的一组点以及一个顶点列表，此函数相当于找到 :math:"
"`vertex_i` 和 :math:`vertex_{i+1}` 之间的最短路径（其中 :math:`vertex` 可以是"
"一个顶点或图上的一个点），对于所有的 :math:`i`，满足 :math:`i < size\\_of(via"
"\\;vertices)`。"

msgid ""
"pgr_withPointsVia(`Edges SQL`_, `Points SQL`_, **via vertices**, "
"[**options**])"
msgstr ""
"pgr_withPointsVia(`Edges SQL`_, `Points SQL`_, **via vertices**, "
"[**options**])"

msgid ""
"Find the route that visits the vertices :math:`\\{ -6, 15, -1\\}` in that "
"order on a **directed** graph."
msgstr "在**有向**图上按顺序访问顶点 :math:`\\{ -6, 15, -1\\}` 的路线。"

msgid "Use :doc:`pgr_findCloseEdges` in the `Points SQL`_"
msgstr "在 `Points SQL`_ 中使用 :doc:`pgr_findCloseEdges` 函数"

msgid ""
"All this examples are about the route that visits the vertices :math:`\\{-1, "
"7, -3, 16, 15\\}` in that order on a **directed** graph."
msgstr ""
"所有这些示例都是关于在**有向**图上按顺序访问顶点 :math:`\\{-1, 7, -3, 16, "
"15\\}` 的路线。"

msgid "Prim - Family of functions"
msgstr "Prim - 函数族"

msgid ""
"The prim algorithm was developed in 1930 by Czech mathematician Vojtěch "
"Jarník. It is a greedy algorithm that finds a minimum spanning tree for a "
"weighted undirected graph. This means it finds a subset of the edges that "
"forms a tree that includes every vertex, where the total weight of all the "
"edges in the tree is minimized. The algorithm operates by building this tree "
"one vertex at a time, from an arbitrary starting vertex, at each step adding "
"the cheapest possible connection from the tree to another vertex."
msgstr ""
"prim 算法由捷克数学家 Vojtěch Jarník 于 1930 年开发。 它是一种贪心算法，为带"
"权无向图找到最小生成树。 这意味着它找到形成包含每个顶点的树的边的子集，其中树"
"中所有边的总权重最小化。 该算法的运行方式是从任意起始顶点一次构建一个顶点，在"
"每一步添加从树到另一个顶点的最便宜的可能连接。"

msgid ""
"This algorithms find the minimum spanning forest in a possibly disconnected "
"graph; in contrast, the most basic form of Prim's algorithm only finds "
"minimum spanning trees in connected graphs. However, running Prim's "
"algorithm separately for each connected component of the graph, then it is "
"called minimum spanning forest."
msgstr ""
"该算法在可能不连通的图中找到最小生成森林； 相反，Prim 算法的最基本形式只能在"
"连通图中找到最小生成树。 然而，对图的每个连通分量分别运行Prim算法，则称为最小"
"生成森林。"

msgid ""
"From boost Graph: \"The algorithm as implemented in Boost.Graph does not "
"produce correct results on graphs with parallel edges.\""
msgstr ""
"来自 boost Graph：“Boost.Graph 中实现的算法不会在具有平行边的图上产生正确的结"
"果。”"

msgid ""
"Boost: `Prim's algorithm <https://www.boost.org/libs/graph/doc/"
"prim_minimum_spanning_tree.html>`__"
msgstr ""
"Boost: `Prim算法 <https://www.boost.org/libs/graph/doc/"
"prim_minimum_spanning_tree.html>`__"

msgid ""
"Wikipedia: `Prim's algorithm <https://en.wikipedia.org/wiki/Prim"
"%27s_algorithm>`__"
msgstr ""
"维基百科: `Prim算法 <https://en.wikipedia.org/wiki/Prim%27s_algorithm>`__"

msgid "Proposed Functions"
msgstr "拟议的功能"

msgid ":doc:`pgr_withPoints` - Route from/to points anywhere on the graph."
msgstr ":doc:`pgr_withPoints` - 从/到图表上任意点的路线。"

msgid ":doc:`pgr_withPointsCost` - Costs of the shortest paths."
msgstr ":doc:`pgr_withPointsCost` - 最短路径的成本。"

msgid ":doc:`pgr_withPointsCostMatrix` - Costs of the shortest paths."
msgstr ":doc:`pgr_withPointsCostMatrix` - 最短路径的成本。"

msgid ":doc:`pgr_withPointsKSP` - K shortest paths."
msgstr ":doc:`pgr_withPointsKSP` -K 最短路径。"

msgid ":doc:`pgr_withPointsDD` - Driving distance."
msgstr ":doc:`pgr_withPointsDD` -行驶距离。"

msgid ":doc:`pgr_withPointsVia` - Via routing"
msgstr ":doc:`pgr_withPointsVia` -通过路由"

msgid "These proposed functions do not modify the database."
msgstr "这些拟议的功能不会修改数据库。"

msgid ""
":doc:`pgr_degree` - Returns a set of vertices and corresponding count of "
"incidet edges to the vertex."
msgstr ":doc:`pgr_degree` -返回一组顶点以及该顶点对应的关联边数。"

msgid ""
":doc:`pgr_extractVertices` - Extracts vertex information based on the edge "
"table information."
msgstr ":doc:`pgr_extractVertices` - 根据边表信息提取顶点信息。"

msgid ":doc:`pgr_withPointsVia`"
msgstr ":doc:`pgr_withPointsVia`"

msgid ":doc:`pgr_trspVia`"
msgstr ":doc:`pgr_trspVia`"

msgid ":doc:`pgr_trspVia_withPoints`"
msgstr ":doc:`pgr_trspVia_withPoints`"

msgid ":doc:`withPoints-family` - Functions based on Dijkstra algorithm."
msgstr ":doc:`withPoints-family` -基于 Dijkstra 算法的函数。"

msgid "From the :doc:`TRSP-family`:"
msgstr "来自 :doc:`TRSP-family`:"

msgid "Utilities"
msgstr "实用程序"

msgid ":doc:`pgr_findCloseEdges`"
msgstr ":doc:`pgr_findCloseEdges`"

msgid "Reference"
msgstr "参考"

msgid "Release Notes"
msgstr "发行说明"

msgid ""
"To see the full list of changes check the list of `Git commits <https://"
"github.com/pgRouting/pgrouting/commits>`_ on Github."
msgstr ""
"要查看完整的更改列表，请检查 Github 上的 `Git提交列表 <https://github.com/"
"pgRouting/pgrouting/commits>`_。"

msgid "pgRouting 3.6.0 Release Notes"
msgstr "pgRouting 3.6.0 发布说"

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.6.0 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.6.0%22>`_"
msgstr ""
"要查看此版本关闭的所有问题和拉取请求，请访问 `Git 3.6.0 里程碑的已关闭问题和"
"拉取请求 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C"
"%93&q=milestone%3A%22Release%203.6.0%22>`_"

msgid "Official functions changes"
msgstr "官方功能变更"

msgid ""
"`#2516 <https://github.com/pgRouting/pgrouting/pull/2516>`__ Standarize "
"output pgr_aStar"
msgstr ""
"`#2516 <https://github.com/pgRouting/pgrouting/pull/2516>`__标准化输出"
"pgr_aStar"

msgid ""
"``pgr_aStar`` (`One to One`) added ``start_vid`` and ``end_vid`` columns."
msgstr ""

msgid "``pgr_aStar`` (`One to Many`) added ``end_vid`` column."
msgstr ""

msgid "``pgr_aStar`` (`Many to One`) added ``start_vid`` column."
msgstr ""

msgid ""
"`#2523 <https://github.com/pgRouting/pgrouting/pull/2523>`__ Standarize "
"output pgr_bdAstar"
msgstr ""

msgid ""
"``pgr_bdAstar`` (`One to One`) added ``start_vid`` and ``end_vid`` columns."
msgstr ""

msgid "``pgr_bdAstar`` (`One to Many`) added ``end_vid`` column."
msgstr ""

msgid "``pgr_bdAstar`` (`Many to One`) added ``start_vid`` column."
msgstr ""

msgid ""
"`#2547 <https://github.com/pgRouting/pgrouting/pull/2547>`__ Standarize "
"output and modifying signature pgr_KSP"
msgstr ""

msgid ""
"`#2548 <https://github.com/pgRouting/pgrouting/pull/2548>`__ Standarize "
"output pgr_drivingdistance"
msgstr ""

msgid "Proposed functions changes"
msgstr ""

msgid ""
"`#2544 <https://github.com/pgRouting/pgrouting/pull/2544>`__ Standarize "
"output and modifying signature pgr_withPointsDD"
msgstr ""

msgid ""
"`#2546 <https://github.com/pgRouting/pgrouting/pull/2546>`__ Standarize "
"output and modifying signature pgr_withPointsKSP"
msgstr ""

msgid "C/C++ code enhancements"
msgstr ""

msgid ""
"`#2504 <https://github.com/pgRouting/pgrouting/pull/2504>`__ To C++ pg data "
"get, fetch and check."
msgstr ""

msgid "Stopping support for compilation with MSVC."
msgstr ""

msgid ""
"`#2505 <https://github.com/pgRouting/pgrouting/pull/2505>`__ Using namespace."
msgstr ""

msgid ""
"`#2512 <https://github.com/pgRouting/pgrouting/pull/2512>`__ [Dijkstra] "
"Removing duplicate code on Dijkstra."
msgstr ""

msgid ""
"`#2517 <https://github.com/pgRouting/pgrouting/pull/2517>`__ Astar code "
"simplification."
msgstr ""

msgid ""
"`#2521 <https://github.com/pgRouting/pgrouting/pull/2521>`__ Dijkstra code "
"simplification."
msgstr ""

msgid ""
"`#2522 <https://github.com/pgRouting/pgrouting/pull/2522>`__ bdAstar code "
"simplification."
msgstr ""

msgid "Documentation"
msgstr ""

msgid ""
"`#2490 <https://github.com/pgRouting/pgrouting/pull/2490>`__ Automatic page "
"history links."
msgstr ""

msgid "..rubric:: SQL standarization"
msgstr ""

msgid ""
"`#2555 <https://github.com/pgRouting/pgrouting/pull/2555>`__ standarize "
"deprecated messages"
msgstr ""

msgid ""
"On new internal function: do not use named parameters and default parameters."
msgstr ""

msgid "pgRouting 3.5.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.5.1 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.5.1%22>`_"
msgstr ""

msgid "Documentation fixes"
msgstr ""

msgid "Changes on the documentation to the following:"
msgstr ""

msgid "pgr_degree"
msgstr ""

msgid "pgr_dijkstra"
msgstr ""

msgid "pgr_ksp"
msgstr ""

msgid "Automatic page history links"
msgstr ""

msgid "using bootstrap_version 2 because 3+ does not do dropdowns"
msgstr ""

msgid "Issue fixes"
msgstr ""

msgid ""
"`#2565 <https://github.com/pgRouting/pgrouting/issues/2565>`__ "
"pgr_pgr_lengauerTarjanDominatorTree triggers an assertion"
msgstr ""

msgid "SQL enhancements"
msgstr ""

msgid ""
"`#2561 <https://github.com/pgRouting/pgrouting/issues/2561>`__ Not use "
"wildcards on SQL"
msgstr ""

msgid "pgtap tests"
msgstr ""

msgid ""
"`#2559 <https://github.com/pgRouting/pgrouting/issues/2559>`__ pgtap test "
"using sampledata"
msgstr ""

msgid "Build fixes"
msgstr ""

msgid "Fix winnie build"
msgstr ""

msgid "Code fixes"
msgstr ""

msgid "Fix clang warnings"
msgstr ""

msgid "Grouping headers of postgres readers"
msgstr ""

msgid "pgRouting 3.5.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.5.0 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.5.0%22>`_"
msgstr ""

msgid "Dijkstra"
msgstr ""

msgid ""
"``pgr_dijkstra`` (`One to One`) added ``start_vid`` and ``end_vid`` columns."
msgstr ""

msgid "``pgr_dijkstra`` (`One to Many`) added ``end_vid`` column."
msgstr ""

msgid "``pgr_dijkstra`` (`Many to One`) added ``start_vid`` column."
msgstr ""

msgid "pgRouting 3.4.2 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.4.2 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.4.2%22>`_"
msgstr ""

msgid ""
"`#2394 <https://github.com/pgRouting/pgrouting/issues/2394>`__: pgr_bdAstar "
"accumulates heuristic cost in visited node cost."
msgstr ""

msgid ""
"`#2427 <https://github.com/pgRouting/pgrouting/issues/2427>`__: "
"pgr_createVerticesTable & pgr_createTopology, variable should be of type "
"Record."
msgstr ""

msgid "pgRouting 3.4.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.4.1 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.4.1%22>`_"
msgstr ""

msgid ""
"`#2401 <https://github.com/pgRouting/pgrouting/issues/2401>`__: pgRouting "
"3.4.0 do not build docs when sphinx is too low or missing"
msgstr ""

msgid ""
"`#2398 <https://github.com/pgRouting/pgrouting/issues/2398>`__: v3.4.0 does "
"not upgrade from 3.3.3"
msgstr ""

msgid "pgRouting 3.4.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.4.0 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.4.0%22>`_"
msgstr ""

msgid ""
"`#1891 <https://github.com/pgRouting/pgrouting/issues/1891>`__: pgr_ksp "
"doesn't give all correct shortest path"
msgstr ""

msgid "New proposed functions"
msgstr ""

msgid "With points"
msgstr ""

msgid "``pgr_withPointsVia`` (One Via)"
msgstr ""

msgid "Turn Restrictions"
msgstr ""

msgid "Via with turn restrictions"
msgstr ""

msgid "``pgr_trspVia`` (One Via)"
msgstr ""

msgid "``pgr_trspVia_withPoints`` (One Via)"
msgstr ""

msgid "``pgr_trsp``"
msgstr ""

msgid "``pgr_trsp`` (One to One)"
msgstr ""

msgid "``pgr_trsp`` (One to Many)"
msgstr ""

msgid "``pgr_trsp`` (Many to One)"
msgstr ""

msgid "``pgr_trsp`` (Many to Many)"
msgstr ""

msgid "``pgr_trsp`` (Combinations)"
msgstr ""

msgid "``pgr_trsp_withPoints``"
msgstr ""

msgid "``pgr_trsp_withPoints`` (One to One)"
msgstr ""

msgid "``pgr_trsp_withPoints`` (One to Many)"
msgstr ""

msgid "``pgr_trsp_withPoints`` (Many to One)"
msgstr ""

msgid "``pgr_trsp_withPoints`` (Many to Many)"
msgstr ""

msgid "``pgr_trsp_withPoints`` (Combinations)"
msgstr ""

msgid "Topology"
msgstr ""

msgid "``pgr_degree``"
msgstr ""

msgid "``pgr_findCloseEdges`` (One point)"
msgstr ""

msgid "``pgr_findCloseEdges`` (Many points)"
msgstr ""

msgid "New experimental functions"
msgstr ""

msgid "Ordering"
msgstr ""

msgid "``pgr_cuthillMckeeOrdering``"
msgstr ""

msgid "Unclassified"
msgstr ""

msgid "Flow functions"
msgstr ""

msgid "``pgr_maxCardinalityMatch(text)``"
msgstr ""

msgid "Deprecating ``pgr_maxCardinalityMatch(text,boolean)``"
msgstr ""

msgid "Deprecated functions"
msgstr ""

msgid "``pgr_trsp(text,integer,float8,integer,float8,boolean,boolean,text)``"
msgstr ""

msgid "``pgr_trspViaEdges(text,integer[],float[],boolean,boolean,text)``"
msgstr ""

msgid "pgRouting 3.3.5 Release Notes"
msgstr ""

msgid "pgRouting 3.3.4 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.3.4 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.3.4%22>`_"
msgstr ""

msgid ""
"`#2400 <https://github.com/pgRouting/pgrouting/issues/2400>`__: pgRouting "
"3.3.3 does not build in focal"
msgstr ""

msgid "pgRouting 3.3.3 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.3.3 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.3.3%22>`_"
msgstr ""

msgid ""
"Ignoring optional boolean parameter, as the algorithm works only for "
"undirected graphs."
msgstr ""

msgid "pgRouting 3.3.2 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.3.2 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.3.2%22>`_"
msgstr ""

msgid "Revised documentation"
msgstr ""

msgid "Simplifying table names and table columns, for example:"
msgstr ""

msgid "``edges`` instead of ``edge_table``"
msgstr ""

msgid "Removing unused columns ``category_id`` and ``reverse_category_id``."
msgstr ""

msgid "``combinations`` instead of ``combinations_table``"
msgstr ""

msgid "Using PostGIS standard for geometry column."
msgstr ""

msgid "``geom`` instead of ``the_geom``"
msgstr ""

msgid "Avoiding usage of functions that modify indexes, columns etc on tables."
msgstr ""

msgid "Using ``pgr_extractVertices`` to create a routing topology"
msgstr ""

msgid "Restructure of the pgRouting concepts page."
msgstr ""

msgid ""
"`#2276 <https://github.com/pgRouting/pgrouting/issues/2276>`__: "
"edgeDisjointPaths issues with start_vid and combinations"
msgstr ""

msgid ""
"`#2312 <https://github.com/pgRouting/pgrouting/issues/2312>`__: "
"pgr_extractVertices error when target is not BIGINT"
msgstr ""

msgid ""
"`#2357 <https://github.com/pgRouting/pgrouting/issues/2357>`__: Apply clang-"
"tidy performance-*"
msgstr ""

msgid "pgRouting 3.3.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.3.1 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.3.1%22>`_ on Github."
msgstr ""

msgid ""
"`#2216 <https://github.com/pgRouting/pgrouting/issues/2216>`__: Warnings "
"when using clang"
msgstr ""

msgid ""
"`#2266 <https://github.com/pgRouting/pgrouting/issues/2266>`__: Error "
"processing restrictions"
msgstr ""

msgid "pgRouting 3.3.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.3.0 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.3.0%22>`_ on Github."
msgstr ""

msgid ""
"`#2057 <https://github.com/pgRouting/pgrouting/issues/2057>`__: trspViaEdges "
"columns in different order"
msgstr ""

msgid ""
"`#2087 <https://github.com/pgRouting/pgrouting/issues/2087>`__: "
"pgr_extractVertices to proposed"
msgstr ""

msgid ""
"`#2201 <https://github.com/pgRouting/pgrouting/issues/2201>`__: "
"pgr_depthFirstSearch to proposed"
msgstr ""

msgid ""
"`#2202 <https://github.com/pgRouting/pgrouting/issues/2202>`__: "
"pgr_sequentialVertexColoring to proposed"
msgstr ""

msgid ""
"`#2203 <https://github.com/pgRouting/pgrouting/issues/2203>`__: "
"pgr_dijkstraNear and pgr_dijkstraNearCost to proposed"
msgstr ""

msgid "Coloring"
msgstr ""

msgid "pgr_edgeColoring"
msgstr ""

msgid "Experimental promoted to Proposed"
msgstr ""

msgid "pgr_dijkstraNear"
msgstr ""

msgid "pgr_dijkstraNear(Combinations)"
msgstr ""

msgid "pgr_dijkstraNear(Many to Many)"
msgstr ""

msgid "pgr_dijkstraNear(Many to One)"
msgstr ""

msgid "pgr_dijkstraNear(One to Many)"
msgstr ""

msgid "pgr_dijkstraNearCost"
msgstr ""

msgid "pgr_dijkstraNearCost(Combinations)"
msgstr ""

msgid "pgr_dijkstraNearCost(Many to Many)"
msgstr ""

msgid "pgr_dijkstraNearCost(Many to One)"
msgstr ""

msgid "pgr_dijkstraNearCost(One to Many)"
msgstr ""

msgid "pgr_sequentialVertexColoring"
msgstr ""

msgid "pgr_extractVertices"
msgstr ""

msgid "Traversal"
msgstr ""

msgid "pgr_depthFirstSearch(Multiple vertices)"
msgstr ""

msgid "pgr_depthFirstSearch(Single vertex)"
msgstr ""

msgid "pgRouting 3.2.2 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.2.2 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.2.2%22>`_ on Github."
msgstr ""

msgid "Issues"
msgstr ""

msgid ""
"`#2093 <https://github.com/pgRouting/pgrouting/issues/2093>`__: Compilation "
"on Visual Studio"
msgstr ""

msgid ""
"`#2189 <https://github.com/pgRouting/pgrouting/issues/2189>`__: Build error "
"on RHEL 7"
msgstr ""

msgid "pgRouting 3.2.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.2.1 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.2.1%22>`_ on Github."
msgstr ""

msgid ""
"`#1883 <https://github.com/pgRouting/pgrouting/issues/1883>`__: "
"pgr_TSPEuclidean crashes connection on Windows"
msgstr ""

msgid "The solution is to use Boost::graph::metric_tsp_approx"
msgstr ""

msgid ""
"To not break user's code the optional parameters related to the TSP "
"Annaeling are ignored"
msgstr ""

msgid "The function with the annaeling optional parameters is deprecated"
msgstr ""

msgid "pgRouting 3.2.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.2.0 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.2.0%22>`_ on Github."
msgstr ""

msgid "Build"
msgstr ""

msgid ""
"`#1850 <https://github.com/pgRouting/pgrouting/issues/1850>`__: Change Boost "
"min version to 1.56"
msgstr ""

msgid "Removing support for Boost v1.53, v1.54 & v1.55"
msgstr ""

msgid "pgr_bellmanFord(Combinations)"
msgstr ""

msgid "pgr_binaryBreadthFirstSearch(Combinations)"
msgstr ""

msgid "pgr_bipartite"
msgstr ""

msgid "pgr_depthFirstSearch"
msgstr ""

msgid "Dijkstra Near"
msgstr ""

msgid "pgr_edwardMoore(Combinations)"
msgstr ""

msgid "pgr_isPlanar"
msgstr ""

msgid "pgr_lengauerTarjanDominatorTree"
msgstr ""

msgid "pgr_makeConnected"
msgstr ""

msgid "pgr_maxFlowMinCost(Combinations)"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(Combinations)"
msgstr ""

msgid "Astar"
msgstr ""

msgid "pgr_aStar(Combinations)"
msgstr ""

msgid "pgr_aStarCost(Combinations)"
msgstr ""

msgid "Bidirectional Astar"
msgstr ""

msgid "pgr_bdAstar(Combinations)"
msgstr ""

msgid "pgr_bdAstarCost(Combinations)"
msgstr ""

msgid "Bidirectional Dijkstra"
msgstr ""

msgid "pgr_bdDijkstra(Combinations)"
msgstr ""

msgid "pgr_bdDijkstraCost(Combinations)"
msgstr ""

msgid "pgr_boykovKolmogorov(Combinations)"
msgstr ""

msgid "pgr_edmondsKarp(Combinations)"
msgstr ""

msgid "pgr_maxFlow(Combinations)"
msgstr ""

msgid "pgr_pushRelabel(Combinations)"
msgstr ""

msgid "pgRouting 3.1.4 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.1.4 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.1.4%22>`_ on Github."
msgstr ""

msgid "Issues fixes"
msgstr ""

msgid "pgRouting 3.1.3 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.1.3 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.1.3%22>`_ on Github."
msgstr ""

msgid ""
"`#1825 <https://github.com/pgRouting/pgrouting/issues/1825>`__: Boost "
"versions are not honored"
msgstr ""

msgid ""
"`#1849 <https://github.com/pgRouting/pgrouting/issues/1849>`__: Boost 1.75.0 "
"geometry \"point_xy.hpp\" build error on macOS environment"
msgstr ""

msgid ""
"`#1861 <https://github.com/pgRouting/pgrouting/issues/1861>`__: vrp "
"functions crash server"
msgstr ""

msgid "pgRouting 3.1.2 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.1.2 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.1.2%22>`_ on Github."
msgstr ""

msgid ""
"`#1304 <https://github.com/pgRouting/pgrouting/issues/1304>`__: FreeBSD 12 "
"64-bit crashes on pgr_vrOneDepot tests Experimental Function"
msgstr ""

msgid ""
"`#1356 <https://github.com/pgRouting/pgrouting/issues/1356>`__: tools/"
"testers/pg_prove_tests.sh fails when PostgreSQL port is not passed"
msgstr ""

msgid ""
"`#1725 <https://github.com/pgRouting/pgrouting/issues/1725>`__: Server crash "
"on pgr_pickDeliver and pgr_vrpOneDepot on openbsd"
msgstr ""

msgid ""
"`#1760 <https://github.com/pgRouting/pgrouting/issues/1760>`__: TSP server "
"crash on ubuntu 20.04 #1760"
msgstr ""

msgid ""
"`#1770 <https://github.com/pgRouting/pgrouting/issues/1770>`__: Remove "
"warnings when using clang compiler"
msgstr ""

msgid "pgRouting 3.1.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.1.1 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.1.1%22>`_ on Github."
msgstr ""

msgid ""
"`#1733 <https://github.com/pgRouting/pgrouting/issues/1733>`__: pgr_bdAstar "
"fails when source or target vertex does not exist in the graph"
msgstr ""

msgid ""
"`#1647 <https://github.com/pgRouting/pgrouting/issues/1647>`__: Linear "
"Contraction contracts self loops"
msgstr ""

msgid ""
"`#1640 <https://github.com/pgRouting/pgrouting/issues/1640>`__: "
"pgr_withPoints fails when points_sql is empty"
msgstr ""

msgid ""
"`#1616 <https://github.com/pgRouting/pgrouting/issues/1616>`__: Path "
"evaluation on C++ not updated before the results go back to C"
msgstr ""

msgid ""
"`#1300 <https://github.com/pgRouting/pgrouting/issues/1300>`__: "
"pgr_chinesePostman crash on test data"
msgstr ""

msgid "pgRouting 3.1.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.1.0 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.1.0%22>`_ on Github."
msgstr ""

msgid "pgr_dijkstra(combinations)"
msgstr ""

msgid "pgr_dijkstraCost(combinations)"
msgstr ""

msgid "Build changes"
msgstr ""

msgid "Minimal requirement for Sphinx: version 1.8"
msgstr ""

msgid "pgRouting 3.0.6 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.0.6 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.0.6%22>`_ on Github."
msgstr ""

msgid "pgRouting 3.0.5 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.0.5 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.0.5%22>`_ on Github."
msgstr ""

msgid "Backport issues fixes"
msgstr ""

msgid "pgRouting 3.0.4 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.0.4 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.0.4%22>`_ on Github."
msgstr ""

msgid "pgRouting 3.0.3 Release Notes"
msgstr ""

msgid "pgRouting 3.0.2 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.0.2 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.0.2%22>`_ on Github."
msgstr ""

msgid ""
"`#1378 <https://github.com/pgRouting/pgrouting/issues/1378>`__: Visual "
"Studio build failing"
msgstr ""

msgid "pgRouting 3.0.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.0.1 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.0.1%22>`_ on Github."
msgstr ""

msgid ""
"`#232 <https://github.com/pgRouting/pgrouting/issues/232>`__:  Honor client "
"cancel requests in C /C++ code"
msgstr ""

msgid "pgRouting 3.0.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.0.0 <https://github.com/pgRouting/pgrouting/issues?utf8="
"%E2%9C%93&q=milestone%3A%22Release%203.0.0%22>`_ on Github."
msgstr ""

msgid "Fixed Issues"
msgstr ""

msgid ""
"`#1153 <https://github.com/pgRouting/pgrouting/issues/1153>`__: Renamed "
"pgr_eucledianTSP to pgr_TSPeuclidean"
msgstr ""

msgid ""
"`#1188 <https://github.com/pgRouting/pgrouting/issues/1188>`__: Removed CGAL "
"dependency"
msgstr ""

msgid ""
"`#1002 <https://github.com/pgRouting/pgrouting/issues/1002>`__: Fixed "
"contraction issues:"
msgstr ""

msgid ""
"`#1004 <https://github.com/pgRouting/pgrouting/issues/1004>`__: Contracts "
"when forbidden vertices do not belong to graph"
msgstr ""

msgid ""
"`#1005 <https://github.com/pgRouting/pgrouting/issues/1005>`__: Intermideate "
"results eliminated"
msgstr ""

msgid ""
"`#1006 <https://github.com/pgRouting/pgrouting/issues/1006>`__: No loss of "
"information"
msgstr ""

msgid "New functions"
msgstr ""

msgid "Kruskal family"
msgstr ""

msgid "pgr_kruskal"
msgstr ""

msgid "pgr_kruskalBFS"
msgstr ""

msgid "pgr_kruskalDD"
msgstr ""

msgid "pgr_kruskalDFS"
msgstr ""

msgid "Prim family"
msgstr ""

msgid "pgr_prim"
msgstr ""

msgid "pgr_primDD"
msgstr ""

msgid "pgr_primDFS"
msgstr ""

msgid "pgr_primBFS"
msgstr ""

msgid "Proposed moved to official on pgRouting"
msgstr ""

msgid "aStar Family"
msgstr ""

msgid "pgr_aStar(one to many)"
msgstr ""

msgid "pgr_aStar(many to one)"
msgstr ""

msgid "pgr_aStar(many to many)"
msgstr ""

msgid "pgr_aStarCost(one to one)"
msgstr ""

msgid "pgr_aStarCost(one to many)"
msgstr ""

msgid "pgr_aStarCost(many to one)"
msgstr ""

msgid "pgr_aStarCost(many to many)"
msgstr ""

msgid "pgr_aStarCostMatrix(one to one)"
msgstr ""

msgid "pgr_aStarCostMatrix(one to many)"
msgstr ""

msgid "pgr_aStarCostMatrix(many to one)"
msgstr ""

msgid "pgr_aStarCostMatrix(many to many)"
msgstr ""

msgid "bdAstar Family"
msgstr ""

msgid "pgr_bdAstar(one to many)"
msgstr ""

msgid "pgr_bdAstar(many to one)"
msgstr ""

msgid "pgr_bdAstar(many to many)"
msgstr ""

msgid "pgr_bdAstarCost(one to one)"
msgstr ""

msgid "pgr_bdAstarCost(one to many)"
msgstr ""

msgid "pgr_bdAstarCost(many to one)"
msgstr ""

msgid "pgr_bdAstarCost(many to many)"
msgstr ""

msgid "pgr_bdAstarCostMatrix(one to one)"
msgstr ""

msgid "pgr_bdAstarCostMatrix(one to many)"
msgstr ""

msgid "pgr_bdAstarCostMatrix(many to one)"
msgstr ""

msgid "pgr_bdAstarCostMatrix(many to many)"
msgstr ""

msgid "bdDijkstra Family"
msgstr ""

msgid "pgr_bdDijkstra(one to many)"
msgstr ""

msgid "pgr_bdDijkstra(many to one)"
msgstr ""

msgid "pgr_bdDijkstra(many to many)"
msgstr ""

msgid "pgr_bdDijkstraCost(one to one)"
msgstr ""

msgid "pgr_bdDijkstraCost(one to many)"
msgstr ""

msgid "pgr_bdDijkstraCost(many to one)"
msgstr ""

msgid "pgr_bdDijkstraCost(many to many)"
msgstr ""

msgid "pgr_bdDijkstraCostMatrix(one to one)"
msgstr ""

msgid "pgr_bdDijkstraCostMatrix(one to many)"
msgstr ""

msgid "pgr_bdDijkstraCostMatrix(many to one)"
msgstr ""

msgid "pgr_bdDijkstraCostMatrix(many to many)"
msgstr ""

msgid "Flow Family"
msgstr ""

msgid "pgr_pushRelabel(one to one)"
msgstr ""

msgid "pgr_pushRelabel(one to many)"
msgstr ""

msgid "pgr_pushRelabel(many to one)"
msgstr ""

msgid "pgr_pushRelabel(many to many)"
msgstr ""

msgid "pgr_edmondsKarp(one to one)"
msgstr ""

msgid "pgr_edmondsKarp(one to many)"
msgstr ""

msgid "pgr_edmondsKarp(many to one)"
msgstr ""

msgid "pgr_edmondsKarp(many to many)"
msgstr ""

msgid "pgr_boykovKolmogorov (one to one)"
msgstr ""

msgid "pgr_boykovKolmogorov (one to many)"
msgstr ""

msgid "pgr_boykovKolmogorov (many to one)"
msgstr ""

msgid "pgr_boykovKolmogorov (many to many)"
msgstr ""

msgid "pgr_maxCardinalityMatching"
msgstr ""

msgid "pgr_maxFlow"
msgstr ""

msgid "pgr_edgeDisjointPaths(one to one)"
msgstr ""

msgid "pgr_edgeDisjointPaths(one to many)"
msgstr ""

msgid "pgr_edgeDisjointPaths(many to one)"
msgstr ""

msgid "pgr_edgeDisjointPaths(many to many)"
msgstr ""

msgid "Components family"
msgstr ""

msgid "pgr_strongComponents"
msgstr ""

msgid "pgr_biconnectedComponents"
msgstr ""

msgid "pgr_articulationPoints"
msgstr ""

msgid "pgr_bridges"
msgstr ""

msgid "Contraction:"
msgstr ""

msgid "Removed unnecessary column seq"
msgstr ""

msgid "Bug Fixes"
msgstr ""

msgid "New Experimental functions"
msgstr ""

msgid "pgr_maxFlowMinCost"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost"
msgstr ""

msgid "pgr_turnRestrictedPath"
msgstr ""

msgid "pgr_stoerWagner"
msgstr ""

msgid "pgr_dagShortestpath"
msgstr ""

msgid "pgr_topologicalSort"
msgstr ""

msgid "pgr_transitiveClosure"
msgstr ""

msgid "VRP category"
msgstr ""

msgid "pgr_pickDeliverEuclidean"
msgstr ""

msgid "pgr_pickDeliver"
msgstr ""

msgid "Chinese Postman family"
msgstr ""

msgid "pgr_chinesePostman"
msgstr ""

msgid "pgr_chinesePostmanCost"
msgstr ""

msgid "Breadth First Search family"
msgstr ""

msgid "pgr_breadthFirstSearch"
msgstr ""

msgid "pgr_binaryBreadthFirstSearch"
msgstr ""

msgid "Bellman Ford family"
msgstr ""

msgid "pgr_bellmanFord"
msgstr ""

msgid "pgr_edwardMoore"
msgstr ""

msgid "Moved to legacy"
msgstr ""

msgid "pgr_labelGraph  -  Use the components family of functions instead."
msgstr ""

msgid "Max flow - functions were renamed on v2.5.0"
msgstr ""

msgid "pgr_maxFlowPushRelabel"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp"
msgstr ""

msgid "pgr_maximumcardinalitymatching"
msgstr ""

msgid "VRP"
msgstr ""

msgid "pgr_gsoc_vrppdtw"
msgstr ""

msgid "TSP old signatures"
msgstr ""

msgid "pgr_pointsAsPolygon"
msgstr ""

msgid "pgr_alphaShape old signature"
msgstr ""

msgid "pgRouting 2.6.3 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.6.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C"
"%93&q=milestone%3A%22Release%202.6.3%22%20>`_ on Github."
msgstr ""

msgid ""
"`#1219 <https://github.com/pgRouting/pgrouting/pull/1219>`__ Implicit cast "
"for via_path integer to text"
msgstr ""

msgid ""
"`#1193 <https://github.com/pgRouting/pgrouting/pull/1193>`__ Fixed "
"pgr_pointsAsPolygon breaking when comparing strings in WHERE clause"
msgstr ""

msgid ""
"`#1185 <https://github.com/pgRouting/pgrouting/pull/1185>`__ Improve "
"FindPostgreSQL.cmake"
msgstr ""

msgid "pgRouting 2.6.2 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.6.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C"
"%93&q=milestone%3A%22Release%202.6.2%22%20>`_ on Github."
msgstr ""

msgid ""
"`#1152 <https://github.com/pgRouting/pgrouting/issues/1152>`__ Fixes driving "
"distance when vertex is not part of the graph"
msgstr ""

msgid ""
"`#1098 <https://github.com/pgRouting/pgrouting/issues/1098>`__ Fixes windows "
"test"
msgstr ""

msgid ""
"`#1165 <https://github.com/pgRouting/pgrouting/issues/1165>`__ Fixes build "
"for python3 and perl5"
msgstr ""

msgid "pgRouting 2.6.1 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.6.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C"
"%93&q=milestone%3A%22Release%202.6.1%22%20>`_ on Github."
msgstr ""

msgid "Fixes server crash on several functions."
msgstr ""

msgid "pgr_floydWarshall"
msgstr ""

msgid "pgr_johnson"
msgstr ""

msgid "pgr_astar"
msgstr ""

msgid "pgr_bdAstar"
msgstr ""

msgid "pgr_bdDijstra"
msgstr ""

msgid "pgr_alphashape"
msgstr ""

msgid "pgr_dijkstraCostMatrix"
msgstr ""

msgid "pgr_dijkstraCost"
msgstr ""

msgid "pgr_drivingDistance"
msgstr ""

msgid "pgr_dijkstraVia (proposed)"
msgstr ""

msgid "pgr_boykovKolmogorov (proposed)"
msgstr ""

msgid "pgr_edgeDisjointPaths (proposed)"
msgstr ""

msgid "pgr_edmondsKarp (proposed)"
msgstr ""

msgid "pgr_maxCardinalityMatch (proposed)"
msgstr ""

msgid "pgr_maxFlow (proposed)"
msgstr ""

msgid "pgr_withPoints (proposed)"
msgstr ""

msgid "pgr_withPointsCost (proposed)"
msgstr ""

msgid "pgr_withPointsKSP (proposed)"
msgstr ""

msgid "pgr_withPointsDD (proposed)"
msgstr ""

msgid "pgr_withPointsCostMatrix (proposed)"
msgstr ""

msgid "pgr_contractGraph (experimental)"
msgstr ""

msgid "pgr_pushRelabel (experimental)"
msgstr ""

msgid "pgr_vrpOneDepot (experimental)"
msgstr ""

msgid "pgr_gsoc_vrppdtw (experimental)"
msgstr ""

msgid "Fixes for deprecated functions where also applied but not tested"
msgstr ""

msgid "Removed compilation warning for g++8"
msgstr ""

msgid "Fixed a fallthrugh on Astar and bdAstar."
msgstr ""

msgid "pgRouting 2.6.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.6.0 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C"
"%93&q=milestone%3A%22Release%202.6.0%22%20>`_ on Github."
msgstr ""

msgid "pgr_lineGraphFull"
msgstr ""

msgid ""
"Fix pgr_trsp(text,integer,double precision,integer,double precision,boolean,"
"boolean[,text])"
msgstr ""

msgid "without restrictions"
msgstr ""

msgid "calls pgr_dijkstra when both end points have a fraction IN (0,1)"
msgstr ""

msgid "calls pgr_withPoints when at least one fraction NOT IN (0,1)"
msgstr ""

msgid "with restrictions"
msgstr ""

msgid "calls original trsp code"
msgstr ""

msgid "Internal code"
msgstr ""

msgid ""
"Cleaned the internal code of trsp(text,integer,integer,boolean,boolean [, "
"text])"
msgstr ""

msgid "Removed the use of pointers"
msgstr ""

msgid "Internal code can accept BIGINT"
msgstr ""

msgid "Cleaned the internal code of withPoints"
msgstr ""

msgid "pgRouting 2.5.5 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.5.5 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C"
"%93&q=milestone%3A%22Release%202.5.5%22%20>`_ on Github."
msgstr ""

msgid "Fixes driving distance when vertex is not part of the graph"
msgstr ""

msgid "Fixes windows test"
msgstr ""

msgid "Fixes build for python3 and perl5"
msgstr ""

msgid "pgRouting 2.5.4 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.5.4 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C"
"%93&q=milestone%3A%22Release%202.5.4%22%20>`_ on Github."
msgstr ""

msgid "pgRouting 2.5.3 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.5.3 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C"
"%93&q=milestone%3A%22Release%202.5.3%22%20>`_ on Github."
msgstr ""

msgid ""
"Fix for postgresql 11: Removed a compilation error when compiling with "
"postgreSQL"
msgstr ""

msgid "pgRouting 2.5.2 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.5.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C"
"%93&q=milestone%3A%22Release%202.5.2%22%20>`_ on Github."
msgstr ""

msgid "Fix for postgresql 10.1: Removed a compiler condition"
msgstr ""

msgid "pgRouting 2.5.1 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.5.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C"
"%93&q=milestone%3A%22Release%202.5.1%22%20>`_ on Github."
msgstr ""

msgid "Fixed prerequisite minimum version of: cmake"
msgstr ""

msgid "pgRouting 2.5.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.5.0 <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release"
"+2.5.0%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "enhancement:"
msgstr ""

msgid "pgr_version is now on SQL language"
msgstr ""

msgid "Breaking change on:"
msgstr ""

msgid "pgr_edgeDisjointPaths:"
msgstr ""

msgid "Added path_id, cost and agg_cost columns on the result"
msgstr ""

msgid "Parameter names changed"
msgstr ""

msgid "The many version results are the union of the one to one version"
msgstr ""

msgid "New Signatures:"
msgstr ""

msgid "pgr_bdAstar(one to one)"
msgstr ""

msgid "New Proposed functions"
msgstr ""

msgid "pgr_bdAstarCostMatrix"
msgstr ""

msgid "pgr_bdDijkstraCostMatrix"
msgstr ""

msgid "pgr_lineGraph"
msgstr ""

msgid "Deprecated Signatures"
msgstr ""

msgid "pgr_bdastar - use pgr_bdAstar instead"
msgstr ""

msgid "Renamed Functions"
msgstr ""

msgid "pgr_maxFlowPushRelabel - use pgr_pushRelabel instead"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp -use pgr_edmondsKarp instead"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov - use pgr_boykovKolmogorov instead"
msgstr ""

msgid "pgr_maximumCardinalityMatching - use pgr_maxCardinalityMatch instead"
msgstr ""

msgid "Deprecated function"
msgstr ""

msgid "pgr_pointToEdgeNode"
msgstr ""

msgid "pgRouting 2.4.2 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.4.2 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C"
"%93&q=milestone%3A%22Release%202.4.2%22%20>`_ on Github."
msgstr ""

msgid "Improvement"
msgstr ""

msgid "Works for postgreSQL 10"
msgstr ""

msgid "Fixed: Unexpected error column \"cname\""
msgstr ""

msgid ""
"Replace __linux__ with __GLIBC__ for glibc-specific headers and functions"
msgstr ""

msgid "pgRouting 2.4.1 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.4.1 <https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C"
"%93&q=milestone%3A%22Release%202.4.1%22%20>`_ on Github."
msgstr ""

msgid "Fixed compiling error on macOS"
msgstr ""

msgid "Condition error on pgr_withPoints"
msgstr ""

msgid "pgRouting 2.4.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.4.0 <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release"
"+2.4.0%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "New Signatures"
msgstr ""

msgid "pgr_bdDijkstra"
msgstr ""

msgid "New Proposed Signatures"
msgstr ""

msgid "pgr_astar(one to many)"
msgstr ""

msgid "pgr_astar(many to one)"
msgstr ""

msgid "pgr_astar(many to many)"
msgstr ""

msgid "pgr_astarCost(one to one)"
msgstr ""

msgid "pgr_astarCost(one to many)"
msgstr ""

msgid "pgr_astarCost(many to one)"
msgstr ""

msgid "pgr_astarCost(many to many)"
msgstr ""

msgid "pgr_astarCostMatrix"
msgstr ""

msgid "pgr_bddijkstra - use pgr_bdDijkstra instead"
msgstr ""

msgid "Deprecated Functions"
msgstr ""

msgid "pgr_pointsToVids"
msgstr ""

msgid "Bug fixes on proposed functions"
msgstr ""

msgid "pgr_withPointsKSP: fixed ordering"
msgstr ""

msgid "TRSP original code is used with no changes on the compilation warnings"
msgstr ""

msgid "pgRouting 2.3.2 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.3.2 <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release"
"+2.3.2%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Fixed pgr_gsoc_vrppdtw crash when all orders fit on one truck."
msgstr ""

msgid "Fixed pgr_trsp:"
msgstr ""

msgid "Alternate code is not executed when the point is in reality a vertex"
msgstr ""

msgid "Fixed ambiguity on seq"
msgstr ""

msgid "pgRouting 2.3.1 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.3.1 <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release"
"+2.3.1%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Leaks on proposed max_flow functions"
msgstr ""

msgid "Regression error on pgr_trsp"
msgstr ""

msgid "Types discrepancy on pgr_createVerticesTable"
msgstr ""

msgid "pgRouting 2.3.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.3.0 <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release"
"+2.3.0%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "pgr_TSP"
msgstr ""

msgid "pgr_aStar"
msgstr ""

msgid "New Functions"
msgstr ""

msgid "pgr_eucledianTSP"
msgstr ""

msgid "pgr_withPointsCostMatrix"
msgstr ""

msgid "pgr_maxFlowPushRelabel(one to one)"
msgstr ""

msgid "pgr_maxFlowPushRelabel(one to many)"
msgstr ""

msgid "pgr_maxFlowPushRelabel(many to one)"
msgstr ""

msgid "pgr_maxFlowPushRelabel(many to many)"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp(one to one)"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp(one to many)"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp(many to one)"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp(many to many)"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov (one to one)"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov (one to many)"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov (many to one)"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov (many to many)"
msgstr ""

msgid "pgr_maximumCardinalityMatching"
msgstr ""

msgid "pgr_contractGraph"
msgstr ""

msgid "pgr_tsp - use pgr_TSP or pgr_eucledianTSP instead"
msgstr ""

msgid "pgr_astar - use pgr_aStar instead"
msgstr ""

msgid "pgr_flip_edges"
msgstr ""

msgid "pgr_vidsToDmatrix"
msgstr ""

msgid "pgr_pointsToDMatrix"
msgstr ""

msgid "pgr_textToPoints"
msgstr ""

msgid "pgRouting 2.2.4 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.2.4 <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release"
"+2.2.4%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Bogus uses of extern \"C\""
msgstr ""

msgid "Build error on Fedora 24 + GCC 6.0"
msgstr ""

msgid "Regression error pgr_nodeNetwork"
msgstr ""

msgid "pgRouting 2.2.3 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.2.3 <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release"
"+2.2.3%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Fixed compatibility issues with PostgreSQL 9.6."
msgstr ""

msgid "pgRouting 2.2.2 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.2.2 <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release"
"+2.2.2%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Fixed regression error on pgr_drivingDistance"
msgstr ""

msgid "pgRouting 2.2.1 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.2.1 <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A2.2.1+is"
"%3Aclosed>`_ on Github."
msgstr ""

msgid "Server crash fix on pgr_alphaShape"
msgstr ""

msgid "Bug fix on With Points family of functions"
msgstr ""

msgid "pgRouting 2.2.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.2.0 <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release"
"+2.2.0%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Improvements"
msgstr ""

msgid "Adding a row_where and outall optional parameters"
msgstr ""

msgid "Signature fix"
msgstr ""

msgid "pgr_dijkstra  -- to match what is documented"
msgstr ""

msgid "pgr_Johnson"
msgstr ""

msgid "pgr_dijkstraCost(one to one)"
msgstr ""

msgid "pgr_dijkstraCost(one to many)"
msgstr ""

msgid "pgr_dijkstraCost(many to one)"
msgstr ""

msgid "pgr_dijkstraCost(many to many)"
msgstr ""

msgid "Proposed functionality"
msgstr ""

msgid "pgr_withPoints(one to one)"
msgstr ""

msgid "pgr_withPoints(one to many)"
msgstr ""

msgid "pgr_withPoints(many to one)"
msgstr ""

msgid "pgr_withPoints(many to many)"
msgstr ""

msgid "pgr_withPointsCost(one to one)"
msgstr ""

msgid "pgr_withPointsCost(one to many)"
msgstr ""

msgid "pgr_withPointsCost(many to one)"
msgstr ""

msgid "pgr_withPointsCost(many to many)"
msgstr ""

msgid "pgr_withPointsDD(single vertex)"
msgstr ""

msgid "pgr_withPointsDD(multiple vertices)"
msgstr ""

msgid "pgr_withPointsKSP"
msgstr ""

msgid "pgr_dijkstraVia"
msgstr ""

msgid "Deprecated functions:"
msgstr ""

msgid "pgr_apspWarshall  use pgr_floydWarshall instead"
msgstr ""

msgid "pgr_apspJohnson   use pgr_Johnson instead"
msgstr ""

msgid "pgr_kDijkstraCost use pgr_dijkstraCost instead"
msgstr ""

msgid "pgr_kDijkstraPath use pgr_dijkstra instead"
msgstr ""

msgid "Renamed and deprecated function"
msgstr ""

msgid "pgr_makeDistanceMatrix renamed to _pgr_makeDistanceMatrix"
msgstr ""

msgid "pgRouting 2.1.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.1.0 <https://github.com/pgRouting/pgrouting/issues?q=is%3Aissue+milestone"
"%3A%22Release+2.1.0%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "pgr_dijkstra(one to many)"
msgstr ""

msgid "pgr_dijkstra(many to one)"
msgstr ""

msgid "pgr_dijkstra(many to many)"
msgstr ""

msgid "pgr_drivingDistance(multiple vertices)"
msgstr ""

msgid "Refactored"
msgstr ""

msgid "pgr_dijkstra(one to one)"
msgstr ""

msgid "pgr_drivingDistance(single vertex)"
msgstr ""

msgid ""
"pgr_alphaShape function now can generate better (multi)polygon with holes "
"and alpha parameter."
msgstr ""

msgid ""
"Proposed functions from Steve Woodbridge, (Classified as Convenience by the "
"author.)"
msgstr ""

msgid ""
"pgr_pointToEdgeNode - convert a point geometry to a vertex_id based on "
"closest edge."
msgstr ""

msgid ""
"pgr_flipEdges - flip the edges in an array of geometries so the connect end "
"to end."
msgstr ""

msgid ""
"pgr_textToPoints - convert a string of x,y;x,y;... locations into point "
"geometries."
msgstr ""

msgid ""
"pgr_pointsToVids - convert an array of point geometries into vertex ids."
msgstr ""

msgid "pgr_pointsToDMatrix - Create a distance matrix from an array of points."
msgstr ""

msgid ""
"pgr_vidsToDMatrix - Create a distance matrix from an array of vertix_id."
msgstr ""

msgid "Added proposed functions from GSoc Projects:"
msgstr ""

msgid "pgr_vrppdtw"
msgstr ""

msgid "pgr_vrponedepot"
msgstr ""

msgid "pgr_getColumnName"
msgstr ""

msgid "pgr_getTableName"
msgstr ""

msgid "pgr_isColumnCndexed"
msgstr ""

msgid "pgr_isColumnInTable"
msgstr ""

msgid "pgr_quote_ident"
msgstr ""

msgid "pgr_versionless"
msgstr ""

msgid "pgr_startPoint"
msgstr ""

msgid "pgr_endPoint"
msgstr ""

msgid "pgr_pointToId"
msgstr ""

msgid "No longer supported"
msgstr ""

msgid "Removed the 1.x legacy functions"
msgstr ""

msgid "Some bug fixes in other functions"
msgstr ""

msgid "Refactoring Internal Code"
msgstr ""

msgid "A C and C++ library for developer was created"
msgstr ""

msgid "encapsulates postgreSQL related functions"
msgstr ""

msgid "encapsulates Boost.Graph graphs"
msgstr ""

msgid "Directed Boost.Graph"
msgstr ""

msgid "Undirected Boost.graph."
msgstr ""

msgid "allow any-integer in the id's"
msgstr ""

msgid "allow any-numerical on the cost/reverse_cost columns"
msgstr ""

msgid ""
"Instead of generating many libraries: - All functions are encapsulated in "
"one library - The library has the prefix 2-1-0"
msgstr ""

msgid "pgRouting 2.0.1 Release Notes"
msgstr ""

msgid "Minor bug fixes."
msgstr ""

msgid "No track of the bug fixes were kept."
msgstr ""

msgid "pgRouting 2.0.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.0.0 <https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release"
"+2.0.0%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid ""
"With the release of pgRouting 2.0.0 the library has abandoned backwards "
"compatibility to `pgRouting 1.x Release Notes`_ releases. The main Goals for "
"this release are:"
msgstr ""

msgid "Major restructuring of pgRouting."
msgstr ""

msgid "Standardization of the function naming"
msgstr ""

msgid "Preparation of the project for future development."
msgstr ""

msgid "As a result of this effort:"
msgstr ""

msgid "pgRouting has a simplified structure"
msgstr ""

msgid "Significant new functionality has being added"
msgstr ""

msgid "Documentation has being integrated"
msgstr ""

msgid "Testing has being integrated"
msgstr ""

msgid "And made it easier for multiple developers to make contributions."
msgstr ""

msgid "Important Changes"
msgstr ""

msgid ""
"Graph Analytics - tools for detecting and fixing connection some problems in "
"a graph"
msgstr ""

msgid "A collection of useful utility functions"
msgstr ""

msgid ""
"Two new All Pairs Short Path algorithms (pgr_apspJohnson, pgr_apspWarshall)"
msgstr ""

msgid ""
"Bi-directional Dijkstra and A-star search algorithms (pgr_bdAstar, "
"pgr_bdDijkstra)"
msgstr ""

msgid "One to many nodes search (pgr_kDijkstra)"
msgstr ""

msgid "K alternate paths shortest path (pgr_ksp)"
msgstr ""

msgid ""
"New TSP solver that simplifies the code and the build process (pgr_tsp), "
"dropped \"Gaul Library\" dependency"
msgstr ""

msgid "Turn Restricted shortest path (pgr_trsp) that replaces Shooting Star"
msgstr ""

msgid "Dropped support for Shooting Star"
msgstr ""

msgid ""
"Built a test infrastructure that is run before major code changes are "
"checked in"
msgstr ""

msgid ""
"Tested and fixed most all of the outstanding bugs reported against 1.x that "
"existing in the 2.0-dev code base."
msgstr ""

msgid "Improved build process for Windows"
msgstr ""

msgid ""
"Automated testing on Linux and Windows platforms trigger by every commit"
msgstr ""

msgid "Modular library design"
msgstr ""

msgid "Compatibility with PostgreSQL 9.1 or newer"
msgstr ""

msgid "Compatibility with PostGIS 2.0 or newer"
msgstr ""

msgid "Installs as PostgreSQL EXTENSION"
msgstr ""

msgid "Return types re factored and unified"
msgstr ""

msgid "Support for table SCHEMA in function parameters"
msgstr ""

msgid "Support for ``st_`` PostGIS function prefix"
msgstr ""

msgid "Added ``pgr_`` prefix to functions and types"
msgstr ""

msgid "Better documentation: https://docs.pgrouting.org"
msgstr ""

msgid "shooting_star is discontinued"
msgstr ""

msgid "pgRouting 1.x Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for 1.x "
"<https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release+1.x"
"%22+is%3Aclosed>`_ on Github. The following release notes have been copied "
"from the previous ``RELEASE_NOTES`` file and are kept as a reference."
msgstr ""

msgid "Changes for release 1.05"
msgstr ""

msgid "Changes for release 1.03"
msgstr ""

msgid "Much faster topology creation"
msgstr ""

msgid "Changes for release 1.02"
msgstr ""

msgid "Shooting* bug fixes"
msgstr ""

msgid "Compilation problems solved"
msgstr ""

msgid "Changes for release 1.01"
msgstr ""

msgid "Changes for release 1.0"
msgstr ""

msgid "Core and extra functions are separated"
msgstr ""

msgid "Cmake build process"
msgstr ""

msgid "Changes for release 1.0.0b"
msgstr ""

msgid "Additional SQL file with more simple names for wrapper functions"
msgstr ""

msgid "Changes for release 1.0.0a"
msgstr ""

msgid "Shooting* shortest path algorithm for real road networks"
msgstr ""

msgid "Several SQL bugs were fixed"
msgstr ""

msgid "Changes for release 0.9.9"
msgstr ""

msgid "PostgreSQL 8.2 support"
msgstr ""

msgid ""
"Shortest path functions return empty result if they could not find any path"
msgstr ""

msgid "Changes for release 0.9.8"
msgstr ""

msgid "Renumbering scheme was added to shortest path functions"
msgstr ""

msgid "Directed shortest path functions were added"
msgstr ""

msgid "routing_postgis.sql was modified to use dijkstra in TSP search"
msgstr ""

msgid "Function Families"
msgstr ""

msgid "Sample Data"
msgstr ""

msgid ""
"The documentation provides very simple example queries based on a small "
"sample network that resembles a city. To be able to execute the mayority of "
"the examples queries, follow the instructions bellow."
msgstr ""

msgid "Main graph"
msgstr ""

msgid "A graph consists of a set of edges and a set of vertices."
msgstr ""

msgid "The following city is to be inserted into the database:"
msgstr ""

msgid ""
"Information known at this point is the geometry of the edges, cost values, "
"cpacity values, category values and some locations that are not in the graph."
msgstr ""

msgid ""
"The process to have working topology starts by inserting the edges. After "
"that everything else is calculated."
msgstr ""

msgid "Edges"
msgstr ""

msgid ""
"The database design for the documentation of pgRouting, keeps in the same "
"row 2 segments, one in the direction of the geometry and the second in the "
"oposite direction. Therfore some information has the ``reverse_`` prefix "
"which corresponds to the segment on the oposite direction of the geometry."
msgstr ""

msgid "Identifier of the starting vertex of the geometry ``geom``."
msgstr ""

msgid "Identifier of the ending vertex of the geometry ``geom``"
msgstr ""

msgid "Cost to traverse from `source` to ``target``."
msgstr ""

msgid "Cost to traverse from `target` to ``source``."
msgstr ""

msgid "Flow capacity from `source` to ``target``."
msgstr ""

msgid "Flow capacity from `target` to ``source``."
msgstr ""

msgid "``category``"
msgstr ""

msgid "``reverse_category``"
msgstr ""

msgid ":math:`x` coordinate of the starting vertex of the geometry."
msgstr ""

msgid ""
"For convinience it is saved on the table but can be calculated as "
"``ST_X(ST_StartPoint(geom))``."
msgstr ""

msgid ":math:`y` coordinate of the ending vertex of the geometry."
msgstr ""

msgid ""
"For convinience it is saved on the table but can be calculated as "
"``ST_Y(ST_EndPoint(geom))``."
msgstr ""

msgid "The geometry of the segments."
msgstr ""

msgid "Starting on  PostgreSQL 12::"
msgstr ""

msgid ""
"Optionally indexes on different columns can be created. The recomendation is "
"to have"
msgstr ""

msgid "``id`` indexed."
msgstr ""

msgid ""
"``source`` and ``target`` columns indexed to speed up pgRouting queries."
msgstr ""

msgid ""
"``geom`` indexed to speed up gemetry processes that might be needed in the "
"front end."
msgstr ""

msgid "For this small example the indexes are skipped, except for ``id``"
msgstr ""

msgid "Edges data"
msgstr ""

msgid "Inserting into the database the information of the edges:"
msgstr ""

msgid ""
"Negative values on the cost, capacity and category means that the edge do "
"not exist."
msgstr ""

msgid "Vertices"
msgstr ""

msgid ""
"The vertex information is calculated based on the identifier of the edge and "
"the geometry and saved on a table. Saving all the information provided by :"
"doc:`pgr_extractVertices`:"
msgstr ""

msgid ""
"In this case the because the ``CREATE`` statement was not used, the "
"definition of an index on the table is needed."
msgstr ""

msgid "The structure of the table is:"
msgstr ""

msgid "Vertices data"
msgstr ""

msgid "The saved information of the vertices is:"
msgstr ""

msgid ""
"Here is where adding more columns to the vertices table can be done. "
"Additional columns names and types will depend on the application."
msgstr ""

msgid "The topology"
msgstr ""

msgid ""
"This queries based on the vertices data create a topology by filling the "
"``source`` and ``target`` columns in the edges table."
msgstr ""

msgid "Topology data"
msgstr ""

msgid "Points outside the graph"
msgstr ""

msgid "Support tables"
msgstr ""

msgid ""
"Many functions can be used with a combinations of ``(source, target)`` pairs "
"when wanting a route from ``source`` to ``target``."
msgstr ""

msgid ""
"For convinence of this documentations, some combinations will be stored on a "
"table:"
msgstr ""

msgid "Inserting the data:"
msgstr ""

msgid "Combinations data"
msgstr ""

msgid "Some functions accept soft restrictions about the segments."
msgstr ""

msgid "Red arrows correspond when ``cost`` > 0 in the edge table."
msgstr ""

msgid "Blue arrows correspond when ``reverse_cost`` > 0 in the edge table."
msgstr ""

msgid "Points are outside the graph."
msgstr ""

msgid "Click on the graph to enlarge."
msgstr ""

msgid "Directed graph with ``cost`` and ``reverse_cost``"
msgstr ""

msgid ""
"When working with city networks, this is recommended for point of view of "
"vehicles."
msgstr ""

msgid "Directed, with cost and reverse_cost"
msgstr ""

msgid "Undirected graph with ``cost`` and ``reverse_cost``"
msgstr ""

msgid ""
"When working with city networks, this is recommended for point of view of "
"pedestrians."
msgstr ""

msgid "Undirected, with cost and reverse cost"
msgstr ""

msgid "Directed graph with ``cost``"
msgstr ""

msgid "Directed, with cost"
msgstr ""

msgid "Undirected graph with ``cost``"
msgstr ""

msgid "Undirected, with cost"
msgstr ""

msgid "Pick & Deliver Data"
msgstr ""

msgid "Spanning Tree - Category"
msgstr "生成树 - 类别"

msgid ""
"A spanning tree of an undirected graph is a tree that includes all the "
"vertices of G with the minimum possible number of edges."
msgstr ""

msgid ""
"For a disconnected graph, there there is no single tree, but a spanning "
"forest, consisting of a spanning tree of each connected component."
msgstr ""

msgid ""
"pgRouting community support is available through the `pgRouting website "
"<https://pgrouting.org/support.html>`_, `documentation <https://docs."
"pgrouting.org>`_, tutorials, mailing lists and others. If you’re looking "
"for :ref:`commercial support <support_commercial>`, find below a list of "
"companies providing pgRouting development and consulting services."
msgstr ""
"pgRouting 社区支持可通过 `pgRouting 网站 <https://pgrouting.org/support."
"html>`_、`文档<https://docs.pgrouting.org>`_、教程、邮件列表等获得。 如果您正"
"在寻求:ref:`商业支持<support_commercial>`，请在下面找到提供 pgRouting 开发和"
"咨询服务的公司列表。"

msgid "Reporting Problems"
msgstr "报告问题"

msgid ""
"Bugs are reported and managed in an `issue tracker <https://github.com/"
"pgrouting/pgrouting/issues>`_. Please follow these steps:"
msgstr ""
"错误在`问题跟踪器<https://github.com/pgrouting/pgrouting/issues>`_中报告和管"
"理。 请按照以下步骤操作："

msgid ""
"Search the tickets to see if your problem has already been reported. If so, "
"add any extra context you might have found, or at least indicate that you "
"too are having the problem. This will help us prioritize common issues."
msgstr ""
"搜索票证以查看您的问题是否已被报告。 如果是这样，请添加您可能发现的任何额外上"
"下文，或者至少表明您也遇到了问题。 这将帮助我们优先考虑常见问题。"

msgid ""
"If your problem is unreported, create a `new issue <https://github.com/"
"pgRouting/pgrouting/issues/new>`__ for it."
msgstr ""
"如果您的问题未报告，请为其创建一个`新问题 <https://github.com/pgRouting/"
"pgrouting/issues/new>`__ 。"

msgid ""
"In your report include explicit instructions to replicate your issue. The "
"best tickets include the exact SQL necessary to replicate a problem."
msgstr ""
"在您的报告中包含重现问题的明确说明。 最好的票证包含复制问题所需的确切 SQL。"

msgid ""
"If you can test older versions of PostGIS for your problem, please do. On "
"your ticket, note the earliest version the problem appears."
msgstr ""
"如果您可以测试旧版本的 PostGIS 来解决您的问题，请这样做。 在您的票证上，记下"
"问题出现的最早版本。"

msgid ""
"For the versions where you can replicate the problem, note the operating "
"system and version of pgRouting, PostGIS and PostgreSQL."
msgstr ""
"对于可以重现问题的版本，请记下操作系统以及 pgRouting、PostGIS 和 PostgreSQL "
"的版本。"

msgid ""
"It is recommended to use the following wrapper on the problem to pin point "
"the step that is causing the problem."
msgstr "建议对问题使用以下包装器来查明导致问题的步骤。"

msgid "Mailing List and GIS StackExchange"
msgstr "邮件列表和 GIS StackExchange"

msgid ""
"There are two mailing lists for pgRouting hosted on OSGeo mailing list "
"server:"
msgstr "OSGeo 邮件列表服务器上托管有两个 pgRouting 邮件列表："

msgid ""
"User mailing list: https://lists.osgeo.org/mailman/listinfo/pgrouting-users"
msgstr "用户邮件列表：https://lists.osgeo.org/mailman/listinfo/pgrouting-users"

msgid ""
"Developer mailing list: https://lists.osgeo.org/mailman/listinfo/pgrouting-"
"dev"
msgstr "开发者邮件列表：https://lists.osgeo.org/mailman/listinfo/pgrouting-dev"

msgid ""
"For general questions and topics about how to use pgRouting, please write to "
"the user mailing list."
msgstr "有关如何使用 pgRouting 的一般问题和主题，请写信给用户邮件列表。"

msgid ""
"You can also ask at `GIS StackExchange <https://gis.stackexchange.com/>`_ "
"and tag the question with ``pgrouting``. Find all questions tagged with "
"``pgrouting`` under https://gis.stackexchange.com/questions/tagged/pgrouting "
"or subscribe to the `pgRouting questions feed <https://gis.stackexchange.com/"
"feeds/tag?tagnames=pgrouting&sort=newest>`_."
msgstr ""
"您还可以在 `GIS StackExchange <https://gis.stackexchange.com/>`_ 上提问，并使"
"用 ``pgrouting`` 标签。查找所有带有 ``pgrouting`` 标签的问题，请访问 https://"
"gis.stackexchange.com/questions/tagged/pgrouting 或订阅 `pgRouting 问题订阅 "
"<https://gis.stackexchange.com/feeds/tag?tagnames=pgrouting&sort=newest>`_。"

msgid "Commercial Support"
msgstr "商业支持"

msgid ""
"For users who require professional support, development and consulting "
"services, consider contacting any of the following organizations, which have "
"significantly contributed to the development of pgRouting:"
msgstr ""
"对于需要专业支持、开发和咨询服务的用户，请考虑联系以下任何一个组织，这些组织"
"对 pgRouting 的发展做出了重大贡献："

msgid "**Company**"
msgstr "**公司**"

msgid "**Offices in**"
msgstr "**办事处**"

msgid "**Website**"
msgstr "**网站**"

msgid "Germany, Japan"
msgstr "德国，日本"

msgid "https://georepublic.info"
msgstr "https://georepublic.info"

msgid "United States"
msgstr "美国"

msgid "https://www.paragoncorporation.com"
msgstr "https://www.paragoncorporation.com"

msgid "Netlab"
msgstr "Netlab"

msgid "Capranica, Italy"
msgstr "卡普拉尼卡，意大利"

msgid "https://www.osgeo.org/service-providers/netlab/"
msgstr "https://www.osgeo.org/service-providers/netlab/"

msgid "Topology - Family of Functions"
msgstr "Topology - 函数族"

msgid ""
"The pgRouting's topology of a network represented with a graph in form of "
"two tables: and edge table and a vertex table."
msgstr "pgRouting 的网络拓扑以两个表形式的图表示：边表和顶点表。"

msgid ""
"Attributes associated to the tables help to indicate if the graph is "
"directed or undirected, if an edge is one way on a directed graph, and "
"depending on the final application needs, suitable topology(s) need to be "
"created."
msgstr ""
"与表关联的属性有助于指示图是有向的还是无向的，边是否是有向图上的单向，并且根"
"据最终应用程序的需要，需要创建合适的拓扑。"

msgid ""
"pgRouting suplies some functions to create a routing topology and to analyze "
"the topology."
msgstr "pgRouting 提供一些函数来创建路由拓扑并分析拓扑。"

msgid "Additional functions to create a graph:"
msgstr "创建图表的附加函数："

msgid "Additional functions to analyze a graph:"
msgstr "用于分析图表的附加函数："

msgid "Transformation - Family of functions (Experimental)"
msgstr "Transformation - 函数族（实验）"

msgid ""
"This family of functions is used for transforming a given input graph :math:"
"`G(V,E)` into a new graph :math:`G'(V',E')`."
msgstr "该函数族用于将给定的输入图:math:`G(V,E)`转换为新图 :math:`G'(V',E')`。"

msgid "Traversal - Family of functions"
msgstr "Traversal - 函数族"

msgid "Aditionaly there are 2 categories under this family"
msgstr "此外，该家族下还有 2 个类别"

msgid "Via - Category"
msgstr "Via - 类别"

msgid "This category intends to solve the general problem:"
msgstr "该类别旨在解决普遍问题："

msgid ""
"Given a graph and a list of vertices, find the shortest path between :math:"
"`vertex_i` and :math:`vertex_{i+1}` for all vertices"
msgstr ""
"给定一个图和一个顶点列表，找到所有相邻顶点对 :math:`vertex_i` 和 :math:"
"`vertex_{i+1}` 之间的最短路径"

msgid ""
"In other words, find a continuos route that visits all the vertices in the "
"order given."
msgstr "换句话说，找到一条按给定顺序访问所有顶点的连续路线。"

msgid "path"
msgstr "path"

msgid "represents a section of a **route**."
msgstr "代表**route**的一部分。"

msgid "route"
msgstr "route"

msgid "is a sequence of **paths**"
msgstr "是一系列**paths**"

msgid "**Used on:**"
msgstr "**用于:**"

msgid ""
"Besides the compulsory parameters each function has, there are optional "
"parameters that exist due to the kind of function."
msgstr "除了每个函数具有的强制参数之外，由于函数的种类而存在可选参数。"

msgid "Used on all Via functions"
msgstr "用于所有 Via 函数"

msgid "Depending on the function one or more inner queries are needed."
msgstr "根据函数需要一个或多个内部查询。"

msgid "Used on"
msgstr "用于"

msgid "withPoints - Category"
msgstr "withPoints - 类别"

msgid "When points are added to the graph."
msgstr "当点添加到图中时。"

msgid ""
"The **with points** category modifies the graph on the fly by adding points "
"on edges as required by the `Points SQL`_ query."
msgstr ""
"**with points** 类别通过根据 `Points SQL`_ 查询的要求在边上添加点来动态修改图"
"形。"

msgid ""
"The functions within this category give the ability to process between "
"arbitrary points located outside the original graph."
msgstr "该类别中的函数能够在位于原始图之外的任意点之间进行处理。"

msgid ""
"This category of functions was thought for routing vehicles, but might as "
"well work for some other application not involving vehicles."
msgstr ""
"此类功能被认为用于路由车辆，但也可能适用于其他一些不涉及车辆的应用程序。"

msgid ""
"When given a point identifier ``pid`` that its being mapped to an edge with "
"an identifier ``edge_id``, with a fraction from the source to the target "
"along the edge ``fraction`` and some additional information about which side "
"of the edge the point is on ``side``, then processing from arbitrary points "
"can be done on fixed networks."
msgstr ""
"当给定一个点标识符 `pid`，它被映射到具有标识符 `edge_id` 的边上，并且有一个从"
"源到目标沿边的分数 `fraction`，以及关于点位于边的哪一侧的其他信息 `side`，那"
"么可以在固定网络上从任意点进行处理。"

msgid ""
"All this functions consider as many traits from the \"real world\" as "
"possible:"
msgstr "所有这些函数都考虑了尽可能多的“现实世界”特征："

msgid "Kind of graph:"
msgstr "图的种类："

msgid "**directed** graph"
msgstr "**有向**图"

msgid "**undirected** graph"
msgstr "**无向**图"

msgid "Arriving at the point:"
msgstr "到达点："

msgid ""
"Compulsory arrival on the side of the segment where the point is located."
msgstr "强制到达该点所在航段的一侧。"

msgid "On either side of the segment."
msgstr "位于该段的两侧。"

msgid "Countries with:"
msgstr "具有以下条件的国家："

msgid "**Right** side driving"
msgstr "**右侧**驾驶"

msgid "**Left** side driving"
msgstr "**左侧**驾驶"

msgid "Some points are:"
msgstr "一些要点是："

msgid ""
"**Permanent**: for example the set of points of clients stored in a table in "
"the data base."
msgstr "**永久**：例如，存储在表中的客户端点集 数据库。"

msgid ""
"The graph has been modified to permanently have those points as vertices."
msgstr "图已修改为将这些点永久用作顶点。"

msgid "There is a table on the database that describes the points"
msgstr "数据库上有一个描述点的表格"

msgid "**Temporal**: for example points given through a web application"
msgstr "**时间**：例如通过 Web 应用程序给出的点"

msgid "The numbering of the points are handled with negative sign."
msgstr "在点 SQL 中使用pgr_findCloseEdges。"

msgid ""
"This sign change is to avoid confusion when there is a vertex with the same "
"identifier as the point identifier."
msgstr "这种符号变化是为了避免当存在与点标识符具有相同标识符的顶点时发生混淆。"

msgid "Original point identifiers are to be positive."
msgstr "原始点标识符应为正数。"

msgid "Transformation to negative is done internally."
msgstr "向负数的转变是在内部完成的。"

msgid "Interpretation of the sign on the node information of the output"
msgstr "解释输出的节点上的符号信息"

msgid "positive sign is a vertex of the original graph"
msgstr "正号是原始图的顶点"

msgid "negative sign is a point of the `Points SQL`_"
msgstr "负号是`Points SQL`_ 的一个点"

msgid "About points"
msgstr "关于积分"

msgid ""
"For this section the following city (see :doc:`sampledata`) some interesing "
"points such as restaurant, supermarket, post office, etc. will be used as "
"example."
msgstr ""
"对于本节，将使用以下城市（参见:doc:`示例数据`）一些有趣的点（例如餐馆、超市、"
"邮局等）作为示例。"

msgid "The graph is **directed**"
msgstr "图是**有向**的"

msgid "Red arrows show the ``(source, target)`` of the edge on the edge table"
msgstr "红色箭头显示边表上的边``(source, target)``"

msgid "Blue arrows show the ``(target, source)`` of the edge on the edge table"
msgstr "蓝色箭头显示边表上的边``(target, source)``"

msgid ""
"Each point location shows where it is located with relation of the edge "
"``(source, target)``"
msgstr "每个点位置显示它与边 ``(source, target)``的关系"

msgid "On the right for points **2** and **4**."
msgstr "在右侧为第** 2 **点和第** 4** 点。"

msgid "On the left for points **1**, **3** and **5**."
msgstr "左侧为第 **1**、**3** 和** 5 **点。"

msgid "On both sides for point **6**."
msgstr "在两侧为第**6**点。"

msgid ""
"The representation on the data base follows the `Points SQL`_ description, "
"and for this example:"
msgstr "数据库上的表示遵循 `Points SQL`_ 描述，对于本示例："

msgid "Driving side"
msgstr "驾驶侧"

msgid "In the the folowwing images:"
msgstr "在下面的图片中："

msgid "The squared vertices are the temporary vertices,"
msgstr "平方顶点是临时顶点，"

msgid "The temporary vertices are added according to the driving side,"
msgstr "根据驾驶侧添加临时顶点，"

msgid ""
"visually showing the differences on how depending on the driving side the "
"data is interpreted."
msgstr "直观地显示不同驾驶侧数据解释方式的差异。"

msgid "Point **1** located on edge ``(6, 5)``"
msgstr "点** 1 **位于边``(6, 5)``"

msgid "Point **2** located on edge ``(16, 17)``"
msgstr "点** 2 **位于边缘 ``(16, 17)``"

msgid "Point **3** located on edge ``(8, 12)``"
msgstr "点 **3** 位于边缘``(8, 12)``"

msgid "Point **4** located on edge ``(1, 3)``"
msgstr "点 **4 **位于边 ``(1, 3)``"

msgid "Point **5** located on edge ``(10, 11)``"
msgstr "点 **5** 位于边缘 ``(10, 11)``"

msgid "Point **6** located on edges ``(6, 7)`` and ``(7, 6)``"
msgstr "点** 6** 位于边``(6, 7)``和``(7, 6)``"

msgid "Point **1** located on edge ``(5, 6)``"
msgstr "点 **1 **位于边 ``(5, 6)``"

msgid "Point **2** located on edge ``(17, 16)``"
msgstr "点** 2** 位于边 ``(17, 16)``"

msgid "Point **4** located on edge ``(3, 1)``"
msgstr "点 4 位于边``(3, 1)``"

msgid "Like having all points to be considered in both sides ``b``"
msgstr "就像双方都要考虑所有点 ``b``"

msgid "Prefered usage on **undirected** graphs"
msgstr "**无向**图上的首选用法"

msgid "On the :doc:`TRSP-family` this option is not valid"
msgstr "在 :doc:`TRSP-family`上，此选项无效"

msgid "Point **1** located on edge ``(5, 6)`` and ``(6, 5)``"
msgstr "点**1**位于边``(5, 6)``和 ``(6, 5)``"

msgid "Point **2** located on edge ``(17, 16)``and ``16, 17``"
msgstr "点**2**位于边``(17, 16)``和 ``16, 17``"

msgid "Point **4** located on edge ``(3, 1)`` and ``(1, 3)``"
msgstr "点 **4**位于边``(3, 1)``和``(1, 3)``"

msgid "Creating temporary vertices"
msgstr "创建临时顶点"

msgid ""
"This section will demonstrate how a temporary vertex is created internally "
"on the graph."
msgstr "本节将演示如何在图内部创建临时顶点。"

msgid "Problem"
msgstr "问题"

msgid "For edge:"
msgstr "对于边:"

msgid "insert point:"
msgstr "插入点："

msgid "On a right hand side driving network"
msgstr "在右侧行驶网络"

msgid "Arrival to point ``-2`` can be achived only via vertex **16**."
msgstr "只能通过顶点 **16**才能到达点 ``-2``。"

msgid "Does not affects edge ``(17, 16)``, therefore the edge is kept."
msgstr "不影响边``(17, 16)``，因此边被保留。"

msgid "It only affects the edge ``(16, 17)``, therefore the edge is removed."
msgstr "它只影响边``(16, 17)``，因此边被移除。"

msgid "Create two new edges:"
msgstr "创建两条新边："

msgid ""
"Edge ``(16, -2)`` with cost ``0.4`` (original cost * fraction == :math:`1 * "
"0.4`)"
msgstr "边``(16, -2)``的成本为``0.4``（原始成本*分数==:math:`1 * 0.4`）"

msgid "Edge ``(-2, 17)`` with cost ``0.6`` (the remaing cost)"
msgstr "边``(-2, 17)``的成本为``0.6``（剩余成本）"

msgid "The total cost of the additional edges is equal to the original cost."
msgstr "附加边的总成本等于原始成本。"

msgid ""
"If more points are on the same edge, the process is repeated recursevly."
msgstr "如果同一条边上有更多点，则递归地重复该过程。"

msgid "On a left hand side driving network"
msgstr "在左侧驾驶网络上"

msgid "Arrival to point ``-2`` can be achived only via vertex **17**."
msgstr "只能通过顶点 **17 **才能到达点 ``-2`` 。"

msgid "Does not affects edge ``(16, 17)``, therefore the edge is kept."
msgstr "不影响边 ``(16, 17)``，因此保留边。"

msgid "It only affects the edge ``(17, 16)``, therefore the edge is removed."
msgstr "它只影响边 ``(17, 16)``，因此边被移除。"

msgid ""
"Work with the original edge ``(16, 17)`` as the fraction is a fraction of "
"the original:"
msgstr "使用原始边``(16, 17)``，因为分数是原始边的分数："

msgid "Flip the Edges and add them to the graph:"
msgstr "翻转边并将它们添加到图中："

msgid ""
"Edge ``(17, -2)`` becomes ``(-2, 16)`` with cost ``0.4`` and is added to the "
"graph."
msgstr "边 ``(17, -2)``变为 ``(-2, 16)``，成本为``0.4``，并添加到图中。"

msgid ""
"Edge ``(-2, 16)`` becomes ``(17, -2)`` with cost ``0.6`` and is added to the "
"graph."
msgstr "边 ``(-2, 16)`` 变为 ``(17, -2)``，成本为 ``0.6``，并添加到图中。"

msgid "When driving side does not matter"
msgstr "当驾驶侧无关紧要时"

msgid "Arrival to point ``-2`` can be achived via vertices **16** or **17**."
msgstr "可以通过顶点 **16**或 **17**到达点 ``-2`` 。"

msgid ""
"Affects the edges ``(16, 17)`` and ``(17, 16)``, therefore the edges are "
"removed."
msgstr "影响边 ``(16, 17)`` 和 ``(17, 16)``，因此边被移除。"

msgid "Create four new edges:"
msgstr "创建四个新边："

msgid "Flip the Edges and add all the edges to the graph:"
msgstr "翻转边并将所有边添加到图中："

msgid "Edge ``(16, -2)`` is added to the graph."
msgstr "边 ``(16, -2)``被添加到图中。"

msgid "Edge ``(-2, 17)`` is added to the graph."
msgstr "边``(-2, 17)``被添加到图中。"

msgid ""
"Edge ``(16, -2)`` becomes ``(-2, 16)`` with cost ``0.4`` and is added to the "
"graph."
msgstr "边 ``(16, -2)``变为 ``(-2, 16)``，成本为 0.4，并添加到图中。"

msgid ""
"Edge ``(-2, 17)`` becomes ``(17, -2)`` with cost ``0.6`` and is added to the "
"graph."
msgstr "边``(-2, 17)``变为``(17, -2)``，成本为``0.6``，并添加到图中。"

msgid "withPoints - Family of functions"
msgstr "withPoints -函数族"

msgid ""
"This family of functions belongs to the :doc:`withPoints-category` and the "
"functions that compose them are based one way or another on dijkstra "
"algorithm."
msgstr ""
"这一系列函数属于:doc:`withPoints-category`，组成它们的函数以某种方式基于 "
"dijkstra 算法。"

msgid "Depending on the name:"
msgstr "取决于名称："

msgid "pgr_withPoints is pgr_dijkstra **with points**"
msgstr "pgr_withPoints 是**带有点**的 pgr_dijkstra"

msgid "pgr_withPointsCost is pgr_dijkstraCost **with points**"
msgstr "pgr_withPointsCost 是**带有点**的 pgr_dijkstraCost"

msgid "pgr_withPointsCostMatrix is pgr_dijkstraCostMatrix **with points**"
msgstr "pgr_withPointsCostMatrix 是**带有点**的 pgr_dijkstraCostMatrix"

msgid "pgr_withPointsKSP is pgr_ksp **with points**"
msgstr "pgr_withPointsKSP 是**带有点**的 pgr_ksp"

msgid "pgr_withPointsDD is pgr_drivingDistance **with points**"
msgstr "pgr_withPointsDD 是**带有点**的 pgr_drivenDistance"

msgid "pgr_withPointsvia is pgr_dijkstraVia **with points**"
msgstr "pgr_withPointsvia 是**带有点**的 pgr_dijkstraVia"

msgid ""
"A discussion about the work of Hamilton & Kirkman can be found in the book "
"**Graph Theory (Biggs et al. 1976)**."
msgstr ""
"关于汉密尔顿和柯克曼工作的讨论可参见《**图论》（比格斯等人，1976 年）一书**。"

msgid "And :math:`n-2` choices for the third city, etc."
msgstr "第三个城市的 :math:`n-2` 选项等。"

msgid "Multiplying these together we get :math:`(n-1)! = (n-1) (n-2) . . 1`."
msgstr "相乘得到 :math:`(n-1)！= (n-1) (n-2) ..1`."

msgid ""
"To handle problems like: 10 (equal dimension) boxes of apples and 5 kg of "
"feathers that are to be transported (not packed in boxes)."
msgstr "处理以下问题：10 箱（尺寸相等）苹果和 5 千克羽毛的运输（不装箱）。"

msgid ""
"Working with cost/reverse_cost as length in degrees, x/y in lat/lon: Factor "
"= 1 (no need to change units)"
msgstr ""
"使用 cost/reverse_cost 作为长度（以度为单位），x/y 以纬度/经度为单位：因子 = "
"1（无需更改单位）"

msgid ""
"Working with cost/reverse_cost as length in meters, x/y in lat/lon: Factor = "
"would depend on the location of the points:"
msgstr ""
"使用 cost/reverse_cost 作为以米为单位的长度，以纬度/经度为单位的 x/y： "
"Factor = 将取决于点的位置："

msgid "1 longitude degree is 78846.81 m"
msgstr "1 经度为 78846.81 米"

msgid "The `agg_cost` of `(u, v)` is the same as for `(v, u)`."
msgstr "`(u, v)` 的 `agg_cost` 与 `(v, u)`相同。"

msgid "When `start_vid` = `end_vid`, the `agg_cost` = 0."
msgstr "当`start_vid` = `end_vid`时，`agg_cost`= 0。"

msgid ""
":doc:`pgr_bdDijkstraCostMatrix` - Bidirectional Dijkstra algorithm to create "
"a matrix of costs of the shortest paths."
msgstr ""
":doc:`pgr_bdDijkstraCostMatrix` - 创建最短路径成本矩阵的双向 Dijkstra 算法。"

msgid ""
"The edges :math:`v \\rightarrow w` and :math:`w \\rightarrow z` are removed "
"from the graph."
msgstr "从图中删除边 :math:`v \\rightarrow w` 和 :math:`w \\rightarrow z`。"

msgid ""
"The edges :math:`u \\rightarrow v` and :math:`v \\rightarrow z` are removed "
"from the graph."
msgstr "从图中删除边 :math:`u \\rightarrow v` 和 :math:`v \\rightarrow z`。"

msgid ""
"The **aggregate cost** of :math:`(u, v)` is the same as for :math:`(v, u)`."
msgstr ":math:`(u, v)`的**总成本**与 :math:`(v, u)`的相同。"

msgid ""
"where :math:`sql = \\{(id_i, source_i, target_i, cost_i, reverse\\_cost_i)\\}"
"`"
msgstr ""
"其中 :math:`sql =\\{(id_i, source_i, target_i, cost_i, reverse\\_cost_i)\\}`"

msgid "the set of vertices :math:`V`"
msgstr "顶点集:math:`V`"

msgid ""
"In other words: The algorithm returns a the shortest path between :math:"
"`start_{vid}` and :math:`end_{vid}`, if it exists, in terms of a sequence of "
"nodes and of edges,"
msgstr ""
"换句话说：如果:math:`start_{vid}`和:math:`end_{vid}`之间存在最短路径，算法会"
"根据节点和边的序列返回该路径、"

msgid "Capacity of the edge (``source``, ``target``)"
msgstr "边 (``source``, ``target``)的容量"

msgid "Weight of the edge (``source``, ``target``) if it exist"
msgstr "边 (``source``, ``target``)的权重（如果存在）"

msgid ":doc:`pgr_createTopology` - create a topology based on the geometry."
msgstr ":doc:`pgr_createTopology` - 根据几何形状创建拓扑。"

msgid ""
":doc:`pgr_analyzeGraph` - to analyze the edges and vertices of the edge "
"table."
msgstr ":doc:`pgr_analyzeGraph` - 分析边表的边和顶点。"

msgid ":doc:`pgr_nodeNetwork` - to create nodes to a not noded edge table."
msgstr ":doc:`pgr_nodeNetwork` -为无节点边表创建节点。"

msgid "Also ``l`` could be used as **driving side**"
msgstr "此外，``l`` 也可用作**行驶方向**"

msgid ""
"Edge :math:`2` (:math:`1 \\frac{\\;\\;\\;\\;\\;}{} 3`) is not part of the "
"graph."
msgstr "边 :math:`2` (:math:`1 \\frac{\\;\\;\\;\\;\\;}{} 3`) 不是图的一部分。"

msgid "The set of vertices :math:`V`:"
msgstr "顶点集 :math:`V`："

msgid ":math:`2` (:math:`1 \\rightarrow 3`)"
msgstr ":math:`2` (:math:`1 \\rightarrow 3`)"

msgid ":math:`3` (:math:`3 \\rightarrow 2`)"
msgstr ":math:`3` (:math:`3 \\rightarrow 2`)"

msgid ":math:`2` (:math:`1 \\frac{\\;\\;\\;\\;\\;}{} 3`)"
msgstr ":math:`2` (:math:`1 \\frac{\\;\\;\\;\\;\\;}{} 3`)"

msgid ":math:`3` (:math:`3 \\frac{\\;\\;\\;\\;\\;}{} 2`)"
msgstr ":math:`3` (:math:`3 \\frac{\\;\\;\\;\\;\\;}{} 2`)"

msgid ""
"Personal relationships, genealogy, file dependency problems can be solved "
"using pgRouting. Those problems, normally, do not come with geometries "
"associated with the graph."
msgstr ""
"使用 pgRouting 可以解决个人关系、家谱和文件依赖性问题。这些问题通常不会与图形"
"相关的几何图形一起出现。"

msgid "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vid** [, ``directed``])"
msgstr ""
"pgr_dijkstra(`Edges SQL`_, **start vid**, **end vid** [, ``directed``])"

msgid ""
"When ``true`` departing from a visited vertex will not try to avoid using "
"the edge used to reach it. In other words, U turn using the edge with same "
"identifier is allowed."
msgstr ""
"当 为``true``时，从已访问的顶点出发，不会试图避免使用用于到达它的边。换句话"
"说，允许使用具有相同标识符的边来进行掉头。"

msgid ""
"When ``false`` when a departing from a visited vertex tries to avoid using "
"the edge used to reach it. In other words, U turn using the edge with same "
"identifier is used when no other path is found."
msgstr ""
"当为``false``时，从已访问的顶点出发，尝试避免使用用于到达它的边。换句话说，只"
"有在找不到其他路径时才使用具有相同标识符的边来进行掉头。"

msgid "Returned on `Many to One`_ and `Many to Many`_"
msgstr "`多对一`_和 `多对多`_的返回值"

msgid ""
"Edit an existing `pgRouting Wiki <https://github.com/pgRouting/pgrouting/"
"wiki>`__ page."
msgstr ""
"编辑现有的 `pgRouting 维基 <https://github.com/pgRouting/pgrouting/wiki>`__ "
"页面。"

msgid ""
"And all the people that give us a little of their time making comments, "
"finding issues, making pull requests etc. in any of our products: "
"osm2pgrouting, pgRouting, pgRoutingLayer, workshop."
msgstr ""
"还有所有为我们的产品（osm2pgrouting、pgRouting、pgRoutingLayer、workshop）提"
"供意见、发现问题、提出拉取请求等的人们。"

msgid ""
"The minimum value of the ``agg_cost`` all instances of edge `(u, v)` is "
"going to be considered as the ``agg_cost`` of edge `(u, v)`"
msgstr "边 `(u, v)` 的所有实例的 ``agg_cost`` 最小值将被视为边 `(u, v)` 的 "
"``agg_cost``"

msgid ""
"Visualy, The first image is the `optimal solution <https://www.math."
"uwaterloo.ca/tsp/world/witour.html>`__ and the second image is the solution "
"obtained with ``pgr_TSPeuclidean``."
msgstr ""
"从视觉上看，第一幅图像是 `最优解 <https://www.math.uwaterloo.ca/tsp/world/"
"witour.html>`__ ，第二幅图像是使用 ``pgr_TSPeuclidean``获得的解。"

msgid ""
"The edge table to be analyzed must contain a source column and a target "
"column filled with id's of the vertices of the segments and the "
"corresponding vertices table <edge_table>_vertices_pgr that stores the "
"vertices information."
msgstr ""
"待分析的边表必须包含源列和目标列，其中填充了线段顶点的id以及对应的存储顶点信"
"息的顶点表<edge_table>_vertices_pgr。"

msgid ""
"``text`` Target column name of the network table. Default value is "
"``target``."
msgstr "``text``网络表的Target列名称。 默认值为 ``target``。"

msgid ""
"``text`` Condition to select a subset or rows. Default value is ``true`` to "
"indicate all rows."
msgstr "``text`` 用于选择子集或行的条件。默认值为``true``，表示选择所有行。"

msgid ""
"Returns the analysis of the section of the network defined by ``rows_where``"
msgstr "返回由``rows_where`` 定义的网络部分的分析结果"

msgid "``integer`` Indicator that the vertex might have a problem."
msgstr "``integer``指示顶点可能有问题。"

msgid ""
"``boolean`` flag to treat oneway NULL values as bi-directional. Default "
"value is ``true``."
msgstr "``boolean``将单向 NULL 值视为双向的标志。 默认值为 ``true``。"

msgid ""
"``integer`` Indicator that the vertex might have a problem. See :doc:"
"`pgr_analyzeGraph <pgr_analyzeGraph>`."
msgstr ""
"``integer``指示顶点可能有问题。 请参阅 :doc:`pgr_analyzeGraph "
"<pgr_analyzeGraph>`。"

msgid ""
"It is well-known that the shortest paths between a single source and all "
"other vertices can be found using Breadth First Search in :math:`O(|E|)` in "
"an unweighted graph, i.e. the distance is the minimal number of edges that "
"you need to traverse from the source to another vertex. We can interpret "
"such a graph also as a weighted graph, where every edge has the weight :math:"
"`1`. If not alledges in graph have the same weight, that we need a more "
"general algorithm, like Dijkstra's Algorithm which runs in :math:`O(|E|log|"
"V|)` time."
msgstr ""
"众所周知，在无权重图中，使用广度优先搜索（Breadth First Search）可以在 :math:"
"`O(|E|)`内找到单个源点与所有其他顶点之间的最短路径，也就是说，距离是指从源点"
"到另一个顶点所需的最少边数。我们也可以把这样的图解释为加权图，其中每条边的权"
"重为 :math:`1`。如果图中不是所有边的权重都相同，我们就需要一种更通用的算法，"
"比如 Dijkstra 算法，它的运行时间为 :math:`O(|E|log|V||)`。"

msgid ""
"The algorithm checks graph is bipartite or not. If it is bipartite then it "
"returns the node along with two colors `0` and `1` which represents two "
"different sets."
msgstr ""
"该算法检查图是否是二分图。 如果它是二分的，那么它返回节点以及代表两个不同集合"
"的两种颜色 `0` 和`1`。"

msgid "Returns set of |result-contract|"
msgstr "Returns set of |result-toposort|"

msgid ""
"``text`` Condition to SELECT a subset or rows. Default value is ``true`` to "
"indicate all rows that where ``source`` or ``target`` have a null value, "
"otherwise the condition is used."
msgstr ""
"``text`` 用于选择行的条件。默认值为``true`` ，表示选择所有具有空值的 "
"``source``或``target`` 的行，否则将使用指定的条件。"

msgid "``boolean`` Clean any previous topology. Default value is ``false``."
msgstr "``boolean`` 清除先前的拓扑。默认值为 ``false``。"

msgid ""
"``integer`` Indicator that the vertex might have a problem. See :doc:"
"`pgr_analyzeGraph`."
msgstr "``integer``指示顶点可能有问题。 请参阅 :doc:`pgr_analyzeGraph`。"

msgid ""
"The reconstruction of the vertices table function accepts the following "
"parameters:"
msgstr "顶点表重建函数接受以下参数："

msgid ""
"``text`` Condition to SELECT a subset or rows. Default value is ``true`` to "
"indicate all rows."
msgstr "``text`` 用于选择行的条件。默认值为 ``true`` 表示选择所有行。"

msgid ""
":doc:`topology-functions` for an overview of a topology for routing "
"algorithms."
msgstr ":doc:`topology-functions`用于路由算法的拓扑概述。"

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vid**, **end vid**)"
msgstr "pgr_dagShortestPath(`Edges SQL`_, **start vid**, **end vid**)"

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vid**, **end vids**)"
msgstr "pgr_dagShortestPath(`Edges SQL`_, **start vid**, **end vids**)"

msgid "From vertex :math:`5` to vertex :math:`11` on a **directed** graph"
msgstr "在**有向**图上，从顶点:math:`5`到顶点 :math:`11`"

msgid ""
"pgr_drivingDistance(`Edges SQL`_, **Root vid**, **distance**, [``directed``])"
msgstr ""
"pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"

msgid ""
"the chromatic number :math:`x'(G)` (minimum number of colors needed for "
"proper edge coloring of graph) is equal to the degree :math:`\\Delta + 1` of "
"the graph, (:math:`x'(G) = \\Delta`)"
msgstr ""
"色数（chromatic number）:math:`x'(G)`（用于图的适当边着色所需的最小颜色数）等"
"于图的度:math:`\\Delta + 1`（:math:`x'(G) = \\Delta`）"

msgid ""
"``pgr_edwardMoore`` — Returns the shortest path using Edward-Moore algorithm."
msgstr "`pgr_edwardMoore`` - 使用 Edward-Moore 算法返回最短路径。"

msgid ""
"The geometry ``geom``, marked as **g1** and **g2** are the **original "
"points**"
msgstr ""

msgid ""
"``pgr_hawickCircuits`` — Returns the list of cirucits using hawick circuits "
"algorithm."
msgstr "``pgr_hawickCircuits`` — 使用 Hawick 回路算法返回回路列表。"

msgid "The output table will have for ``edge_table_noded``"
msgstr "输出表中将包含``edge_table_noded``内容"

msgid "From vertex :math:`6` to vertex :math:`10` on an undirected graph."
msgstr "从无向图上的顶点 :math:`6` 到顶点 :math:`10`."

msgid "From vertex :math:`3` to vertex :math:`8` on a directed graph"
msgstr "从有向图上的顶点 :math:`3` 到顶点 :math:`8`"

msgid "From vertex :math:`3` to vertex :math:`8` on an undirected graph"
msgstr "从无向图上的顶点 :math:`3` 到顶点 :math:`8`"

msgid "From vertex :math:`3` to vertex :math:`8` with more alternatives"
msgstr "从顶点 :math:`3` 到顶点 :math:`8` 更多选择"

#, fuzzy
msgid ""
"From point :math:`1` and vertex :math:`6` to point :math:`3` and vertex :"
"math:`1`"
msgstr "从点:math:`1`和顶点 :math:`6`到点 :math:`3`和顶点:math:`1`。"

msgid "**options:** ``[directed, driving_side]``"
msgstr "**options:** ``[directed, driving_side]``"

msgid ""
"From point :math:`15` and vertex :math:`6` to point :math:`3` and vertex :"
"math:`1`"
msgstr "从点 :math:`15` 和顶点 :math:`6` 到点 :math:`3` 和顶点 :math:`1`"

msgid "**options:** ``[directed, heap_paths, details]``"
msgstr "**options:** ``[directed, heap_paths, details]``"

msgid ""
"`#232 <https://github.com/pgRouting/pgrouting/issues/232>`__: Honor client "
"cancel requests in C /C++ code"
msgstr ""
"`#232 <https://github.com/pgRouting/pgrouting/issues/232>`__：在 C /C++ "
"代码中尊重客户端取消请求"

msgid "pgr_labelGraph - Use the components family of functions instead."
msgstr ""

msgid "pgr_dijkstra -- to match what is documented"
msgstr ""

msgid "pgr_apspWarshall use pgr_floydWarshall instead"
msgstr ""

msgid "pgr_apspJohnson use pgr_Johnson instead"
msgstr ""

#, fuzzy
msgid "Starting on PostgreSQL 12::"
msgstr "创建 PostgreSQL 角色"

msgid "Result columns"
msgstr "结果列"

msgid "Returns set of ``(seq, depth, start_vid, node, edge, cost, agg_cost)``"
msgstr "返回一组``(seq, depth, start_vid, node, edge, cost, agg_cost)``"

msgid "aStar optional parameters"
msgstr "aStar 可选参数"

#, fuzzy
msgid "Returns set of ``(vertex_id, color_id)``"
msgstr "返回``(vertex_id, color_id)``的集合"

msgid "Returns set of ``(edge_id, color_id)``"
msgstr "返回 ``(edge_id, color_id)`` 的集合"

msgid "Returns set of |result-spantree|"
msgstr "Returns set of |result-spantree| 返回结果树集"

msgid "Be aware of the existance of the additional result Columns."
msgstr "注意附加结果列的存在。"

msgid ":doc:`sampledata`: a small graph used in the documentation examples"
msgstr ":doc:`sampledata`: 文档示例中使用的小图形"

msgid ""
"Capacity information, used in the :doc:`flow-family` functions does not need "
"to change when splitting edges."
msgstr "分割边时，在 :doc:`flow-family` 函数中使用的容量信息不需要改变。"

msgid "Used in combination signatures"
msgstr "结合签名使用"

msgid "Result columns for a path"
msgstr "路径的结果列"

msgid "Used in functions that return one path solution"
msgstr "在返回一个路径解的函数中使用"

#, fuzzy
msgid "Used in functions the following:"
msgstr "用于以下函数："

msgid "Result columns for cost functions"
msgstr "成本函数结果列"

msgid "Result columns for flow functions"
msgstr "流量函数的结果列"

msgid "Result columns for spanning tree functions"
msgstr "生成树函数的结果列"

#, fuzzy
msgid "Returns set of ``(edge, cost)``"
msgstr "返回集合``(edge, cost)``"

msgid "Result columns standarized to: |nksp-result|"
msgstr "结果列标准化为|nksp-result|"

msgid "Returns set of |tsp-result|"
msgstr "返回 |tsp-result| 的集合"

#, fuzzy
msgid "Returns set of |short-generic-result|"
msgstr "返回集合|nksp-result|"

msgid "Returns set of |matrix-result|"
msgstr "返回 |matrix-result| 的集合"

msgid "Result columns change: ``seq`` is removed"
msgstr "结果列更改：删除了 ``seq``"

msgid "Returns set of |old-generic-result|"
msgstr "返回 |old-generic-result| 的集合"

msgid "Returns set of |result-1-1|"
msgstr "返回 |result-1-1| 的集合"

msgid "Returns set of |result-1-m|"
msgstr "返回 |result-1-m| 的集合"

msgid "Returns set of |result-m-1|"
msgstr "返回 |result-m-1| 的集合"

msgid "Result columns change:"
msgstr "结果列发生变化："

#, fuzzy
msgid "Returns set of |result-node-color|"
msgstr "Returns set of |result-node|"

#, fuzzy
msgid "Returns set of |result-flow|"
msgstr "Returns set of |result-node|"

msgid "Returns set of |result-bfs|"
msgstr "返回 |result-bfs| 的集合"

msgid "Returns set of |result-1-1-no-seq|"
msgstr "返回|result-1-1-no-seq|的集合"

msgid "We get the sameresult as the simplest way to use the function."
msgstr "我们得到的结果与使用该函数的最简单方法相同。"

#, fuzzy
msgid "Returns set of |result-node-order|"
msgstr "Returns set of |result-node|"

msgid "Returns set of ``(seq, node)``"
msgstr "返回 ``(seq, node)`` 的集合"

msgid "Returns set of |via-result|"
msgstr "返回 |via-result| 的集合"

#, fuzzy
msgid "Returns set of |result-edge-color|"
msgstr "Returns set of |result-edge|"

#, fuzzy
msgid "Returns set of |result-disjoint|"
msgstr "Returns set of |result-toposort|"

msgid "Returns set of |result-disjoint-1-1|"
msgstr "返回 |result-disjoint-1-1|的集合"

msgid "Returns set of |result-disjoint-1-m|"
msgstr "返回|result-disjoint-1-m|的集合"

#, fuzzy
msgid "Returns set of |result-disjoint-m-1|"
msgstr "Returns set of |result-toposort|"

msgid "Returns set of |result-disjoint-m-m|"
msgstr "返回|result-disjoint-m-m|的集合"

msgid "Returns set of |generic-result|"
msgstr "返回 |eneric-result| 的集合"

msgid "Returns set of |result-mst|"
msgstr "返回 |result-mst| 的集合"

msgid "Returns set of |result-idom|"
msgstr "返回 |result-idom| 的集合"

#, fuzzy
msgid "Returns set of |result-lineg|"
msgstr "Returns set of |result-node|"

msgid "Returns set of |result-linegf|"
msgstr "返回 |result-linegf| 的集合"

msgid "Returns set of |result-flow-mincost|"
msgstr "返回 |result-flow-mincost| 的集合"

msgid "Before image"
msgstr "图片前"

msgid "After image"
msgstr "图像后"

msgid "Returns set of |result-pickdrop|"
msgstr "返回 |result-pickdrop| 的集合"

msgid "Returns set of |result-mincut|"
msgstr "返回|result-mincut|的集合"

#, fuzzy
msgid "Returns set of |result-closure|"
msgstr "Returns set of |result-node|"

#, fuzzy
msgid "New proposed signatures"
msgstr "新拟议的签名："

#, fuzzy
msgid "Deprecated signatures"
msgstr "弃用签名："

#, fuzzy
msgid "New prototypes"
msgstr "新原型："

msgid "Returns set of |ksp-result|"
msgstr "返回 |ksp-result| 的集合"

msgid "Returns set of |old-pid-result|"
msgstr "返回 |old-pid-result| 的集合"

msgid "Returns set of |pid-1-m|"
msgstr "返回 |pid-1-m| 的集合"

msgid "Returns set of |pid-m-1|"
msgstr "返回 |pid-m-1| 的集合"

msgid "Returns set of |pid-m-m|"
msgstr "返回 |pid-m-m| 的集合"

msgid "Returns set of |matrix-pid|"
msgstr "返回|matrix-pid|的集合"

msgid ""
"Point :math:`-1` corresponds to the closest edge from point :math:`(2.9, "
"1.8)`."
msgstr "点 :math:`-1` 对应距离点 :math:`(2.9, 1.8)` 最近的边。"

msgid ""
"Point :math:`-2` corresponds to the next close edge from point :math:`(2.9, "
"1.8)`."
msgstr "点 :math:`-2` 对应于点 :math:`(2.9, 1.8)` 的下一条近边。"

#, fuzzy
msgid "New overload functions"
msgstr "新的重载函数："

msgid "Backport issue fixes"
msgstr ""

msgid "Renamed functions"
msgstr "重新命名的功能"

msgid "Deprecated Function"
msgstr "已废弃的功能"

msgid "Proposed Functionality"
msgstr "建议的功能"

msgid "Renamed and Deprecated Function"
msgstr ""

msgid "**Used in:**"
msgstr "**用于：**"

msgid "Used in all Via functions"
msgstr "用于所有 Via 功能"

msgid ""
"That information is correct, for example, when in terms of vehicles, is it a "
"tunnel or bridge crossing over another road."
msgstr "这些信息是正确的，例如，就车辆而言，是隧道还是横跨另一条道路的桥梁。"

msgid "RETURNS SET OF |result-node-color|"
msgstr "RETURNS SET OF |result-node-color|"

msgid "RETURNS SET OF |result-flow|"
msgstr "RETURNS SET OF |result-flow|"

msgid "RETURNS SET OF |result-bfs|"
msgstr "RETURNS SET OF |result-bfs|"

msgid "RETURNS SET OF |result-edge|"
msgstr "RETURNS SET OF |result-edge|"

msgid "RETURNS SET OF |result-1-1-no-seq|"
msgstr "RETURNS SET OF |result-1-1-no-seq|"

msgid "RETURNS SET OF |result-component-V|"
msgstr "RETURNS SET OF |result-component-V|"

msgid "RETURNS SET OF |result-contract|"
msgstr "RETURNS SET OF |result-contract|"

msgid "``text`` Network table name. (may contain the schema name AS well)"
msgstr "``text``网络表名称。（可能包括模式名称）"

msgid "When the arguments are given in the order described:"
msgstr "当参数按描述的顺序给出时："

msgid "We get the same result AS the simplest way to use the function."
msgstr "我们得到与使用该函数的最简单方法相同的结果。"

msgid ""
"The vertices table is a requierment of the :doc:`pgr_analyzeGraph` and the :"
"doc:`pgr_analyzeOneWay` functions."
msgstr ""
"顶点表是 :doc:`pgr_analyzeGraph`和 :doc:`pgr_analyzeOneWay` 函数的必需条件。"

msgid "RETURNS SET OF |result-node-order|"
msgstr "RETURNS SET OF |result-node-order|"

msgid ""
"The results can be used as base code to make a refinement based on the back "
"end development needs."
msgstr "结果可以作为基础代码，根据后端开发需求进行细化。"

msgid ""
"The subway stations are on the following vertices :math:`\\{ 1, 10, 11\\}`"
msgstr "地铁站位于以下顶点上 :math:``{ 1, 10, 11\\}`"

msgid "RETURNS SET OF |via-result|"
msgstr "返回 |via-result| 的集合"

msgid "RETURNS SET OF |result-spantree|"
msgstr "RETURNS SET OF |result-spantree|"

msgid "Weight of the edge  (``source``, ``target``)"
msgstr "边(``source``, ``target``)的权重"

msgid ""
"``text``  Geometry column name of the network table. Default value is "
"``the_geom``."
msgstr "``text``网络表的几何列名称。 默认值为 ``the_geom``。"

msgid ""
"``text``  Primary key column name of the network table. Default value is "
"``id``."
msgstr "``text``网络表的主键列名称。 默认值为``id``。"

msgid "From vertex :math:`6` to vertex  :math:`10` on a **directed** graph"
msgstr "在**有向**图上从顶点 :math:`6`到顶点 :math:`10`"

msgid ""
"From point :math:`1` and vertex :math:`6`  to point :math:`3` and vertex :"
"math:`1`"
msgstr "从点 :math:`1`和顶点 :math:`6`到点:math:`3`和顶点 :math:`1`"
