# SOME DESCRIPTIVE TITLE.
# Copyright (C) pgRouting Contributors - Version v3.8
# This file is distributed under the same license as the pgRouting package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pgRouting v3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-17 02:15+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

msgid "BFS - Category"
msgstr ""

msgid ":doc:`pgr_kruskalBFS`"
msgstr ""

msgid ":doc:`pgr_primBFS`"
msgstr ""

msgid "Traversal using breadth first search."
msgstr ""

msgid "It's implementation is only on **undirected** graph."
msgstr ""

msgid "Process is done only on edges with positive costs."
msgstr ""

msgid "When the graph is connected"
msgstr ""

msgid "The resulting edges make up a tree"
msgstr ""

msgid "When the graph is not connected,"
msgstr ""

msgid "Finds a minimum spanning tree for each connected component."
msgstr ""

msgid "The resulting edges make up a forest."
msgstr ""

msgid "Parameters"
msgstr ""

msgid "Parameter"
msgstr ""

msgid "Type"
msgstr ""

msgid "Description"
msgstr ""

msgid "`Edges SQL`_"
msgstr ""

msgid "``TEXT``"
msgstr ""

msgid "`Edges SQL`_ as described below."
msgstr ""

msgid "**root vid**"
msgstr ""

msgid "``BIGINT``"
msgstr ""

msgid "Identifier of the root vertex of the tree."
msgstr ""

msgid ""
"When value is :math:`0` then gets the spanning forest starting in "
"aleatory nodes for each tree in the forest."
msgstr ""

msgid "**root vids**"
msgstr ""

msgid "``ARRAY`` [ **ANY-INTEGER** ]"
msgstr ""

msgid "Array of identifiers of the root vertices."
msgstr ""

msgid ":math:`0` values are ignored"
msgstr ""

msgid "For optimization purposes, any duplicated value is ignored."
msgstr ""

msgid "Where:"
msgstr ""

msgid "ANY-INTEGER"
msgstr ""

msgid "SMALLINT, INTEGER, BIGINT"
msgstr ""

msgid "ANY-NUMERIC"
msgstr ""

msgid "SMALLINT, INTEGER, BIGINT, REAL, FLOAT, NUMERIC"
msgstr ""

msgid "BFS optional parameters"
msgstr ""

msgid "Default"
msgstr ""

msgid "``max_depth``"
msgstr ""

msgid ":math:`9223372036854775807`"
msgstr ""

msgid "Upper limit of the depth of the tree."
msgstr ""

msgid "When negative throws an error."
msgstr ""

msgid "Inner Queries"
msgstr ""

msgid "Edges SQL"
msgstr ""

msgid "Column"
msgstr ""

msgid "``id``"
msgstr ""

msgid "**ANY-INTEGER**"
msgstr ""

msgid "Identifier of the edge."
msgstr ""

msgid "``source``"
msgstr ""

msgid "Identifier of the first end point vertex of the edge."
msgstr ""

msgid "``target``"
msgstr ""

msgid "Identifier of the second end point vertex of the edge."
msgstr ""

msgid "``cost``"
msgstr ""

msgid "**ANY-NUMERICAL**"
msgstr ""

msgid "Weight of the edge (``source``, ``target``)"
msgstr ""

msgid "``reverse_cost``"
msgstr ""

msgid "-1"
msgstr ""

msgid "Weight of the edge (``target``, ``source``)"
msgstr ""

msgid ""
"When negative: edge (``target``, ``source``) does not exist, therefore "
"it's not part of the graph."
msgstr ""

msgid "``SMALLINT``, ``INTEGER``, ``BIGINT``"
msgstr ""

msgid "ANY-NUMERICAL"
msgstr ""

msgid "``SMALLINT``, ``INTEGER``, ``BIGINT``, ``REAL``, ``FLOAT``"
msgstr ""

msgid "Result columns"
msgstr ""

msgid "Returns set of ``(seq, depth, start_vid, node, edge, cost, agg_cost)``"
msgstr ""

msgid "``seq``"
msgstr ""

msgid "Sequential value starting from :math:`1`."
msgstr ""

msgid "``depth``"
msgstr ""

msgid "Depth of the ``node``."
msgstr ""

msgid ":math:`0` when ``node`` = ``start_vid``."
msgstr ""

msgid "``start_vid``"
msgstr ""

msgid "Identifier of the root vertex."
msgstr ""

msgid "``node``"
msgstr ""

msgid "Identifier of ``node`` reached using ``edge``."
msgstr ""

msgid "``edge``"
msgstr ""

msgid "Identifier of the ``edge`` used to arrive to ``node``."
msgstr ""

msgid ":math:`-1` when ``node`` = ``start_vid``."
msgstr ""

msgid "``FLOAT``"
msgstr ""

msgid "Cost to traverse ``edge``."
msgstr ""

msgid "``agg_cost``"
msgstr ""

msgid "Aggregate cost from ``start_vid`` to ``node``."
msgstr ""

msgid "See Also"
msgstr ""

msgid ""
"`Boost: Prim's algorithm "
"<https://www.boost.org/libs/graph/doc/prim_minimum_spanning_tree.html>`__"
msgstr ""

msgid ""
"`Boost: Kruskal's algorithm "
"<https://www.boost.org/libs/graph/doc/kruskal_min_spanning_tree.html>`__"
msgstr ""

#, python-format
msgid ""
"`Wikipedia: Prim's algorithm "
"<https://en.wikipedia.org/wiki/Prim%27s_algorithm>`__"
msgstr ""

msgid ""
"`Wikipedia: Kruskal's algorithm "
"<https://en.wikipedia.org/wiki/Kruskal's_algorithm>`__"
msgstr ""

msgid "Indices and tables"
msgstr ""

msgid ":ref:`genindex`"
msgstr ""

msgid ":ref:`search`"
msgstr ""

msgid "DFS - Category"
msgstr ""

msgid "Traversal using Depth First Search."
msgstr ""

msgid ":doc:`pgr_kruskalDFS`"
msgstr ""

msgid ":doc:`pgr_primDFS`"
msgstr ""

msgid "Proposed"
msgstr ""

msgid "Proposed functions for next mayor release."
msgstr ""

msgid "They are not officially in the current release."
msgstr ""

msgid "Code has been reviewed therefore is not experimental."
msgstr ""

msgid "Name, signature and functionality might not change."
msgstr ""

msgid "pgTap tests have being done. But might need more."
msgstr ""

msgid "Documentation might need refinement."
msgstr ""

msgid ":doc:`pgr_depthFirstSearch` - Depth first search traversal of the graph."
msgstr ""

msgid "In general:"
msgstr ""

msgid "K shortest paths - Category"
msgstr ""

msgid ":doc:`pgr_KSP` - Yen's algorithm based on pgr_dijkstra"
msgstr ""

msgid ":doc:`pgr_withPointsKSP` - Yen's algorithm based on pgr_withPoints"
msgstr ""

msgid "TRSP - Family of functions"
msgstr ""

msgid "When points are also given as input:"
msgstr ""

msgid ":doc:`pgr_trsp` - Routing with restrictions."
msgstr ""

msgid ":doc:`pgr_trspVia` - Via Vertices routing with restrictions."
msgstr ""

msgid ":doc:`pgr_trsp_withPoints` - Vertex/Point routing with restrictions."
msgstr ""

msgid ""
":doc:`pgr_trspVia_withPoints` - Via Vertex/point routing with "
"restrictions."
msgstr ""

msgid "Experimental"
msgstr ""

msgid "Experimental functions"
msgstr ""

msgid "They are not officially of the current release."
msgstr ""

msgid "They likely will not be officially be part of the next release:"
msgstr ""

msgid "The functions might not make use of ANY-INTEGER and ANY-NUMERICAL"
msgstr ""

msgid "Name might change."
msgstr ""

msgid "Signature might change."
msgstr ""

msgid "Functionality might change."
msgstr ""

msgid "pgTap tests might be missing."
msgstr ""

msgid "Might need c/c++ review."
msgstr ""

msgid "Documentation if any might need to be rewritten."
msgstr ""

msgid "Might need a lot of feedback from the community."
msgstr ""

msgid ":doc:`pgr_turnRestrictedPath` - Routing with restrictions."
msgstr ""

msgid "Introduction"
msgstr ""

msgid ""
"Road restrictions are a sequence of road segments that can not be taken "
"in a sequential manner. Some restrictions are implicit on a directed "
"graph, for example, one way roads where the wrong way edge is not even "
"inserted on the graph. But normally on turns like no left turn or no "
"right turn, hence the name turn restrictions, there are sometimes "
"restrictions."
msgstr ""

msgid "TRSP algorithm"
msgstr ""

msgid ""
"The internal TRSP algorithm performs a lookahead over the dijkstra "
"algorithm in order to find out if the attempted path has a restriction. "
"This allows the algorithm to pass twice on the same vertex."
msgstr ""

msgid "`Edges SQL`_ query as described."
msgstr ""

msgid "`Restrictions SQL`_"
msgstr ""

msgid "`Restrictions SQL`_ query as described."
msgstr ""

msgid "**via vertices**"
msgstr ""

msgid "``ARRAY[`` **ANY-INTEGER** ``]``"
msgstr ""

msgid "Array of ordered vertices identifiers that are going to be visited."
msgstr ""

msgid "Restrictions"
msgstr ""

msgid ""
"On road networks, there are restrictions such as left or right turn "
"restrictions, no U turn restrictions."
msgstr ""

msgid ""
"A restriction is a sequence of edges, called path and that path is to be "
"avoided."
msgstr ""

msgid "**Restrictions on the road network**"
msgstr ""

msgid "These restrictions are represented on a table as follows:"
msgstr ""

msgid ""
"The table has an identifier, which maybe is needed for the administration"
" of the restrictions, but the algorithms do not need that information. If"
" given it will be ignored."
msgstr ""

msgid "Restrictions SQL"
msgstr ""

msgid "``path``"
msgstr ""

msgid "``ARRAY`` [**ANY-INTEGER**]"
msgstr ""

msgid ""
"Sequence of edge identifiers that form a path that is not allowed to be "
"taken. - Empty arrays or ``NULL`` arrays are ignored. - Arrays that have "
"a ``NULL`` element will raise an exception."
msgstr ""

msgid "``Cost``"
msgstr ""

msgid "Cost of taking the forbidden path."
msgstr ""

msgid "Traveling Sales Person - Family of functions"
msgstr ""

msgid ":doc:`pgr_TSP` - When input is given as matrix cell information."
msgstr ""

msgid ":doc:`pgr_TSPeuclidean` - When input are coordinates."
msgstr ""

msgid "Table of Contents"
msgstr ""

msgid "General Information"
msgstr ""

msgid "Problem Definition"
msgstr ""

msgid "The travelling salesperson problem (TSP) asks the following question:"
msgstr ""

msgid ""
"*Given a list of cities and the distances between each pair of cities, "
"which is the shortest possible route that visits each city exactly once "
"and returns to the origin city?*"
msgstr ""

msgid "Origin"
msgstr ""

msgid ""
"The traveling sales person problem was studied in the 18th century by "
"mathematicians **Sir William Rowam Hamilton** and **Thomas Penyngton "
"Kirkman**."
msgstr ""

msgid ""
"A discussion about the work of Hamilton & Kirkman can be found in the "
"book **Graph Theory (Biggs et al. 1976)**."
msgstr ""

msgid "ISBN-13: 978-0198539162"
msgstr ""

msgid "ISBN-10: 0198539169"
msgstr ""

msgid ""
"It is believed that the general form of the TSP have been first studied "
"by Kalr Menger in Vienna and Harvard. The problem was later promoted by "
"Hassler, Whitney & Merrill at Princeton. A detailed description about the"
" connection between Menger & Whitney, and the development of the TSP can "
"be found in `On the history of combinatorial optimization (till 1960) "
"<https://homepages.cwi.nl/~lex/files/histco.ps>`__"
msgstr ""

msgid "To calculate the number of different tours through :math:`n` cities:"
msgstr ""

msgid "Given a starting city,"
msgstr ""

msgid "There are :math:`n-1` choices for the second city,"
msgstr ""

msgid "And :math:`n-2` choices for the third city, etc."
msgstr ""

msgid "Multiplying these together we get :math:`(n-1)! = (n-1) (n-2) . . 1`."
msgstr ""

msgid ""
"Now since the travel costs do not depend on the direction taken around "
"the tour:"
msgstr ""

msgid "this number by 2"
msgstr ""

msgid ":math:`(n-1)!/2`."
msgstr ""

msgid "Characteristics"
msgstr ""

msgid "This problem is an NP-hard optimization problem."
msgstr ""

msgid "Metric Algorithm is used"
msgstr ""

msgid ""
"Implementation generates solutions that *are twice as long as the optimal"
" tour in the worst case*:"
msgstr ""

msgid "Graph characteristics for best performance:"
msgstr ""

msgid "Graph is undirected"
msgstr ""

msgid "Graph is fully connected"
msgstr ""

msgid "Graph where traveling costs on edges obey the triangle inequality."
msgstr ""

msgid "The traveling costs are symmetric:"
msgstr ""

msgid ""
"Traveling costs from ``u`` to ``v`` are just as much as traveling from "
"``v`` to ``u``"
msgstr ""

msgid "TSP optional parameters"
msgstr ""

msgid "``start_id``"
msgstr ""

msgid "``0``"
msgstr ""

msgid "The first visiting vertex"
msgstr ""

msgid "When `0` any vertex can become the first visiting vertex."
msgstr ""

msgid "``end_id``"
msgstr ""

msgid "Last visiting vertex before returning to ``start_vid``."
msgstr ""

msgid ""
"When ``0`` any vertex can become the last visiting vertex before "
"returning to ``start_id``."
msgstr ""

msgid "When ``NOT 0`` and ``start_id = 0`` then it is the first and last vertex"
msgstr ""

msgid "References"
msgstr ""

msgid ""
"`Boost: metric TSP approx "
"<https://www.boost.org/libs/graph/doc/metric_tsp_approx.html>`__"
msgstr ""

msgid "`University of Waterloo TSP <https://www.math.uwaterloo.ca/tsp/>`__"
msgstr ""

msgid ""
"`Wikipedia: Traveling Salesman Problem "
"<https://en.wikipedia.org/wiki/Traveling_salesman_problem>`__"
msgstr ""

msgid "Vehicle Routing Functions - Category"
msgstr ""

msgid "Pickup and delivery problem"
msgstr ""

msgid ":doc:`pgr_pickDeliver` - Pickup & Delivery using a Cost Matrix"
msgstr ""

msgid ""
":doc:`pgr_pickDeliverEuclidean` - Pickup & Delivery with Euclidean "
"distances"
msgstr ""

msgid "Distribution problem"
msgstr ""

msgid ":doc:`pgr_vrpOneDepot` - From a single depot, distributes orders"
msgstr ""

msgid "Contents"
msgstr ""

msgid ""
"Vehicle Routing Problems `VRP` are **NP-hard** optimization problem, it "
"generalises the travelling salesman problem (TSP)."
msgstr ""

msgid "The objective of the VRP is to minimize the total route cost."
msgstr ""

msgid "There are several variants of the VRP problem,"
msgstr ""

msgid "**pgRouting does not try to implement all variants.**"
msgstr ""

msgid ""
"Capacitated Vehicle Routing Problem `CVRP` where The vehicles have "
"limited carrying capacity of the goods."
msgstr ""

msgid ""
"Vehicle Routing Problem with Time Windows `VRPTW` where the locations "
"have time windows within which the vehicle's visits must be made."
msgstr ""

msgid ""
"Vehicle Routing Problem with Pickup and Delivery `VRPPD` where a number "
"of goods need to be moved from certain pickup locations to other delivery"
" locations."
msgstr ""

msgid "Limitations"
msgstr ""

msgid "No multiple time windows for a location."
msgstr ""

msgid "Less vehicle used is considered better."
msgstr ""

msgid "Less total duration is better."
msgstr ""

msgid "Less wait time is better."
msgstr ""

msgid "Pick & Delivery"
msgstr ""

msgid ""
"Problem: `CVRPPDTW` Capacitated Pick and Delivery Vehicle Routing problem"
" with Time Windows"
msgstr ""

msgid "Times are relative to `0`"
msgstr ""

msgid "The vehicles"
msgstr ""

msgid "have start and ending service duration times."
msgstr ""

msgid "have opening and closing times for the start and ending locations."
msgstr ""

msgid "have a capacity."
msgstr ""

msgid "The orders"
msgstr ""

msgid "Have pick up and delivery locations."
msgstr ""

msgid "Have opening and closing times for the pickup and delivery locations."
msgstr ""

msgid "Have pickup and delivery duration service times."
msgstr ""

msgid ""
"have a demand request for moving goods from the pickup location to the "
"delivery location."
msgstr ""

msgid "Time based calculations:"
msgstr ""

msgid "Travel time between customers is :math:`distance / speed`"
msgstr ""

msgid "Pickup and delivery order pair is done by the same vehicle."
msgstr ""

msgid "A pickup is done before the delivery."
msgstr ""

msgid "Pick & deliver"
msgstr ""

msgid "Used in :doc:`pgr_pickDeliverEuclidean`"
msgstr ""

msgid "`Orders SQL`_"
msgstr ""

msgid "`Orders SQL`_ as described below."
msgstr ""

msgid "`Vehicles SQL`_"
msgstr ""

msgid "`Vehicles SQL`_ as described below."
msgstr ""

msgid "Used in :doc:`pgr_pickDeliver`"
msgstr ""

msgid "`Matrix SQL`_"
msgstr ""

msgid "`Matrix SQL`_ as described below."
msgstr ""

msgid "Pick-Deliver optional parameters"
msgstr ""

msgid "``factor``"
msgstr ""

msgid "``NUMERIC``"
msgstr ""

msgid "1"
msgstr ""

msgid "Travel time multiplier. See :ref:`pd_factor`"
msgstr ""

msgid "``max_cycles``"
msgstr ""

msgid "``INTEGER``"
msgstr ""

msgid "10"
msgstr ""

msgid "Maximum number of cycles to perform on the optimization."
msgstr ""

msgid "``initial_sol``"
msgstr ""

msgid "4"
msgstr ""

msgid "Initial solution to be used."
msgstr ""

msgid "``1`` One order per truck"
msgstr ""

msgid "``2`` Push front order."
msgstr ""

msgid "``3`` Push back order."
msgstr ""

msgid "``4`` Optimize insert."
msgstr ""

msgid "``5`` Push back order that allows more orders to be inserted at the back"
msgstr ""

msgid "``6`` Push front order that allows more orders to be inserted at the front"
msgstr ""

msgid "Orders SQL"
msgstr ""

msgid "Common columns for the orders SQL in both implementations:"
msgstr ""

msgid "|ANY-INTEGER|"
msgstr ""

msgid "Identifier of the pick-delivery order pair."
msgstr ""

msgid "``demand``"
msgstr ""

msgid "|ANY-NUMERICAL|"
msgstr ""

msgid "Number of units in the order"
msgstr ""

msgid "``p_open``"
msgstr ""

msgid "The time, relative to 0, when the pickup location opens."
msgstr ""

msgid "``p_close``"
msgstr ""

msgid "The time, relative to 0, when the pickup location closes."
msgstr ""

msgid "[``p_service``]"
msgstr ""

msgid "The duration of the loading at the pickup location."
msgstr ""

msgid "When missing: 0 time units are used"
msgstr ""

msgid "``d_open``"
msgstr ""

msgid "The time, relative to 0, when the delivery location opens."
msgstr ""

msgid "``d_close``"
msgstr ""

msgid "The time, relative to 0, when the delivery location closes."
msgstr ""

msgid "[``d_service``]"
msgstr ""

msgid "The duration of the unloading at the delivery location."
msgstr ""

msgid ""
"For :doc:`pgr_pickDeliver` the pickup and delivery identifiers of the "
"locations are needed:"
msgstr ""

msgid "``p_node_id``"
msgstr ""

msgid ""
"The node identifier of the pickup, must match a vertex identifier in the "
"`Matrix SQL`_."
msgstr ""

msgid "``d_node_id``"
msgstr ""

msgid ""
"The node identifier of the delivery, must match a vertex identifier in "
"the `Matrix SQL`_."
msgstr ""

msgid ""
"For :doc:`pgr_pickDeliverEuclidean` the :math:`(x, y)` values of the "
"locations are needed:"
msgstr ""

msgid "``p_x``"
msgstr ""

msgid ":math:`x` value of the pick up location"
msgstr ""

msgid "``p_y``"
msgstr ""

msgid ":math:`y` value of the pick up location"
msgstr ""

msgid "``d_x``"
msgstr ""

msgid ":math:`x` value of the delivery location"
msgstr ""

msgid "``d_y``"
msgstr ""

msgid ":math:`y` value of the delivery location"
msgstr ""

msgid "Vehicles SQL"
msgstr ""

msgid "Common columns for the vehicles SQL in both implementations:"
msgstr ""

msgid "Identifier of the vehicle."
msgstr ""

msgid "``capacity``"
msgstr ""

msgid "Maiximum capacity units"
msgstr ""

msgid "``start_open``"
msgstr ""

msgid "The time, relative to 0, when the starting location opens."
msgstr ""

msgid "``start_close``"
msgstr ""

msgid "The time, relative to 0, when the starting location closes."
msgstr ""

msgid "[``start_service``]"
msgstr ""

msgid "The duration of the loading at the starting location."
msgstr ""

msgid "When missing: A duration of :math:`0` time units is used."
msgstr ""

msgid "[``end_open``]"
msgstr ""

msgid "The time, relative to 0, when the ending location opens."
msgstr ""

msgid "When missing: The value of ``start_open`` is used"
msgstr ""

msgid "[``end_close``]"
msgstr ""

msgid "The time, relative to 0, when the ending location closes."
msgstr ""

msgid "When missing: The value of ``start_close`` is used"
msgstr ""

msgid "[``end_service``]"
msgstr ""

msgid "The duration of the loading at the ending location."
msgstr ""

msgid "When missing: A duration in ``start_service`` is used."
msgstr ""

msgid ""
"For :doc:`pgr_pickDeliver` the starting and ending identifiers of the "
"locations are needed:"
msgstr ""

msgid "``start_node_id``"
msgstr ""

msgid ""
"The node identifier of the start location, must match a vertex identifier"
" in the `Matrix SQL`_."
msgstr ""

msgid "[``end_node_id``]"
msgstr ""

msgid ""
"The node identifier of the end location, must match a vertex identifier "
"in the `Matrix SQL`_."
msgstr ""

msgid "When missing: ``end_node_id`` is used."
msgstr ""

msgid "``start_x``"
msgstr ""

msgid ":math:`x` value of the starting location"
msgstr ""

msgid "``start_y``"
msgstr ""

msgid ":math:`y` value of the starting location"
msgstr ""

msgid "[``end_x``]"
msgstr ""

msgid ":math:`x` value of the ending location"
msgstr ""

msgid "When missing: ``start_x`` is used."
msgstr ""

msgid "[``end_y``]"
msgstr ""

msgid ":math:`y` value of the ending location"
msgstr ""

msgid "When missing: ``start_y`` is used."
msgstr ""

msgid "Matrix SQL"
msgstr ""

msgid "Set of |matrix-result|"
msgstr ""

msgid "Identifier of the starting vertex."
msgstr ""

msgid "``end_vid``"
msgstr ""

msgid "Identifier of the ending vertex."
msgstr ""

msgid "Aggregate cost from ``start_vid`` to ``end_vid``."
msgstr ""

msgid "Sequential value starting from **1**."
msgstr ""

msgid "``vehicle_seq``"
msgstr ""

#, python-brace-format
msgid ""
"Sequential value starting from **1** for current vehicles. The "
":math:`n_{th}` vehicle in the solution."
msgstr ""

msgid "Value :math:`-2` indicates it is the summary row."
msgstr ""

msgid "``vehicle_id``"
msgstr ""

msgid "BIGINT"
msgstr ""

msgid "Current vehicle identifier."
msgstr ""

msgid "Summary row has the **total capacity violations**."
msgstr ""

msgid "A capacity violation happens when overloading or underloading a vehicle."
msgstr ""

msgid "``stop_seq``"
msgstr ""

msgid "INTEGER"
msgstr ""

#, python-brace-format
msgid ""
"Sequential value starting from **1** for the stops made by the current "
"vehicle. The :math:`m_{th}` stop of the current vehicle."
msgstr ""

msgid "Summary row has the **total time windows violations**."
msgstr ""

msgid ""
"A time window violation happens when arriving after the location has "
"closed."
msgstr ""

msgid "``stop_type``"
msgstr ""

msgid "Kind of stop location the vehicle is at"
msgstr ""

msgid ":math:`-1`: at the solution summary row"
msgstr ""

msgid ":math:`1`: Starting location"
msgstr ""

msgid ":math:`2`: Pickup location"
msgstr ""

msgid ":math:`3`: Delivery location"
msgstr ""

msgid ":math:`6`: Ending location and indicates the vehicle's summary row"
msgstr ""

msgid "``order_id``"
msgstr ""

msgid "Pickup-Delivery order pair identifier."
msgstr ""

msgid "Value :math:`-1`: When no order is involved on the current stop location."
msgstr ""

msgid "``cargo``"
msgstr ""

msgid "Cargo units of the vehicle when leaving the stop."
msgstr ""

msgid "Value :math:`-1` on solution summary row."
msgstr ""

msgid "``travel_time``"
msgstr ""

msgid "Travel time from previous ``stop_seq`` to current ``stop_seq``."
msgstr ""

msgid "Summary has the **total traveling time**:"
msgstr ""

msgid "The sum of all the ``travel_time``."
msgstr ""

msgid "``arrival_time``"
msgstr ""

msgid "Time spent waiting for current location to open."
msgstr ""

msgid ":math:`-1`: at the solution summary row."
msgstr ""

msgid ":math:`0`: at the starting location."
msgstr ""

msgid "``wait_time``"
msgstr ""

msgid "Summary row has the **total waiting time**:"
msgstr ""

msgid "The sum of all the ``wait_time``."
msgstr ""

msgid "``service_time``"
msgstr ""

msgid "Service duration at current location."
msgstr ""

msgid "Summary row has the **total service time**:"
msgstr ""

msgid "The sum of all the ``service_time``."
msgstr ""

msgid "``departure_time``"
msgstr ""

msgid "The time at which the vehicle departs from the stop."
msgstr ""

msgid ":math:`arrival\\_time + wait\\_time + service\\_time`."
msgstr ""

msgid "The ending location has the **total time** used by the current vehicle."
msgstr ""

msgid "Summary row has the **total solution time**:"
msgstr ""

msgid ""
":math:`total\\ traveling\\ time + total\\ waiting\\ time + total\\ "
"service\\ time`."
msgstr ""

msgid "Summary Row"
msgstr ""

msgid "Continues the sequence"
msgstr ""

msgid "**total capacity violations**:"
msgstr ""

msgid "**total time windows violations**:"
msgstr ""

msgid ":math:`-1`"
msgstr ""

msgid "**total traveling time**:"
msgstr ""

msgid "**total waiting time**:"
msgstr ""

msgid "**total service time**:"
msgstr ""

msgid "Handling Parameters"
msgstr ""

msgid ""
"To define a problem, several considerations have to be done, to get "
"consistent results. This section gives an insight of how parameters are "
"to be considered."
msgstr ""

msgid "`Capacity and Demand Units Handling`_"
msgstr ""

msgid "`Locations`_"
msgstr ""

msgid "`Time Handling`_"
msgstr ""

msgid "`Factor Handling`_"
msgstr ""

msgid "Capacity and Demand Units Handling"
msgstr ""

msgid "The `capacity` of a vehicle, can be measured in:"
msgstr ""

msgid "Volume units like :math:`m^3`."
msgstr ""

msgid "Area units like :math:`m^2` (when no stacking is allowed)."
msgstr ""

msgid "Weight units like :math:`kg`."
msgstr ""

msgid "Number of boxes that fit in the vehicle."
msgstr ""

msgid "Number of seats in the vehicle"
msgstr ""

msgid ""
"The `demand` request of the pickup-deliver orders must use the same units"
" as the units used in the vehicle's `capacity`."
msgstr ""

msgid ""
"To handle problems like: 10 (equal dimension) boxes of apples and 5 kg of"
" feathers that are to be transported (not packed in boxes)."
msgstr ""

msgid ""
"If the vehicle's **capacity** is measured in `boxes`, a conversion of `kg"
" of feathers` to `number of boxes` is needed."
msgstr ""

msgid ""
"If the vehicle's **capacity** is measured in `kg`, a conversion of `box "
"of apples` to `kg` is needed."
msgstr ""

msgid "Showing how the 2 possible conversions can be done"
msgstr ""

msgid ""
"Let: - :math:`f\\_boxes`: number of boxes needed for `1` kg of feathers. "
"- :math:`a\\_weight`: weight of `1` box of apples."
msgstr ""

msgid "Capacity Units"
msgstr ""

msgid "apples"
msgstr ""

msgid "feathers"
msgstr ""

msgid "boxes"
msgstr ""

msgid ":math:`5 * f\\_boxes`"
msgstr ""

msgid "kg"
msgstr ""

msgid ":math:`10 * a\\_weight`"
msgstr ""

msgid "5"
msgstr ""

msgid "Locations"
msgstr ""

msgid "When using :doc:`pgr_pickDeliverEuclidean`:"
msgstr ""

msgid "The vehicles have :math:`(x, y)` pairs for start and ending locations."
msgstr ""

msgid "The orders Have :math:`(x, y)` pairs for pickup and delivery locations."
msgstr ""

msgid "When using :doc:`pgr_pickDeliver`:"
msgstr ""

msgid "The vehicles have identifiers for the start and ending locations."
msgstr ""

msgid "The orders have identifiers for the pickup and delivery locations."
msgstr ""

msgid "All the identifiers are indices to the given matrix."
msgstr ""

msgid "Time Handling"
msgstr ""

msgid ""
"The times are relative to **0**. All time units have to be converted to a"
" **0** reference and the same time units."
msgstr ""

msgid ""
"Suppose that a vehicle's driver starts the shift at 9:00 am and ends the "
"shift at 4:30 pm and the service time duration is 10 minutes with 30 "
"seconds."
msgstr ""

msgid "Meaning of 0"
msgstr ""

msgid "time units"
msgstr ""

msgid "9:00 am"
msgstr ""

msgid "4:30 pm"
msgstr ""

msgid "10 min 30 secs"
msgstr ""

msgid "0:00 am"
msgstr ""

msgid "hours"
msgstr ""

msgid "9"
msgstr ""

msgid "16.5"
msgstr ""

msgid ":math:`10.5 / 60 = 0.175`"
msgstr ""

msgid "minutes"
msgstr ""

msgid ":math:`9*60 = 54`"
msgstr ""

msgid ":math:`16.5*60 = 990`"
msgstr ""

msgid "10.5"
msgstr ""

msgid "0"
msgstr ""

msgid "7.5"
msgstr ""

msgid ":math:`7.5*60 = 540`"
msgstr ""

msgid "Factor handling"
msgstr ""

msgid ""
"``factor`` acts as a multiplier to convert from distance values to time "
"units the matrix values or the euclidean values."
msgstr ""

msgid "When the values are already in the desired time units"
msgstr ""

msgid "``factor`` should be **1**"
msgstr ""

msgid "When ``factor`` > 1 the travel times are faster"
msgstr ""

msgid "When ``factor`` < 1 the travel times are slower"
msgstr ""

msgid "For the :doc:`pgr_pickDeliverEuclidean`:"
msgstr ""

msgid ""
"Working with time units in seconds, and x/y in lat/lon: Factor: would "
"depend on the location of the points and on the average velocity say "
"25m/s is the velocity."
msgstr ""

msgid "Latitude"
msgstr ""

msgid "Conversion"
msgstr ""

msgid "Factor"
msgstr ""

msgid "45"
msgstr ""

msgid "1 longitude degree is (78846.81m)/(25m/s)"
msgstr ""

msgid "3153 s"
msgstr ""

msgid "1 longitude degree is (111319.46 m)/(25m/s)"
msgstr ""

msgid "4452 s"
msgstr ""

msgid "For the :doc:`pgr_pickDeliver`:"
msgstr ""

msgid ""
"Given :math:`v = d / t` therefore :math:`t = d / v` And the ``factor`` "
"becomes :math:`1 / v`"
msgstr ""

msgid "v"
msgstr ""

msgid "Velocity"
msgstr ""

msgid "d"
msgstr ""

msgid "Distance"
msgstr ""

msgid "t"
msgstr ""

msgid "Time"
msgstr ""

msgid ""
"For the following equivalences :math:`10m/s \\approx 600m/min \\approx 36"
" km/hr`"
msgstr ""

msgid ""
"Working with time units in seconds and the matrix been in meters: For a "
"1000m length value on the matrix:"
msgstr ""

msgid "Units"
msgstr ""

msgid "velocity"
msgstr ""

msgid "Result"
msgstr ""

msgid "seconds"
msgstr ""

msgid ":math:`10 m/s`"
msgstr ""

#, python-brace-format
msgid ":math:`\\frac{1}{10m/s}`"
msgstr ""

msgid ":math:`0.1s/m`"
msgstr ""

msgid ":math:`1000m * 0.1s/m = 100s`"
msgstr ""

msgid ":math:`600 m/min`"
msgstr ""

#, python-brace-format
msgid ":math:`\\frac{1}{600m/min}`"
msgstr ""

msgid ":math:`0.0016min/m`"
msgstr ""

msgid ":math:`1000m * 0.0016min/m = 1.6min`"
msgstr ""

msgid "Hours"
msgstr ""

msgid ":math:`36 km/hr`"
msgstr ""

#, python-brace-format
msgid ":math:`\\frac{1}{36 km/hr}`"
msgstr ""

msgid ":math:`0.0277hr/km`"
msgstr ""

msgid ":math:`1km * 0.0277hr/km = 0.0277hr`"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Vehicle_routing_problem"
msgstr ""

msgid ":doc:`sampledata`"
msgstr ""

msgid "A* - Family of functions"
msgstr ""

msgid ""
"The A* (pronounced \"A Star\") algorithm is based on Dijkstra's algorithm"
" with a heuristic that allow it to solve most shortest path problems by "
"evaluation only a sub-set of the overall graph."
msgstr ""

msgid ":doc:`pgr_aStar` - A* algorithm for the shortest path."
msgstr ""

msgid ":doc:`pgr_aStarCost` - Get the aggregate cost of the shortest paths."
msgstr ""

msgid ":doc:`pgr_aStarCostMatrix` - Get the cost matrix of the shortest paths."
msgstr ""

msgid "The main Characteristics are:"
msgstr ""

msgid "Process works for directed and undirected graphs."
msgstr ""

msgid "Ordering is:"
msgstr ""

msgid "first by ``start_vid`` (if exists)"
msgstr ""

msgid "then by ``end_vid``"
msgstr ""

msgid "Values are returned when there is a path."
msgstr ""

msgid "Let :math:`v` and :math:`u` be nodes on the graph:"
msgstr ""

msgid "If there is no path from :math:`v` to :math:`u`:"
msgstr ""

msgid "no corresponding row is returned"
msgstr ""

msgid "``agg_cost`` from :math:`v` to :math:`u` is :math:`\\infty`"
msgstr ""

msgid "There is no path when :math:`v = u` therefore"
msgstr ""

msgid "``agg_cost`` from `v` to `u` is :math:`0`"
msgstr ""

msgid "When :math:`(x,y)` coordinates for the same vertex identifier differ:"
msgstr ""

msgid "A random selection of the vertex's :math:`(x,y)` coordinates is used."
msgstr ""

msgid "Running time: :math:`O((E + V) * \\log V)`"
msgstr ""

msgid "aStar optional parameters"
msgstr ""

msgid "``heuristic``"
msgstr ""

msgid "Heuristic number. Current valid values 0~5."
msgstr ""

msgid "0: :math:`h(v) = 0` (Use this value to compare with pgr_dijkstra)"
msgstr ""

msgid "1: :math:`h(v) = abs(max(\\Delta x, \\Delta y))`"
msgstr ""

msgid "2: :math:`h(v) = abs(min(\\Delta x, \\Delta y))`"
msgstr ""

msgid "3: :math:`h(v) = \\Delta x * \\Delta x + \\Delta y * \\Delta y`"
msgstr ""

msgid "4: :math:`h(v) = sqrt(\\Delta x * \\Delta x + \\Delta y * \\Delta y)`"
msgstr ""

msgid "5: :math:`h(v) = abs(\\Delta x) + abs(\\Delta y)`"
msgstr ""

msgid "``1``"
msgstr ""

msgid "For units manipulation. :math:`factor > 0`."
msgstr ""

msgid "``epsilon``"
msgstr ""

msgid "For less restricted results. :math:`epsilon >= 1`."
msgstr ""

msgid ""
"See :ref:`heuristics <astar_heuristics>` available and :ref:`factor "
"<astar_factor>` handling."
msgstr ""

msgid "Advanced documentation"
msgstr ""

msgid "Heuristic"
msgstr ""

msgid "Currently the heuristic functions available are:"
msgstr ""

msgid "where :math:`\\Delta x = x_1 - x_0` and :math:`\\Delta y = y_1 - y_0`"
msgstr ""

msgid "Analysis 1"
msgstr ""

msgid ""
"Working with cost/reverse_cost as length in degrees, x/y in lat/lon: "
"Factor = 1 (no need to change units)"
msgstr ""

msgid "Analysis 2"
msgstr ""

msgid ""
"Working with cost/reverse_cost as length in meters, x/y in lat/lon: "
"Factor = would depend on the location of the points:"
msgstr ""

msgid "1 longitude degree is 78846.81 m"
msgstr ""

msgid "78846"
msgstr ""

msgid "1 longitude degree is 111319.46 m"
msgstr ""

msgid "111319"
msgstr ""

msgid "Analysis 3"
msgstr ""

msgid ""
"Working with cost/reverse_cost as time in seconds, x/y in lat/lon: "
"Factor: would depend on the location of the points and on the average "
"speed say 25m/s is the speed."
msgstr ""

msgid ":doc:`bdAstar-family`"
msgstr ""

msgid ""
"`Boost: A* search "
"<https://www.boost.org/libs/graph/doc/astar_search.html>`__"
msgstr ""

msgid "https://en.wikipedia.org/wiki/A*_search_algorithm"
msgstr ""

msgid "All Pairs - Family of Functions"
msgstr ""

msgid "The following functions work on all vertices pair combinations"
msgstr ""

msgid ":doc:`pgr_floydWarshall` - Floyd-Warshall's algorithm."
msgstr ""

msgid ":doc:`pgr_johnson` - Johnson's algorithm"
msgstr ""

msgid "The main characteristics are:"
msgstr ""

msgid "It does not return a path."
msgstr ""

msgid ""
"Returns the sum of the costs of the shortest path for each pair of nodes "
"in the graph."
msgstr ""

msgid ""
"Boost returns a :math:`V \\times V` matrix, where the infinity values. "
"Represent the distance between vertices for which there is no path."
msgstr ""

msgid ""
"We return only the non infinity values in form of a set of `(start_vid, "
"end_vid, agg_cost)`."
msgstr ""

msgid ""
"Let be the case the values returned are stored in a table, so the unique "
"index would be the pair: `(start_vid, end_vid)`."
msgstr ""

msgid "For the undirected graph, the results are symmetric."
msgstr ""

msgid "The `agg_cost` of `(u, v)` is the same as for `(v, u)`."
msgstr ""

msgid "When `start_vid` = `end_vid`, the `agg_cost` = 0."
msgstr ""

msgid "**Recommended, use a bounding box of no more than 3500 edges.**"
msgstr ""

msgid "Optional parameters"
msgstr ""

msgid "``directed``"
msgstr ""

msgid "``BOOLEAN``"
msgstr ""

msgid "``true``"
msgstr ""

msgid "When ``true`` the graph is considered `Directed`"
msgstr ""

msgid "When ``false`` the graph is considered as `Undirected`."
msgstr ""

msgid "Performance"
msgstr ""

msgid "The following tests:"
msgstr ""

msgid "non server computer"
msgstr ""

msgid "with AMD 64 CPU"
msgstr ""

msgid "4G memory"
msgstr ""

msgid "trusty"
msgstr ""

msgid "PostgreSQL version 9.3"
msgstr ""

msgid "Data"
msgstr ""

msgid "The following data was used"
msgstr ""

msgid "Data processing was done with osm2pgrouting-alpha"
msgstr ""

msgid "Results"
msgstr ""

msgid "Test"
msgstr ""

msgid "One"
msgstr ""

msgid ""
"This test is not with a bounding box The density of the passed graph is "
"extremely low. For each <SIZE> 30 tests were executed to get the average "
"The tested query is:"
msgstr ""

msgid "The results of this tests are presented as:"
msgstr ""

msgid "SIZE"
msgstr ""

msgid "is the number of edges given as input."
msgstr ""

msgid "EDGES"
msgstr ""

msgid "is the total number of records in the query."
msgstr ""

msgid "DENSITY"
msgstr ""

#, python-brace-format
msgid "is the density of the data :math:`\\dfrac{E}{V \\times (V-1)}`."
msgstr ""

msgid "OUT ROWS"
msgstr ""

msgid "is the number of records returned by the queries."
msgstr ""

msgid "Floyd-Warshall"
msgstr ""

msgid "is the average execution time in seconds of pgr_floydWarshall."
msgstr ""

msgid "Johnson"
msgstr ""

msgid "is the average execution time in seconds of pgr_johnson."
msgstr ""

msgid "500"
msgstr ""

msgid "0.18E-7"
msgstr ""

msgid "1346"
msgstr ""

msgid "0.14"
msgstr ""

msgid "0.13"
msgstr ""

msgid "1000"
msgstr ""

msgid "0.36E-7"
msgstr ""

msgid "2655"
msgstr ""

msgid "0.23"
msgstr ""

msgid "0.18"
msgstr ""

msgid "1500"
msgstr ""

msgid "0.55E-7"
msgstr ""

msgid "4110"
msgstr ""

msgid "0.37"
msgstr ""

msgid "0.34"
msgstr ""

msgid "2000"
msgstr ""

msgid "0.73E-7"
msgstr ""

msgid "5676"
msgstr ""

msgid "0.56"
msgstr ""

msgid "2500"
msgstr ""

msgid "0.89E-7"
msgstr ""

msgid "7177"
msgstr ""

msgid "0.84"
msgstr ""

msgid "0.51"
msgstr ""

msgid "3000"
msgstr ""

msgid "1.07E-7"
msgstr ""

msgid "8778"
msgstr ""

msgid "1.28"
msgstr ""

msgid "0.68"
msgstr ""

msgid "3500"
msgstr ""

msgid "1.24E-7"
msgstr ""

msgid "10526"
msgstr ""

msgid "2.08"
msgstr ""

msgid "0.95"
msgstr ""

msgid "4000"
msgstr ""

msgid "1.41E-7"
msgstr ""

msgid "12484"
msgstr ""

msgid "3.16"
msgstr ""

msgid "1.24"
msgstr ""

msgid "4500"
msgstr ""

msgid "1.58E-7"
msgstr ""

msgid "14354"
msgstr ""

msgid "4.49"
msgstr ""

msgid "1.47"
msgstr ""

msgid "5000"
msgstr ""

msgid "1.76E-7"
msgstr ""

msgid "16503"
msgstr ""

msgid "6.05"
msgstr ""

msgid "1.78"
msgstr ""

msgid "5500"
msgstr ""

msgid "1.93E-7"
msgstr ""

msgid "18623"
msgstr ""

msgid "7.53"
msgstr ""

msgid "2.03"
msgstr ""

msgid "6000"
msgstr ""

msgid "2.11E-7"
msgstr ""

msgid "20710"
msgstr ""

msgid "8.47"
msgstr ""

msgid "2.37"
msgstr ""

msgid "6500"
msgstr ""

msgid "2.28E-7"
msgstr ""

msgid "22752"
msgstr ""

msgid "9.99"
msgstr ""

msgid "2.68"
msgstr ""

msgid "7000"
msgstr ""

msgid "2.46E-7"
msgstr ""

msgid "24687"
msgstr ""

msgid "11.82"
msgstr ""

msgid "3.12"
msgstr ""

msgid "7500"
msgstr ""

msgid "2.64E-7"
msgstr ""

msgid "26861"
msgstr ""

msgid "13.94"
msgstr ""

msgid "3.60"
msgstr ""

msgid "8000"
msgstr ""

msgid "2.83E-7"
msgstr ""

msgid "29050"
msgstr ""

msgid "15.61"
msgstr ""

msgid "4.09"
msgstr ""

msgid "8500"
msgstr ""

msgid "3.01E-7"
msgstr ""

msgid "31693"
msgstr ""

msgid "17.43"
msgstr ""

msgid "4.63"
msgstr ""

msgid "9000"
msgstr ""

msgid "3.17E-7"
msgstr ""

msgid "33879"
msgstr ""

msgid "19.19"
msgstr ""

msgid "5.34"
msgstr ""

msgid "9500"
msgstr ""

msgid "3.35E-7"
msgstr ""

msgid "36287"
msgstr ""

msgid "20.77"
msgstr ""

msgid "6.24"
msgstr ""

msgid "10000"
msgstr ""

msgid "3.52E-7"
msgstr ""

msgid "38491"
msgstr ""

msgid "23.26"
msgstr ""

msgid "6.51"
msgstr ""

msgid "Two"
msgstr ""

msgid ""
"This test is with a bounding box The density of the passed graph higher "
"than of the Test One. For each <SIZE> 30 tests were executed to get the "
"average The tested edge query is:"
msgstr ""

msgid "The tested queries"
msgstr ""

msgid "is the size of the bounding box."
msgstr ""

msgid "0.001"
msgstr ""

msgid "44"
msgstr ""

msgid "0.0608"
msgstr ""

msgid "1197"
msgstr ""

msgid "0.10"
msgstr ""

msgid "0.002"
msgstr ""

msgid "99"
msgstr ""

msgid "0.0251"
msgstr ""

msgid "4330"
msgstr ""

msgid "0.003"
msgstr ""

msgid "223"
msgstr ""

msgid "0.0122"
msgstr ""

msgid "18849"
msgstr ""

msgid "0.12"
msgstr ""

msgid "0.004"
msgstr ""

msgid "358"
msgstr ""

msgid "0.0085"
msgstr ""

msgid "71834"
msgstr ""

msgid "0.16"
msgstr ""

msgid "0.005"
msgstr ""

msgid "470"
msgstr ""

msgid "0.0070"
msgstr ""

msgid "116290"
msgstr ""

msgid "0.22"
msgstr ""

msgid "0.19"
msgstr ""

msgid "0.006"
msgstr ""

msgid "639"
msgstr ""

msgid "0.0055"
msgstr ""

msgid "207030"
msgstr ""

msgid "0.27"
msgstr ""

msgid "0.007"
msgstr ""

msgid "843"
msgstr ""

msgid "0.0043"
msgstr ""

msgid "346930"
msgstr ""

msgid "0.64"
msgstr ""

msgid "0.38"
msgstr ""

msgid "0.008"
msgstr ""

msgid "996"
msgstr ""

msgid "0.0037"
msgstr ""

msgid "469936"
msgstr ""

msgid "0.90"
msgstr ""

msgid "0.49"
msgstr ""

msgid "0.009"
msgstr ""

msgid "1146"
msgstr ""

msgid "0.0032"
msgstr ""

msgid "613135"
msgstr ""

msgid "1.26"
msgstr ""

msgid "0.62"
msgstr ""

msgid "0.010"
msgstr ""

msgid "1360"
msgstr ""

msgid "0.0027"
msgstr ""

msgid "849304"
msgstr ""

msgid "1.87"
msgstr ""

msgid "0.82"
msgstr ""

msgid "0.011"
msgstr ""

msgid "1573"
msgstr ""

msgid "0.0024"
msgstr ""

msgid "1147101"
msgstr ""

msgid "2.65"
msgstr ""

msgid "1.04"
msgstr ""

msgid "0.012"
msgstr ""

msgid "1789"
msgstr ""

msgid "0.0021"
msgstr ""

msgid "1483629"
msgstr ""

msgid "3.72"
msgstr ""

msgid "1.35"
msgstr ""

msgid "0.013"
msgstr ""

msgid "1975"
msgstr ""

msgid "0.0019"
msgstr ""

msgid "1846897"
msgstr ""

msgid "4.86"
msgstr ""

msgid "1.68"
msgstr ""

msgid "0.014"
msgstr ""

msgid "2281"
msgstr ""

msgid "0.0017"
msgstr ""

msgid "2438298"
msgstr ""

msgid "7.08"
msgstr ""

msgid "2.28"
msgstr ""

msgid "0.015"
msgstr ""

msgid "2588"
msgstr ""

msgid "0.0015"
msgstr ""

msgid "3156007"
msgstr ""

msgid "10.28"
msgstr ""

msgid "2.80"
msgstr ""

msgid "0.016"
msgstr ""

msgid "2958"
msgstr ""

msgid "0.0013"
msgstr ""

msgid "4090618"
msgstr ""

msgid "14.67"
msgstr ""

msgid "3.76"
msgstr ""

msgid "0.017"
msgstr ""

msgid "3247"
msgstr ""

msgid "0.0012"
msgstr ""

msgid "4868919"
msgstr ""

msgid "18.12"
msgstr ""

msgid "4.48"
msgstr ""

msgid ":doc:`pgr_johnson`"
msgstr ""

msgid ":doc:`pgr_floydWarshall`"
msgstr ""

msgid ""
"Boost `floyd-Warshall "
"<https://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html>`__"
msgstr ""

msgid "Bidirectional A* - Family of functions"
msgstr ""

msgid ""
"The bidirectional A* (pronounced \"A Star\") algorithm is based on the A*"
" algorithm."
msgstr ""

msgid ":doc:`pgr_bdAstar` - Bidirectional A* algorithm for obtaining paths."
msgstr ""

msgid ""
":doc:`pgr_bdAstarCost` - Bidirectional A* algorithm to calculate the cost"
" of the paths."
msgstr ""

msgid ""
":doc:`pgr_bdAstarCostMatrix` - Bidirectional A* algorithm to calculate a "
"cost matrix of paths."
msgstr ""

msgid ""
"Based on A* algorithm, the bidirectional search finds a shortest path "
"from a starting vertex (``start_vid``) to an ending vertex (``end_vid``)."
" It runs two simultaneous searches: one forward from the ``start_vid``, "
"and one backward from the ``end_vid``, stopping when the two meet in the "
"middle. This implementation can be used with a directed graph and an "
"undirected graph."
msgstr ""

msgid ""
"For large graphs where there is a path between the starting vertex and "
"ending vertex:"
msgstr ""

msgid "It is expected to terminate faster than doc:`pgr_aStar`"
msgstr ""

msgid ":doc:`aStar-family`"
msgstr ""

msgid "Bidirectional Dijkstra - Family of functions"
msgstr ""

msgid ""
":doc:`pgr_bdDijkstra` - Bidirectional Dijkstra algorithm for the shortest"
" paths."
msgstr ""

msgid ""
":doc:`pgr_bdDijkstraCost` - Bidirectional Dijkstra to calculate the cost "
"of the shortest paths"
msgstr ""

msgid ""
":doc:`pgr_bdDijkstraCostMatrix` - Bidirectional Dijkstra algorithm to "
"create a matrix of costs of the shortest paths."
msgstr ""

msgid "Synopsis"
msgstr ""

msgid ""
"Based on Dijkstra's algorithm, the bidirectional search finds a shortest "
"path a starting vertex to an ending vertex."
msgstr ""

msgid ""
"It runs two simultaneous searches: one forward from the source, and one "
"backward from the target, stopping when the two meet in the middle."
msgstr ""

msgid ""
"This implementation can be used with a directed graph and an undirected "
"graph."
msgstr ""

msgid ""
"A negative value on a cost column is interpreted as the edge does not "
"exist."
msgstr ""

msgid "When there is no path:"
msgstr ""

msgid "When the starting vertex and ending vertex are the same."
msgstr ""

msgid ""
"The **aggregate cost** of the non included values :math:`(v, v)` is "
":math:`0`"
msgstr ""

msgid ""
"When the starting vertex and ending vertex are the different and there is"
" no path:"
msgstr ""

msgid ""
"The **aggregate cost** the non included values :math:`(u, v)` is "
":math:`\\infty`"
msgstr ""

msgid ""
"For optimization purposes, any duplicated value in the starting vertices "
"or on the ending vertices are ignored."
msgstr ""

msgid "Running time (worse case scenario): :math:`O((V \\log V + E))`"
msgstr ""

msgid ""
"For large graphs where there is a path bewtween the starting vertex and "
"ending vertex:"
msgstr ""

msgid "It is expected to terminate faster than pgr_dijkstra"
msgstr ""

msgid "`Boost  <https://www.boost.org/libs/graph/doc>`__"
msgstr ""

msgid "Chinese Postman Problem - Family of functions (Experimental)"
msgstr ""

msgid ":doc:`pgr_chinesePostman`"
msgstr ""

msgid ":doc:`pgr_chinesePostmanCost`"
msgstr ""

msgid "**The main characteristics are:**"
msgstr ""

msgid "Process is done only on edges with **positive** costs."
msgstr ""

msgid "Running time: :math:`O(E * (E + V * logV))`"
msgstr ""

msgid "Graph must be connected."
msgstr ""

msgid ""
"An Edges SQL that represents a **directed** graph with the following "
"columns"
msgstr ""

msgid "Coloring - Family of functions"
msgstr ""

msgid ""
":doc:`pgr_sequentialVertexColoring` - Vertex coloring algorithm using "
"greedy approach."
msgstr ""

msgid ""
":doc:`pgr_bipartite` - Bipartite graph algorithm using a DFS-based "
"coloring approach."
msgstr ""

msgid ":doc:`pgr_edgeColoring` - Edge Coloring algorithm using Vizing's theorem."
msgstr ""

msgid "Returns set of |result_edge_color|"
msgstr ""

msgid "``color``"
msgstr ""

msgid "Color of the edge."
msgstr ""

msgid "The minimum value of color is 1."
msgstr ""

msgid "Returns set of |result_node_color|"
msgstr ""

msgid "Identifier of the node."
msgstr ""

msgid "Color of the node."
msgstr ""

msgid "`Boost: <https://www.boost.org/libs/graph/doc/table_of_contents.html>`__"
msgstr ""

msgid "Components - Family of functions"
msgstr ""

msgid ""
":doc:`pgr_connectedComponents` - Connected components of an undirected "
"graph."
msgstr ""

msgid ""
":doc:`pgr_strongComponents` - Strongly connected components of a directed"
" graph."
msgstr ""

msgid ""
":doc:`pgr_biconnectedComponents` - Biconnected components of an "
"undirected graph."
msgstr ""

msgid ""
":doc:`pgr_articulationPoints` - Articulation points of an undirected "
"graph."
msgstr ""

msgid ":doc:`pgr_bridges` - Bridges of an undirected graph."
msgstr ""

msgid ":doc:`pgr_makeConnected` - Details of edges to make graph connected."
msgstr ""

msgid "Contraction - Family of functions"
msgstr ""

msgid ":doc:`pgr_contraction`"
msgstr ""

msgid ":doc:`pgr_contractionDeadEnd`"
msgstr ""

msgid ":doc:`pgr_contractionLinear`"
msgstr ""

msgid ":doc:`pgr_contractionHierarchies`"
msgstr ""

msgid ""
"In large graphs, like road graphs or electric networks, graph contraction"
" can be used to speed up some graph algorithms. Contraction can reduce "
"the size of the graph by removing some of the vertices and edges and "
"adding edges that represent a sequence of original edges (the original "
"ones can be kept in some methods). In this way, it decreases the total "
"time and space used by graph algorithms, particularly those searching for"
" an optimal path."
msgstr ""

msgid ""
"This implementation gives a flexible framework for adding contraction "
"algorithms in the future. Currently, it supports three algorithms."
msgstr ""

msgid "Dead end contraction"
msgstr ""

msgid "Linear contraction"
msgstr ""

msgid "Contraction hierarchies"
msgstr ""

msgid ""
"The two first ones can be combined through a iterative procedure, via the"
" ``pgr_contraction`` method. The third one is implemented on its own."
msgstr ""

msgid "All functions allow the user to forbid contraction on a set of nodes."
msgstr ""

msgid "https://www.cs.cmu.edu/afs/cs/academic/class/15210-f12/www/lectures/lecture16.pdf"
msgstr ""

msgid "https://ae.iti.kit.edu/download/diploma_thesis_geisberger.pdf"
msgstr ""

msgid "https://jlazarsfeld.github.io/ch.150.project/contents/"
msgstr ""

msgid "Cost - Category"
msgstr ""

msgid ":doc:`pgr_aStarCost`"
msgstr ""

msgid ":doc:`pgr_bdAstarCost`"
msgstr ""

msgid ":doc:`pgr_dijkstraCost`"
msgstr ""

msgid ":doc:`pgr_bdDijkstraCost`"
msgstr ""

msgid ":doc:`pgr_withPointsCost`"
msgstr ""

msgid ":doc:`pgr_dijkstraNearCost`"
msgstr ""

msgid "Each function works as part of the family it belongs to."
msgstr ""

msgid ""
"Returns the sum of the costs of the shortest path of each pair "
"combination of nodes requested."
msgstr ""

msgid ""
"Let be the case the values returned are stored in a table, so the unique "
"index would be the pair: ``(start_vid, end_vid)``."
msgstr ""

msgid ""
"Depending on the function and its parameters, the results can be "
"symmetric."
msgstr ""

msgid ""
"The **aggregate cost** of :math:`(u, v)` is the same as for :math:`(v, "
"u)`."
msgstr ""

msgid "Any duplicated value in the start or end vertex identifiers are ignored."
msgstr ""

msgid "The returned values are ordered:"
msgstr ""

msgid "``start_vid`` ascending"
msgstr ""

msgid "``end_vid`` ascending"
msgstr ""

msgid "Cost Matrix - Category"
msgstr ""

msgid ":doc:`pgr_aStarCostMatrix`"
msgstr ""

msgid ":doc:`pgr_dijkstraCostMatrix`"
msgstr ""

msgid ":doc:`pgr_bdAstarCostMatrix`"
msgstr ""

msgid ":doc:`pgr_bdDijkstraCostMatrix`"
msgstr ""

msgid ":doc:`pgr_withPointsCostMatrix`"
msgstr ""

msgid ""
":doc:`TSP-family` needs as input a symmetric cost matrix and no edge `(u,"
" v)` must value :math:`\\infty`."
msgstr ""

msgid "This collection of functions will return a cost matrix in form of a table."
msgstr ""

msgid "Can be used as input to :doc:`pgr_TSP`."
msgstr ""

msgid ""
"Use directly when the resulting matrix is symmetric and there is no "
":math:`\\infty` value."
msgstr ""

msgid "It will be the users responsibility to make the matrix symmetric."
msgstr ""

msgid "By using geometric or harmonic average of the non symmetric values."
msgstr ""

msgid "By using max or min the non symmetric values."
msgstr ""

msgid ""
"By setting the upper triangle to be the mirror image of the lower "
"triangle."
msgstr ""

msgid ""
"By setting the lower triangle to be the mirror image of the upper "
"triangle."
msgstr ""

msgid "It is also the users responsibility to fix an :math:`\\infty` value."
msgstr ""

msgid ""
"Returns the sum of the costs of the shortest path for pair combination of"
" nodes in the graph."
msgstr ""

msgid "When the starting vertex and ending vertex are the same, there is no path."
msgstr ""

msgid "The aggregate cost in the non included values `(v, v)` is `0`."
msgstr ""

msgid ""
"When the starting vertex and ending vertex are the different and there is"
" no path."
msgstr ""

msgid "The aggregate cost in the non included values `(u, v)` is :math:`\\infty`."
msgstr ""

msgid "Let be the case the values returned are stored in a table:"
msgstr ""

msgid "The unique index would be the pair: ``(start_vid, end_vid)``."
msgstr ""

msgid "The aggregate cost of `(u, v)` is the same as for `(v, u)`."
msgstr ""

msgid "Any duplicated value in the **start vids** are ignored."
msgstr ""

msgid "Used in:"
msgstr ""

msgid "`Edges SQL`_ as described below"
msgstr ""

msgid "**start vids**"
msgstr ""

msgid "``ARRAY[BIGINT]``"
msgstr ""

msgid "Array of identifiers of starting vertices."
msgstr ""

msgid "`Points SQL`_"
msgstr ""

msgid "`Points SQL`_ as described below"
msgstr ""

msgid "Points SQL"
msgstr ""

msgid "``pid``"
msgstr ""

msgid "**value**"
msgstr ""

msgid "Identifier of the point."
msgstr ""

msgid "Use with positive value, as internally will be converted to negative value"
msgstr ""

msgid "If column is present, it can not be NULL."
msgstr ""

msgid ""
"If column is not present, a sequential negative **value** will be given "
"automatically."
msgstr ""

msgid "``edge_id``"
msgstr ""

msgid "Identifier of the \"closest\" edge to the point."
msgstr ""

msgid "``fraction``"
msgstr ""

msgid ""
"Value in <0,1> that indicates the relative position from the first end "
"point of the edge."
msgstr ""

msgid "``side``"
msgstr ""

msgid "``CHAR``"
msgstr ""

msgid "``b``"
msgstr ""

msgid "Value in [``b``, ``r``, ``l``, ``NULL``] indicating if the point is:"
msgstr ""

msgid "In the right ``r``,"
msgstr ""

msgid "In the left ``l``,"
msgstr ""

msgid "In both sides ``b``, ``NULL``"
msgstr ""

msgid ":doc:`TSP-family`"
msgstr ""

msgid "Dijkstra - Family of functions"
msgstr ""

msgid ":doc:`pgr_dijkstra` - Dijkstra's algorithm for the shortest paths."
msgstr ""

msgid ":doc:`pgr_dijkstraCost` - Get the aggregate cost of the shortest paths."
msgstr ""

msgid ":doc:`pgr_dijkstraCostMatrix` - Use pgr_dijkstra to create a costs matrix."
msgstr ""

msgid ""
":doc:`pgr_drivingDistance` - Use pgr_dijkstra to calculate catchament "
"information."
msgstr ""

msgid ""
":doc:`pgr_KSP` - Use Yen algorithm with pgr_dijkstra to get the K "
"shortest paths."
msgstr ""

msgid ":doc:`pgr_dijkstraVia` - Get a route of a sequence of vertices."
msgstr ""

msgid ":doc:`pgr_dijkstraNear` - Get the route to the nearest vertex."
msgstr ""

msgid ":doc:`pgr_dijkstraNearCost` - Get the cost to the nearest vertex."
msgstr ""

msgid ""
"Dijkstra's algorithm, conceived by Dutch computer scientist Edsger "
"Dijkstra in 1956. It is a graph search algorithm that solves the shortest"
" path problem for a graph with non-negative edge path costs, producing a "
"shortest path from a starting vertex to an ending vertex. This "
"implementation can be used with a directed graph and an undirected graph."
msgstr ""

msgid "Running time: :math:`O(| start\\ vids | * (V \\log V + E))`"
msgstr ""

msgid "The Dijkstra family functions are based on the Dijkstra algorithm."
msgstr ""

msgid "`Combinations SQL`_"
msgstr ""

msgid "`Combinations SQL`_ as described below"
msgstr ""

msgid "**start vid**"
msgstr ""

msgid "Identifier of the starting vertex of the path."
msgstr ""

msgid "**end vid**"
msgstr ""

msgid "Identifier of the ending vertex of the path."
msgstr ""

msgid "**end vids**"
msgstr ""

msgid "Array of identifiers of ending vertices."
msgstr ""

msgid "Combinations SQL"
msgstr ""

msgid "Identifier of the departure vertex."
msgstr ""

msgid "Identifier of the arrival vertex."
msgstr ""

msgid "The problem definition (Advanced documentation)"
msgstr ""

msgid "Given the following query:"
msgstr ""

#, python-brace-format
msgid "pgr_dijkstra(:math:`sql, start_{vid}, end_{vid}, directed`)"
msgstr ""

#, python-brace-format
msgid ""
"where :math:`sql = \\{(id_i, source_i, target_i, cost_i, "
"reverse\\_cost_i)\\}`"
msgstr ""

msgid "and"
msgstr ""

msgid ":math:`source = \\bigcup source_i`,"
msgstr ""

msgid ":math:`target = \\bigcup target_i`,"
msgstr ""

msgid "The graphs are defined as follows:"
msgstr ""

msgid "Directed graph"
msgstr ""

msgid "The weighted directed graph, :math:`G_d(V,E)`, is defined by:"
msgstr ""

msgid "the set of vertices :math:`V`"
msgstr ""

msgid ":math:`V = source \\cup target \\cup {start_{vid}} \\cup  {end_{vid}}`"
msgstr ""

msgid "the set of edges :math:`E`"
msgstr ""

msgid ""
":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, cost_i) "
"\\text{ when } cost >=0 \\} & \\quad \\text{if } reverse\\_cost = "
"\\varnothing \\\\ \\text{ } \\text{ }  & \\quad \\text{ } \\\\ \\text{ } "
"\\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\} &  \\quad "
"\\text{ } \\\\ \\cup \\{(target_i, source_i, reverse\\_cost_i) \\text{ "
"when } reverse\\_cost_i>=0 \\} & \\quad \\text{if } reverse\\_cost \\neq "
"\\varnothing \\\\ \\end{cases}`"
msgstr ""

msgid "Undirected graph"
msgstr ""

msgid "The weighted undirected graph, :math:`G_u(V,E)`, is defined by:"
msgstr ""

msgid ":math:`V = source \\cup target \\cup {start_v{vid}} \\cup  {end_{vid}}`"
msgstr ""

msgid ""
":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, cost_i) "
"\\text{ when } cost >=0 \\}  & \\quad \\text{ } \\\\ \\cup \\{(target_i, "
"source_i, cost_i) \\text{ when } cost >=0 \\}  & \\quad \\text{ if } "
"reverse\\_cost = \\varnothing \\\\ \\text{ } \\text{ }  & \\text{ } \\\\ "
"\\text{ } \\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\} & "
"\\text{ } \\\\ \\cup \\{(target_i, source_i, cost_i) \\text{ when } cost "
">=0 \\} & \\text{ } \\\\ \\cup \\{(target_i, source_i, reverse\\_cost_i) "
"\\text{ when } reverse\\_cost_i >=0)\\} & \\text{ } \\\\ \\cup "
"\\{(source_i, target_i, reverse\\_cost_i) \\text{ when } reverse\\_cost_i"
" >=0)\\} & \\quad \\text{ if } reverse\\_cost \\neq \\varnothing \\\\ "
"\\end{cases}`"
msgstr ""

msgid "The problem"
msgstr ""

msgid "Given:"
msgstr ""

#, python-brace-format
msgid ":math:`start_{vid} \\in V` a starting vertex"
msgstr ""

#, python-brace-format
msgid ":math:`end_{vid} \\in V` an ending vertex"
msgstr ""

#, python-brace-format
msgid ""
":math:`G(V,E) = \\begin{cases} G_d(V,E) & \\quad \\text{ if6 } directed ="
" true \\\\ G_u(V,E) & \\quad \\text{ if5 } directed = false \\\\ "
"\\end{cases}`"
msgstr ""

msgid "Then:"
msgstr ""

#, python-brace-format
msgid ""
":math:`\\boldsymbol{\\pi} = \\{(path\\_seq_i, node_i, edge_i, cost_i, "
"agg\\_cost_i)\\}`"
msgstr ""

msgid "where:"
msgstr ""

msgid ":math:`path\\_seq_i = i`"
msgstr ""

#, python-brace-format
msgid ":math:`path\\_seq_{| \\pi |} = | \\pi |`"
msgstr ""

msgid ":math:`node_i \\in V`"
msgstr ""

#, python-brace-format
msgid ":math:`node_1 = start_{vid}`"
msgstr ""

#, python-brace-format
msgid ":math:`node_{| \\pi |}  = end_{vid}`"
msgstr ""

#, python-brace-format
msgid ""
":math:`\\forall i \\neq | \\pi |, \\quad (node_i, node_{i+1}, cost_i) "
"\\in E`"
msgstr ""

msgid ""
":math:`edge_i  = \\begin{cases}  id_{(node_i, node_{i+1},cost_i)}  "
"&\\quad  \\text{when } i \\neq | \\pi | \\\\ -1 &\\quad  \\text{when } i "
"= | \\pi | \\\\ \\end{cases}`"
msgstr ""

msgid ":math:`cost_i = cost_{(node_i, node_{i+1})}`"
msgstr ""

msgid ""
":math:`agg\\_cost_i  = \\begin{cases}  0   &\\quad  \\text{when } i = 1  "
"\\\\ \\displaystyle\\sum_{k=1}^{i}  cost_{(node_{k-1}, node_k)}  &\\quad"
"  \\text{when } i \\neq 1 \\\\ \\end{cases}`"
msgstr ""

#, python-brace-format
msgid ""
"In other words: The algorithm returns a the shortest path between "
":math:`start_{vid}` and :math:`end_{vid}`, if it exists, in terms of a "
"sequence of nodes and of edges,"
msgstr ""

msgid ""
":math:`path\\_seq` indicates the relative position in the path of the "
":math:`node` or :math:`edge`."
msgstr ""

msgid ":math:`cost` is the cost of the edge to be used to go to the next node."
msgstr ""

#, python-brace-format
msgid ""
":math:`agg\\_cost` is the cost from the :math:`start_{vid}` up to the "
"node."
msgstr ""

msgid "If there is no path, the resulting set is empty."
msgstr ""

msgid "Driving Distance - Category"
msgstr ""

msgid ""
":doc:`pgr_drivingDistance` - Driving Distance based on Dijkstra's "
"algorithm"
msgstr ""

msgid ":doc:`pgr_primDD` - Driving Distance based on Prim's algorithm"
msgstr ""

msgid ":doc:`pgr_kruskalDD` - Driving Distance based on Kruskal's algorithm"
msgstr ""

msgid ":doc:`pgr_withPointsDD` - Driving Distance based on pgr_withPoints"
msgstr ""

msgid "Calculate nodes that are within a distance."
msgstr ""

msgid ""
"Extracts all the nodes that have costs less than or equal to the value "
"distance."
msgstr ""

msgid "The edges extracted will conform to the corresponding spanning tree."
msgstr ""

msgid "Edge :math:`(u, v)` will not be included when:"
msgstr ""

msgid "The distance from the **root** to :math:`u` > limit distance."
msgstr ""

msgid "The distance from the **root** to :math:`v` > limit distance."
msgstr ""

msgid ""
"No new nodes are created on the graph, so when is within the limit and is"
" not within the limit, the edge is not included."
msgstr ""

msgid "Edges SQL as described below."
msgstr ""

msgid "**Root vid**"
msgstr ""

msgid "**Root vids**"
msgstr ""

msgid "``ARRAY[ANY-INTEGER]``"
msgstr ""

msgid "**distance**"
msgstr ""

msgid "Upper limit for the inclusion of a node in the result."
msgstr ""

msgid "Returns set of |result-spantree|"
msgstr ""

msgid ":math:`depth-1` is the depth of ``pred``"
msgstr ""

msgid "``pred``"
msgstr ""

msgid "Predecessor of ``node``."
msgstr ""

msgid "When ``node`` = ``start_vid`` then has the value ``node``."
msgstr ""

msgid "Identifier of the ``edge`` used to arrive from ``pred`` to ``node``."
msgstr ""

msgid "Experimental Functions"
msgstr ""

msgid "Families"
msgstr ""

msgid ":doc:`flow-family`"
msgstr ""

msgid ":doc:`pgr_maxFlowMinCost` - Details of flow and cost on edges."
msgstr ""

msgid ":doc:`pgr_maxFlowMinCost_Cost` - Only the Min Cost calculation."
msgstr ""

msgid ":doc:`chinesePostmanProblem-family`"
msgstr ""

msgid ":doc:`coloring-family`"
msgstr ""

msgid ":doc:`contraction-family`"
msgstr ""

msgid ":doc:`transformation-family`"
msgstr ""

msgid ""
":doc:`pgr_lineGraphFull` - Transformation algorithm for generating a Line"
" Graph out of each vertex in the input graph."
msgstr ""

msgid ":doc:`traversal-family`"
msgstr ""

msgid ""
":doc:`pgr_breadthFirstSearch` - Breath first search traversal of the "
"graph."
msgstr ""

msgid ""
":doc:`pgr_binaryBreadthFirstSearch` - Breath first search traversal of "
"the graph."
msgstr ""

msgid ":doc:`components-family`"
msgstr ""

msgid ":doc:`ordering-family`"
msgstr ""

msgid ""
":doc:`pgr_cuthillMckeeOrdering` - Return reverse Cuthill-McKee ordering "
"of an undirected graph."
msgstr ""

msgid ""
":doc:`pgr_topologicalSort` - Linear ordering of the vertices for directed"
" acyclic graph."
msgstr ""

msgid ""
":doc:`pgr_sloanOrdering` - Returns the sloan ordering of an undirected "
"graph."
msgstr ""

msgid ""
":doc:`pgr_kingOrdering` - Returns the King ordering of an undirected "
"graph."
msgstr ""

msgid ":doc:`metrics-family`"
msgstr ""

msgid ""
":doc:`pgr_betweennessCentrality` - Calculates relative betweenness "
"centrality using Brandes Algorithm"
msgstr ""

msgid ":doc:`pgr_bandwidth` - Computes the bandwidth of a graph."
msgstr ""

msgid ":doc:`TRSP-family`"
msgstr ""

msgid "categories"
msgstr ""

msgid ":doc:`VRP-category`"
msgstr ""

msgid "Shortest Path Category"
msgstr ""

msgid ":doc:`pgr_bellmanFord`"
msgstr ""

msgid ":doc:`pgr_dagShortestPath`"
msgstr ""

msgid ":doc:`pgr_edwardMoore`"
msgstr ""

msgid "Planar Family"
msgstr ""

msgid ":doc:`pgr_isPlanar`"
msgstr ""

msgid "Miscellaneous Algorithms"
msgstr ""

msgid ":doc:`pgr_lengauerTarjanDominatorTree`"
msgstr ""

msgid ":doc:`pgr_stoerWagner`"
msgstr ""

msgid ":doc:`pgr_transitiveClosure`"
msgstr ""

msgid ":doc:`pgr_hawickCircuits`"
msgstr ""

msgid "Flow - Family of functions"
msgstr ""

msgid ""
":doc:`pgr_maxFlow` - Only the Max flow calculation using Push and Relabel"
" algorithm."
msgstr ""

msgid ""
":doc:`pgr_boykovKolmogorov` - Boykov and Kolmogorov with details of flow "
"on edges."
msgstr ""

msgid ""
":doc:`pgr_edmondsKarp` - Edmonds and Karp algorithm with details of flow "
"on edges."
msgstr ""

msgid ""
":doc:`pgr_pushRelabel` - Push and relabel algorithm with details of flow "
"on edges."
msgstr ""

msgid "Applications"
msgstr ""

msgid ""
":doc:`pgr_edgeDisjointPaths` - Calculates edge disjoint paths between two"
" groups of vertices."
msgstr ""

msgid ""
":doc:`pgr_maxCardinalityMatch` - Calculates a maximum cardinality "
"matching in a graph."
msgstr ""

msgid "Flow Functions General Information"
msgstr ""

msgid "The graph is **directed**."
msgstr ""

msgid "Process is done only on edges with positive capacities."
msgstr ""

msgid ""
"When the maximum flow is 0 then there is no flow and **EMPTY SET** is "
"returned."
msgstr ""

msgid "There is no flow when source has the same value as target."
msgstr ""

msgid "Any duplicated values in source or target are ignored."
msgstr ""

msgid "Calculates the flow/residual capacity for each edge. In the output"
msgstr ""

msgid "Edges with zero flow are omitted."
msgstr ""

msgid "Creates"
msgstr ""

msgid "a **super source** and edges from it to all the sources,"
msgstr ""

msgid "a **super target** and edges from it to all the targetss."
msgstr ""

msgid ""
"The maximum flow through the graph is guaranteed to be the value returned"
" by :doc:`pgr_maxFlow <pgr_maxFlow>` when executed with the same "
"parameters and can be calculated:"
msgstr ""

msgid "By aggregation of the outgoing flow from the sources"
msgstr ""

msgid "By aggregation of the incoming flow to the targets"
msgstr ""

msgid ""
":doc:`pgr_maxFlow` is the maximum Flow and that maximum is guaranteed to "
"be the same on the functions :doc:`pgr_pushRelabel`, "
":doc:`pgr_edmondsKarp`, :doc:`pgr_boykovKolmogorov`, but the actual flow "
"through each edge may vary."
msgstr ""

msgid "Capacity edges"
msgstr ""

msgid ":doc:`pgr_pushRelabel`"
msgstr ""

msgid ":doc:`pgr_edmondsKarp`"
msgstr ""

msgid ":doc:`pgr_boykovKolmogorov`"
msgstr ""

msgid "``reverse_capacity``"
msgstr ""

msgid "Capacity-Cost edges"
msgstr ""

msgid ":doc:`pgr_maxFlowMinCost`"
msgstr ""

msgid ":doc:`pgr_maxFlowMinCost_Cost`"
msgstr ""

msgid "Capacity of the edge (``source``, ``target``)"
msgstr ""

msgid "Capacity of the edge (``target``, ``source``)"
msgstr ""

msgid "Weight of the edge (``source``, ``target``) if it exist"
msgstr ""

msgid "Weight of the edge (``target``, ``source``) if it exist"
msgstr ""

msgid "Cost edges"
msgstr ""

msgid ":doc:`pgr_edgeDisjointPaths`"
msgstr ""

msgid "Used in"
msgstr ""

msgid "**seq**"
msgstr ""

msgid "``INT``"
msgstr ""

msgid "**edge**"
msgstr ""

msgid "Identifier of the edge in the original query (edges_sql)."
msgstr ""

msgid "**start_vid**"
msgstr ""

msgid "**end_vid**"
msgstr ""

msgid "**flow**"
msgstr ""

msgid "Flow through the edge in the direction (``start_vid``, ``end_vid``)."
msgstr ""

msgid "**residual_capacity**"
msgstr ""

msgid ""
"Residual capacity of the edge in the direction (``start_vid``, "
"``end_vid``)."
msgstr ""

msgid "For :doc:`pgr_maxFlowMinCost`"
msgstr ""

msgid "**source**"
msgstr ""

msgid "**target**"
msgstr ""

msgid "Flow through the edge in the direction (source, target)."
msgstr ""

msgid "Residual capacity of the edge in the direction (source, target)."
msgstr ""

msgid "**cost**"
msgstr ""

msgid ""
"The cost of sending this flow through the edge in the direction (source, "
"target)."
msgstr ""

msgid "**agg_cost**"
msgstr ""

msgid "The aggregate cost."
msgstr ""

msgid "Advanced Documentation"
msgstr ""

msgid ""
"A flow network is a directed graph where each edge has a capacity and a "
"flow. The flow through an edge must not exceed the capacity of the edge. "
"Additionally, the incoming and outgoing flow of a node must be equal "
"except for source which only has outgoing flow, and the destination(sink)"
" which only has incoming flow."
msgstr ""

msgid ""
"Maximum flow algorithms calculate the maximum flow through the graph and "
"the flow of each edge."
msgstr ""

msgid ""
"The maximum flow through the graph is guaranteed to be the same with all "
"implementations, but the actual flow through each edge may vary."
msgstr ""

msgid "pgr_maxFlow :math:`(edges\\_sql, source\\_vertex, sink\\_vertex)`"
msgstr ""

#, python-brace-format
msgid ""
"where :math:`edges\\_sql = \\{(id_i, source_i, target_i, capacity_i, "
"reverse\\_capacity_i)\\}`"
msgstr ""

msgid "Graph definition"
msgstr ""

msgid "The weighted directed graph, :math:`G(V,E)`, is defined as:"
msgstr ""

msgid "the set of vertices  :math:`V`"
msgstr ""

msgid ""
":math:`source\\_vertex  \\cup  sink\\_vertex  \\bigcup  source_i  "
"\\bigcup  target_i`"
msgstr ""

msgid ""
":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, capacity_i) "
"\\text{ when } capacity > 0 \\} & \\quad  \\text{ if } reverse\\_capacity"
" = \\varnothing \\\\ \\text{ } & \\quad \\text{ } \\\\ \\{(source_i, "
"target_i, capacity_i) \\text{ when } capacity > 0 \\} & \\text{ } \\\\ "
"\\cup \\{(target_i, source_i, reverse\\_capacity_i) \\text{ when } "
"reverse\\_capacity_i > 0)\\} & \\quad \\text{ if } reverse\\_capacity "
"\\neq \\varnothing \\\\ \\end{cases}`"
msgstr ""

msgid "Maximum flow problem"
msgstr ""

msgid ":math:`G(V,E)`"
msgstr ""

msgid ":math:`source\\_vertex \\in V` the source vertex"
msgstr ""

msgid ":math:`sink\\_vertex \\in V` the sink vertex"
msgstr ""

#, python-brace-format
msgid ":math:`pgr\\_maxFlow(edges\\_sql, source, sink) = \\boldsymbol{\\Phi}`"
msgstr ""

#, python-brace-format
msgid ""
":math:`\\boldsymbol{\\Phi} = {(id_i, edge\\_id_i, source_i, target_i, "
"flow_i, residual\\_capacity_i)}`"
msgstr ""

#, python-brace-format
msgid ""
":math:`\\boldsymbol{\\Phi}` is a subset of the original edges with their "
"residual capacity and flow. The maximum flow through the graph can be "
"obtained by aggregating on the source or sink and summing the flow "
"from/to it. In particular:"
msgstr ""

msgid ":math:`id_i = i`"
msgstr ""

msgid ":math:`edge\\_id = id_i` in edges_sql"
msgstr ""

msgid ":math:`residual\\_capacity_i = capacity_i - flow_i`"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Maximum_flow_problem"
msgstr ""

msgid ""
"pgRouting extends the `PostGIS <https://postgis.net>`__/`PostgreSQL "
"<https://www.postgresql.org>`__ geospatial database to provide geospatial"
" routing and other network analysis functionality."
msgstr ""

msgid "This is the manual for pgRouting |release|."
msgstr ""

msgid "Creative Commons Attribution-Share Alike 3.0 License"
msgstr ""

msgid ""
"The pgRouting Manual is licensed under a `Creative Commons Attribution-"
"Share Alike 3.0 License <https://creativecommons.org/licenses/by-"
"sa/3.0/>`_. Feel free to use this material any way you like, but we ask "
"that you attribute credit to the pgRouting Project and wherever possible,"
" a link back to https://pgrouting.org. For other licenses used in "
"pgRouting see the :ref:`license` page."
msgstr ""

msgid "General"
msgstr ""

msgid ":doc:`sampledata` that is used in the examples of this manual."
msgstr ""

msgid "Pgrouting Concepts"
msgstr ""

msgid ":doc:`routingFunctions`"
msgstr ""

msgid ":doc:`allpairs-family`"
msgstr ""

msgid ":doc:`bdDijkstra-family`"
msgstr ""

msgid ":doc:`dijkstra-family`"
msgstr ""

msgid ":doc:`kruskal-family`"
msgstr ""

msgid ":doc:`pgr_kruskal`"
msgstr ""

msgid ":doc:`pgr_kruskalDD`"
msgstr ""

msgid ""
":doc:`pgr_degree` - Returns a set of vertices and corresponding count of "
"incident edges to the vertex."
msgstr ""

msgid ":doc:`prim-family`"
msgstr ""

msgid ":doc:`pgr_prim`"
msgstr ""

msgid ":doc:`pgr_primDD`"
msgstr ""

msgid ":doc:`reference`"
msgstr ""

msgid ":doc:`pgr_version`"
msgstr ""

msgid ":doc:`pgr_full_version`"
msgstr ""

msgid ":doc:`utilities-family`"
msgstr ""

msgid ""
":doc:`pgr_extractVertices` - Extracts vertex information based on the "
"edge table information."
msgstr ""

msgid ":doc:`pgr_findCloseEdges` - Finds close edges of points on the fly"
msgstr ""

msgid ":doc:`pgr_separateCrossing` - Breaks geometries that cross each other."
msgstr ""

msgid ""
":doc:`pgr_separateTouching` - Breaks geometries that (almost) touch each "
"other."
msgstr ""

msgid ":doc:`withPoints-family`"
msgstr ""

msgid ":doc:`pgr_withPoints` - Route from/to points anywhere on the graph."
msgstr ""

msgid ":doc:`pgr_withPointsCost` - Costs of the shortest paths."
msgstr ""

msgid ":doc:`pgr_withPointsCostMatrix` - Costs of the shortest paths."
msgstr ""

msgid ":doc:`pgr_withPointsKSP` - K shortest paths."
msgstr ""

msgid ":doc:`pgr_withPointsDD` - Driving distance."
msgstr ""

msgid ":doc:`pgr_withPointsVia` - Via routing"
msgstr ""

msgid "Functions by categories"
msgstr ""

msgid ":doc:`cost-category`"
msgstr ""

msgid ":doc:`costMatrix-category`"
msgstr ""

msgid ":doc:`drivingDistance-category`"
msgstr ""

msgid ":doc:`KSP-category`"
msgstr ""

msgid ":doc:`spanningTree-category`"
msgstr ""

msgid ":doc:`BFS-category`"
msgstr ""

msgid ":doc:`DFS-category`"
msgstr ""

msgid ":doc:`withPoints-category`"
msgstr ""

msgid ":doc:`withPoints-family` - Functions based on Dijkstra algorithm."
msgstr ""

msgid "From the :doc:`TRSP-family`:"
msgstr ""

msgid "Available Functions but not official pgRouting functions"
msgstr ""

msgid ":doc:`proposed`"
msgstr ""

msgid ":doc:`experimental`"
msgstr ""

msgid ":doc:`release_notes`"
msgstr ""

msgid "pgRouting 4.0.0-alpha1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 4.0.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%204.0.0%22>`__"
msgstr ""

msgid "Build"
msgstr ""

msgid "C++ standard is std17"
msgstr ""

msgid ""
"Using this standard, all supported toolchains across our CI matrix will "
"work."
msgstr ""

msgid "The code is not yet modified to use std17:"
msgstr ""

msgid "If needed: ``-DCMAKE_CXX_STANDARD=14`` to lower the standard."
msgstr ""

msgid "The user's documentation is built by default."
msgstr ""

msgid "The doxygen documentation is built by default."
msgstr ""

msgid "For developers:"
msgstr ""

msgid "Set `-DUSE_CLANG_TIDY=ON` for clang tidy checks."
msgstr ""

msgid "Tidy checks are done on CI."
msgstr ""

msgid "Documentation build"
msgstr ""

msgid "The doxygen documentation is built by default"
msgstr ""

msgid "The HTML documentation is built by default"
msgstr ""

msgid ""
"The translated languages (en, es, sv, zh_Hans) HTML documentation are "
"built by default"
msgstr ""

msgid "`WITH-DOC` is not used anymore"
msgstr ""

msgid "User Documentation is not built when"
msgstr ""

msgid "Sphinx is not found"
msgstr ""

msgid "When all Sphinx formats are OFF"
msgstr ""

msgid "To not build HTML default format: `-DBUILD_HTML=OFF`"
msgstr ""

msgid "When all languages are OFF"
msgstr ""

msgid "To build only English: `-DES=OFF -DSV=OFF -DZH_HANS=OFF`"
msgstr ""

msgid "Documentation output location: ``build/doc/_build/<format>``"
msgstr ""

msgid "For example: for HTML output is on `build/doc/_build/html` directory"
msgstr ""

msgid "Developers' Documentation is not built when"
msgstr ""

msgid "Doxygen is not found"
msgstr ""

msgid "To not build Doxygen documentation: `-DBUILD_DOXY=OFF`"
msgstr ""

msgid "Summary of changes by function"
msgstr ""

msgid "pgr_aStar"
msgstr ""

msgid "Combinations signature promoted to official."
msgstr ""

msgid "pgr_aStarCost"
msgstr ""

msgid "pgr_bandwidth"
msgstr ""

msgid "New experimental function."
msgstr ""

msgid "pgr_bdAstar"
msgstr ""

msgid "pgr_bdAstarCost"
msgstr ""

msgid "pgr_bdDijkstra"
msgstr ""

msgid "Output columns standardized to |short-generic-result|"
msgstr ""

msgid "pgr_bdDijkstraCost"
msgstr ""

msgid "pgr_bellmanFord"
msgstr ""

msgid "pgr_binaryBreadthFirstSearch"
msgstr ""

msgid "pgr_bipartite"
msgstr ""

msgid "Output columns standardized to |result_node_color|"
msgstr ""

msgid "pgr_boykovKolmogorov"
msgstr ""

msgid "pgr_breadthFirstSearch"
msgstr ""

msgid ":"
msgstr ""

msgid "Standardizing output columns to |result-spantree|"
msgstr ""

msgid "pgr_contraction"
msgstr ""

msgid "Breaking change, signatures no longer available:"
msgstr ""

msgid "pgr_contraction(text,bigint[],integer,bigint[],boolean)"
msgstr ""

msgid "pgr_dagShortestPath"
msgstr ""

msgid "pgr_depthFirstSearch"
msgstr ""

msgid "pgr_dijkstra"
msgstr ""

msgid "pgr_dijkstraCost"
msgstr ""

msgid "pgr_edgeColoring"
msgstr ""

msgid "Output columns standardized to |result_edge_color|"
msgstr ""

msgid "pgr_edgeDisjointPaths"
msgstr ""

msgid "Output columns standardized to |generic-result|"
msgstr ""

msgid "pgr_edmondsKarp"
msgstr ""

msgid "pgr_edwardMoore"
msgstr ""

msgid "Version 3.2.0"
msgstr ""

msgid "New experimental signature:"
msgstr ""

msgid "pgr_edwardMoore(Combinations)"
msgstr ""

msgid "Version 3.0.0"
msgstr ""

msgid "pgr_kingOrdering"
msgstr ""

msgid "pgr_KSP"
msgstr ""

msgid "All signatures promoted to official."
msgstr ""

msgid "pgr_maxFlow"
msgstr ""

msgid "pgr_pushRelabel"
msgstr ""

msgid "pgr_sloanOrdering"
msgstr ""

msgid "pgr_sequentialVertexColoring"
msgstr ""

msgid "pgr_topologicalSort"
msgstr ""

msgid "Standardize output to |result_node_order|"
msgstr ""

msgid "pgr_transitiveClosure"
msgstr ""

msgid "Standardized output to |result-closure|"
msgstr ""

msgid "pgr_trsp"
msgstr ""

msgid "Function promoted to official."
msgstr ""

msgid "pgr_trsp(text,integer,integer,boolean,boolean,text)"
msgstr ""

msgid ""
"pgr_trsp(text,integer,double precision,integer,double "
"precision,boolean,boolean,text)"
msgstr ""

msgid "pgr_trspVia"
msgstr ""

msgid "pgr_trspviavertices(text,anyarray,boolean,boolean,text)"
msgstr ""

msgid "pgr_trspVia_withPoints"
msgstr ""

msgid "**Driving side** parameter is positional unnamed."
msgstr ""

msgid "Valid values depend on kind of graph"
msgstr ""

msgid "pgr_trspvia_withpoints(text,text,text,anyarray,boolean,boolean,boolean,character,boolean)"
msgstr ""

msgid "pgr_trspviaedges(text,integer[],double precision[],boolean,boolean,text)"
msgstr ""

msgid "pgr_trsp_withPoints"
msgstr ""

msgid "**Driving side** parameter is positional unnamed and compulsory."
msgstr ""

msgid "pgr_trsp_withpoints(text,text,text,anyarray,anyarray,boolean,character,boolean)"
msgstr ""

msgid "pgr_trsp_withpoints(text,text,text,anyarray,bigint,boolean,character,boolean)"
msgstr ""

msgid "pgr_trsp_withpoints(text,text,text,bigint,anyarray,boolean,character,boolean)"
msgstr ""

msgid "pgr_trsp_withpoints(text,text,text,bigint,bigint,boolean,character,boolean)"
msgstr ""

msgid "pgr_trsp_withpoints(text,text,text,text,boolean,character,boolean)"
msgstr ""

msgid "pgr_turnRestrictedPath"
msgstr ""

msgid "Output columns standardized to |nksp-result|"
msgstr ""

msgid "pgr_withPoints"
msgstr ""

msgid "pgr_withpoints(text,text,anyarray,anyarray,boolean,character,boolean)"
msgstr ""

msgid "pgr_withpoints(text,text,anyarray,bigint,boolean,character,boolean)"
msgstr ""

msgid "pgr_withpoints(text,text,bigint,anyarray,boolean,character,boolean)"
msgstr ""

msgid "pgr_withpoints(text,text,bigint,bigint,boolean,character,boolean)"
msgstr ""

msgid "pgr_withpoints(text,text,text,boolean,character,boolean)"
msgstr ""

msgid "pgr_withPointsCost"
msgstr ""

msgid "**Driving side** parameter is unnamed and compulsory."
msgstr ""

msgid "Output columns standardized to |matrix-result|"
msgstr ""

msgid "pgr_withpointscost(text,text,anyarray,anyarray,boolean,character)"
msgstr ""

msgid "pgr_withpointscost(text,text,anyarray,bigint,boolean,character)"
msgstr ""

msgid "pgr_withpointscost(text,text,bigint,anyarray,boolean,character)"
msgstr ""

msgid "pgr_withpointscost(text,text,bigint,bigint,boolean,character)"
msgstr ""

msgid "pgr_withpointscost(text,text,text,boolean,character)"
msgstr ""

msgid "pgr_withPointsCostMatrix"
msgstr ""

msgid "pgr_withpointscostmatrix(text,text,anyarray,boolean,character)"
msgstr ""

msgid "pgr_withPointsDD"
msgstr ""

msgid ""
"pgr_withpointsdd(text,text,bigint,double "
"precision,boolean,character,boolean)"
msgstr ""

msgid ""
"pgr_withpointsdd(text,text,anyarray,double "
"precision,boolean,character,boolean,boolean)"
msgstr ""

msgid "pgr_withPointsKSP"
msgstr ""

msgid "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,character,boolean)"
msgstr ""

msgid "pgr_withPointsVia"
msgstr ""

msgid "pgr_withpointsvia(text,text,anyarray,boolean,boolean,boolean,character,boolean)"
msgstr ""

msgid "Functions promoted to official"
msgstr ""

msgid "`#2701 <https://github.com/pgRouting/pgrouting/issues/2701>`__: pgr_trsp"
msgstr ""

msgid ""
"`#2701 <https://github.com/pgRouting/pgrouting/issues/2701>`__: "
"pgr_trspVia"
msgstr ""

msgid ""
"`#2701 <https://github.com/pgRouting/pgrouting/issues/2701>`__: "
"pgr_trspVia_withPoints"
msgstr ""

msgid ""
"`#2701 <https://github.com/pgRouting/pgrouting/issues/2701>`__: "
"pgr_trsp_withPoints"
msgstr ""

msgid ""
"`#2700 <https://github.com/pgRouting/pgrouting/issues/2700>`__: "
"pgr_withPoints"
msgstr ""

msgid ""
"`#2700 <https://github.com/pgRouting/pgrouting/issues/2700>`__: "
"pgr_withPointsCost"
msgstr ""

msgid ""
"`#2700 <https://github.com/pgRouting/pgrouting/issues/2700>`__: "
"pgr_withPointsCostMatrix"
msgstr ""

msgid ""
"`#2700 <https://github.com/pgRouting/pgrouting/issues/2700>`__: "
"pgr_withPointsDD"
msgstr ""

msgid ""
"`#2700 <https://github.com/pgRouting/pgrouting/issues/2700>`__: "
"pgr_withPointsKSP"
msgstr ""

msgid ""
"`#2700 <https://github.com/pgRouting/pgrouting/issues/2700>`__: "
"pgr_withPointsVia"
msgstr ""

msgid "Signatures promoted to official"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_aStar(Combinations)"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_aStarCost(Combinations)"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_bdAstar(Combinations)"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_bdAstarCost(Combinations)"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_bdDijkstra(Combinations)"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_bdDijkstraCost(Combinations)"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_dijkstra(Combinations)"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_dijkstraCost(Combinations)"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_KSP(All signatures)"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_boykovKolmogorov(Combinations)"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_edmondsKarp(Combinations)"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_maxFlow(Combinations)"
msgstr ""

msgid ""
"`#2718 <https://github.com/pgRouting/pgrouting/issues/2718>`__: "
"pgr_pushRelabel(Combinations)"
msgstr ""

msgid "New experimental functions."
msgstr ""

msgid "Metrics"
msgstr ""

msgid ""
"`#2951 <https://github.com/pgRouting/pgrouting/issues/2951>`__: "
"pgr_bandwidth"
msgstr ""

msgid "Ordering"
msgstr ""

msgid ""
"`#2954 <https://github.com/pgRouting/pgrouting/issues/2954>`__: "
"pgr_kingOrdering"
msgstr ""

msgid ""
"`#2955 <https://github.com/pgRouting/pgrouting/issues/2955>`__: "
"pgr_sloanOrdering"
msgstr ""

msgid "SQL signatures and output standardization"
msgstr ""

msgid ""
"`#2904 <https://github.com/pgRouting/pgrouting/issues/2904>`__: "
"Standardize output columns of functions with different output"
msgstr ""

msgid "columns within overloads"
msgstr ""

msgid "Standardized to |short-generic-result|"
msgstr ""

msgid ""
"`#2905 <https://github.com/pgRouting/pgrouting/issues/2905>`__: "
"pgr_withPoints"
msgstr ""

msgid ""
"`#2906 <https://github.com/pgRouting/pgrouting/issues/2906>`__: "
"pgr_bdDijkstra"
msgstr ""

msgid ""
"`#2907 <https://github.com/pgRouting/pgrouting/issues/2907>`__: "
"pgr_bellmanFord"
msgstr ""

msgid ""
"`#2908 <https://github.com/pgRouting/pgrouting/issues/2908>`__: "
"pgr_binaryBreadthFirstSearch"
msgstr ""

msgid ""
"`#2910 <https://github.com/pgRouting/pgrouting/issues/2910>`__: "
"pgr_edwardMoore"
msgstr ""

msgid ""
"`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__: "
"pgr_dagShortestPath"
msgstr ""

msgid "Standardized to |matrix-result|"
msgstr ""

msgid ""
"`#2905 <https://github.com/pgRouting/pgrouting/issues/2905>`__: "
"pgr_withPointsCost"
msgstr ""

msgid ""
"`#2905 <https://github.com/pgRouting/pgrouting/issues/2905>`__: "
"pgr_withPointsCostMatrix"
msgstr ""

msgid "Standardized to |generic-result|"
msgstr ""

msgid ""
"`#2909 <https://github.com/pgRouting/pgrouting/issues/2909>`__: "
"pgr_edgeDisjointPaths"
msgstr ""

msgid ""
"`#2909 <https://github.com/pgRouting/pgrouting/issues/2909>`__: "
"pgr_turnRestrictedPath"
msgstr ""

msgid "Standardized to |result_edge_color|"
msgstr ""

msgid ""
"`#2924 <https://github.com/pgRouting/pgrouting/issues/2924>`__: "
"pgr_edgeColoring"
msgstr ""

msgid "Standardized to |result_node_color|"
msgstr ""

msgid ""
"`#2924 <https://github.com/pgRouting/pgrouting/issues/2924>`__: "
"pgr_bipartite"
msgstr ""

msgid ""
"`#2927 <https://github.com/pgRouting/pgrouting/issues/2927>`__: "
"pgr_sequentialVertexColoring"
msgstr ""

msgid "Standardized to |result-spantree|"
msgstr ""

msgid ""
"`#2931 <https://github.com/pgRouting/pgrouting/issues/2931>`__: "
"pgr_breadthFirstSearch"
msgstr ""

msgid ""
"`#2931 <https://github.com/pgRouting/pgrouting/issues/2931>`__: "
"pgr_depthFirstSearch"
msgstr ""

msgid "Standardized to |result_node_order|"
msgstr ""

msgid ""
"`#2934 <https://github.com/pgRouting/pgrouting/issues/2934>`__: "
"pgr_topologicalSort"
msgstr ""

msgid "Standardized to |result-closure|"
msgstr ""

msgid ""
"`#2934 <https://github.com/pgRouting/pgrouting/issues/2934>`__: "
"pgr_transitiveClosure"
msgstr ""

msgid "Removal of SQL deprecated signatures"
msgstr ""

msgid ""
"`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__: "
"pgr_contraction"
msgstr ""

msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: pgr_trsp"
msgstr ""

msgid ""
"`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__: "
"pgr_trspVia"
msgstr ""

msgid ""
"`#2888 <https://github.com/pgRouting/pgrouting/issues/2888>`__: "
"pgr_findCloseEdges"
msgstr ""

msgid "pgr_findcloseedges(text,geometry,double precision,integer,boolean,boolean)"
msgstr ""

msgid ""
"pgr_findcloseedges(text,geometry[],double "
"precision,integer,boolean,boolean)"
msgstr ""

msgid ""
"`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__: "
"pgr_withPointsDD"
msgstr ""

msgid ""
"`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__: "
"pgr_withPointsKSP"
msgstr ""

msgid ""
"`#2899 <https://github.com/pgRouting/pgrouting/issues/2899>`__: "
"pgr_maxCardinalityMatch"
msgstr ""

msgid "pgr_maxCardinalityMatch(text,boolean)"
msgstr ""

msgid "`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__: pgr_TSP"
msgstr ""

msgid ""
"pgr_tsp(text,bigint,bigint,double "
"precision,integer,integer,integer,double precision,double "
"precision,double precision,boolean)"
msgstr ""

msgid ""
"`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__: "
"pgr_TSPeuclidean"
msgstr ""

msgid ""
"pgr_tspeuclidean(text,bigint,bigint,double precision,integer,integer, "
"integer,double precision,double precision,double precision,boolean)"
msgstr ""

msgid "Removal of SQL deprecated functions"
msgstr ""

msgid ""
"`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__: "
"pgr_trspViaedges"
msgstr ""

msgid ""
"`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__: "
"pgr_trspViaVertices"
msgstr ""

msgid ""
"`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__: "
"pgr_alphaShape"
msgstr ""

msgid ""
"`#2751 <https://github.com/pgRouting/pgrouting/issues/2751>`__: "
"pgr_createTopology"
msgstr ""

msgid ""
"`#2752 <https://github.com/pgRouting/pgrouting/issues/2752>`__: "
"pgr_analyzeGraph"
msgstr ""

msgid ""
"`#2755 <https://github.com/pgRouting/pgrouting/issues/2755>`__: "
"pgr_analyzeOneWay"
msgstr ""

msgid ""
"`#2827 <https://github.com/pgRouting/pgrouting/issues/2827>`__: "
"pgr_createVerticesTable"
msgstr ""

msgid ""
"`#2886 <https://github.com/pgRouting/pgrouting/issues/2886>`__: "
"pgr_nodeNetwork"
msgstr ""

msgid "Removal of SQL deprecated internal functions"
msgstr ""

msgid ""
"`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__ "
"_pgr_alphaShape(text,double precision)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_checkVertTab(text,text[],integer,text)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_createIndex(text,text,text,integer,text)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_createIndex(text,text,text,text,integer,text)"
msgstr ""

msgid ""
"`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__ "
"_pgr_dagShortestPath(text,anyarray,anyarray,boolean,boolean)"
msgstr ""

msgid ""
"`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__ "
"_pgr_dagShortestPath(text,text,boolean,boolean)"
msgstr ""

msgid ""
"`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ "
"_pgr_dijkstraNear(text,anyarray,anyarray,bigint,boolean)"
msgstr ""

msgid ""
"`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ "
"_pgr_dijkstraNear(text,anyarray,bigint,bigint,boolean)"
msgstr ""

msgid ""
"`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ "
"_pgr_dijkstraNear(text,bigint,anyarray,bigint,boolean)"
msgstr ""

msgid ""
"`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ "
"_pgr_dijkstra(text,anyarray,anyarray,boolean,boolean,boolean,bigint)"
msgstr ""

msgid ""
"`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ "
"_pgr_dijkstra(text,anyarray,anyarray,boolean,boolean,boolean,bigint,boolean)"
msgstr ""

msgid ""
"`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ "
"_pgr_dijkstra(text,text,boolean,boolean,bigint,boolean)"
msgstr ""

msgid ""
"`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__ "
"_pgr_dijkstra(text,text,boolean,boolean,boolean)"
msgstr ""

msgid ""
"`#2735 <https://github.com/pgRouting/pgrouting/issues/2735>`__ "
"_pgr_drivingDistance(text,anyarray,double precision,boolean,boolean)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_endPoint(geometry)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"__pgr_getColumnName(text,text,integer,text)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"__pgr_getColumnName(text,text,text,integer,text)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"__pgr_getColumnType(text,text,integer,text)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"__pgr_getColumnType(text,text,text,integer,text)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"__pgr_getTableName(text,integer,text)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_isColumnIndexed(text,text,integer,text)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_isColumnIndexed(text,text,text,integer,text)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_isColumnIntable(text,text)"
msgstr ""

msgid ""
"`#2745 <https://github.com/pgRouting/pgrouting/issues/2745>`__ "
"_pgr_kruskal(text,anyarray,text,bigint,double precision)"
msgstr ""

msgid ""
"`#2897 <https://github.com/pgRouting/pgrouting/issues/2897>`__ "
"_pgr_ksp(text,anyarray,anyarray,integer,boolean,boolean,boolean)"
msgstr ""

msgid ""
"`#2897 <https://github.com/pgRouting/pgrouting/issues/2897>`__ "
"_pgr_ksp(text,bigint,bigint,integer,boolean,boolean)"
msgstr ""

msgid ""
"`#2897 <https://github.com/pgRouting/pgrouting/issues/2897>`__ "
"_pgr_ksp(text,text,integer,boolean,boolean)"
msgstr ""

msgid ""
"`#2899 <https://github.com/pgRouting/pgrouting/issues/2899>`__ "
"_pgr_maxCardinalityMatch(text,boolean)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_msg(integer,text,text)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_onerror(boolean,integer,text,text,text,text)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_pointtoid(geometry,double precision,text,integer)"
msgstr ""

msgid ""
"`#2743 <https://github.com/pgRouting/pgrouting/issues/2743>`__ "
"_pgr_prim(text,anyarray,text,bigint,double precision)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_quote_ident(text)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_startPoint(geometry)"
msgstr ""

msgid ""
"`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ "
"_pgr_trsp(text,integer,double precision,integer,double "
"precision,boolean,boolean,text)"
msgstr ""

msgid ""
"`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ "
"_pgr_trsp(text,text,anyarray,anyarray,boolean)"
msgstr ""

msgid ""
"`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ "
"_pgr_trsp(text,text,anyarray,bigint,boolean)"
msgstr ""

msgid ""
"`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ "
"_pgr_trsp(text,text,bigint,anyarray,boolean)"
msgstr ""

msgid ""
"`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ "
"_pgr_trsp(text,text,bigint,bigint,boolean)"
msgstr ""

msgid ""
"`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__ "
"_pgr_trspViaVertices(text,integer[],boolean,boolean,text)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"_pgr_trspVia_withPoints(text,text,text,anyarray,boolean,boolean,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"_pgr_trsp_withPoints(text,text,text,anyarray,anyarray,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"_pgr_trsp_withPoints(text,text,text,text,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__ "
"_pgr_tspEuclidean(text,bigint,bigint,double "
"precision,integer,integer,integer,double precision,double "
"precision,double precision,boolean)"
msgstr ""

msgid ""
"`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__ "
"_pgr_tsp(text,bigint,bigint,double "
"precision,integer,integer,integer,double precision,double "
"precision,double precision,boolean)"
msgstr ""

msgid ""
"`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__ "
"_pgr_versionLess(text,text)"
msgstr ""

msgid ""
"`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__ "
"_pgr_withPointsDD(text,text,anyarray,double "
"precision,boolean,character,boolean,boolean)"
msgstr ""

msgid ""
"`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__ "
"_pgr_withPointsKSP(text,text,anyarray,anyarray,integer,character,boolean,boolean,boolean,boolean)"
msgstr ""

msgid ""
"`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__ "
"_pgr_withPointsKSP(text,text,bigint,bigint,integer,boolean,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__ "
"_pgr_withPointsKSP(text,text,text,integer,character,boolean,boolean,boolean)"
msgstr ""

msgid ""
"`#2741 <https://github.com/pgRouting/pgrouting/issues/2741>`__ "
"_pgr_withPointsVia(text,bigint[],double precision[],boolean)"
msgstr ""

msgid ""
"`#2741 <https://github.com/pgRouting/pgrouting/issues/2741>`__ "
"_pgr_withPointsVia(text,text,anyarray,boolean,boolean,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ "
"_trsp(text,text,anyarray,anyarray,boolean)"
msgstr ""

msgid ""
"`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ "
"_v4trsp(text,text,anyarray,anyarray,boolean)"
msgstr ""

msgid ""
"`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ "
"_v4trsp(text,text,text,boolean)"
msgstr ""

msgid "Summary of functions and signatures no longer on pgrouting"
msgstr ""

msgid ""
"`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__ "
"pgr_alphashape(geometry,double precision)"
msgstr ""

msgid ""
"`#2752 <https://github.com/pgRouting/pgrouting/issues/2752>`__ "
"pgr_analyzegraph(text,double precision,text,text,text,text,text)"
msgstr ""

msgid ""
"`#2755 <https://github.com/pgRouting/pgrouting/issues/2755>`__ "
"pgr_analyzeoneway(text,text[],text[],text[],text[],boolean,text,text,text)"
msgstr ""

msgid ""
"`#2798 <https://github.com/pgRouting/pgrouting/issues/2798>`__ "
"pgr_contraction(text,bigint[],integer,bigint[],boolean)"
msgstr ""

msgid ""
"`#2751 <https://github.com/pgRouting/pgrouting/issues/2751>`__ "
"pgr_createtopology(text,double "
"precision,text,text,text,text,text,boolean)"
msgstr ""

msgid ""
"`#2827 <https://github.com/pgRouting/pgrouting/issues/2827>`__ "
"pgr_createverticestable(text,text,text,text,text)"
msgstr ""

msgid ""
"`#2888 <https://github.com/pgRouting/pgrouting/issues/2888>`__ "
"pgr_findcloseedges(text,geometry,double "
"precision,integer,boolean,boolean)"
msgstr ""

msgid ""
"`#2888 <https://github.com/pgRouting/pgrouting/issues/2888>`__ "
"pgr_findcloseedges(text,geometry[],double "
"precision,integer,boolean,boolean)"
msgstr ""

msgid ""
"`#2899 <https://github.com/pgRouting/pgrouting/issues/2899>`__ "
"pgr_maxCardinalityMatch(text,boolean)"
msgstr ""

msgid ""
"`#2886 <https://github.com/pgRouting/pgrouting/issues/2886>`__ "
"pgr_nodenetwork(text,double precision,text,text,text,text,boolean)"
msgstr ""

msgid ""
"`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ "
"pgr_trsp(text,integer,double precision,integer,double "
"precision,boolean,boolean,text)"
msgstr ""

msgid ""
"`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ "
"pgr_trsp(text,integer,integer,boolean,boolean,text)"
msgstr ""

msgid ""
"`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__ "
"pgr_trspViaedges(text,integer[],double precision[],boolean,boolean,text)"
msgstr ""

msgid ""
"`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__ "
"pgr_trspViaVertices(text,anyarray,boolean,boolean,text)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_trspVia_withPoints(text,text,text,anyarray,boolean,boolean,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_trsp_withPoints(text,text,text,anyarray,anyarray,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_trsp_withPoints(text,text,text,anyarray,bigint,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_trsp_withPoints(text,text,text,bigint,anyarray,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_trsp_withPoints(text,text,text,bigint,bigint,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_trsp_withPoints(text,text,text,text,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__ "
"pgr_tspEuclidean(text,bigint,bigint,double "
"precision,integer,integer,integer,double precision,double "
"precision,double precision,boolean)"
msgstr ""

msgid ""
"`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__ "
"pgr_tsp(text,bigint,bigint,double "
"precision,integer,integer,integer,double precision,double "
"precision,double precision,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_withPointsCostMatrix(text,text,anyarray,boolean,character)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_withPointsCost(text,text,anyarray,anyarray,boolean,character)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_withPointsCost(text,text,anyarray,bigint,boolean,character)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_withPointsCost(text,text,bigint,anyarray,boolean,character)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_withPointsCost(text,text,bigint,bigint,boolean,character)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_withPointsCost(text,text,text,boolean,character)"
msgstr ""

msgid ""
"`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__ "
"pgr_withPointsDD(text,text,anyarray,double "
"precision,boolean,character,boolean,boolean)"
msgstr ""

msgid ""
"`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__ "
"pgr_withPointsDD(text,text,bigint,double "
"precision,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__ "
"pgr_withPointsKSP(text,text,bigint,bigint,integer,boolean,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_withPoints(text,text,anyarray,anyarray,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_withPoints(text,text,anyarray,bigint,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_withPoints(text,text,bigint,anyarray,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_withPoints(text,text,bigint,bigint,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_withPoints(text,text,text,boolean,character,boolean)"
msgstr ""

msgid ""
"`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__ "
"pgr_withPointsVia(text,text,anyarray,boolean,boolean,boolean,character,boolean)"
msgstr ""

msgid "Code enhancements"
msgstr ""

msgid "Removal of unused C/C++ code"
msgstr ""

msgid "Refactor the Script to build the update PostgreSQL file."
msgstr ""

msgid "One process & driver for:"
msgstr ""

msgid "allpairs: johnson and Floyd-Warshall"
msgstr ""

msgid "Shortest path: Dijkstra and withPoints using Dijkstra"
msgstr ""

msgid "Deprecation of internal C/C++ functions"
msgstr ""

msgid "Deprecated functions are substituted by new function."
msgstr ""

msgid "_pgr_drivingDistance => _pgr_drivingDistancev4"
msgstr ""

msgid "_pgr_withPointsDD => _pgr_withPointsddv4"
msgstr ""

msgid "_pgr_kruskal => _pgr_kruskalv4"
msgstr ""

msgid "_pgr_prim => _pgr_primv4"
msgstr ""

msgid "_pgr_dijkstra => _pgr_dijkstra_v4"
msgstr ""

msgid "_pgr_withPointsKSP => _pgr_withPointsKSP_v4"
msgstr ""

msgid "_pgr_trspVia_withPoints => _pgr_trspVia_withPoints_v4"
msgstr ""

msgid "_pgr_trsp_withPoints => _pgr_trsp_withPoints_v4"
msgstr ""

msgid "_pgr_withPointsVia => _pgr_withPointsvia_v4"
msgstr ""

msgid "Internal C/C++ functions in legacy"
msgstr ""

msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ _trsp"
msgstr ""

msgid "`#2683 <https://github.com/pgRouting/pgrouting/issues/2683>`__ _v4trsp"
msgstr ""

msgid ""
"`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__ "
"_pgr_alphaShape"
msgstr ""

msgid ""
"`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__ "
"_pgr_dagShortestPath"
msgstr ""

msgid "All releases"
msgstr ""

msgid "Kruskal - Family of functions"
msgstr ""

msgid ""
"Kruskal's algorithm is a greedy minimum spanning tree algorithm that in "
"each cycle finds and adds the edge of the least possible weight that "
"connects any two trees in the forest."
msgstr ""

msgid "**The main Characteristics are:**"
msgstr ""

msgid "The total weight of all the edges in the tree or forest is minimized."
msgstr ""

msgid "Kruskal's running time: :math:`O(E * log E)`"
msgstr ""

msgid "Metrics - Family of functions"
msgstr ""

msgid "Migration guide"
msgstr ""

msgid ""
"Several functions are having changes on the signatures, and/or have been "
"replaced by new functions."
msgstr ""

msgid "Results can be different because of the changes."
msgstr ""

msgid "All deprecated functions will be removed on next major version 4.0.0"
msgstr ""

msgid "Migration to standardized columns"
msgstr ""

msgid ""
"There has been an effort to standardize function output columns names and"
" types."
msgstr ""

msgid ":ref:`pgRouting-concepts:Result columns for cost functions`"
msgstr ""

msgid "|matrix-result|"
msgstr ""

msgid ":ref:`pgRouting-concepts:Result columns for single path functions`"
msgstr ""

msgid "|short-generic-result|"
msgstr ""

msgid ":ref:`pgRouting-concepts:Result columns for spanning tree functions`"
msgstr ""

msgid "|result-spantree|"
msgstr ""

msgid "Function"
msgstr ""

msgid ":doc:`pgr_dijkstra`"
msgstr ""

msgid "`Migration of single path functions`_"
msgstr ""

msgid ":doc:`pgr_aStar`"
msgstr ""

msgid ":doc:`pgr_bdAstar`"
msgstr ""

msgid ":doc:`pgr_drivingDistance`"
msgstr ""

msgid "`Migration of spanning tree functions`_"
msgstr ""

msgid ":doc:`pgr_withPointsDD`"
msgstr ""

msgid ":doc:`pgr_bdDijkstra`"
msgstr ""

msgid ":doc:`pgr_binaryBreadthFirstSearch`"
msgstr ""

msgid ":doc:`pgr_bipartite`"
msgstr ""

msgid "`Migration of output column name change`_"
msgstr ""

msgid ":doc:`pgr_breadthFirstSearch`"
msgstr ""

msgid ":doc:`pgr_depthFirstSearch`"
msgstr ""

msgid ":doc:`pgr_edgeColoring`"
msgstr ""

msgid "`Migration of multiple paths functions`_"
msgstr ""

msgid ":doc:`pgr_sequentialVertexColoring`"
msgstr ""

msgid ":doc:`pgr_topologicalSort`"
msgstr ""

msgid ":doc:`pgr_withPoints`"
msgstr ""

msgid "`Migration of cost functions`_"
msgstr ""

msgid "Migration of cost functions"
msgstr ""

msgid ""
"The standardized :ref:`pgRouting-concepts:Result columns for cost "
"functions` are |matrix-result|"
msgstr ""

msgid ""
"The following functions need to be migrated when they are being used in "
"an application."
msgstr ""

msgid "Version"
msgstr ""

msgid "From"
msgstr ""

msgid "``pgr_withPointsCost``"
msgstr ""

msgid "v < 4.0"
msgstr ""

msgid "|matrix-pid|"
msgstr ""

msgid "``pgr_withPointsCostMatrix``"
msgstr ""

msgid "**to** |matrix-result|"
msgstr ""

msgid "Migration of |matrix-pid|"
msgstr ""

msgid "Signatures to be migrated:"
msgstr ""

msgid "One to One"
msgstr ""

msgid "One to Many"
msgstr ""

msgid "Many to One"
msgstr ""

msgid "Many to Many"
msgstr ""

msgid "Combinations"
msgstr ""

msgid "Breaking change"
msgstr ""

msgid ""
"If using ``pgr_withPointsCost``: column names must be changed after "
"updating pgRouting"
msgstr ""

msgid "New output columns are |matrix-result|"
msgstr ""

msgid ""
"To get the old version column names: rename ``start_vid`` to "
"``start_pid`` and ``end_vid`` to ``end_pid``."
msgstr ""

msgid "Examples"
msgstr ""

msgid "Examples for One to One for cost functions"
msgstr ""

msgid "Using ``pgr_withPointsCost``"
msgstr ""

msgid ""
"Migrating `this v3.8 "
"<https://docs.pgrouting.org/3.8/en/pgr_withPointsCost.html#one-to-one>`__"
" example."
msgstr ""

msgid "from"
msgstr ""

msgid "to"
msgstr ""

msgid "Examples for One to Many for cost functions"
msgstr ""

msgid ""
"Migrating `this v3.8 "
"<https://docs.pgrouting.org/3.8/en/pgr_withPointsCost.html#one-to-"
"many>`__ example."
msgstr ""

msgid "Examples for Many to One for cost functions"
msgstr ""

msgid ""
"Migrating `this v3.8 "
"<https://docs.pgrouting.org/3.8/en/pgr_withPointsCost.html#many-to-"
"one>`__ example."
msgstr ""

msgid "Examples for Many to Many for cost functions"
msgstr ""

msgid ""
"Migrating `this v3.8 "
"<https://docs.pgrouting.org/3.8/en/pgr_withPointsCost.html#many-to-"
"many>`__ example."
msgstr ""

msgid "Examples for Combinations for cost functions"
msgstr ""

msgid ""
"Migrating `this v3.8 "
"<https://docs.pgrouting.org/3.8/en/pgr_withPointsCost.html#combinations>`__"
" example."
msgstr ""

msgid "Migration of multiple paths functions"
msgstr ""

msgid ""
"The standardized :ref:`pgRouting-concepts:Result columns for single path "
"functions` are |nksp-result|"
msgstr ""

msgid "``pgr_KSP``"
msgstr ""

msgid "v < 3.6"
msgstr ""

msgid ":ref:`from_ksp_result`"
msgstr ""

msgid "``pgr_edgeDisjointPaths``"
msgstr ""

msgid ":ref:`from_result_disjoint`"
msgstr ""

msgid "Migration of |ksp-result|"
msgstr ""

msgid "|nksp-result|"
msgstr ""

msgid "Before updating pgRouting, enumerate the |ksp-result|"
msgstr ""

msgid "One to One example using ``pgr_KSP``"
msgstr ""

msgid ""
"Using `this "
"<https://docs.pgrouting.org/3.5/en/pgr_KSP.html#signatures>`__ example."
msgstr ""

msgid "Migration of |result-disjoint|"
msgstr ""

msgid "Before updating pgRouting, enumerate the |result-disjoint|"
msgstr ""

msgid "Skip when applicable, ``start_vid``"
msgstr ""

msgid "Skip when applicable, ``end_vid``"
msgstr ""

msgid "One to One example using ``pgr_edgeDisjointPaths``"
msgstr ""

msgid ""
"Migrating `this v3.8 "
"<https://docs.pgrouting.org/3.6/en/pgr_edgeDisjointPaths.html#one-to-"
"one>`__ example."
msgstr ""

msgid "Before updating pgRouting enumerate the columns: |ksp-result|"
msgstr ""

msgid "Migration of single path functions"
msgstr ""

msgid ""
"The standardized :ref:`pgRouting-concepts:Result columns for single path "
"functions` are |short-generic-result|"
msgstr ""

msgid "``pgr_dijkstra``"
msgstr ""

msgid "v < 3.5"
msgstr ""

msgid "|old-generic-result|"
msgstr ""

msgid "``pgr_aStar``"
msgstr ""

msgid "``pgr_bdDijkstra``"
msgstr ""

msgid "``pgr_bellmanFord``"
msgstr ""

msgid "``pgr_dagShortestPath``"
msgstr ""

msgid "|result-1-1|"
msgstr ""

msgid "``pgr_edwardMoore``"
msgstr ""

msgid "``pgr_withPoints``"
msgstr ""

msgid "|old-pid-result|"
msgstr ""

msgid "Migration of |old-generic-result|"
msgstr ""

msgid ""
"Before updating pgRouting, enumerate the corresponding columns of the "
"signature"
msgstr ""

msgid "Migration of |old-pid-result|"
msgstr ""

msgid "To get the old version column names, depending on the signature:"
msgstr ""

msgid "Filter out the columns: ``start_vid`` and/or ``end_vid``"
msgstr ""

msgid "Rename the columns:"
msgstr ""

msgid "``start_vid`` to ``start_pid``"
msgstr ""

msgid "``end_vid`` to ``end_pid``"
msgstr ""

msgid ""
"If using ``pgr_withPoints``: column names must be changed after updating "
"pgRouting"
msgstr ""

msgid "Migration of |result-1-1|"
msgstr ""

msgid "To get the old version column names:"
msgstr ""

msgid "Filter out the columns: ``start_vid`` and ``end_vid``"
msgstr ""

msgid "Examples with One to One with one route result"
msgstr ""

msgid "Using ``pgr_aStar``"
msgstr ""

msgid ""
"Migrating `this v3.5 <https://docs.pgrouting.org/3.5/en/pgr_aStar.html"
"#one-to-one>`__ example."
msgstr ""

msgid "Before updating pgRouting enumerate the columns: |result-1-1|"
msgstr ""

msgid "Using ``pgr_bdDijkstra``"
msgstr ""

msgid ""
"Migrating `this v3.8 "
"<https://docs.pgrouting.org/3.8/en/pgr_bdDijkstra.html#one-to-one>`__ "
"example."
msgstr ""

msgid "Using ``pgr_DAGshortestPath``"
msgstr ""

msgid ""
"Migrating `this v3.8 "
"<https://docs.pgrouting.org/3.8/en/pgr_dagShortestPath.html#one-to-"
"one>`__ example."
msgstr ""

msgid "This applies to all signatures of ``pgr_DAGshortestPath``"
msgstr ""

msgid "Examples for One to Many with one route result"
msgstr ""

msgid "Using ``pgr_bdAstar``"
msgstr ""

msgid ""
"Migrating `this v3.5 <https://docs.pgrouting.org/3.5/en/pgr_bdAstar.html"
"#one-to-many>`__ example."
msgstr ""

msgid "Before updating pgRouting enumerate the columns: |result-1-m|"
msgstr ""

msgid "Using ``pgr_withPoints``"
msgstr ""

msgid ""
"Migrating `this v3.8 "
"<https://docs.pgrouting.org/3.8/en/pgr_withPoints.html#one-to-many>`__ "
"example."
msgstr ""

msgid "|pid-1-m|"
msgstr ""

msgid ""
"To get the old signature column names: filter out the column "
"``start_vid`` and rename ``end_vid`` to ``end_pid``."
msgstr ""

msgid "Examples for Many to One with one route result"
msgstr ""

msgid ""
"Migrating `this v3.8 "
"<https://docs.pgrouting.org/3.8/en/pgr_bdDijkstra.html#many-to-one>`__ "
"example."
msgstr ""

msgid "Before updating pgRouting enumerate the columns: |result-m-1|"
msgstr ""

msgid "Using ``pgr_dijkstra``"
msgstr ""

msgid ""
"Migrating `this v3.4 <https://docs.pgrouting.org/3.4/en/pgr_dijkstra.html"
"#many-to-one>`__ example."
msgstr ""

msgid "Examples for Many to Many with one route result"
msgstr ""

msgid ""
"Migrating `this v3.8 "
"<https://docs.pgrouting.org/3.8/en/pgr_withPoints.html#many-to-many>`__ "
"example."
msgstr ""

msgid "|pid-m-m|"
msgstr ""

msgid "Examples for combinations with one route result"
msgstr ""

msgid ""
"Migrating `this v3.8 `this "
"<https://docs.pgrouting.org/3.8/en/pgr_withPoints.html#combinations>`__ "
"example."
msgstr ""

msgid "Migration of spanning tree functions"
msgstr ""

msgid ""
"The standardized :ref:`pgRouting-concepts:Result columns for spanning "
"tree functions` are |result-spantree|"
msgstr ""

msgid "``pgr_drivingDistance``"
msgstr ""

msgid ":ref:`from_result_dij_dd`"
msgstr ""

msgid "``pgr_withPointsDD``"
msgstr ""

msgid ":ref:`from_result_generic_no_seq`"
msgstr ""

msgid "``pgr_kruskalDD``"
msgstr ""

msgid "v < 3.7"
msgstr ""

msgid ":ref:`from_result_bfs`"
msgstr ""

msgid "``pgr_kruskalBFS``"
msgstr ""

msgid "``pgr_kruskalDFS``"
msgstr ""

msgid "``pgr_primDD``"
msgstr ""

msgid "``pgr_primBFS``"
msgstr ""

msgid "``pgr_primDFS``"
msgstr ""

msgid "``pgr_breadthFisrtSearch``"
msgstr ""

msgid "v < 4.0.0"
msgstr ""

msgid "``pgr_depthFisrtSearch``"
msgstr ""

msgid "to |result-spantree|"
msgstr ""

msgid "Migration from |result-bfs|."
msgstr ""

msgid "Single vertex"
msgstr ""

msgid "Multiple vertices"
msgstr ""

msgid "Before updating pgRouting enumerate the columns: |result-bfs|"
msgstr ""

msgid "Single vertex example using ``pgr_kruskalDD``"
msgstr ""

msgid ""
"Migrating `this v3.6 "
"<https://docs.pgrouting.org/3.6/en/pgr_kruskalDD.html#single-vertex>`__ "
"example."
msgstr ""

msgid "Before updating pgRouting enumerate the columns: |result-bfs|."
msgstr ""

msgid "Multiple vertices example using ``pgr_kruskalDFS``"
msgstr ""

msgid ""
"Migrating `this v3.6 "
"<https://docs.pgrouting.org/3.6/en/pgr_kruskalDFS.html#multiple-"
"vertices>`__ example."
msgstr ""

msgid "Migration from |result-dij-dd|"
msgstr ""

msgid "Migration depends on the signature."
msgstr ""

msgid "For single vertex:"
msgstr ""

msgid "Before updating pgRouting, enumerate |result-1-1| columns"
msgstr ""

msgid "For multiple vertices:"
msgstr ""

msgid "Changes must be done after updating pgRouting."
msgstr ""

msgid "To get the old version column names |result-dij-dd-m|:"
msgstr ""

msgid "filter out the column ``pred`` and ``depth`` and"
msgstr ""

msgid "rename ``start_vid`` to ``from_v``."
msgstr ""

msgid "Single vertex example using ``pgr_drivingDistance``"
msgstr ""

msgid ""
"Migrating `this v3.5 "
"<https://docs.pgrouting.org/3.5/en/pgr_drivingDistance.html#single-"
"vertex>`__ example."
msgstr ""

msgid "Before updating pgRouting, enumerate |result-1-1-no-seq| columns"
msgstr ""

msgid "Multiple vertices example using ``pgr_drivingDistance``"
msgstr ""

msgid ""
"Migrating `this v3.5 "
"<https://docs.pgrouting.org/3.5/en/pgr_drivingDistance.html#multiple-"
"vertices>`__ example."
msgstr ""

msgid ""
"To get the old version column names |result-dij-dd-m|: filter out the "
"column ``pred`` and ``depth`` and rename ``start_vid`` to ``from_v``."
msgstr ""

msgid "Migration of |result-generic-no-seq|"
msgstr ""

msgid "After updating pgRouting:"
msgstr ""

msgid "Enumerate |result-1-1-no-seq| columns"
msgstr ""

msgid ""
"Use an unnamed valid value for **driving side** after the **distance** "
"parameter."
msgstr ""

msgid "Enumerate |result-m-1-no-seq| columns"
msgstr ""

msgid "Default value of **driving side** parameter"
msgstr ""

msgid ""
"**driving side** parameter is unnamed, and valid values differ for "
"directed and undirected graphs."
msgstr ""

msgid "In directed graph: valid values are [``r``, ``R``, ``l``, ``L``]"
msgstr ""

msgid "Default value = 'r';"
msgstr ""

msgid "In undirected graph: valid values are [``b``, ``B``]"
msgstr ""

msgid "Default value = 'b';"
msgstr ""

msgid "Single vertex example using ``pgr_withPointsDD``"
msgstr ""

msgid ""
"Migrating `this v3.5 "
"<https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-"
"vertex>`__ example."
msgstr ""

msgid "Multiple vertices example using ``pgr_withPointsDD``"
msgstr ""

msgid ""
"Migrating `this v3.5 "
"<https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#multiple-"
"vertex>`__ example."
msgstr ""

msgid "Migration of output column name change"
msgstr ""

msgid "The standardized result columns:"
msgstr ""

msgid "|result_edge_color|"
msgstr ""

msgid "|result_node_color|"
msgstr ""

msgid "|result_node_order|"
msgstr ""

msgid "Changes on column names must be done after updating pgRouting."
msgstr ""

msgid "``pgr_edgeColoring``"
msgstr ""

msgid ":ref:`from_old_edge_color`"
msgstr ""

msgid "``pgr_bipartite``"
msgstr ""

msgid ":ref:`from_old_node_color`"
msgstr ""

msgid "``pgr_sequentialVertexColoring``"
msgstr ""

msgid "``pgr_topologicalSort``"
msgstr ""

msgid ":ref:`from_toposort`"
msgstr ""

msgid "``pgr_transitiveClosure``"
msgstr ""

msgid ":ref:`from_old_closure`"
msgstr ""

msgid "Migration from |result-old-closure|"
msgstr ""

msgid "Migration to: |result-old-closure|"
msgstr ""

msgid "After update:"
msgstr ""

msgid "Remove column ``seq``"
msgstr ""

msgid "Rename ``vid`` to ``node`` and ``target_array`` to ``targets``"
msgstr ""

msgid "Migration from |result-toposort|"
msgstr ""

msgid "Migration to: |result_node_order|"
msgstr ""

msgid "Rename ``sorted_v`` to ``node``"
msgstr ""

msgid "Migration from |old-edge-color|"
msgstr ""

msgid "Migration to: |result_edge_color|"
msgstr ""

msgid "Rename ``edge_id`` to ``edge`` and ``color_id`` to ``color``."
msgstr ""

msgid "Migration from |old-node-color|"
msgstr ""

msgid "Migration to: |result_node_color|"
msgstr ""

msgid "Rename ``vertex_id`` to ``node`` and ``color_id`` to ``color``."
msgstr ""

msgid "Migration of deleted functions"
msgstr ""

msgid "Functions no longer on pgRouting"
msgstr ""

msgid "Migration of ``pgr_alphaShape``"
msgstr ""

msgid "Deprecated"
msgstr ""

msgid "`v3.8.0 <https://docs.pgrouting.org/3.8>`__"
msgstr ""

msgid "Removed"
msgstr ""

msgid "`v4.0.0 <https://docs.pgrouting.org/4.0>`__"
msgstr ""

msgid "**Before Deprecation:** The following was calculated:"
msgstr ""

msgid "An alphaShape was calculated"
msgstr ""

msgid "**After Deprecation:**"
msgstr ""

msgid "PostGIS has two ways of generating alphaShape."
msgstr ""

msgid "If you have SFCGAL, which you can install using"
msgstr ""

msgid ""
"Since PostGIS 3.5+ use `CG_AlphaShape "
"<https://postgis.net/docs/CG_AlphaShape.html>`__"
msgstr ""

msgid "For PostGIS 3.5+ use the old name ``ST_AlphaShape``"
msgstr ""

msgid "Other PostGIS options are"
msgstr ""

msgid "`ST_ConvexHull <https://postgis.net/docs/ST_ConvexHull.html>`__"
msgstr ""

msgid "`ST_ConcaveHull <https://postgis.net/docs/ST_ConcaveHull.html>`__"
msgstr ""

msgid "Migration of ``pgr_nodeNetwork``"
msgstr ""

msgid ""
"**Before Deprecation:** A table with `<edges>_nodded` was created. with "
"split edges."
msgstr ""

msgid "**Migration**"
msgstr ""

msgid "Use :doc:`pgr_separateTouching` and/or use :doc:`pgr_separateCrossing`"
msgstr ""

msgid "Migration of ``pgr_createTopology``"
msgstr ""

msgid "A table with `<edges>_vertices_pgr` was created."
msgstr ""

msgid ""
"**After Deprecation:** The user is responsible to create the complete "
"topology."
msgstr ""

msgid "Build a routing topology"
msgstr ""

msgid ""
"The basic information to use the majority of the pgRouting functions "
"``id, source, target, cost, [reverse_cost]`` is what in pgRouting is "
"called the routing topology."
msgstr ""

msgid ""
"``reverse_cost`` is optional but strongly recommended to have in order to"
" reduce the size of the database due to the size of the geometry columns."
" Having said that, in this documentation ``reverse_cost`` is used in this"
" documentation."
msgstr ""

msgid ""
"When the data comes with geometries and there is no routing topology, "
"then this step is needed."
msgstr ""

msgid ""
"All the start and end vertices of the geometries need an identifier that "
"is to be stored in a ``source`` and ``target`` columns of the table of "
"the data. Likewise, ``cost`` and ``reverse_cost`` need to have the value "
"of traversing the edge in both directions."
msgstr ""

msgid ""
"If the columns do not exist they need to be added to the table in "
"question. (see `ALTER TABLE <https://www.postgresql.org/docs/current/sql-"
"altertable.html>`__)"
msgstr ""

msgid ""
"The function :doc:`pgr_extractVertices` is used to create a vertices "
"table based on the edge identifier and the geometry of the edge of the "
"graph."
msgstr ""

msgid ""
"Finally using the data stored on the vertices tables the ``source`` and "
"``target`` are filled up."
msgstr ""

msgid "Migration of ``pgr_createVerticesTable``"
msgstr ""

msgid ""
"**After Deprecation:** The user is responsible to create the vertices "
"table, indexes, etc. They may use :doc:`pgr_extractVertices` for that "
"purpose."
msgstr ""

msgid "Migration of ``pgr_analyzeOneWay``"
msgstr ""

msgid "Number of potential problems in directionality"
msgstr ""

msgid "WHERE"
msgstr ""

msgid "Directionality problems were calculated based on codes."
msgstr ""

msgid "Dead ends."
msgstr ""

msgid ""
"A routing problem can arise when from a vertex there is only a way on or "
"a way out but not both:"
msgstr ""

msgid ""
"Either saving or using directly :doc:`pgr_extractVertices` get the dead "
"ends information and determine if the adjacent edge is one way or not."
msgstr ""

msgid "In this example :doc:`pgr_extractVertices` has already been applied."
msgstr ""

msgid "Bridges."
msgstr ""

msgid ""
"Another routing problem can arise when there is an edge of an undirected "
"graph whose deletion increases its number of connected components, and "
"the bridge is only one way."
msgstr ""

msgid "To determine if the bridges are or not one way."
msgstr ""

msgid "Migration of ``pgr_analyzeGraph``"
msgstr ""

msgid "Number of isolated segments."
msgstr ""

msgid "Number of dead ends."
msgstr ""

msgid "Number of potential gaps found near dead ends."
msgstr ""

msgid "Number of intersections. (between 2 edges)"
msgstr ""

msgid "Graph component"
msgstr ""

msgid "A connected subgraph that is not part of any larger connected subgraph."
msgstr ""

msgid "Isolated segment"
msgstr ""

msgid "A graph component with only one segment."
msgstr ""

msgid "Dead ends"
msgstr ""

msgid "A vertex that participates in only one edge."
msgstr ""

msgid "gaps"
msgstr ""

msgid "Space between two geometries."
msgstr ""

msgid "Intersection"
msgstr ""

msgid "Is a topological relationship between two geometries."
msgstr ""

msgid "Migration."
msgstr ""

msgid "Components."
msgstr ""

msgid ""
"Instead of counting only isolated segments, determine all the components "
"of the graph."
msgstr ""

msgid "Depending of the final application requirements use:"
msgstr ""

msgid ":doc:`pgr_connectedComponents`"
msgstr ""

msgid ":doc:`pgr_strongComponents`"
msgstr ""

msgid ":doc:`pgr_biconnectedComponents`"
msgstr ""

msgid "For example:"
msgstr ""

msgid ""
"Instead of counting the dead ends, determine all the dead ends of the "
"graph using :doc:`pgr_degree`."
msgstr ""

msgid "Potential gaps near dead ends."
msgstr ""

msgid ""
"Instead of counting potential gaps between geometries, determine the "
"geometric gaps in the graph using :doc:`pgr_findCloseEdges`."
msgstr ""

msgid "Topological relationships."
msgstr ""

msgid ""
"Instead of counting intersections, determine topological relationships "
"between geometries."
msgstr ""

msgid ""
"Several PostGIS functions can be used: `ST_Intersects "
"<https://postgis.net/docs/ST_Intersects.html>`__, `ST_Crosses "
"<https://postgis.net/docs/ST_Crosses.html>`__, `ST_Overlaps "
"<https://postgis.net/docs/ST_Overlaps.html>`__, etc."
msgstr ""

msgid "Migration of ``pgr_trsp`` (Vertices)"
msgstr ""

msgid "Signature:"
msgstr ""

msgid "`v3.4.0 <https://docs.pgrouting.org/3.4>`__"
msgstr ""

msgid ":doc:`pgr_trsp`"
msgstr ""

msgid "`Migration of restrictions`_"
msgstr ""

msgid "Use ``pgr_dijkstra`` when there are no restrictions."
msgstr ""

msgid "Use :doc:`pgr_dijkstra` instead."
msgstr ""

msgid "To get the original column names:"
msgstr ""

msgid "``id1`` is the node"
msgstr ""

msgid "``id2`` is the edge"
msgstr ""

msgid "Use ``pgr_trsp`` when there are restrictions."
msgstr ""

msgid "Use :doc:`pgr_trsp` (One to One) instead."
msgstr ""

msgid "Migration of ``pgr_trsp`` (Edges)"
msgstr ""

msgid ":doc:`pgr_trsp_withPoints`"
msgstr ""

msgid "Migration of ``pgr_trspViaVertices``"
msgstr ""

msgid ":doc:`pgr_dijkstraVia`"
msgstr ""

msgid ":doc:`pgr_trspVia`"
msgstr ""

msgid "Use ``pgr_dijkstraVia`` when there are no restrictions"
msgstr ""

msgid "Use :doc:`pgr_dijkstraVia` instead."
msgstr ""

msgid "``id1`` is the path identifier"
msgstr ""

msgid "``id2`` is the node"
msgstr ""

msgid "``id3`` is the edge"
msgstr ""

msgid "Use ``pgr_trspVia`` when there are restrictions"
msgstr ""

msgid "Use :doc:`pgr_trspVia` instead."
msgstr ""

msgid "Migration of ``pgr_trspViaEdges``"
msgstr ""

msgid ":doc:`pgr_withPointsVia`"
msgstr ""

msgid ":doc:`pgr_trspVia_withPoints`"
msgstr ""

msgid "Use ``pgr_withPointsVia`` when there are no restrictions"
msgstr ""

msgid "Use :doc:`pgr_withPointsVia` instead."
msgstr ""

msgid "Use ``pgr_trspVia_withPoints`` when there are restrictions"
msgstr ""

msgid "Use :doc:`pgr_trspVia_withPoints` instead."
msgstr ""

msgid "Not yet classified migrations"
msgstr ""

msgid "Migration of ``pgr_withPointsKSP``"
msgstr ""

msgid ""
"Starting from `v3.6.0 "
"<https://docs.pgrouting.org/3.6/en/migration.html>`__ "
":doc:`pgr_withPointsKSP` result columns are being standardized."
msgstr ""

msgid "|ksp-result|"
msgstr ""

msgid "|generic-result|"
msgstr ""

msgid ""
"And ``driving side`` parameter changed from named optional to unnamed "
"**driving side** and its validity differ for directed and undirected "
"graphs."
msgstr ""

msgid "``pgr_withPointsKSP`` (`One to One`)"
msgstr ""

msgid "Before Migration"
msgstr ""

msgid "Output columns were |old-pid-result|"
msgstr ""

msgid "the columns ``start_vid`` and ``end_vid`` do not exist."
msgstr ""

msgid "Migration"
msgstr ""

msgid "Be aware of the existence of the additional result Columns."
msgstr ""

msgid "New output columns are |generic-result|"
msgstr ""

msgid ""
"Using `this "
"<https://docs.pgrouting.org/3.5/en/pgr_withPointsKSP.html#signatures>`__ "
"example."
msgstr ""

msgid "``start_vid`` contains the **start vid** parameter value."
msgstr ""

msgid "``end_vid`` contains the **end vid** parameter value."
msgstr ""

msgid ""
"If needed filter out the additional columns, for example, to return the "
"original columns:"
msgstr ""

msgid "Use ``pgr_withPoints`` when there are no restrictions."
msgstr ""

msgid "Use :doc:`pgr_withPoints` (One to One) instead."
msgstr ""

msgid "Use ``pgr_trsp_withPoints`` when there are restrictions."
msgstr ""

msgid "Use :doc:`pgr_trsp_withPoints` instead."
msgstr ""

msgid "Migration of ``pgr_maxCardinalityMatch``"
msgstr ""

msgid ""
":doc:`pgr_maxCardinalityMatch` works only for undirected graphs, "
"therefore the ``directed`` flag has been removed."
msgstr ""

msgid ""
"Starting from `v3.4.0 "
"<https://docs.pgrouting.org/3.4/en/migration.html>`__"
msgstr ""

msgid "Signature to be migrated:"
msgstr ""

msgid "Migration is needed, because:"
msgstr ""

msgid "Use ``cost`` and ``reverse_cost`` on the inner query"
msgstr ""

msgid "Results are ordered"
msgstr ""

msgid "Works for undirected graphs."
msgstr ""

msgid "New signature"
msgstr ""

msgid "``pgr_maxCardinalityMatch(text)`` returns only ``edge`` column."
msgstr ""

msgid "The optional flag ``directed`` is removed."
msgstr ""

msgid "Before migration"
msgstr ""

msgid ""
"Columns used are ``going`` and ``coming`` to represent the existence of "
"an edge."
msgstr ""

msgid ""
"Flag ``directed`` was used to indicate if it was for a **directed** or "
"**undirected** graph."
msgstr ""

msgid "The flag ``directed`` is ignored."
msgstr ""

msgid ""
"Regardless of it's value it gives the result considering the graph as "
"**undirected**."
msgstr ""

msgid ""
"Use the columns ``cost`` and ``reverse_cost`` to represent the existence "
"of an edge."
msgstr ""

msgid "Do not use the flag ``directed``."
msgstr ""

msgid "In the query returns only ``edge`` column."
msgstr ""

msgid "Migration of restrictions"
msgstr ""

msgid "The structure of the restrictions have changed:"
msgstr ""

msgid "Old restrictions structure"
msgstr ""

msgid "On the deprecated signatures:"
msgstr ""

msgid "Column ``rid`` is ignored"
msgstr ""

msgid "``via_path``"
msgstr ""

msgid "Must be in reverse order."
msgstr ""

msgid "Is of type ``TEXT``."
msgstr ""

msgid "When more than one via edge must be separated with ``,``."
msgstr ""

msgid "``target_id``"
msgstr ""

msgid "Is the last edge of the forbidden path."
msgstr ""

msgid "Is of type ``INTEGER``."
msgstr ""

msgid "``to_cost``"
msgstr ""

msgid "Is of type ``FLOAT``."
msgstr ""

msgid "Creation of the old restrictions table"
msgstr ""

msgid "Old restrictions fill up"
msgstr ""

msgid "Old restrictions contents"
msgstr ""

msgid ""
"The restriction with ``rid = 2`` is representing :math:`3 \\rightarrow 5 "
"\\rightarrow9`"
msgstr ""

msgid ":math:`3\\rightarrow5`"
msgstr ""

msgid "is on column ``via_path`` in reverse order"
msgstr ""

msgid "is of type ``TEXT``"
msgstr ""

msgid ":math:`9`"
msgstr ""

msgid "is on column ``target_id``"
msgstr ""

msgid "is of type ``INTEGER``"
msgstr ""

msgid "New restrictions structure"
msgstr ""

msgid "Column ``id`` is ignored"
msgstr ""

msgid "Column ``path``"
msgstr ""

msgid "Is of type ``ARRAY[ANY-INTEGER]``."
msgstr ""

msgid "Contains all the edges involved on the restriction."
msgstr ""

msgid "The array has the ordered edges of the restriction."
msgstr ""

msgid "Column ``cost``"
msgstr ""

msgid "Is of type ``ANY-NUMERICAL``"
msgstr ""

msgid "The creation of the restrictions table"
msgstr ""

msgid "Adding the restrictions"
msgstr ""

msgid "Restrictions data"
msgstr ""

msgid ""
"The restriction with ``rid = 2`` represents the path :math:`3 "
"\\rightarrow5 \\rightarrow9`."
msgstr ""

msgid "By inspection the path is clear."
msgstr ""

msgid "To transform the old restrictions table to the new restrictions structure,"
msgstr ""

msgid "Create a new table with the new restrictions structure."
msgstr ""

msgid "In this migration guide ``new_restrictions`` is been used."
msgstr ""

msgid ""
"For this migration pgRouting supplies an auxiliary function for reversal "
"of an array ``_pgr_array_reverse`` needed for the migration."
msgstr ""

msgid "``_pgr_array_reverse``:"
msgstr ""

msgid "Was created temporally for this migration"
msgstr ""

msgid "Is not documented."
msgstr ""

msgid "Will be removed on the next mayor version 4.0.0"
msgstr ""

msgid "The migrated table contents:"
msgstr ""

msgid ":doc:`pgRouting-concepts`"
msgstr ""

msgid "Ordering - Family of functions"
msgstr ""

msgid "pgRouting Concepts"
msgstr ""

msgid ""
"This is a simple guide that go through some of the steps for getting "
"started with pgRouting. This guide covers:"
msgstr ""

msgid "Graphs"
msgstr ""

msgid "A graph is an ordered pair :math:`G = (V ,E)` where:"
msgstr ""

msgid ":math:`V` is a set of vertices, also called nodes."
msgstr ""

#, python-brace-format
msgid ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V \\}`"
msgstr ""

msgid "There are different kinds of graphs:"
msgstr ""

#, python-brace-format
msgid ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V\\}`"
msgstr ""

msgid "Undirected simple graph"
msgstr ""

#, python-brace-format
msgid ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V, u \\neq v\\}`"
msgstr ""

#, python-brace-format
msgid ":math:`E \\subseteq \\{( u, v ) \\mid (u , v) \\in (V X V) \\}`"
msgstr ""

msgid "Directed simple graph"
msgstr ""

#, python-brace-format
msgid ":math:`E \\subseteq \\{( u, v ) \\mid (u , v) \\in (V X V), u \\neq v\\}`"
msgstr ""

msgid "Graphs:"
msgstr ""

msgid "Do not have geometries."
msgstr ""

msgid ""
"Some graph theory problems require graphs to have weights, called "
"**cost** in pgRouting."
msgstr ""

msgid "In pgRouting there are several ways to represent a graph on the database:"
msgstr ""

msgid "With ``cost``"
msgstr ""

msgid "(``id``, ``source``, ``target``, ``cost``)"
msgstr ""

msgid "With ``cost`` and ``reverse_cost``"
msgstr ""

msgid "(``id``, ``source``, ``target``, ``cost``, ``reverse_cost``)"
msgstr ""

msgid ""
"Identifier of the edge. Requirement to use the database in a consistent. "
"manner."
msgstr ""

msgid "Identifier of a vertex."
msgstr ""

msgid "Weight of the edge (``source``, ``target``):"
msgstr ""

msgid "When negative the edge (``source``, ``target``) do not exist on the graph."
msgstr ""

msgid "``cost`` must exist in the query."
msgstr ""

msgid "When negative the edge (``target``, ``source``) do not exist on the graph."
msgstr ""

msgid ""
"The decision of the graph to be **directed** or **undirected** is done "
"when executing a pgRouting algorithm."
msgstr ""

msgid "Graph with ``cost``"
msgstr ""

msgid "The weighted directed graph, :math:`G_d(V,E)`:"
msgstr ""

msgid "Graph data is obtained with a query"
msgstr ""

msgid "``SELECT id, source, target, cost FROM edges``"
msgstr ""

msgid ""
":math:`E = \\{(source_{id}, target_{id}, cost_{id}) \\text{ when } "
"cost_{id} \\ge 0 \\}`"
msgstr ""

msgid "Edges where ``cost`` is non negative are part of the graph."
msgstr ""

msgid ":math:`V = \\{source_{id} \\cup target_{id}\\}`"
msgstr ""

msgid "All vertices in ``source`` and ``target`` are part of the graph."
msgstr ""

#, python-brace-format
msgid ""
"In a directed graph the edge :math:`(source_{id}, target_{id}, "
"cost_{id})` has directionality: :math:`source_{id} \\rightarrow "
"target_{id}`"
msgstr ""

msgid "For the following data:"
msgstr ""

msgid "Edge :math:`2` (:math:`1 \\rightarrow 3`) is not part of the graph."
msgstr ""

msgid "The data is representing the following graph:"
msgstr ""

#, python-brace-format
msgid ""
"In an undirected graph the edge :math:`(source_{id}, target_{id}, "
"cost_{id})` does not have directionality: :math:`source_{id} "
"\\frac{\\;\\;\\;\\;\\;}{} target_{id}`"
msgstr ""

#, python-brace-format
msgid ""
"In terms of a directed graph is like having two edges: :math:`source_{id}"
" \\leftrightarrow target_{id}`"
msgstr ""

#, python-brace-format
msgid ""
"Edge :math:`2` (:math:`1 \\frac{\\;\\;\\;\\;\\;}{} 3`) is not part of the"
" graph."
msgstr ""

msgid "Graph with ``cost`` and ``reverse_cost``"
msgstr ""

msgid "``SELECT id, source, target, cost, reverse_cost FROM edges``"
msgstr ""

msgid "The set of edges :math:`E`:"
msgstr ""

msgid ""
":math:`E = \\begin{split} \\begin{align} & {\\{(source_{id}, target_{id},"
" cost_{id}) \\text{ when } cost_{id} >=0 \\}} \\\\ & \\cup \\\\ & "
"{\\{(target_{id}, source_{id}, reverse\\_cost_{id}) \\text{ when } "
"reverse\\_cost_{id} >=0 \\}} \\end{align} \\end{split}`"
msgstr ""

msgid ""
"Edges :math:`(source \\rightarrow target)` where ``cost`` is non negative"
" are part of the graph."
msgstr ""

msgid ""
"Edges :math:`(target \\rightarrow source)` where ``reverse_cost`` is non "
"negative are part of the graph."
msgstr ""

msgid "The set of vertices :math:`V`:"
msgstr ""

msgid "In a directed graph both edges have directionality"
msgstr ""

#, python-brace-format
msgid ""
"edge :math:`(source_{id}, target_{id}, cost_{id})` has directionality: "
":math:`source_{id} \\rightarrow target_{id}`"
msgstr ""

#, python-brace-format
msgid ""
"edge :math:`(target_{id}, source_{id}, reverse\\_cost_{id})` has "
"directionality: :math:`target_{id} \\rightarrow source_{id}`"
msgstr ""

msgid "Edges not part of the graph:"
msgstr ""

msgid ":math:`2` (:math:`1 \\rightarrow 3`)"
msgstr ""

msgid ":math:`3` (:math:`3 \\rightarrow 2`)"
msgstr ""

msgid "In a directed graph both edges do not have directionality"
msgstr ""

#, python-brace-format
msgid ""
"Edge :math:`(source_{id}, target_{id}, cost_{id})` is :math:`source_{id} "
"\\frac{\\;\\;\\;\\;\\;}{} target_{id}`"
msgstr ""

#, python-brace-format
msgid ""
"Edge :math:`(target_{id}, source_{id}, reverse\\_cost_{id})` is "
":math:`target_{id} \\frac{\\;\\;\\;\\;\\;}{} source_{id}`"
msgstr ""

msgid "In terms of a directed graph is like having four edges:"
msgstr ""

msgid ":math:`source_i \\leftrightarrow target_i`"
msgstr ""

msgid ":math:`target_i \\leftrightarrow source_i`"
msgstr ""

#, python-brace-format
msgid ":math:`2` (:math:`1 \\frac{\\;\\;\\;\\;\\;}{} 3`)"
msgstr ""

#, python-brace-format
msgid ":math:`3` (:math:`3 \\frac{\\;\\;\\;\\;\\;}{} 2`)"
msgstr ""

msgid "Graphs without geometries"
msgstr ""

msgid ""
"Personal relationships, genealogy, file dependency problems can be solved"
" using pgRouting. Those problems, normally, do not come with geometries "
"associated with the graph."
msgstr ""

msgid "Wiki example"
msgstr ""

#, python-format
msgid ""
"Solve the example problem taken from `wikipedia "
"<https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm>`__):"
msgstr ""

msgid "Problem is to find the shortest path from :math:`1` to :math:`5`."
msgstr ""

msgid "Is an undirected graph."
msgstr ""

msgid ""
"Although visually looks like to have geometries, the drawing is not to "
"scale."
msgstr ""

msgid "No geometries associated to the vertices or edges"
msgstr ""

#, python-brace-format
msgid "Has 6 vertices :math:`\\{1,2,3,4,5,6\\}`"
msgstr ""

msgid "Has 9 edges:"
msgstr ""

#, python-brace-format
msgid ""
":math:`\\begin{split} \\begin{align} E = & \\{(1,2,7), (1,3,9), (1,6,14),"
" \\\\ & (2,3,10), (2,4,13), \\\\ & (3,4,11), (3,6,2), \\\\ & (4,5,6), "
"\\\\ & (5,6,9) \\} \\end{align} \\end{split}`"
msgstr ""

msgid "The graph can be represented in many ways for example:"
msgstr ""

msgid "Prepare the database"
msgstr ""

msgid ""
"Create a database for the example, access the database and install "
"pgRouting: ::"
msgstr ""

msgid "Create a table"
msgstr ""

msgid ""
"The basic elements needed to perform basic routing on an undirected graph"
" are:"
msgstr ""

msgid "SMALLINT, INTEGER, BIGINT, REAL, FLOAT"
msgstr ""

msgid "Using this table design for this example:"
msgstr ""

msgid "Insert the data"
msgstr ""

msgid "Find the shortest path"
msgstr ""

msgid "To solve this example :doc:`pgr_dijkstra` is used:"
msgstr ""

msgid ""
"To go from :math:`1` to :math:`5` the path goes thru the following "
"vertices: :math:`1 \\rightarrow 3 \\rightarrow 6 \\rightarrow 5`"
msgstr ""

msgid "Vertex information"
msgstr ""

msgid "To obtain the vertices information, use :doc:`pgr_extractVertices`"
msgstr ""

msgid "Graphs with geometries"
msgstr ""

msgid "Create a routing Database"
msgstr ""

msgid "The first step is to create a database and load pgRouting in the database."
msgstr ""

msgid "Typically create a database for each project."
msgstr ""

msgid ""
"Once having the database to work in, load your data and build the routing"
" application in that database."
msgstr ""

msgid "Load Data"
msgstr ""

msgid "There are several ways to load your data into pgRouting."
msgstr ""

msgid "Manually creating a database."
msgstr ""

msgid "`Graphs without geometries`_"
msgstr ""

msgid ":doc:`sampledata`: a small graph used in the documentation examples"
msgstr ""

msgid ""
"Using `osm2pgrouting "
"<https://workshop.pgrouting.org/latest/en/basic/data.html>`__"
msgstr ""

msgid "There are various open source tools that can help, like:"
msgstr ""

msgid "shp2pgsql"
msgstr ""

msgid "postgresql shapefile loader"
msgstr ""

msgid "ogr2ogr"
msgstr ""

msgid "vector data conversion utility"
msgstr ""

msgid "osm2pgsql"
msgstr ""

msgid "load OSM data into postgresql"
msgstr ""

msgid ""
"Please note that these tools will **not** import the data in a structure "
"compatible with pgRouting and when this happens the topology needs to be "
"adjusted."
msgstr ""

msgid "Breakup a segments on each segment-segment intersection"
msgstr ""

msgid ""
"When missing, add columns and assign values to ``source``, ``target``, "
"``cost``, ``reverse_cost``."
msgstr ""

msgid "Connect a disconnected graph."
msgstr ""

msgid "Create the complete graph topology"
msgstr ""

msgid "Create one or more graphs based on the application to be developed."
msgstr ""

msgid "Create a contracted graph for the high speed roads"
msgstr ""

msgid "Create graphs per state/country"
msgstr ""

msgid "In few words:"
msgstr ""

msgid "Prepare the graph"
msgstr ""

msgid ""
"What and how to prepare the graph, will depend on the application and/or "
"on the quality of the data and/or on how close the information is to have"
" a topology usable by pgRouting and/or some other factors not mentioned."
msgstr ""

msgid ""
"The steps to prepare the graph involve geometry operations using `PostGIS"
" <https://postgis.net/>`__ and some others involve graph operations like "
":doc:`pgr_contraction` to contract a graph."
msgstr ""

msgid ""
"The `workshop <https://workshop.pgrouting.org/latest>`__ has a step by "
"step on how to prepare a graph using Open Street Map data, for a small "
"application."
msgstr ""

msgid "The use of indexes on the database design in general:"
msgstr ""

msgid "Have the geometries indexed."
msgstr ""

msgid "Have the identifiers columns indexed."
msgstr ""

msgid ""
"Please consult the `PostgreSQL <https://www.postgresql.org/docs/>`__ "
"documentation and the `PostGIS <https://postgis.net/>`__ documentation."
msgstr ""

msgid ""
"Data coming from OSM and using `osm2pgrouting "
"<https://github.com/pgRouting/osm2pgrouting>`__ as an import tool, comes "
"with the routing topology. See an example of using ``osm2pgrouting`` on "
"the `workshop "
"<https://workshop.pgrouting.org/latest/en/basic/data.html>`__."
msgstr ""

msgid "Adjust costs"
msgstr ""

msgid ""
"For this example the ``cost`` and ``reverse_cost`` values are going to be"
" the double of the length of the geometry."
msgstr ""

msgid "Update costs to length of geometry"
msgstr ""

msgid ""
"Suppose that ``cost`` and ``reverse_cost`` columns in the sample data "
"represent:"
msgstr ""

msgid ":math:`1` when the edge exists in the graph"
msgstr ""

msgid ":math:`-1` when the edge does not exist in the graph"
msgstr ""

msgid "Using that information updating to the length of the geometries:"
msgstr ""

msgid "Which gives the following results:"
msgstr ""

msgid ""
"Note that to be able to follow the documentation examples, everything is "
"based on the original graph."
msgstr ""

msgid "Returning to the original data:"
msgstr ""

msgid "Update costs based on codes"
msgstr ""

msgid "Other datasets, can have a column with values like"
msgstr ""

msgid "``FT`` vehicle flow on the direction of the geometry"
msgstr ""

msgid "``TF`` vehicle flow opposite of the direction of the geometry"
msgstr ""

msgid "``B`` vehicle flow on both directions"
msgstr ""

msgid "Preparing a code column for the example:"
msgstr ""

msgid "Adjusting the costs based on the codes:"
msgstr ""

msgid "Check the Routing Topology"
msgstr ""

msgid "There are lots of possible problems in a graph."
msgstr ""

msgid "The data used may not have been designed with routing in mind."
msgstr ""

msgid "A graph has some very specific requirements."
msgstr ""

msgid "The graph is disconnected."
msgstr ""

msgid "There are unwanted intersections."
msgstr ""

msgid "The graph is too large and needs to be contracted."
msgstr ""

msgid "A sub graph is needed for the application."
msgstr ""

msgid ""
"and many other problems that the pgRouting user, that is the application "
"developer might encounter."
msgstr ""

msgid "Crossing edges"
msgstr ""

msgid "To get the crossing edges:"
msgstr ""

msgid ""
"That information is correct, for example, when in terms of vehicles, is "
"it a tunnel or bridge crossing over another road."
msgstr ""

msgid "It might be incorrect, for example:"
msgstr ""

msgid ""
"When it is actually an intersection of roads, where vehicles can make "
"turns."
msgstr ""

msgid ""
"When in terms of electrical lines, the electrical line is able to switch "
"roads even on a tunnel or bridge."
msgstr ""

msgid "When it is incorrect, it needs fixing:"
msgstr ""

msgid "For vehicles and pedestrians"
msgstr ""

msgid ""
"If the data comes from OSM and was imported to the database using "
"``osm2pgrouting``, the fix needs to be done in the `OSM portal "
"<https://www.openstreetmap.org>`__ and the data imported again."
msgstr ""

msgid ""
"In general when the data comes from a supplier that has the data prepared"
" for routing vehicles, and there is a problem, the data is to be fixed "
"from the supplier"
msgstr ""

msgid "For very specific applications"
msgstr ""

msgid ""
"The data is correct when from the point of view of routing vehicles or "
"pedestrians."
msgstr ""

msgid "The data needs a local fix for the specific application."
msgstr ""

msgid ""
"Once analyzed one by one the crossings, for the ones that need a local "
"fix, the edges need to be `split "
"<https://postgis.net/docs/ST_Split.html>`__."
msgstr ""

msgid ""
"The new edges need to be added to the edges table, the rest of the "
"attributes need to be updated in the new edges, the old edges need to be "
"removed and the routing topology needs to be updated."
msgstr ""

msgid "Fixing an intersection"
msgstr ""

msgid ""
"In this example the original edge table will be used to store the "
"additional geometries."
msgstr ""

msgid "An example use without results"
msgstr ""

msgid "Routing from :math:`1` to :math:`18` gives no solution."
msgstr ""

msgid "Analyze the network for intersections."
msgstr ""

msgid "The analysis tell us that the network has an intersection."
msgstr ""

msgid "Prepare tables"
msgstr ""

msgid "Additional columns to control the origin of the segments."
msgstr ""

msgid "Adding new segments."
msgstr ""

msgid ""
"Calling :doc:`pgr_separateCrossing` and adding the new segments to the "
"edges table."
msgstr ""

msgid "Update other values"
msgstr ""

msgid ""
"In this example only ``cost`` and ``reverse_cost`` are updated, where "
"they are based on the length of the geometry and the directionality is "
"kept using the ``sign`` function."
msgstr ""

msgid "Update the topology"
msgstr ""

msgid "Insert the new vertices if any."
msgstr ""

msgid "Update source and target information on the edges table."
msgstr ""

msgid "The example has results"
msgstr ""

msgid "Routing from :math:`1` to :math:`18` gives a solution."
msgstr ""

msgid "Touching edges"
msgstr ""

msgid "Visually the edges seem to be connected, but internally they are not."
msgstr ""

msgid "The validity of the information is application dependent."
msgstr ""

msgid "Maybe there is a small barrier for vehicles but not for pedestrians."
msgstr ""

msgid ""
"Once analyzed one by one the touchings, for the ones that need a local "
"fix, the edges need to be `split "
"<https://postgis.net/docs/ST_Split.html>`__."
msgstr ""

msgid "Fixing a gap"
msgstr ""

msgid "Routing from :math:`1` to :math:`2` gives no solution."
msgstr ""

msgid "Analyze the network for gaps."
msgstr ""

msgid "The analysis tell us that the network has a gap."
msgstr ""

msgid ""
"Calling :doc:`pgr_separateTouching` and adding the new segments to the "
"edges table."
msgstr ""

msgid "Routing from :math:`1` to :math:`2` gives a solution."
msgstr ""

msgid "Connecting components"
msgstr ""

msgid "To get the graph connectivity:"
msgstr ""

msgid "There are three basic ways to connect components:"
msgstr ""

msgid "From the vertex to the starting point of the edge"
msgstr ""

msgid "From the vertex to the ending point of the edge"
msgstr ""

msgid "From the vertex to the closest vertex on the edge"
msgstr ""

msgid "This solution requires the edge to be split."
msgstr ""

msgid ""
"In this example :doc:`pgr_separateCrossing` and "
":doc:`pgr_separateTouching` will be used."
msgstr ""

msgid "Get the connectivity"
msgstr ""

msgid ""
"In this example: the edges table will need an additional column and the "
"vertex table will be rebuilt completely."
msgstr ""

msgid "Insert new edges"
msgstr ""

msgid ""
"Using :doc:`pgr_separateCrossing` and :doc:`pgr_separateTouching` insert "
"the results into the edges table."
msgstr ""

msgid "Create the vertices table"
msgstr ""

msgid "Using :doc:`pgr_extractVertices` create the table."
msgstr ""

msgid "Contraction of a graph"
msgstr ""

msgid "The graph can be reduced in size using :doc:`contraction-family`"
msgstr ""

msgid ""
"When to contract will depend on the size of the graph, processing times, "
"correctness of the data, on the final application, or any other factor "
"not mentioned."
msgstr ""

msgid ""
"A fairly good method of finding out if contraction can be useful is "
"because of the number of dead ends and/or the number of linear edges."
msgstr ""

msgid ""
"A complete method on how to contract and how to use the contracted graph "
"is described on :doc:`contraction-family`"
msgstr ""

msgid "To get the dead ends:"
msgstr ""

msgid "A dead end happens when"
msgstr ""

msgid ""
"The vertex is the limit of a cul-de-sac, a no-through road or a no-exit "
"road."
msgstr ""

msgid "The vertex is on the limit of the imported graph."
msgstr ""

msgid "If a larger graph is imported then the vertex might not be a dead end"
msgstr ""

msgid ""
"Node :math:`4`, is a dead end on the query, even that it visually looks "
"like an end point of 3 edges."
msgstr ""

msgid "Is node :math:`4` a dead end or not?"
msgstr ""

msgid "The answer to that question will depend on the application."
msgstr ""

msgid "Is there such a small curb:"
msgstr ""

msgid "That does not allow a vehicle to use that visual intersection?"
msgstr ""

msgid ""
"Is the application for pedestrians and therefore the pedestrian can "
"easily walk on the small curb?"
msgstr ""

msgid ""
"Is the application for the electricity and the electrical lines than can "
"easily be extended on top of the small curb?"
msgstr ""

msgid ""
"Is there a big cliff and from eagles view look like the dead end is close"
" to the segment?"
msgstr ""

msgid "Depending on the answer, modification of the data might be needed."
msgstr ""

msgid ""
"When there are many dead ends, to speed up processing, the :doc"
":`contraction-family` functions can be used to contract the graph."
msgstr ""

msgid "Linear edges"
msgstr ""

msgid "To get the linear edges:"
msgstr ""

msgid ""
"These linear vertices are correct, for example, when those the vertices "
"are speed bumps, stop signals and the application is taking them into "
"account."
msgstr ""

msgid ""
"When there are many linear vertices, that need not to be taken into "
"account, to speed up the processing, the :doc:`contraction-family` "
"functions can be used to contract the problem."
msgstr ""

msgid "Function's structure"
msgstr ""

msgid "Once the graph preparation work has been done above, it is time to use a"
msgstr ""

msgid "The general form of a pgRouting function call is:"
msgstr ""

msgid "\\ \\"
msgstr ""

msgid "pgr_<name>(`Inner queries`_, **parameters**, [ ``Optional parameters``)"
msgstr ""

msgid ""
"`Inner queries`_: Are compulsory parameters that are ``TEXT`` strings "
"containing SQL queries."
msgstr ""

msgid "**parameters**: Additional compulsory parameters needed by the function."
msgstr ""

msgid ""
"``Optional parameters``: Are non compulsory **named** parameters that "
"have a default value when omitted."
msgstr ""

msgid ""
"The compulsory parameters are positional parameters, the optional "
"parameters are named parameters."
msgstr ""

msgid "For example, for this :doc:`pgr_dijkstra` signature:"
msgstr ""

msgid "pgr_dijkstra(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr ""

msgid "`Edges SQL`_:"
msgstr ""

msgid "Is the first parameter."
msgstr ""

msgid "It is compulsory."
msgstr ""

msgid "It is an inner query."
msgstr ""

msgid ""
"It has no name, so **Edges SQL** gives an idea of what kind of inner "
"query needs to be used"
msgstr ""

msgid "**start vid**:"
msgstr ""

msgid "Is the second parameter."
msgstr ""

msgid ""
"It has no name, so **start vid** gives an idea of what the second "
"parameter's value should contain."
msgstr ""

msgid "Is the third parameter."
msgstr ""

msgid ""
"It has no name, so **end vid** gives an idea of what the third "
"parameter's value should contain"
msgstr ""

msgid "Is the fourth parameter."
msgstr ""

msgid "It is optional."
msgstr ""

msgid "It has a name."
msgstr ""

msgid ""
"The full description of the parameters are found on the `Parameters`_ "
"section of each function."
msgstr ""

msgid "Function's overloads"
msgstr ""

msgid "A function might have different overloads. The most common are called:"
msgstr ""

msgid "`One to One`_"
msgstr ""

msgid "`One to Many`_"
msgstr ""

msgid "`Many to One`_"
msgstr ""

msgid "`Many to Many`_"
msgstr ""

msgid "`Combinations`_"
msgstr ""

msgid "Depending on the overload the parameters types change."
msgstr ""

msgid "**One**: **ANY-INTEGER**"
msgstr ""

msgid "**Many**: ``ARRAY`` [**ANY-INTEGER**]"
msgstr ""

msgid ""
"Depending of the function the overloads may vary. But the concept of "
"parameter type change remains the same."
msgstr ""

msgid "When routing from:"
msgstr ""

msgid "From **one** starting vertex"
msgstr ""

msgid "to **one** ending vertex"
msgstr ""

msgid "to **many** ending vertices"
msgstr ""

msgid "From **many** starting vertices"
msgstr ""

msgid "From **many** different starting vertices"
msgstr ""

msgid "to **many** different ending vertices"
msgstr ""

msgid "Every tuple specifies a pair of a start vertex and an end vertex"
msgstr ""

msgid "Users can define the combinations as desired."
msgstr ""

msgid "Needs a `Combinations SQL`_"
msgstr ""

msgid ""
"There are several kinds of valid inner queries and also the columns "
"returned are depending of the function. Which kind of inner query will "
"depend on the function's requirements. To simplify the variety of types, "
"**ANY-INTEGER** and **ANY-NUMERICAL** is used."
msgstr ""

msgid "Edges SQL for"
msgstr ""

msgid "Some uncategorised functions"
msgstr ""

msgid "General without ``id``"
msgstr ""

msgid "General with (X,Y)"
msgstr ""

msgid ""
"When negative: edge (``source``, ``target``) does not exist, therefore "
"it's not part of the graph."
msgstr ""

msgid "Weight of the edge (``target``, ``source``),"
msgstr ""

msgid "``x1``"
msgstr ""

msgid "X coordinate of ``source`` vertex."
msgstr ""

msgid "``y1``"
msgstr ""

msgid "Y coordinate of ``source`` vertex."
msgstr ""

msgid "``x2``"
msgstr ""

msgid "X coordinate of ``target`` vertex."
msgstr ""

msgid "``y2``"
msgstr ""

msgid "Y coordinate of ``target`` vertex."
msgstr ""

msgid "Flow"
msgstr ""

msgid "Edges SQL for :doc:`flow-family`"
msgstr ""

msgid "Edges SQL for the following functions of :doc:`flow-family`"
msgstr ""

msgid "Used in combination signatures"
msgstr ""

msgid "Points SQL for"
msgstr ""

msgid ""
"The main parameter of the majority of the pgRouting functions is a query "
"that selects the edges of the graph."
msgstr ""

msgid ""
"Depending on the family or category of a function it will have additional"
" parameters, some of them are compulsory and some are optional."
msgstr ""

msgid ""
"The compulsory parameters are nameless and must be given in the required "
"order. The optional parameters are named parameters and will have a "
"default value."
msgstr ""

msgid "Parameters for the Via functions"
msgstr ""

msgid "SQL query as described."
msgstr ""

msgid "When ``true`` Graph is considered `Directed`"
msgstr ""

msgid "When ``false`` the graph is considered as Undirected."
msgstr ""

msgid "``strict``"
msgstr ""

msgid "``false``"
msgstr ""

msgid "When ``true`` if a path is missing stops and returns **EMPTY SET**"
msgstr ""

msgid "When ``false`` ignores missing paths returning all paths found"
msgstr ""

msgid "``U_turn_on_edge``"
msgstr ""

msgid ""
"When ``true`` departing from a visited vertex will not try to avoid using"
" the edge used to reach it. In other words, U turn using the edge with "
"same identifier is allowed."
msgstr ""

msgid ""
"When ``false`` when a departing from a visited vertex tries to avoid "
"using the edge used to reach it. In other words, U turn using the edge "
"with same identifier is used when no other path is found."
msgstr ""

msgid "For the TRSP functions"
msgstr ""

msgid "Array of identifiers of destination vertices."
msgstr ""

msgid "There are several kinds of columns returned are depending of the function."
msgstr ""

msgid "Result columns for single path functions"
msgstr ""

msgid ""
"Used in functions that return one path solution per departure and "
"destination."
msgstr ""

msgid ":doc:`pgr_dijkstraNear`"
msgstr ""

msgid "Returns |short-generic-result|"
msgstr ""

msgid "``path_seq``"
msgstr ""

msgid ""
"Relative position in the path. Has value **1** for the beginning of a "
"path."
msgstr ""

msgid "Identifier of the starting vertex of the current path."
msgstr ""

msgid "Identifier of the ending vertex of the current path."
msgstr ""

msgid "Identifier of the node in the path from ``start_vid`` to ``end_vid``."
msgstr ""

msgid ""
"Identifier of the edge used to go from ``node`` to the next node in the "
"path sequence. **-1** for the last node of the path."
msgstr ""

msgid ""
"Cost to traverse from ``node`` using ``edge`` to the next node in the "
"path sequence."
msgstr ""

msgid ""
"When ``start_vid`` or ``end_vid`` columns have negative values, the "
"identifier is for a Point."
msgstr ""

msgid "Result columns for multiple paths functions"
msgstr ""

msgid ""
"Used in functions that return many paths solutions per departure and "
"destination."
msgstr ""

msgid ":doc:`pgr_KSP`"
msgstr ""

msgid ":doc:`pgr_withPointsKSP`"
msgstr ""

msgid "Returns set of |generic-result|"
msgstr ""

msgid "``path_id``"
msgstr ""

msgid "Path identifier."
msgstr ""

msgid "Has value **1** for the first of a path from ``start_vid`` to ``end_vid``."
msgstr ""

msgid "Result columns for cost functions"
msgstr ""

msgid "Used by:"
msgstr ""

msgid ""
"When start_vid or end_vid columns have negative values, the identifier is"
" for a Point."
msgstr ""

msgid "Result columns for flow functions"
msgstr ""

msgid "Result columns for spanning tree functions"
msgstr ""

msgid "Used in functions that return a tree solution per departure."
msgstr ""

msgid "Result columns for simple spanning tree functions"
msgstr ""

msgid "Returns set of ``(edge, cost)``"
msgstr ""

msgid "Cost to traverse the edge."
msgstr ""

msgid "Performance Tips"
msgstr ""

msgid "For the Routing functions"
msgstr ""

msgid "To get faster results bound the queries to an area of interest of routing."
msgstr ""

msgid ""
"In this example Use an inner query SQL that does not include some edges "
"in the routing function and is within the area of the results."
msgstr ""

msgid "Given this area:"
msgstr ""

msgid "Calculate a route:"
msgstr ""

msgid "How to contribute"
msgstr ""

msgid "Wiki"
msgstr ""

msgid ""
"Edit an existing `pgRouting Wiki "
"<https://github.com/pgRouting/pgrouting/wiki>`__ page."
msgstr ""

msgid "Or create a new Wiki page"
msgstr ""

msgid ""
"Create a page on the `pgRouting Wiki "
"<https://github.com/pgRouting/pgrouting/wiki>`__"
msgstr ""

msgid "Give the title an appropriate name"
msgstr ""

msgid ""
"`Example <https://github.com/pgRouting/pgrouting/wiki/How-to:-Handle-"
"parallel-edges-(KSP)>`__"
msgstr ""

msgid "Adding Functionality to pgRouting"
msgstr ""

msgid ""
"Consult the `developer's documentation "
"<https://docs.pgrouting.org/doxy/2.4/index.html>`__"
msgstr ""

msgid "See also"
msgstr ""

msgid "Installation"
msgstr ""

msgid ""
"Instructions for downloading and installing binaries for different "
"operating systems, additional notes and corrections not included in this "
"documentation can be found in `Installation wiki "
"<https://github.com/pgRouting/pgrouting/wiki/Notes-on-Download%2C-"
"Installation-and-building-pgRouting>`__"
msgstr ""

msgid ""
"To use pgRouting, PostGIS needs to be installed, please read the "
"information about installation in this `Install Guide "
"<https://www.postgis.us/presentations/postgis_install_guide_22.html>`__"
msgstr ""

msgid "Short Version"
msgstr ""

msgid "Extracting the tar ball"
msgstr ""

msgid "To compile assuming you have all the dependencies in your search path:"
msgstr ""

msgid ""
"Once pgRouting is installed, it needs to be enabled in each individual "
"database you want to use it in."
msgstr ""

msgid "Get the sources"
msgstr ""

msgid ""
"The pgRouting latest release can be found in "
"https://github.com/pgRouting/pgrouting/releases/latest"
msgstr ""

msgid "To download this release:"
msgstr ""

msgid ""
"Go to :ref:`install-short` for more instructions on extracting tar ball "
"and compiling pgRouting."
msgstr ""

msgid "git"
msgstr ""

msgid "To download the repository"
msgstr ""

msgid ""
"Go to :ref:`install-short` for more instructions on compiling pgRouting "
"(there is no tar ball involved while downloading pgRouting repository "
"from GitHub)."
msgstr ""

msgid "Enabling and upgrading in the database"
msgstr ""

msgid "Enabling the database"
msgstr ""

msgid ""
"pgRouting is a PostgreSQL extension and depends on PostGIS to provide "
"functionalities to end user. Below given code demonstrates enabling "
"PostGIS and pgRouting in the database."
msgstr ""

msgid ""
"Checking PostGIS and pgRouting version after enabling them in the "
"database."
msgstr ""

msgid "Upgrading the database"
msgstr ""

msgid ""
"To upgrade pgRouting in the database to version 4.0.0 use the following "
"command:"
msgstr ""

msgid ""
"More information can be found in https://www.postgresql.org/docs/current"
"/sql-createextension.html"
msgstr ""

msgid "Dependencies"
msgstr ""

msgid "Compilation Dependencies"
msgstr ""

msgid ""
"To be able to compile pgRouting, make sure that the following "
"dependencies are met:"
msgstr ""

msgid "C and C++0x compilers"
msgstr ""

msgid ""
"Compiling with Boost 1.56 up to Boost 1.74 requires C++ Compiler with "
"C++03 or C++11 standard support"
msgstr ""

msgid ""
"Compiling with Boost 1.75 requires C++ Compiler with C++14 standard "
"support"
msgstr ""

msgid "Postgresql version >= 13"
msgstr ""

msgid "The Boost Graph Library (BGL) >= 1.56.0"
msgstr ""

msgid "CMake >= 3.12"
msgstr ""

msgid "For user's documentation"
msgstr ""

msgid "Sphinx >= 4.0"
msgstr ""

msgid "For developer's documentation"
msgstr ""

msgid "Doxygen >= 1.7"
msgstr ""

msgid "For testing"
msgstr ""

msgid "pgtap"
msgstr ""

msgid "pg_prove"
msgstr ""

msgid "For using:"
msgstr ""

msgid "PostGIS version >= 3.0.0"
msgstr ""

msgid "Example: Installing dependencies on linux"
msgstr ""

msgid "Installing the compilation dependencies"
msgstr ""

msgid "Build dependencies"
msgstr ""

msgid "Optional dependencies"
msgstr ""

msgid "For documentation"
msgstr ""

msgid "Configuring"
msgstr ""

msgid "pgRouting uses the `cmake` system to do the configuration."
msgstr ""

msgid "Configurable variables"
msgstr ""

msgid "To see the variables that can be configured"
msgstr ""

msgid "The build directory is different from the source directory"
msgstr ""

msgid "Configuring The Documentation"
msgstr ""

msgid ""
"User and developers documentation are not build if prerequisites are not "
"found."
msgstr ""

msgid ""
"Most of the effort of the documentation has been on the HTML files. Some "
"variables for building documentation:"
msgstr ""

msgid "Variable"
msgstr ""

msgid "Comment"
msgstr ""

msgid "BUILD_HTML"
msgstr ""

msgid "BOOL=ON"
msgstr ""

msgid "If ON, turn on/off building HTML for user's documentation"
msgstr ""

msgid "BUILD_DOXY"
msgstr ""

msgid "If ON, turn on/off building HTML for developer's documentation"
msgstr ""

msgid "BUILD_LATEX"
msgstr ""

msgid "BOOL=OFF"
msgstr ""

msgid "If ON, turn on/off building PDF"
msgstr ""

msgid "BUILD_MAN"
msgstr ""

msgid "If ON, turn on/off building MAN pages"
msgstr ""

msgid "DOC_USE_BOOTSTRAP"
msgstr ""

msgid "If ON, use sphinx-bootstrap for HTML pages of the users documentation"
msgstr ""

msgid "EN"
msgstr ""

msgid "if OFF the English documentation will no be built"
msgstr ""

msgid "ES"
msgstr ""

msgid "if OFF the Spanish documentation will no be built"
msgstr ""

msgid "SV"
msgstr ""

msgid "if OFF the Swedish documentation will no be built"
msgstr ""

msgid "ZH_HANS"
msgstr ""

msgid "if OFF the Chinese simplified documentation will no be built"
msgstr ""

msgid "Building"
msgstr ""

msgid "Using ``make`` to build the code and the documentation"
msgstr ""

msgid "The following instructions start from ``path/to/pgrouting/build``"
msgstr ""

msgid ""
"We have tested on several platforms, For installing or reinstalling all "
"the steps are needed."
msgstr ""

msgid "Linux"
msgstr ""

msgid "The following instructions start from ``path/to/pgrouting``"
msgstr ""

msgid "Testing"
msgstr ""

msgid "Currently there is no :code:`make test` and testing is done as follows"
msgstr ""

msgid ""
"pgRouting is an extension of `PostGIS <https://postgis.net>`__ and "
"`PostgreSQL <https://www.postgresql.org>`__ geospatial database and adds "
"routing and other network analysis functionality. A predecessor of "
"pgRouting  pgDijkstra, written by Sylvain Pasche from `Camptocamp "
"<https://camptocamp.com>`__, was later extended by Orkney and renamed to "
"pgRouting. The project is now supported and maintained by `Georepublic "
"<https://georepublic.info>`__, `Paragon Corporation "
"<https://www.paragoncorporation.com/>`__ and a broad user community."
msgstr ""

msgid ""
"pgRouting is part of `OSGeo Community Projects "
"<https://wiki.osgeo.org/wiki/OSGeo_Community_Projects>`__ from the `OSGeo"
" Foundation <https://www.osgeo.org>`__ and included on `OSGeoLive "
"<http://live.osgeo.org/>`__."
msgstr ""

msgid "Licensing"
msgstr ""

msgid "The following licenses can be found in pgRouting:"
msgstr ""

msgid "**License**"
msgstr ""

msgid "GNU General Public License v2.0 or later"
msgstr ""

msgid ""
"Most features of pgRouting are available under `GNU General Public "
"License v2.0 or later <https://spdx.org/licenses/GPL-2.0-or-"
"later.html>`_."
msgstr ""

msgid "Boost Software License - Version 1.0"
msgstr ""

msgid ""
"Some Boost extensions are available under `Boost Software License - "
"Version 1.0 <https://www.boost.org/LICENSE_1_0.txt>`_."
msgstr ""

msgid "MIT-X License"
msgstr ""

msgid "Some code contributed by iMaptools.com is available under MIT-X license."
msgstr ""

msgid ""
"The pgRouting Manual is licensed under a `Creative Commons Attribution-"
"Share Alike 3.0 License <https://creativecommons.org/licenses/by-"
"sa/3.0/>`_."
msgstr ""

msgid ""
"In general license information should be included in the header of each "
"source file."
msgstr ""

msgid "Contributors"
msgstr ""

msgid "This Release Contributors"
msgstr ""

msgid "Individuals in this release v4.0.0 (in alphabetical order)"
msgstr ""

msgid "Bipasha Gayary, Fan Wu, Regina Obe, Saloni kumari, Vicky Vergara"
msgstr ""

msgid ""
"And all the people that give us a little of their time making comments, "
"finding issues, making pull requests etc. in any of our products: "
"osm2pgrouting, pgRouting, pgRoutingLayer, workshop."
msgstr ""

msgid "Translators (in alphabetical order)"
msgstr ""

msgid "Chinese:"
msgstr ""

msgid "Dapeng Wang"
msgstr ""

msgid "Spanish:"
msgstr ""

msgid "Vicky Vergara"
msgstr ""

msgid "Swedish:"
msgstr ""

msgid "Daniel Nylander"
msgstr ""

msgid "Corporate Sponsors in this release (in alphabetical order)"
msgstr ""

msgid ""
"These are corporate entities that have contributed developer time, "
"hosting, or direct monetary funding to the pgRouting project:"
msgstr ""

msgid "`OSGeo <https://www.osgeo.org>`__"
msgstr ""

msgid "`OSGeo UK <https://uk.osgeo.org>`__"
msgstr ""

msgid "`Google Summer of Code <https://summerofcode.withgoogle.com>`__"
msgstr ""

msgid "`HighGo Software <https://www.highgo.com/>`__"
msgstr ""

msgid "`Paragon Corporation <https://www.paragoncorporation.com/>`__"
msgstr ""

msgid "Contributors Past & Present:"
msgstr ""

msgid "Individuals (in alphabetical order)"
msgstr ""

msgid ""
"Aasheesh Tiwari, Abhinav Jain, Aditya Pratap Singh, Adrien Berchet, Akio "
"Takubo, Andrea Nardelli, Anthony Tasca, Anton Patrushev, Aryan Gupta, "
"Ashraf Hossain, Ashish Kumar, Aurlie Bousquet, Bipasha Gayary, Cayetano "
"Benavent, Christian Gonzalez, Daniel Kastl, Dapeng Wang, Dave Potts, "
"David Techer, Denis Rykov, Ema Miyawaki, Esteban Zimanyi, Fan Wu, Florian"
" Thurkow, Frederic Junod, Gerald Fenoy, Gudesa Venkata Sai Akhil, Hang "
"Wu, Himanshu Raj, Imre Samu, Jay Mahadeokar, Jinfu Leng, Kai Behncke, "
"Kishore Kumar, Ko Nagase, Mahmoud Sakr, Manikata Kondeti, Mario Basa, "
"Martin Wiesenhaan, Maxim Dubinin, Maoguang Wang, Mohamed Bakli, Mohamed "
"Zia, Mukul Priya, Nitish Chauhan, Rajat Shinde, Razequl Islam, Regina "
"Obe, Rohith Reddy, Saloni Kumari, Sarthak Agarwal, Shobhit Chaurasia, "
"Sourabh Garg, Stephen Woodbridge, Swapnil Joshi, Sylvain Housseman, "
"Sylvain Pasche, Veenit Kumar, Vidhan Jain, Virginia Vergara, Yige Huang"
msgstr ""

msgid "Corporate Sponsors (in alphabetical order)"
msgstr ""

msgid "Camptocamp"
msgstr ""

msgid "CSIS (University of Tokyo)"
msgstr ""

msgid "Georepublic"
msgstr ""

msgid "Google Summer of Code"
msgstr ""

msgid "HighGo Software"
msgstr ""

msgid "iMaptools"
msgstr ""

msgid "Leopark"
msgstr ""

msgid "Orkney"
msgstr ""

msgid "OSGeo"
msgstr ""

msgid "OSGeo UK"
msgstr ""

msgid "Paragon Corporation"
msgstr ""

msgid "Versaterm Inc."
msgstr ""

msgid "More Information"
msgstr ""

msgid ""
"The latest software, documentation and news items are available at the "
"pgRouting web site https://pgrouting.org."
msgstr ""

msgid ""
"PostgreSQL database server at the PostgreSQL main site "
"https://www.postgresql.org."
msgstr ""

msgid "PostGIS extension at the PostGIS project web site https://postgis.net."
msgstr ""

msgid "Boost C++ source libraries at https://www.boost.org."
msgstr ""

msgid ":doc:`migration`"
msgstr ""

msgid "``pgr_KSP``  Yen's algorithm for K shortest paths using Dijkstra."
msgstr ""

msgid "Availability"
msgstr ""

msgid "Version 4.0.0"
msgstr ""

msgid "Version 3.6.0"
msgstr ""

msgid "Standardizing output columns to |nksp-result|"
msgstr ""

msgid "pgr_ksp(One to One)"
msgstr ""

msgid "Added ``start_vid`` and ``end_vid`` result columns."
msgstr ""

msgid "New proposed signatures:"
msgstr ""

msgid "pgr_ksp(One to Many)"
msgstr ""

msgid "pgr_ksp(Many to One)"
msgstr ""

msgid "pgr_ksp(Many to Many)"
msgstr ""

msgid "pgr_ksp(Combinations)"
msgstr ""

msgid "Version 2.1.0"
msgstr ""

msgid "Signature change"
msgstr ""

msgid "Old signature no longer supported"
msgstr ""

msgid "Version 2.0.0"
msgstr ""

msgid "Official function."
msgstr ""

msgid ""
"The K shortest path routing algorithm based on Yen's algorithm. \"K\" is "
"the number of shortest paths desired."
msgstr ""

msgid "|Boost| Boost Graph Inside"
msgstr ""

msgid "Boost Graph inside"
msgstr ""

msgid "Signatures"
msgstr ""

msgid "Summary"
msgstr ""

msgid "pgr_KSP(`Edges SQL`_, **start vid**, **end vid**, **K**, [**options**])"
msgstr ""

msgid "pgr_KSP(`Edges SQL`_, **start vid**, **end vids**, **K**, [**options**])"
msgstr ""

msgid "pgr_KSP(`Edges SQL`_, **start vids**, **end vid**, **K**, [**options**])"
msgstr ""

msgid "pgr_KSP(`Edges SQL`_, **start vids**, **end vids**, **K**, [**options**])"
msgstr ""

msgid "pgr_KSP(`Edges SQL`_, `Combinations SQL`_, **K**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, heap_paths]``"
msgstr ""

msgid "Returns set of |nksp-result|"
msgstr ""

msgid "OR EMPTY SET"
msgstr ""

msgid "Example"
msgstr ""

msgid "Get 2 paths from :math:`6` to :math:`17` on a directed graph."
msgstr ""

#, python-brace-format
msgid ""
"Get 2 paths from vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a "
"directed graph."
msgstr ""

#, python-brace-format
msgid ""
"Get 2 paths from vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a "
"directed graph."
msgstr ""

#, python-brace-format
msgid ""
"Get 2 paths vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 17\\}` "
"on a directed graph."
msgstr ""

msgid "Using a combinations table on an directed graph"
msgstr ""

msgid "The combinations table:"
msgstr ""

msgid "The query:"
msgstr ""

msgid "Identifier of the destination vertex."
msgstr ""

msgid "**K**"
msgstr ""

msgid "Number of required paths."
msgstr ""

msgid "KSP Optional parameters"
msgstr ""

msgid "``heap_paths``"
msgstr ""

msgid "When ``false`` Returns at most K paths."
msgstr ""

msgid "When ``true`` all the calculated paths while processing are returned."
msgstr ""

msgid ""
"Roughly, when the shortest path has ``N`` edges, the heap will contain "
"about than ``N * K`` paths for small value of ``K`` and ``K > 5``."
msgstr ""

msgid "Additional Examples"
msgstr ""

msgid "Get 2 paths from :math:`6` to :math:`17` on an undirected graph"
msgstr ""

msgid "Also get the paths in the heap."
msgstr ""

msgid "Get 2 paths using combinations table on an undirected graph"
msgstr ""

#, python-brace-format
msgid ""
"Get 2 paths from vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a "
"undirected graph."
msgstr ""

msgid "https://en.wikipedia.org/wiki/K_shortest_path_routing"
msgstr ""

msgid "``pgr_TSP``"
msgstr ""

msgid "``pgr_TSP`` - Approximation using *metric* algorithm."
msgstr ""

msgid "Availability:"
msgstr ""

msgid "Results change depending on input order"
msgstr ""

msgid "Only for undirected graphs"
msgstr ""

msgid "Version 3.2.1"
msgstr ""

msgid ""
"Metric Algorithm from `Boost library "
"<https://www.boost.org/libs/graph/doc/metric_tsp_approx.html>`__"
msgstr ""

msgid "Simulated Annealing Algorithm no longer supported"
msgstr ""

msgid ""
"The Simulated Annealing Algorithm related parameters are ignored: "
"`max_processing_time`, `tries_per_temperature`, "
"`max_changes_per_temperature`, `max_consecutive_non_changes`, "
"`initial_temperature`, `final_temperature`, `cooling_factor`, `randomize`"
msgstr ""

msgid "Version 2.3.0"
msgstr ""

msgid "Results change depending on input order of the `Matrix SQL`_"
msgstr ""

msgid "Negative costs are ignored."
msgstr ""

msgid ""
"Can be Used with :doc:`costMatrix-category` functions preferably with "
"`directed => false`."
msgstr ""

msgid "With ``directed => false``"
msgstr ""

msgid "Will generate a graph that:"
msgstr ""

msgid "is undirected"
msgstr ""

msgid "is fully connected (As long as the graph has one component)"
msgstr ""

msgid "all traveling costs on edges obey the triangle inequality."
msgstr ""

msgid "When ``start_vid = 0 OR end_vid = 0``"
msgstr ""

msgid ""
"The solutions generated are guaranteed to be *twice as long as the "
"optimal tour in the worst case*"
msgstr ""

msgid "When ``start_vid != 0 AND end_vid != 0 AND start_vid != end_vid``"
msgstr ""

msgid ""
"It is **not guaranteed** that the solution will be, in the worst case, "
"twice as long as the optimal tour, due to the fact that `end_vid` is "
"forced to be in a fixed position."
msgstr ""

msgid "With ``directed => true``"
msgstr ""

msgid ""
"It is **not guaranteed** that the solution will be, in the worst case, "
"twice as long as the optimal tour"
msgstr ""

msgid "is directed"
msgstr ""

msgid ""
"some (or all) traveling costs on edges might not obey the triangle "
"inequality."
msgstr ""

msgid ""
"As an undirected graph is required, the directed graph is transformed as "
"follows:"
msgstr ""

msgid ""
"edges `(u, v)` and `(v, u)` is considered to be the same edge (denoted "
"`(u, v)`"
msgstr ""

msgid "if ``agg_cost`` differs between one or more instances of edge `(u, v)`"
msgstr ""

msgid ""
"The minimum value of the ``agg_cost`` all instances of edge `(u, v)` is "
"going to be considered as the ``agg_cost`` of edge `(u, v)`"
msgstr ""

msgid ""
"Some (or all) traveling costs on edges will still might not obey the "
"triangle inequality."
msgstr ""

msgid ""
"When the data does not come from an undirected graph or its not fully "
"connected:"
msgstr ""

msgid "Missing values will be calculated with dijkstra algorithm."
msgstr ""

msgid "When the graph has more than one component:"
msgstr ""

msgid ""
"``start_vid`` or ``end_vid`` are defined and are on the same component: "
"the TSP tour will happen on that component."
msgstr ""

msgid ""
"``start_vid`` or ``end_vid`` are defined and are not on the same "
"component: the TSP tour will propose a tour that has both components "
"where connecting costs are estimated."
msgstr ""

msgid ""
"``start_vid`` or ``end_vid`` are not defined: the starting point could be"
" on any component and will include data only from that component."
msgstr ""

msgid "One cycle attempt to remove crossing edges is done to the TSP results."
msgstr ""

msgid "pgr_TSP(`Matrix SQL`_, ``[start_id, end_id]``)"
msgstr ""

msgid "Returns set of |tsp-result|"
msgstr ""

msgid "Using :doc:`pgr_dijkstraCostMatrix` to generate the matrix information"
msgstr ""

#, python-brace-format
msgid ""
"**Line 4** Vertices :math:`\\{2, 4, 13, 14\\}` are not included because "
"they are not connected."
msgstr ""

msgid "`Matrix SQL`_ as described below"
msgstr ""

msgid "``ANY-INTEGER``"
msgstr ""

msgid "``ANY-NUMERICAL``"
msgstr ""

msgid "Cost for going from start_vid to end_vid"
msgstr ""

msgid "Returns SET OF ``(seq, node, cost, agg_cost)``"
msgstr ""

msgid "Row sequence."
msgstr ""

msgid "**node**"
msgstr ""

msgid "Identifier of the node/coordinate/point."
msgstr ""

msgid ""
"Cost to traverse from the current ``node`` to the next ``node`` in the "
"path sequence."
msgstr ""

msgid "``0`` for the last row in the tour sequence."
msgstr ""

msgid "Aggregate cost from the ``node`` at ``seq = 1`` to the current node."
msgstr ""

msgid "``0`` for the first row in the tour sequence."
msgstr ""

msgid "Start from vertex :math:`1`"
msgstr ""

msgid "**Line 6** ``start_vid => 1``"
msgstr ""

msgid "Using points of interest to generate an asymmetric matrix."
msgstr ""

msgid "To generate an asymmetric matrix:"
msgstr ""

msgid ""
"**Line 4** The ``side`` information of ``pointsOfInterset`` is ignored by"
" not including it in the query"
msgstr ""

msgid "**Line 6** Generating an asymmetric matrix with ``directed => true``"
msgstr ""

msgid ""
":math:`min(agg\\_cost(u, v), agg\\_cost(v, u))` is going to be considered"
" as the ``agg_cost``"
msgstr ""

msgid ""
"The solution that can be larger than *twice as long as the optimal tour* "
"because:"
msgstr ""

msgid "Triangle inequality might not be satisfied."
msgstr ""

msgid "``start_id != 0 AND end_id != 0``"
msgstr ""

msgid "Connected incomplete data"
msgstr ""

#, python-brace-format
msgid ""
"Using selected edges :math:`\\{2, 4, 5, 8, 9, 15\\}` the matrix is not "
"complete."
msgstr ""

msgid ""
"Cost value for :math:`17 \\rightarrow 10` do not exist on the matrix, but"
" the value used is taken from :math:`10 \\rightarrow 17`."
msgstr ""

msgid "``pgr_TSPeuclidean``"
msgstr ""

msgid "``pgr_TSPeuclidean`` - Approximation using *metric* algorithm."
msgstr ""

msgid ""
"Using `Boost: metric TSP approx "
"<https://www.boost.org/libs/graph/doc/metric_tsp_approx.html>`__"
msgstr ""

msgid "Name change from pgr_eucledianTSP"
msgstr ""

msgid "New official function."
msgstr ""

msgid "Results change depending on input order of the `Coordinates SQL`_"
msgstr ""

msgid ""
"Any duplicated identifier will be ignored. The coordinates that will be "
"kept is arbitrarily."
msgstr ""

msgid "The coordinates are quite similar for the same identifier, for example ::"
msgstr ""

msgid ""
"The coordinates are quite different for the same identifier, for example "
"::"
msgstr ""

msgid "pgr_TSPeuclidean(`Coordinates SQL`_, ``[start_id, end_id]``)"
msgstr ""

msgid "With default values"
msgstr ""

msgid "`Coordinates SQL`_"
msgstr ""

msgid "`Coordinates SQL`_ as described below"
msgstr ""

msgid "Coordinates SQL"
msgstr ""

msgid "``x``"
msgstr ""

msgid "X value of the coordinate."
msgstr ""

msgid "``y``"
msgstr ""

msgid "Y value of the coordinate."
msgstr ""

msgid "Test 29 cities of Western Sahara"
msgstr ""

msgid ""
"This example shows how to make performance tests using University of "
"Waterloo's `example data "
"<https://www.math.uwaterloo.ca/tsp/world/countries.html>`__ using the 29 "
"cities of `Western Sahara dataset "
"<https://www.math.uwaterloo.ca/tsp/world/wi29.tsp>`__"
msgstr ""

msgid "Creating a table for the data and storing the data"
msgstr ""

msgid "Adding a geometry (for visual purposes)"
msgstr ""

msgid "Total tour cost"
msgstr ""

msgid ""
"Getting a total cost of the tour, compare the value with the length of an"
" optimal tour is 27603, given on the dataset"
msgstr ""

msgid "Getting a geometry of the tour"
msgstr ""

msgid "Visual results"
msgstr ""

msgid ""
"Visually, The first image is the `optimal solution "
"<https://www.math.uwaterloo.ca/tsp/world/witour.html>`__ and the second "
"image is the solution obtained with ``pgr_TSPeuclidean``."
msgstr ""

msgid "``pgr_aStar``  Shortest path using the A* algorithm."
msgstr ""

msgid "Standardizing output columns to |short-generic-result|"
msgstr ""

msgid "pgr_aStar(One to One) added ``start_vid`` and ``end_vid`` columns."
msgstr ""

msgid "pgr_aStar(One to Many) added ``end_vid`` column."
msgstr ""

msgid "pgr_aStar(Many to One) added ``start_vid`` column."
msgstr ""

msgid "New proposed signature:"
msgstr ""

msgid "pgr_aStar(Combinations)"
msgstr ""

msgid "Version 2.4.0"
msgstr ""

msgid "pgr_aStar(One to Many)"
msgstr ""

msgid "pgr_aStar(Many to One)"
msgstr ""

msgid "pgr_aStar(Many to Many)"
msgstr ""

msgid "Signature change on pgr_aStar(One to One)"
msgstr ""

msgid ""
"The results are equivalent to the union of the results of the "
"`pgr_aStar(` `One to One`_ `)` on the:"
msgstr ""

msgid "pgr_aStar(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_aStar(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_aStar(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_aStar(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_aStar(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr ""

msgid "**options:** ``[directed, heuristic, factor, epsilon]``"
msgstr ""

msgid "Returns set of |short-generic-result|"
msgstr ""

msgid "Optional parameters are `named parameters` and have a default value."
msgstr ""

msgid ""
"From vertex :math:`6` to vertex :math:`12` on a **directed** graph with "
"heuristic :math:`2`"
msgstr ""

#, python-brace-format
msgid ""
"From vertex :math:`6` to vertices :math:`\\{10, 12\\}` on a **directed** "
"graph with heuristic :math:`3` and factor :math:`3.5`"
msgstr ""

#, python-brace-format
msgid ""
"From vertices :math:`\\{6, 8\\}` to vertex :math:`10` on an "
"**undirected** graph with heuristic :math:`4`"
msgstr ""

#, python-brace-format
msgid ""
"From vertices :math:`\\{6, 8\\}` to vertices :math:`\\{10, 12\\}` on a "
"**directed** graph with factor :math:`0.5`"
msgstr ""

msgid ""
"Using a combinations table on a **directed** graph with factor "
":math:`0.5`."
msgstr ""

msgid "Example 1"
msgstr ""

msgid "Demonstration of repeated values are ignored, and result is sorted."
msgstr ""

msgid "Example 2"
msgstr ""

msgid "Making **start vids** the same as **end vids**."
msgstr ""

msgid "Example 3"
msgstr ""

msgid "Manually assigned vertex combinations."
msgstr ""

msgid "``pgr_aStarCost``"
msgstr ""

msgid ""
"``pgr_aStarCost`` - Total cost of the shortest path using the A* "
"algorithm."
msgstr ""

msgid "pgr_aStarCost(Combinations)"
msgstr ""

msgid "New proposed function."
msgstr ""

msgid ""
"The ``pgr_aStarCost`` function summarizes the cost of the shortest path "
"using the A* algorithm."
msgstr ""

msgid ""
"Let be the case the values returned are stored in a table, so the unique "
"index would be the pair: `(start_vid, end_vid)`"
msgstr ""

msgid "For undirected graphs, the results are symmetric."
msgstr ""

msgid "The returned values are ordered in ascending order:"
msgstr ""

msgid "`start_vid` ascending"
msgstr ""

msgid "`end_vid` ascending"
msgstr ""

msgid "pgr_aStarCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_aStarCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_aStarCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr ""

msgid "Returns set of |matrix-result|"
msgstr ""

msgid "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vids**, [options])"
msgstr ""

msgid "``pgr_aStarCostMatrix``"
msgstr ""

msgid ""
"``pgr_aStarCostMatrix`` - Calculates the a cost matrix using "
":doc:`pgr_aStar`."
msgstr ""

msgid "Using internally the :doc:`pgr_aStar` algorithm"
msgstr ""

msgid "Returns a cost matrix."
msgstr ""

msgid "No ordering is performed"
msgstr ""

msgid "let `v` and `u` are nodes on the graph:"
msgstr ""

msgid "when there is no path from `v` to `u`:"
msgstr ""

msgid "cost from `v` to `u` is :math:`\\inf`"
msgstr ""

msgid "when :math:`v = u` then"
msgstr ""

msgid "cost from `v` to `u` is :math:`0`"
msgstr ""

msgid "When the graph is **undirected** the cost matrix is symmetric"
msgstr ""

msgid "pgr_aStarCostMatrix(`Edges SQL`_, **start vids**, [**options**])"
msgstr ""

#, python-brace-format
msgid ""
"Symmetric cost matrix for vertices :math:`\\{5, 6, 10, 15\\}` on an "
"**undirected** graph using heuristic :math:`2`"
msgstr ""

msgid "Use with :doc:`pgr_TSP`"
msgstr ""

msgid "``pgr_articulationPoints``"
msgstr ""

msgid ""
"``pgr_articulationPoints`` - Return the articulation points of an "
"undirected graph."
msgstr ""

msgid "Result columns change: ``seq`` is removed"
msgstr ""

msgid "Version 2.5.0"
msgstr ""

msgid ""
"Those vertices that belong to more than one biconnected component are "
"called articulation points or, equivalently, cut vertices. Articulation "
"points are vertices whose removal would increase the number of connected "
"components in the graph. This implementation can only be used with an "
"undirected graph."
msgstr ""

msgid "Works for **undirected** graphs."
msgstr ""

msgid "``node`` ascending"
msgstr ""

msgid "Running time: :math:`O(V + E)`"
msgstr ""

msgid "pgr_articulationPoints(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-node|"
msgstr ""

msgid "The articulation points of the graph"
msgstr ""

msgid "Nodes in red are the articulation points."
msgstr ""

msgid "Identifier of the vertex."
msgstr ""

msgid ""
"`Boost: Biconnected components & articulation points "
"<https://www.boost.org/libs/graph/doc/biconnected_components.html>`__"
msgstr ""

msgid ""
"wikipedia: `Biconnected component "
"<https://en.wikipedia.org/wiki/Biconnected_component>`__"
msgstr ""

msgid "``pgr_bandwidth`` - Experimental"
msgstr ""

msgid "``pgr_bandwidth`` - Calculates the bandwidth of the graph"
msgstr ""

msgid ""
"Bandwidth measures how \"spread out\" the connections are in a graph when"
" vertices are arranged in a linear order (like numbering them 1, 2, 3, "
"etc.)."
msgstr ""

msgid ""
"For each edge in the graph, calculate the distance between the vertex "
"numbers it connects"
msgstr ""

msgid "The bandwidth is the maximum of all these distances"
msgstr ""

msgid "The implementation is for undirected graphs"
msgstr ""

msgid "Run time is 0.160789 seconds"
msgstr ""

msgid "pgr_bandwidth(`Edges SQL`_)"
msgstr ""

msgid "Returns ``BIGINT``"
msgstr ""

msgid "For an undirected graph with edges."
msgstr ""

msgid "Returns a bigint ``(pgr_bandwidth)``"
msgstr ""

msgid "``pgr_bandwidth``"
msgstr ""

msgid "gives the bandwidth of the graph."
msgstr ""

msgid "Undirected graph with edges before optimization."
msgstr ""

msgid "Undirected graph with edges after optimization."
msgstr ""

msgid "`Boost: bandwidth <https://www.boost.org/libs/graph/doc/bandwidth.html>`_"
msgstr ""

msgid "``pgr_bdAstar``"
msgstr ""

msgid "``pgr_bdAstar``  Shortest path using the bidirectional A* algorithm."
msgstr ""

msgid "pgr_bdAstar(One to One) added ``start_vid`` and ``end_vid`` columns."
msgstr ""

msgid "pgr_bdAstar(One to Many) added ``end_vid`` column."
msgstr ""

msgid "pgr_bdAstar(Many to One) added ``start_vid`` column."
msgstr ""

msgid "pgr_bdAstar(Combinations)"
msgstr ""

msgid "pgr_bdAstar(One to Many)"
msgstr ""

msgid "pgr_bdAstar(Many to One)"
msgstr ""

msgid "pgr_bdAstar(Many to Many)"
msgstr ""

msgid "Signature change on pgr_bdAstar(One to One)"
msgstr ""

msgid ""
"The results are equivalent to the union of the results of pgr_bdAStar(One"
" to One) on the:"
msgstr ""

msgid "pgr_bdAstar(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_bdAstar(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_bdAstar(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_bdAstar(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_bdAstar(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr ""

msgid "``pgr_bdAstarCost``"
msgstr ""

msgid ""
"``pgr_bdAstarCost`` - Total cost of the shortest path using the "
"bidirectional A* algorithm."
msgstr ""

msgid "pgr_bdAstarCost(Combinations)"
msgstr ""

msgid ""
"The ``pgr_bdAstarCost`` function summarizes the cost of the shortest path"
" using the bidirectional A* algorithm."
msgstr ""

msgid "pgr_bdAstarCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_bdAstarCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_bdAstarCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_bdAstarCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_bdAstarCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr ""

msgid "``pgr_bdAstarCostMatrix``"
msgstr ""

msgid ""
"``pgr_bdAstarCostMatrix`` - Calculates the cost matrix using "
":doc:`pgr_bdAstar`."
msgstr ""

msgid "Internally uses the :doc:`pgr_bdAstar` algorithm."
msgstr ""

msgid "pgr_bdAstarCostMatrix(`Edges SQL`_, **start vids**, [**options**])"
msgstr ""

msgid ""
"``pgr_bdDijkstra``  Returns the shortest path using Bidirectional "
"Dijkstra algorithm."
msgstr ""

msgid "pgr_bdDijkstra(Combinations)"
msgstr ""

msgid "pgr_bdDijkstra(One to Many)"
msgstr ""

msgid "pgr_bdDijkstra(Many to One)"
msgstr ""

msgid "pgr_bdDijkstra(Many to Many)"
msgstr ""

msgid "Signature change on pgr_bdDijkstra(One to One)"
msgstr ""

msgid "pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""

msgid "pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""

msgid "pgr_bdDijkstra(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""

msgid "pgr_bdDijkstra(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr ""

msgid "pgr_bdDijkstra(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

msgid "From vertex :math:`6` to vertex :math:`10` on a **directed** graph"
msgstr ""

#, python-brace-format
msgid ""
"From vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a **directed** "
"graph"
msgstr ""

#, python-brace-format
msgid ""
"From vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a **directed** "
"graph"
msgstr ""

#, python-brace-format
msgid ""
"From vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 17\\}` on an "
"**undirected** graph"
msgstr ""

msgid "Using a combinations table on an **undirected** graph"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Bidirectional_search"
msgstr ""

msgid "``pgr_bdDijkstraCost``"
msgstr ""

msgid ""
"``pgr_bdDijkstraCost``  Returns the shortest path's cost using "
"Bidirectional Dijkstra algorithm."
msgstr ""

msgid "pgr_bdDijkstraCost(Combinations)"
msgstr ""

msgid ""
"The ``pgr_bdDijkstraCost`` function summarizes the cost of the shortest "
"path using the bidirectional Dijkstra Algorithm."
msgstr ""

msgid ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vid**, **end vid** , "
"[``directed``])"
msgstr ""

msgid ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vid**, **end vids**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vids**, **end vid** , "
"[``directed``])"
msgstr ""

msgid ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""

msgid "pgr_bdDijkstraCost(`Edges SQL`_, `Combinations SQL`_, [ ``directed``])"
msgstr ""

msgid "pgr_bdDijkstraCost(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

msgid "``pgr_bdDijkstraCostMatrix``"
msgstr ""

msgid ""
"``pgr_bdDijkstraCostMatrix`` - Calculates a cost matrix using "
":doc:`pgr_bdDijkstra`."
msgstr ""

msgid ""
"Using bidirectional Dijkstra algorithm, calculate and return a cost "
"matrix."
msgstr ""

msgid "pgr_bdDijkstraCostMatrix(`Edges SQL`_, **start vids**, [``directed``])"
msgstr ""

#, python-brace-format
msgid ""
"Symmetric cost matrix for vertices :math:`\\{5, 6, 10, 15\\}` on an "
"**undirected** graph"
msgstr ""

msgid "Use with :doc:`pgr_TSP`."
msgstr ""

msgid "``pgr_bellmanFord - Experimental``"
msgstr ""

msgid "``pgr_bellmanFord``  Shortest path using Bellman-Ford algorithm."
msgstr ""

msgid "pgr_bellmanFord(Combinations)"
msgstr ""

msgid ""
"Bellman-Ford's algorithm, is named after Richard Bellman and Lester Ford,"
" who first published it in 1958 and 1956, respectively.It is a graph "
"search algorithm that computes shortest paths from a starting vertex "
"(``start_vid``) to an ending vertex (``end_vid``) in a graph where some "
"of the edge weights may be negative. Though it is more versatile, it is "
"slower than Dijkstra's algorithm.This implementation can be used with a "
"directed graph and an undirected graph."
msgstr ""

msgid "Process is valid for edges with both positive and negative edge weights."
msgstr ""

msgid ""
"When the start vertex and the end vertex are the same, there is no path. "
"The agg_cost would be :math:`0`."
msgstr ""

msgid ""
"When the start vertex and the end vertex are different, and there exists "
"a path between them without having a *negative cycle*. The agg_cost would"
" be some finite value denoting the shortest distance between them."
msgstr ""

msgid ""
"When the start vertex and the end vertex are different, and there exists "
"a path between them, but it contains a *negative cycle*. In such case, "
"agg_cost for those vertices keep on decreasing furthermore, Hence "
"agg_cost cant be defined for them."
msgstr ""

msgid ""
"When the start vertex and the end vertex are different, and there is no "
"path. The agg_cost is :math:`\\infty`."
msgstr ""

msgid ""
"For optimization purposes, any duplicated value in the `start_vids` or "
"`end_vids` are ignored."
msgstr ""

msgid "Running time: :math:`O(| start\\_vids | * ( V * E))`"
msgstr ""

msgid "pgr_bellmanFord(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""

msgid "pgr_bellmanFord(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""

msgid "pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""

msgid ""
"pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""

msgid "pgr_bellmanFord(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

msgid "From vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a directed graph"
msgstr ""

msgid "From vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a directed graph"
msgstr ""

msgid ""
"From vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 17\\}` on an "
"undirected graph"
msgstr ""

msgid "Using a combinations table on an undirected graph"
msgstr ""

msgid ""
"`Boost: Bellman Ford "
"<https://www.boost.org/libs/graph/doc/bellman_ford_shortest.html>`__"
msgstr ""

#, python-format
msgid "https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm"
msgstr ""

msgid "``pgr_betweennessCentrality`` - Experimental"
msgstr ""

msgid ""
"``pgr_betweennessCentrality`` - Calculates the relative betweenness "
"centrality using Brandes Algorithm"
msgstr ""

msgid "Version 3.7.0"
msgstr ""

msgid ""
"The Brandes Algorithm takes advantage of the sparse graphs for evaluating"
" the betweenness centrality score of all vertices."
msgstr ""

msgid ""
"Betweenness centrality measures the extent to which a vertex lies on the "
"shortest paths between all other pairs of vertices. Vertices with a high "
"betweenness centrality score may have considerable influence in a network"
" by the virtue of their control over the shortest paths passing between "
"them."
msgstr ""

msgid ""
"The removal of these vertices will affect the network by disrupting the "
"it, as most of the shortest paths between vertices pass through them."
msgstr ""

msgid "This implementation work for both directed and undirected graphs."
msgstr ""

msgid "Running time:  :math:`\\Theta(VE)`"
msgstr ""

msgid "Running space: :math:`\\Theta(VE)`"
msgstr ""

msgid "Throws when there are no edges in the graph"
msgstr ""

msgid "pgr_betweennessCentrality(`Edges SQL`_, [``directed``])"
msgstr ""

msgid "Returns set of ``(vid, centrality)``"
msgstr ""

#, python-brace-format
msgid "For a directed graph with edges :math:`\\{1, 2, 3, 4\\}`."
msgstr ""

msgid "Explanation"
msgstr ""

msgid "The betweenness centrality are between parenthesis."
msgstr ""

msgid "The leaf vertices have betweenness centrality :math:`0`."
msgstr ""

msgid ""
"Betweenness centrality of vertex :math:`6` is higher than of vertex "
":math:`10`."
msgstr ""

msgid "Removing vertex :math:`6` will create three graph components."
msgstr ""

msgid "Removing vertex :math:`10` will create two graph components."
msgstr ""

msgid "``vid``"
msgstr ""

msgid "``centrality``"
msgstr ""

msgid ""
"Relative betweenness centrality score of the vertex (will be in range "
"[0,1])"
msgstr ""

msgid ""
"`Boost: betweenness centrality "
"<https://www.boost.org/libs/graph/doc/betweenness_centrality.html>`_"
msgstr ""

msgid "``pgr_biconnectedComponents``"
msgstr ""

msgid ""
"``pgr_biconnectedComponents``  Biconnected components of an undirected "
"graph."
msgstr ""

msgid "Result columns change:"
msgstr ""

msgid "``n_seq`` is removed"
msgstr ""

msgid "``seq`` changed type to ``BIGINT``"
msgstr ""

msgid ""
"The biconnected components of an undirected graph are the maximal subsets"
" of vertices such that the removal of a vertex from particular component "
"will not disconnect the component. Unlike connected components, vertices "
"may belong to multiple biconnected components. Vertices can be present in"
" multiple biconnected components, but each edge can only be contained in "
"a single biconnected component."
msgstr ""

msgid "Components are described by edges."
msgstr ""

msgid "``component`` ascending."
msgstr ""

msgid "``edge`` ascending."
msgstr ""

msgid "pgr_biconnectedComponents(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-component-E|"
msgstr ""

msgid "The biconnected components of the graph"
msgstr ""

msgid "``component``"
msgstr ""

msgid "Component identifier."
msgstr ""

msgid "Has the value of the minimum edge identifier in the component."
msgstr ""

msgid "Identifier of the edge that belongs to the ``component``."
msgstr ""

msgid "``pgr_binaryBreadthFirstSearch`` - Experimental"
msgstr ""

msgid ""
"``pgr_binaryBreadthFirstSearch``  Returns the shortest path in a binary "
"graph."
msgstr ""

#, python-brace-format
msgid ""
"Any graph whose edge-weights belongs to the set {0,X}, where 'X' is any "
"non-negative integer, is termed as a 'binary graph'."
msgstr ""

msgid "pgr_binaryBreadthFirstSearch(Combinations)"
msgstr ""

msgid ""
"It is well-known that the shortest paths between a single source and all "
"other vertices can be found using Breadth First Search in :math:`O(|E|)` "
"in an unweighted graph, i.e. the distance is the minimal number of edges "
"that you need to traverse from the source to another vertex. We can "
"interpret such a graph also as a weighted graph, where every edge has the"
" weight :math:`1`. If not all edges in graph have the same weight, then "
"we a more general algorithm is needed, like Dijkstra's Algorithm which "
"runs in :math:`O(|E|log|V|)` time."
msgstr ""

#, python-brace-format
msgid ""
"However if the weights are more constrained, we can use a faster "
"algorithm. This algorithm, termed as 'Binary Breadth First Search' as "
"well as '0-1 BFS', is a variation of the standard Breadth First Search "
"problem to solve the SSSP (single-source shortest path) problem in "
":math:`O(|E|)`, if the weights of each edge belongs to the set {0,X}, "
"where 'X' is any non-negative real integer."
msgstr ""

#, python-brace-format
msgid ""
"Process is done only on 'binary graphs'. ('Binary Graph': Any graph whose"
" edge-weights belongs to the set {0,X}, where 'X' is any non-negative "
"real integer.)"
msgstr ""

msgid "Running time: :math:`O(| start\\_vids | * |E|)`"
msgstr ""

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vid**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vid**, **end vids**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vids**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, `Combinations SQL`_, "
"[``directed``])"
msgstr ""

msgid ""
"**Note:** Using the :doc:`sampledata` Network as all weights are same "
"(i.e :math:`1``)"
msgstr ""

msgid ""
"`Boost: Breadth First Search "
"<https://www.boost.org/libs/graph/doc/breadth_first_search.html>`__"
msgstr ""

msgid "https://cp-algorithms.com/graph/01_bfs.html"
msgstr ""

#, python-format
msgid "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Specialized_variants"
msgstr ""

msgid "``pgr_bipartite`` - Experimental"
msgstr ""

msgid ""
"``pgr_bipartite``  Disjoint sets of vertices such that no two vertices "
"within the same set are adjacent."
msgstr ""

msgid ""
"A bipartite graph is a graph with two sets of vertices which are "
"connected to each other, but not within themselves. A bipartite graph is "
"possible if the graph coloring is possible using two colors such that "
"vertices in a set are colored with the same color."
msgstr ""

msgid "The algorithm works in undirected graph only."
msgstr ""

msgid "The returned values are not ordered."
msgstr ""

msgid ""
"The algorithm checks graph is bipartite or not. If it is bipartite then "
"it returns the node along with two colors `0` and `1` which represents "
"two different sets."
msgstr ""

msgid "If graph is not bipartite then algorithm returns empty set."
msgstr ""

msgid "pgr_bipartite(`Edges SQL`_)"
msgstr ""

msgid "When the graph is bipartite"
msgstr ""

msgid "Additional Example"
msgstr ""

msgid "The odd length cyclic graph can not be bipartite."
msgstr ""

#, python-brace-format
msgid ""
"The edge :math:`5 \\rightarrow 1` will make subgraph with vertices "
":math:`\\{1, 3, 7, 6, 5\\}` an odd length cyclic graph, as the cycle has "
"5 vertices."
msgstr ""

msgid "Edges in blue represent odd length cycle subgraph."
msgstr ""

msgid ""
"`Boost: is_bipartite "
"<https://www.boost.org/libs/graph/doc/is_bipartite.html>`__"
msgstr ""

msgid ""
"`Wikipedia: bipartite graph "
"<https://en.wikipedia.org/wiki/Bipartite_graph>`__"
msgstr ""

msgid "``pgr_boykovKolmogorov``"
msgstr ""

msgid ""
"``pgr_boykovKolmogorov``  Calculates the flow on the graph edges that "
"maximizes the flow from the sources to the targets using Boykov "
"Kolmogorov algorithm."
msgstr ""

msgid "pgr_boykovKolmogorov(Combinations)"
msgstr ""

msgid "Renamed from ``pgr_maxFlowBoykovKolmogorov``"
msgstr ""

msgid "Function promoted to proposed."
msgstr ""

msgid "Running time: Polynomial"
msgstr ""

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_boykovKolmogorov(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "Returns set of |result-flow|"
msgstr ""

msgid "From vertex :math:`11` to vertex :math:`12`"
msgstr ""

#, python-brace-format
msgid "From vertex :math:`11` to vertices :math:`\\{5, 10, 12\\}`"
msgstr ""

#, python-brace-format
msgid "From vertices :math:`\\{11, 3, 17\\}` to vertex :math:`12`"
msgstr ""

#, python-brace-format
msgid "From vertices :math:`\\{11, 3, 17\\}` to vertices :math:`\\{5, 10, 12\\}`"
msgstr ""

#, python-brace-format
msgid ""
"Using a combinations table, equivalent to calculating result from "
"vertices :math:`\\{5, 6\\}` to vertices :math:`\\{10, 15, 14\\}`."
msgstr ""

msgid ""
"`Boost: Boykov Kolmogorov max flow "
"<https://www.boost.org/libs/graph/doc/boykov_kolmogorov_max_flow.html>`__"
msgstr ""

msgid "``pgr_breadthFirstSearch`` - Experimental"
msgstr ""

msgid ""
"``pgr_breadthFirstSearch``  Returns the traversal order(s) using Breadth"
" First Search algorithm."
msgstr ""

msgid "Version 4.0.0:"
msgstr ""

msgid ""
"Provides the Breadth First Search traversal order from a root vertex to a"
" particular depth."
msgstr ""

msgid "The implementation will work on any type of graph."
msgstr ""

msgid ""
"Provides the Breadth First Search traversal order from a source node to a"
" target depth level."
msgstr ""

msgid "Running time: :math:`O(E + V)`"
msgstr ""

msgid "pgr_breadthFirstSearch(`Edges SQL`_, **root vid**, [**options**])"
msgstr ""

msgid "pgr_breadthFirstSearch(`Edges SQL`_, **root vids**, [**options**])"
msgstr ""

msgid "**options:** ``[max_depth, directed]``"
msgstr ""

msgid ""
"From root vertex :math:`6` on a **directed** graph with edges in "
"ascending order of ``id``"
msgstr ""

#, python-brace-format
msgid ""
"From root vertices :math:`\\{12, 6\\}` on an **undirected** graph with "
"**depth** :math:`<= 2` and edges in ascending order of ``id``"
msgstr ""

msgid "DFS optional parameters"
msgstr ""

msgid "Same as `Single vertex`_ with edges in ascending order of ``id``."
msgstr ""

msgid "Same as `Single vertex`_ with edges in descending order of ``id``."
msgstr ""

msgid "The resulting traversal is different."
msgstr ""

msgid ""
"The left image shows the result with ascending order of ids and the right"
" image shows with descending order of the edge identifiers."
msgstr ""

msgid "|ascending| |descending|"
msgstr ""

msgid "ascending"
msgstr ""

msgid "descending"
msgstr ""

msgid ""
"`Wikipedia: Breadth First Search algorithm <https://en.wikipedia.org/wiki"
"/Breadth-first_search>`__"
msgstr ""

msgid "``pgr_bridges``"
msgstr ""

msgid "``pgr_bridges`` - Return the bridges of an undirected graph."
msgstr ""

msgid ""
"A bridge is an edge of an undirected graph whose deletion increases its "
"number of connected components. This implementation can only be used with"
" an undirected graph."
msgstr ""

msgid "``edge`` ascending"
msgstr ""

msgid "Running time: :math:`O(E * (V + E))`"
msgstr ""

msgid "pgr_bridges(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-edge|"
msgstr ""

msgid "The bridges of the graph"
msgstr ""

msgid "Identifier of the edge that is a bridge."
msgstr ""

#, python-format
msgid "https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29"
msgstr ""

msgid ""
"`Boost: Connected components "
"<https://www.boost.org/libs/graph/doc/connected_components.html>`__"
msgstr ""

msgid "``pgr_chinesePostman`` - Experimental"
msgstr ""

msgid ""
"``pgr_chinesePostman``  Calculates the shortest circuit path which "
"contains every edge in a directed graph and starts and ends on the same "
"vertex."
msgstr ""

msgid "Returns ``EMPTY SET`` on a disconnected graph"
msgstr ""

msgid "pgr_chinesePostman(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-1-1-no-seq|"
msgstr ""

msgid "Returns set of ``(seq, node, edge, cost, agg_cost)``"
msgstr ""

msgid "Sequential value starting from ``1``"
msgstr ""

msgid ""
"Identifier of the edge used to go from ``node`` to the next node in the "
"path sequence. ``-1`` for the last node of the path."
msgstr ""

msgid "Aggregate cost from ``start_v`` to ``node``."
msgstr ""

msgid "``pgr_chinesePostmanCost`` - Experimental"
msgstr ""

msgid ""
"``pgr_chinesePostmanCost``  Calculates the minimum costs of a circuit "
"path which contains every edge in a directed graph and starts and ends on"
" the same vertex."
msgstr ""

msgid "Return value when the graph if disconnected"
msgstr ""

msgid "pgr_chinesePostmanCost(`Edges SQL`_)"
msgstr ""

msgid "RETURNS ``FLOAT``"
msgstr ""

msgid "``pgr_chinesepostmancost``"
msgstr ""

msgid "Minimum costs of a circuit path."
msgstr ""

msgid "``pgr_connectedComponents``"
msgstr ""

msgid ""
"``pgr_connectedComponents``  Connected components of an undirected graph"
" using a DFS-based approach."
msgstr ""

msgid ""
"A connected component of an undirected graph is a set of vertices that "
"are all reachable from each other."
msgstr ""

msgid "Components are described by vertices"
msgstr ""

msgid "``component`` ascending"
msgstr ""

msgid "pgr_connectedComponents(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-component-V|"
msgstr ""

msgid "The connected components of the graph"
msgstr ""

msgid "Has the value of the minimum node identifier in the component."
msgstr ""

msgid "Identifier of the vertex that belongs to the ``component``."
msgstr ""

msgid "Connecting disconnected components"
msgstr ""

msgid ""
"wikipedia: `Connected component "
"<https://en.wikipedia.org/wiki/Connected_component_(graph_theory)>`__"
msgstr ""

msgid "``pgr_contraction``"
msgstr ""

msgid ""
"``pgr_contraction``  Performs graph contraction and returns the "
"contracted vertices and edges."
msgstr ""

msgid "Version 3.8.0"
msgstr ""

msgid "New signature:"
msgstr ""

msgid ""
"Previously compulsory parameter **Contraction order** is now optional "
"with name ``methods``."
msgstr ""

msgid "New name and order of optional parameters."
msgstr ""

msgid ""
"Deprecated signature "
"pgr_contraction(text,bigint[],integer,bigint[],boolean)"
msgstr ""

msgid "Name change from ``pgr_contractGraph``"
msgstr ""

msgid "Bug fixes"
msgstr ""

msgid ""
"Contraction reduces the size of the graph by removing some of the "
"vertices and edges and, for example, might add edges that represent a "
"sequence of original edges decreasing the total time and space used in "
"graph algorithms."
msgstr ""

msgid "Does not return the full contracted graph."
msgstr ""

msgid "Only changes on the graph are returned."
msgstr ""

msgid "The returned values include:"
msgstr ""

msgid "The new edges generated by linear contraction."
msgstr ""

msgid "The modified vertices generated by dead end contraction."
msgstr ""

msgid "The returned values are ordered as follows:"
msgstr ""

msgid "column ``id`` ascending when its a modified vertex."
msgstr ""

msgid "column ``id`` with negative numbers descending when its a new edge."
msgstr ""

msgid ""
"Currently there are two types of contraction methods included in this "
"function:"
msgstr ""

msgid "Dead End Contraction. See :doc:`pgr_contractionDeadEnd`."
msgstr ""

msgid "Linear Contraction. See :doc:`pgr_contractionLinear`."
msgstr ""

msgid "pgr_contraction(`Edges SQL`_, [**options**])"
msgstr ""

msgid "**options:** ``[directed, methods, cycles, forbidden]``"
msgstr ""

msgid "Returns set of |result-contract|"
msgstr ""

msgid "Dead end and linear contraction in that order on an undirected graph."
msgstr ""

msgid "Contraction optional parameters"
msgstr ""

msgid "``methods``"
msgstr ""

msgid "``INTEGER[]``"
msgstr ""

msgid "``ARRAY[1,2]``"
msgstr ""

msgid "Ordered contraction operations."
msgstr ""

msgid "1 = Dead end contraction"
msgstr ""

msgid "2 = Linear contraction"
msgstr ""

msgid "``cycles``"
msgstr ""

msgid ":math:`1`"
msgstr ""

msgid "Number of times the contraction methods will be performed."
msgstr ""

msgid "``forbidden``"
msgstr ""

msgid "``BIGINT[]``"
msgstr ""

msgid "``ARRAY[]::BIGINT[]``"
msgstr ""

msgid "Identifiers of vertices forbidden for contraction."
msgstr ""

msgid "The function returns a single row. The columns of the row are:"
msgstr ""

msgid "``type``"
msgstr ""

msgid "Type of the row."
msgstr ""

msgid "``v`` when the row is a vertex."
msgstr ""

msgid "Column ``id`` has a positive value."
msgstr ""

msgid "``e`` when the row is an edge."
msgstr ""

msgid "Column ``id`` has a negative value."
msgstr ""

msgid "All numbers on this column are ``DISTINCT``"
msgstr ""

msgid "When ``type`` = **'v'**."
msgstr ""

msgid "Identifier of the modified vertex."
msgstr ""

msgid "When ``type`` = **'e'**."
msgstr ""

msgid "Decreasing sequence starting from **-1**."
msgstr ""

msgid ""
"Representing a pseudo `id` as is not incorporated in the set of original "
"edges."
msgstr ""

msgid "``contracted_vertices``"
msgstr ""

msgid "Array of contracted vertex identifiers."
msgstr ""

msgid "When ``type`` = **'v'**: :math:`-1`"
msgstr ""

msgid ""
"When ``type`` = **'e'**: Identifier of the source vertex of the current "
"edge (``source``, ``target``)."
msgstr ""

msgid ""
"When ``type`` = **'e'**: Identifier of the target vertex of the current "
"edge (``source``, ``target``)."
msgstr ""

msgid ""
"When ``type`` = **'e'**: Weight of the current edge (``source``, "
"``target``)."
msgstr ""

msgid "Only dead end contraction"
msgstr ""

msgid "Only linear contraction"
msgstr ""

msgid "The cycle"
msgstr ""

msgid ""
"Contracting a graph can be done with more than one operation. The order "
"of the operations affect the resulting contracted graph, after applying "
"one operation, the set of vertices that can be contracted by another "
"operation changes."
msgstr ""

msgid "This implementation cycles ``cycles`` times through the ``methods`` ."
msgstr ""

msgid "Contracting sample data"
msgstr ""

msgid ""
"In this section, building and using a contracted graph will be shown by "
"example."
msgstr ""

msgid "The :doc:`sampledata` for an undirected graph is used"
msgstr ""

msgid "a dead end operation first followed by a linear operation."
msgstr ""

msgid "Construction of the graph in the database"
msgstr ""

msgid "The original graph:"
msgstr ""

msgid ""
"The results do not represent the contracted graph. They represent the "
"changes that need to be done to the graph after applying the contraction "
"methods."
msgstr ""

msgid ""
"Observe that vertices, for example, :math:`6` do not appear in the "
"results because it was not affected by the contraction algorithm."
msgstr ""

msgid "After doing the dead end contraction operation:"
msgstr ""

msgid "After doing the linear contraction operation to the graph above:"
msgstr ""

msgid "The process to create the contraction graph on the database:"
msgstr ""

msgid "Add additional columns"
msgstr ""

msgid ""
"Adding extra columns to the edges and vertices tables. In this "
"documentation the following will be used:"
msgstr ""

msgid "Column."
msgstr ""

msgid "The vertices set belonging to the vertex/edge"
msgstr ""

msgid "``is_contracted``"
msgstr ""

msgid "On the vertex table"
msgstr ""

msgid ""
"when ``true`` the vertex is contracted, its not part of the contracted "
"graph."
msgstr ""

msgid ""
"when ``false`` the vertex is not contracted, its part of the contracted "
"graph."
msgstr ""

msgid "``is_new``"
msgstr ""

msgid "On the edge table"
msgstr ""

msgid ""
"when ``true`` the edge was generated by the contraction algorithm. its "
"part of the contracted graph."
msgstr ""

msgid ""
"when ``false`` the edge is an original edge, might be or not part of the "
"contracted graph."
msgstr ""

msgid "Store contraction information"
msgstr ""

msgid "Store the contraction results in a table."
msgstr ""

msgid "Update the edges and vertices tables"
msgstr ""

msgid "Use ``is_contracted`` column to indicate the vertices that are contracted."
msgstr ""

msgid ""
"Fill ``contracted_vertices`` with the information from the results that "
"belong to the vertices."
msgstr ""

msgid "Insert the new edges generated by pgr_contraction."
msgstr ""

msgid "The contracted graph"
msgstr ""

msgid "Vertices that belong to the contracted graph."
msgstr ""

msgid "Edges that belong to the contracted graph."
msgstr ""

msgid "Visually:"
msgstr ""

msgid "Using the contracted graph"
msgstr ""

msgid ""
"Depending on the final application the graph is to be prepared. In this "
"example the final application will be to calculate the cost from two "
"vertices in the original graph by using the contracted graph with "
"``pgr_dijkstraCost``"
msgstr ""

msgid ""
"There are three cases when calculating the shortest path between a given "
"source and target in a contracted graph:"
msgstr ""

msgid "Case 1: Both source and target belong to the contracted graph."
msgstr ""

msgid "Case 2: Source and/or target belong to an edge subgraph."
msgstr ""

msgid "Case 3: Source and/or target belong to a vertex."
msgstr ""

msgid "The final application should consider all of those cases."
msgstr ""

msgid "Create a view (or table) of the contracted graph:"
msgstr ""

msgid "Create the function that will use the contracted graph."
msgstr ""

msgid ""
"Case 2: Source and/or target belong to an edge that has contracted "
"vertices."
msgstr ""

msgid "Case 3: Source and/or target belong to a vertex that has been contracted."
msgstr ""

msgid "``pgr_contractionDeadEnd`` - Proposed"
msgstr ""

msgid ""
"``pgr_contractionDeadEnd``  Performs graph contraction and returns the "
"contracted vertices and edges."
msgstr ""

msgid "A node is considered a dead end node when:"
msgstr ""

msgid "On undirected graphs:"
msgstr ""

msgid "The number of adjacent vertices is 1."
msgstr ""

msgid "On directed graphs:"
msgstr ""

msgid "When there is only one adjacent vertex or"
msgstr ""

msgid "When all edges are incoming regardless of the number of adjacent vertices."
msgstr ""

msgid "pgr_contractionDeadEnd(`Edges SQL`_, [**options**])"
msgstr ""

msgid "**options:** ``[directed, forbidden]``"
msgstr ""

msgid "Dead end contraction on an undirected graph."
msgstr ""

msgid "The green nodes are dead end nodes."
msgstr ""

msgid "Node :math:`3` is a dead end node after node :math:`1` is contracted."
msgstr ""

msgid "``ARRAY[`` |ANY-INTEGER| ``]``"
msgstr ""

msgid "**Empty**"
msgstr ""

msgid "Value = ``e`` indicating the row is an edge."
msgstr ""

msgid "A pseudo `id` of the edge."
msgstr ""

msgid "Identifier of the source vertex of the current edge."
msgstr ""

msgid "Identifier of the target vertex of the current edge."
msgstr ""

msgid "Weight of the current edge."
msgstr ""

msgid "Dead end vertex on undirected graph"
msgstr ""

msgid "They have only one adjacent node."
msgstr ""

msgid "Dead end vertex on directed graph"
msgstr ""

msgid "The green nodes are dead end nodes"
msgstr ""

msgid "The blue nodes have an unlimited number of incoming and/or outgoing edges."
msgstr ""

msgid "Node"
msgstr ""

msgid "Adjacent nodes"
msgstr ""

msgid "Dead end"
msgstr ""

msgid "Reason"
msgstr ""

msgid ":math:`6`"
msgstr ""

#, python-brace-format
msgid ":math:`\\{1\\}`"
msgstr ""

msgid "Yes"
msgstr ""

msgid "Has only one adjacent node."
msgstr ""

msgid ":math:`7`"
msgstr ""

#, python-brace-format
msgid ":math:`\\{2\\}`"
msgstr ""

msgid ":math:`8`"
msgstr ""

#, python-brace-format
msgid ":math:`\\{2, 3\\}`"
msgstr ""

msgid "Has more than one adjacent node and all edges are incoming."
msgstr ""

#, python-brace-format
msgid ":math:`\\{4\\}`"
msgstr ""

msgid ":math:`10`"
msgstr ""

#, python-brace-format
msgid ":math:`\\{4, 5\\}`"
msgstr ""

msgid "No"
msgstr ""

msgid "Has more than one adjacent node and all edges are outgoing."
msgstr ""

msgid ":math:`1,2,3,4,5`"
msgstr ""

msgid "Many adjacent nodes."
msgstr ""

msgid ""
"Has more than one adjacent node and some edges are incoming and some are "
"outgoing."
msgstr ""

#, python-brace-format
msgid ""
"From above, nodes :math:`\\{6, 7, 9\\}` are dead ends because the total "
"number of adjacent vertices is one."
msgstr ""

msgid ""
"When there are more than one adjacent vertex, all edges need to be all "
"incoming edges otherwise it is not a dead end."
msgstr ""

msgid "Step by step dead end contraction"
msgstr ""

msgid ""
"The dead end contraction will stop until there are no more dead end "
"nodes. For example, from the following graph where :math:`3` is the dead "
"end node:"
msgstr ""

msgid ""
"After contracting :math:`3`, node :math:`2` is now a dead end node and is"
" contracted:"
msgstr ""

msgid ""
"After contracting :math:`2`, stop. Node :math:`1` has the information of "
"nodes that were contracted."
msgstr ""

msgid "Creating the contracted graph"
msgstr ""

msgid "Steps for the creation of the contracted graph"
msgstr ""

msgid "Add additional columns."
msgstr ""

msgid "Save results into a table."
msgstr ""

msgid "The contracted vertices are not part of the contracted graph."
msgstr ""

msgid "Using when departure and destination are in the contracted graph"
msgstr ""

msgid "Using when departure/destination is not in the contracted graph"
msgstr ""

msgid "Using when departure and destination are not in the contracted graph"
msgstr ""

msgid "``pgr_contractionHierarchies`` - Experimental"
msgstr ""

msgid ""
"``pgr_contractionHierarchies``  Performs graph contraction according to "
"the contraction hierarchies method and returns the contracted vertices "
"and shortcut edges created."
msgstr ""

msgid ""
"The contraction hierarchies method builds, from an initial order of the "
"vertices, a hierarchical order, giving priority to some vertices during "
"the processing of label fixing of shortest paths algorithms. Furthermore,"
" the contraction hierarchies algorithm adds shortcut edges in the graph, "
"that helps the shortest paths algorithm to follow the created "
"hierarchical graph structure."
msgstr ""

msgid ""
"The idea of the hierarchy is to put at a high priority level vertices "
"that belong to the long distance network (highways for example in a road "
"network) and to a low level of priority nodes that belong to the short "
"distance network (arterials or secondary roads for example in road "
"networks)."
msgstr ""

msgid ""
"The contraction hierarchies algorithm makes the assumption that there is "
"already a valuable vertices order that is used to initialize the "
"contraction process. As in most cases there is no valuable initial node "
"ordering, we use the order given by vertices ID. Then, the contraction "
"process is made on the basis of this first order to give the final "
"hierarchy."
msgstr ""

msgid ""
"The basic idea is to keep the vertices in a priority queue sorted by some"
" estimate of how attractive is their contraction. The implemented case "
"uses the metric called *edge difference*, which corresponds to the "
"difference between the number of shortcuts produced by a vertex "
"contraction and the number of incident edges in the graph before "
"contraction (``#shortcuts - #incident edges``)."
msgstr ""

msgid ""
"Finally, the aim is to reduce the explored part of the graph, when using "
"a bidirectional Dijkstra-like algorithm. The vertices order is used to "
"feed the oriented search. The search is made without losing optimality."
msgstr ""

msgid ""
"Finding an optimal vertices ordering for contraction is a difficult "
"problem. Nevertheless, very simple local heuristics work quite well, "
"according to Geisberger et al. [2]. The principle here is to a priori "
"estimate the value of the *edge difference* and to contract the node at "
"the top of the queue only if the new value of the metric keeps it at the "
"top of the queue. Otherwise, it is reinserted in the queue, at its right "
"place corresponding to the new metric value."
msgstr ""

msgid "The process is done on graphs having only edges with positive costs."
msgstr ""

msgid ""
"It is necessary to remember that there are no deleted vertices with this "
"function. At the end, the graph keeps every vertex it had, but has some "
"added edges, corresponding to shortcuts. The vertices which have been "
"contracted, to build the shortcut edges, are kept and hierarchically "
"ordered."
msgstr ""

msgid ""
"As for the other contraction methods, it does not return the full "
"contracted graph, only the changes. They are here of two types:"
msgstr ""

msgid "added shortcut edges, with negative identifiers;"
msgstr ""

msgid "contracted nodes with an order."
msgstr ""

msgid "The ``pgr_contractionHierarchies`` function has the following signature:"
msgstr ""

msgid "pgr_contractionHierarchies(`Edges SQL`_, [**options**])"
msgstr ""

msgid "Returns set of |result-contraction-hierarchies|"
msgstr ""

msgid "Contraction hierarchies optional parameters"
msgstr ""

msgid "True if the graph is directed, False otherwise."
msgstr ""

msgid ""
"The function returns many rows (one per vertex and one per shortcut edge "
"created). The columns of the rows are:"
msgstr ""

msgid "Type of the ``id``."
msgstr ""

msgid "Column ``id`` has a positive value"
msgstr ""

msgid "Column ``id`` has a negative value"
msgstr ""

msgid "``metric``"
msgstr ""

msgid "``vertex_order``"
msgstr ""

msgid "On an undirected graph"
msgstr ""

msgid ""
"The following query shows the original data involved in the contraction "
"operation on an undirected graph."
msgstr ""

msgid "building contraction hierarchies on the whole graph"
msgstr ""

msgid ""
"The results do not represent the contracted graph. They represent the "
"changes done to the graph after applying the contraction algorithm and "
"give the vertex order built by the algorithm, by ordering vertices "
"according to the *edge difference* metric. As a consequence, vertices are"
" all represented in the result (except of course forbidden ones). Only "
"shortcut built by the algorithm are represented in the result."
msgstr ""

msgid ""
"After computing the contraction hierarchies, an order is now given to the"
" vertices,"
msgstr ""

msgid ""
"in order to be used with a specific Dijkstra algorithm (implementation "
"coming in a future version), which speeds up the search."
msgstr ""

msgid "We obtain the contracted graph above:"
msgstr ""

msgid ""
"We can see without surprise that the vertices belonging to the shortcuts "
"have a tendency to have a high priority level in the resulting vertices "
"order."
msgstr ""

msgid "On an undirected graph with forbidden vertices"
msgstr ""

msgid "building contraction with a set of forbidden vertices"
msgstr ""

msgid "Contraction process steps details"
msgstr ""

msgid "Shortcut building process"
msgstr ""

msgid ""
"A vertex ``v`` is contracted by adding shortcuts replacing former paths "
"of the form ``(u, v, w)`` by an edge ``(u, w)``. The shortcut ``(u, w)`` "
"is only needed when ``(u, v, w)`` is the only shortest path between ``u``"
" and ``w``."
msgstr ""

msgid ""
"When all shortcuts have been added for a given vertex ``v``, the incident"
" edges of ``v`` are removed and another vertex is contracted with the "
"remaining graph."
msgstr ""

msgid ""
"The procedure is destructive for the graph and a copy is made to be able "
"to manipulate it again as a whole. The contraction process adds all "
"discovered shortcuts to the edge set ``E`` and attributes a metric to "
"each contracted vertex. This metric is giving what is called the "
"*contraction hierarchy*."
msgstr ""

msgid "Initialize the queue with a first vertices order"
msgstr ""

msgid "For each vertex ``v`` of the graph, a contraction of ``v`` is built:"
msgstr ""

msgid ":math:`v`"
msgstr ""

#, python-brace-format
msgid ":math:`\\{p, r, u\\}`"
msgstr ""

msgid ":math:`p`"
msgstr ""

#, python-brace-format
msgid ":math:`\\{u, v\\}`"
msgstr ""

msgid ":math:`u`"
msgstr ""

#, python-brace-format
msgid ":math:`\\{p, v, w\\}`"
msgstr ""

msgid ":math:`r`"
msgstr ""

#, python-brace-format
msgid ":math:`\\{v, w\\}`"
msgstr ""

msgid ":math:`w`"
msgstr ""

#, python-brace-format
msgid ":math:`\\{r, u\\}`"
msgstr ""

msgid "Adjacent edges are removed."
msgstr ""

msgid ""
"Shortcuts are built from predecessors of ``v`` to successors of ``v`` if "
"and only if the path through ``v`` corresponds to the only shortest path "
"between the predecessor and the successor of ``v`` in the graph. The "
"*edge difference* metric here takes the value of -2."
msgstr ""

msgid ""
"Then the following vertex is contracted. The process goes on until each "
"node of the graph has been contracted. At the end, there are no more "
"edges in the graph, which has been destroyed by the process."
msgstr ""

msgid ""
"This first contraction will give a vertices order, given by ordering them"
" in ascending order on the metric (edge difference). A total vertices "
"order is built. If ``u < v``, then ``u`` is less important than ``v``. "
"The algorithm keeps the vertices into a queue in this order."
msgstr ""

msgid ""
"A hierarchy will now be constructed by contracting again the vertices in "
"this order."
msgstr ""

msgid "Build the final vertex order"
msgstr ""

msgid ""
"Once the first order built, the algorithm uses it to browse the graph "
"once again. For each vertex taken in the queue, the algorithm simulates "
"contraction and calculates its edge difference. If the computed value is "
"greater than the one of the next vertex to be contracted, then the "
"algorithm puts it back in the queue (heuristic approach). Otherwise it "
"contracts it permanently."
msgstr ""

msgid "Add shortcuts to the initial graph"
msgstr ""

msgid ""
"At the end, the algorithm takes the initial graph (before edges "
"deletions) and adds the shortcut edges to it. It gives you the contracted"
" graph, ready to use with a specialized Dijkstra algorithm, which takes "
"into account the order of the nodes in the hierarchy."
msgstr ""

msgid "Use the contraction"
msgstr ""

msgid "Build the contraction"
msgstr ""

msgid "Add shortcuts and hierarchy in the existing tables"
msgstr ""

msgid "Add new columns in the `vertices` and `edges` tables to store the results:"
msgstr ""

msgid "Update and insert the results in the two tables."
msgstr ""

msgid "Use a Dijkstra shortest path algorithm on it"
msgstr ""

msgid ""
"Then you can use any Dijkstra-like algorithm, waiting for the adapted one"
" which will take into account the built vertices hierarchy. For example:"
msgstr ""

msgid "``pgr_contractionLinear`` - Proposed"
msgstr ""

msgid ""
"``pgr_contractionLinear``  Performs graph contraction and returns the "
"contracted vertices and edges."
msgstr ""

msgid "pgr_contractionLinear(`Edges SQL`_, [**options**])"
msgstr ""

msgid "Linear contraction on an undirected graph."
msgstr ""

msgid ""
"The green nodes are linear nodes and will not be part of the contracted "
"graph."
msgstr ""

msgid "All edges adjacent will not be part of the contracted graph."
msgstr ""

msgid "The red lines will be new edges of the contracted graph."
msgstr ""

msgid "**contraction Order**"
msgstr ""

msgid ""
"Number of times the contraction operations on ``contraction_order`` will "
"be performed."
msgstr ""

msgid "A node connects two (or more) `linear` edges when"
msgstr ""

msgid "The number of adjacent vertices is 2."
msgstr ""

msgid "In case of a directed graph, a node is considered a `linear` node when"
msgstr ""

msgid "Linearity is symmetrical."
msgstr ""

msgid "Linearity is not symmetrical"
msgstr ""

msgid "Graph where linearity is not symmetrical."
msgstr ""

msgid ""
"When the graph is processed as a directed graph, linearity is not "
"symmetrical, therefore the graph can not be contracted."
msgstr ""

msgid ""
"When the same graph is processed as an undirected graph, linearity is "
"symmetrical, therefore the graph can be contracted."
msgstr ""

msgid "The three edges can be replaced by one undirected edge"
msgstr ""

msgid "Edge :math:`1 - 3`."
msgstr ""

msgid "With cost: :math:`4`."
msgstr ""

#, python-brace-format
msgid "Contracted vertices in the edge: :math:`\\{2\\}`."
msgstr ""

msgid "Linearity is symmetrical"
msgstr ""

msgid "Graph where linearity is symmetrical."
msgstr ""

msgid "The four edges can be replaced by two directed edges."
msgstr ""

msgid "Edge :math:`3 - 1`."
msgstr ""

msgid "With cost: :math:`6`."
msgstr ""

msgid "The four edges can be replaced by one undirected edge."
msgstr ""

msgid "Step by step linear contraction"
msgstr ""

msgid ""
"The linear contraction will stop when there are no more linear edges. For"
" example from the following graph there are linear edges"
msgstr ""

msgid "Contracting vertex :math:`3`,"
msgstr ""

msgid "The vertex :math:`3` is removed from the graph"
msgstr ""

msgid ""
"The edges :math:`2 \\rightarrow 3` and :math:`w \\rightarrow z` are "
"removed from the graph."
msgstr ""

msgid ""
"A new edge :math:`2 \\rightarrow 4` is inserted represented with red "
"color."
msgstr ""

msgid "Contracting vertex :math:`2`:"
msgstr ""

msgid "The vertex :math:`2` is removed from the graph"
msgstr ""

msgid ""
"The edges :math:`1 \\rightarrow 2` and :math:`2 \\rightarrow 3` are "
"removed from the graph."
msgstr ""

msgid ""
"A new edge :math:`1 \\rightarrow 3` is inserted represented with red "
"color."
msgstr ""

msgid ""
"Edge :math:`1 \\rightarrow 3` has the information of cost and the nodes "
"that were contracted."
msgstr ""

msgid "Create the contracted graph."
msgstr ""

msgid "``pgr_cuthillMckeeOrdering`` - Experimental"
msgstr ""

msgid ""
"``pgr_cuthillMckeeOrdering``  Returns the reverse Cuthill-Mckee ordering"
" of an undirected graphs"
msgstr ""

msgid "Version 3.4.0"
msgstr ""

msgid ""
"In numerical linear algebra, the Cuthill-McKee algorithm (CM), named "
"after Elizabeth Cuthill and James McKee, is an algorithm to permute a "
"sparse matrix that has a symmetric sparsity pattern into a band matrix "
"form with a small bandwidth."
msgstr ""

msgid ""
"The vertices are basically assigned a breadth-first search order, except "
"that at each step, the adjacent vertices are placed in the queue in order"
" of increasing degree."
msgstr ""

msgid "The implementation is for **undirected** graphs."
msgstr ""

msgid "The bandwidth minimization problems are considered NP-complete problems."
msgstr ""

msgid "The running time complexity is: :math:`O(m log(m)|V|)`"
msgstr ""

msgid "where :math:`|V|` is the number of vertices,"
msgstr ""

msgid ":math:`m` is the maximum degree of the vertices in the graph."
msgstr ""

msgid "pgr_cuthillMckeeOrdering(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result_node_order|"
msgstr ""

msgid "Graph ordering of pgRouting :doc:`sampledata`"
msgstr ""

msgid "Returns set of ``(seq, node)``"
msgstr ""

msgid "Sequence of the order starting from 1."
msgstr ""

msgid "New ordering in reverse order."
msgstr ""

msgid ""
"`Boost: Cuthill-McKee Ordering "
"<https://www.boost.org/libs/graph/doc/cuthill_mckee_ordering.html>`__"
msgstr ""

#, python-format
msgid ""
"`Wikipedia: Cuthill-McKee Ordering "
"<https://en.wikipedia.org/wiki/Cuthill%E2%80%93McKee_algorithm>`__"
msgstr ""

msgid "``pgr_dagShortestPath`` - Experimental"
msgstr ""

msgid ""
"``pgr_dagShortestPath``  Returns the shortest path for weighted directed"
" acyclic graphs(DAG). In particular, the DAG shortest paths algorithm "
"implemented by Boost.Graph."
msgstr ""

msgid "pgr_dagShortestPath(Combinations)"
msgstr ""

msgid ""
"Shortest Path for Directed Acyclic Graph(DAG) is a graph search algorithm"
" that solves the shortest path problem for weighted directed acyclic "
"graph, producing a shortest path from a starting vertex (``start_vid``) "
"to an ending vertex (``end_vid``)."
msgstr ""

msgid ""
"This implementation can only be used with a **directed** graph with no "
"cycles i.e. directed acyclic graph."
msgstr ""

msgid ""
"The algorithm relies on topological sorting the dag to impose a linear "
"ordering on the vertices, and thus is more efficient for DAG's than "
"either the Dijkstra or Bellman-Ford algorithm."
msgstr ""

msgid ""
"Process is valid for weighted directed acyclic graphs only. otherwise it "
"will throw warnings."
msgstr ""

msgid "The `agg_cost` the non included values `(v, v)` is `0`"
msgstr ""

msgid "The `agg_cost` the non included values `(u, v)` is :math:`\\infty`"
msgstr ""

msgid "Running time: :math:`O(| start\\_vids | * (V + E))`"
msgstr ""

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_dagShortestPath(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "From vertex :math:`5` to vertex :math:`11` on a **directed** graph"
msgstr ""

#, python-brace-format
msgid "From vertex :math:`5` to vertices :math:`\\{7, 11\\}`"
msgstr ""

#, python-brace-format
msgid "From vertices :math:`\\{5, 10\\}` to vertex :math:`11`"
msgstr ""

#, python-brace-format
msgid ""
"From vertices :math:`\\{5, 15\\}` to vertices :math:`\\{11, 17\\}` on an "
"**undirected** graph"
msgstr ""

msgid "Return columns"
msgstr ""

msgid "Making **start_vids** the same as **end_vids**"
msgstr ""

msgid ""
"`Boost: DAG shortest paths "
"<https://www.boost.org/libs/graph/doc/dag_shortest_paths.html>`__"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Topological_sorting"
msgstr ""

msgid "``pgr_degree``"
msgstr ""

msgid ""
"``pgr_degree``  For each vertex in an undirected graph, return the count"
" of edges incident to the vertex."
msgstr ""

msgid "Error messages adjustment."
msgstr ""

msgid "New signature with only Edges SQL."
msgstr ""

msgid "Calculates the degree of the vertices of an undirected graph"
msgstr ""

msgid ""
"The degree (or valency) of a vertex of a graph is the number of edges "
"that are incident to the vertex."
msgstr ""

msgid "A loop contributes 2 to a vertex's degree."
msgstr ""

msgid "A vertex with degree 0 is called an isolated vertex."
msgstr ""

msgid "Isolated vertex is not part of the result"
msgstr ""

msgid ""
"Vertex not participating on the subgraph is considered and isolated "
"vertex."
msgstr ""

msgid ""
"There can be a ``dryrun`` execution and the code used to get the answer "
"will be shown in a PostgreSQL ``NOTICE``."
msgstr ""

msgid ""
"The code can be used as base code for the particular application "
"requirements."
msgstr ""

msgid "No ordering is performed."
msgstr ""

msgid "pgr_degree(`Edges SQL`_ , [``dryrun``])"
msgstr ""

msgid "pgr_degree(`Edges SQL`_ , `Vertex SQL`_, [``dryrun``])"
msgstr ""

msgid "RETURNS SETOF |result-degree|"
msgstr ""

msgid "Edges"
msgstr ""

msgid "example"
msgstr ""

msgid "Get the degree of the vertices defined on the edges table"
msgstr ""

msgid "Edges and Vertices"
msgstr ""

msgid "Extracting the vertex information"
msgstr ""

msgid "``pgr_degree`` can use :doc:`pgr_extractVertices` embedded in the call."
msgstr ""

msgid ""
"For decent size networks, it is best to prepare your vertices table "
"before hand and use it on ``pgr_degree`` calls. (See `Using a vertex "
"table`_)"
msgstr ""

msgid "Calculate the degree of the nodes:"
msgstr ""

msgid "`Vertex SQL`_"
msgstr ""

msgid "`Vertex SQL`_ as described below"
msgstr ""

msgid "``dryrun``"
msgstr ""

msgid "When true do not process and get in a NOTICE the resulting query."
msgstr ""

msgid "For the `Edges and Vertices`_ signature:"
msgstr ""

msgid "For the `Edges`_ signature:"
msgstr ""

msgid "Vertex SQL"
msgstr ""

msgid "``in_edges``"
msgstr ""

msgid ""
"Array of identifiers of the edges that have the vertex ``id`` as *first "
"end point*."
msgstr ""

msgid "When missing, ``out_edges`` must exist."
msgstr ""

msgid "``out_edges``"
msgstr ""

msgid ""
"Array of identifiers of the edges that have the vertex ``id`` as *second "
"end point*."
msgstr ""

msgid "When missing, ``in_edges`` must exist."
msgstr ""

msgid "Vertex identifier"
msgstr ""

msgid "``degree``"
msgstr ""

msgid "Number of edges that are incident to the vertex ``id``"
msgstr ""

msgid "Degree of a loop"
msgstr ""

msgid "Using the `Edges`_ signature."
msgstr ""

msgid "Using the `Edges and Vertices`_ signature."
msgstr ""

msgid "Degree of a sub graph"
msgstr ""

msgid "For the following is a subgraph of the :doc:`sampledata`:"
msgstr ""

#, python-brace-format
msgid ":math:`E = \\{(1, 5 \\leftrightarrow 6), (1, 6 \\leftrightarrow 10)\\}`"
msgstr ""

#, python-brace-format
msgid ":math:`V = \\{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17\\}`"
msgstr ""

msgid "The vertices not participating on the edge are considered isolated"
msgstr ""

msgid "their degree is 0 in the subgraph and"
msgstr ""

msgid "their degree is not shown in the output."
msgstr ""

msgid "Using a vertex table"
msgstr ""

msgid ""
"For decent size networks, it is best to prepare your vertices table "
"before hand and use it on ``pgr_degree`` calls."
msgstr ""

msgid "Extract the vertex information and save into a table:"
msgstr ""

msgid "Dry run execution"
msgstr ""

msgid ""
"To get the query generated used to get the vertex information, use "
"``dryrun => true``."
msgstr ""

msgid ""
"The results can be used as base code to make a refinement based on the "
"backend development needs."
msgstr ""

msgid "Finding dead ends"
msgstr ""

msgid ""
"If there is a vertices table already built using ``pgr_extractVertices`` "
"and want the degree of the whole graph rather than a subset, it can be "
"forgo using ``pgr_degree`` and work with the ``in_edges`` and "
"``out_edges`` columns directly."
msgstr ""

msgid "The degree of a dead end is 1."
msgstr ""

msgid "Finding linear vertices"
msgstr ""

msgid "The degree of a linear vertex is 2."
msgstr ""

msgid ""
"If there is a vertices table already built using the "
"``pgr_extractVertices``"
msgstr ""

msgid ":doc:`pgr_extractVertices`"
msgstr ""

msgid "``pgr_depthFirstSearch`` - Proposed"
msgstr ""

msgid ""
"``pgr_depthFirstSearch``  Returns a depth first search traversal of the "
"graph. The graph can be directed or undirected."
msgstr ""

msgid "Version 3.3.0"
msgstr ""

msgid ""
"Depth First Search algorithm is a traversal algorithm which starts from a"
" root vertex, goes as deep as possible, and backtracks once a vertex is "
"reached with no adjacent vertices or with all visited adjacent vertices. "
"The traversal continues until all the vertices reachable from the root "
"vertex are visited."
msgstr ""

msgid "The implementation works for both **directed** and **undirected** graphs."
msgstr ""

msgid ""
"Provides the Depth First Search traversal order from a root vertex or "
"from a set of root vertices."
msgstr ""

msgid ""
"An optional non-negative maximum depth parameter to limit the results up "
"to a particular depth."
msgstr ""

msgid ""
"For optimization purposes, any duplicated values in the `Root vids` are "
"ignored."
msgstr ""

msgid ""
"It does not produce the shortest path from a root vertex to a target "
"vertex."
msgstr ""

msgid "The aggregate cost of traversal is not guaranteed to be minimal."
msgstr ""

msgid "The returned values are ordered in ascending order of `start_vid`."
msgstr ""

msgid "Depth First Search Running time: :math:`O(E + V)`"
msgstr ""

msgid "pgr_depthFirstSearch(`Edges SQL`_, **root vid**, [**options**])"
msgstr ""

msgid "pgr_depthFirstSearch(`Edges SQL`_, **root vids**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, max_depth]``"
msgstr ""

msgid "Same as `Single vertex`_ but with edges in descending order of ``id``."
msgstr ""

msgid ""
"`Boost: Depth First Search "
"<https://www.boost.org/libs/graph/doc/depth_first_search.html>`__"
msgstr ""

msgid ""
"`Boost: Undirected DFS "
"<https://www.boost.org/libs/graph/doc/undirected_dfs.html>`__"
msgstr ""

msgid ""
"`Wikipedia: Depth First Search algorithm <https://en.wikipedia.org/wiki"
"/Depth-first_search>`__"
msgstr ""

msgid "``pgr_dijkstra``  Shortest path using Dijkstra algorithm."
msgstr ""

msgid "Version 3.5.0"
msgstr ""

msgid "pgr_dijkstra(One to One) added ``start_vid`` and ``end_vid`` columns."
msgstr ""

msgid "pgr_dijkstra(One to Many) added ``end_vid`` column."
msgstr ""

msgid "pgr_dijkstra(Many to One) added ``start_vid`` column."
msgstr ""

msgid "Version 3.1.0"
msgstr ""

msgid "pgr_dijkstra(Combinations)"
msgstr ""

msgid "Version 2.2.0"
msgstr ""

msgid "pgr_dijkstra(One to Many)"
msgstr ""

msgid "pgr_dijkstra(Many to One)"
msgstr ""

msgid "pgr_dijkstra(Many to Many)"
msgstr ""

msgid "Signature change on pgr_dijkstra(One to One)"
msgstr ""

msgid "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""

msgid "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""

msgid "pgr_dijkstra(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""

msgid "pgr_dijkstra(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

#, python-brace-format
msgid "From vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a **directed**"
msgstr ""

msgid "The examples of this section are based on the :doc:`sampledata` network."
msgstr ""

msgid "For **directed** graphs with ``cost`` and ``reverse_cost`` columns"
msgstr ""

msgid "Directed graph with cost and reverse cost columns"
msgstr ""

msgid "1) Path from :math:`6` to :math:`10`"
msgstr ""

msgid "2) Path from :math:`6` to :math:`7`"
msgstr ""

msgid "3) Path from :math:`12` to :math:`10`"
msgstr ""

msgid "4) Path from :math:`12` to :math:`7`"
msgstr ""

msgid "5) Using `One to Many`_ to get the solution of examples 1 and 2"
msgstr ""

#, python-brace-format
msgid "Paths :math:`\\{6\\}\\rightarrow\\{10, 7\\}`"
msgstr ""

msgid "6) Using `Many to One`_ to get the solution of examples 2 and 4"
msgstr ""

#, python-brace-format
msgid "Paths :math:`\\{6, 12\\}\\rightarrow\\{7\\}`"
msgstr ""

msgid "7) Using `Many to Many`_ to get the solution of examples 1 to 4"
msgstr ""

#, python-brace-format
msgid "Paths :math:`\\{6, 12\\}\\rightarrow\\{10, 7\\}`"
msgstr ""

msgid "8) Using `Combinations`_ to get the solution of examples 1 to 3"
msgstr ""

#, python-brace-format
msgid ""
"Paths :math:`\\{6\\}\\rightarrow\\{10, "
"7\\}\\cup\\{12\\}\\rightarrow\\{10\\}`"
msgstr ""

msgid "For **undirected** graphs with ``cost`` and ``reverse_cost`` columns"
msgstr ""

msgid "Undirected graph with cost and reverse cost columns"
msgstr ""

msgid "9) Path from :math:`6` to :math:`10`"
msgstr ""

msgid "10) Path from :math:`6` to :math:`7`"
msgstr ""

msgid "11) Path from :math:`12` to :math:`10`"
msgstr ""

msgid "12) Path from :math:`12` to :math:`7`"
msgstr ""

msgid "13) Using `One to Many`_ to get the solution of examples 9 and 10"
msgstr ""

msgid "14) Using `Many to One`_ to get the solution of examples 10 and 12"
msgstr ""

msgid "15) Using `Many to Many`_ to get the solution of examples 9 to 12"
msgstr ""

msgid "16) Using `Combinations`_ to get the solution of examples 9 to 11"
msgstr ""

msgid "For **directed** graphs only with ``cost`` column"
msgstr ""

msgid "Directed graph only with cost column"
msgstr ""

msgid "17) Path from :math:`6` to :math:`10`"
msgstr ""

msgid "18) Path from :math:`6` to :math:`7`"
msgstr ""

msgid "19) Path from :math:`12` to :math:`10`"
msgstr ""

msgid "20) Path from :math:`12` to :math:`7`"
msgstr ""

msgid "21) Using `One to Many`_ to get the solution of examples 17 and 18"
msgstr ""

msgid "22) Using `Many to One`_ to get the solution of examples 18 and 20"
msgstr ""

msgid "23) Using `Many to Many`_ to get the solution of examples 17 to 20"
msgstr ""

msgid "24) Using `Combinations`_ to get the solution of examples 17 to 19"
msgstr ""

msgid "For **undirected** graphs only with ``cost`` column"
msgstr ""

msgid "Undirected graph only with cost column"
msgstr ""

msgid "25) Path from :math:`6` to :math:`10`"
msgstr ""

msgid "26) Path from :math:`6` to :math:`7`"
msgstr ""

msgid "27) Path from :math:`12` to :math:`10`"
msgstr ""

msgid "28) Path from :math:`12` to :math:`7`"
msgstr ""

msgid "29) Using `One to Many`_ to get the solution of examples 25 and 26"
msgstr ""

msgid "30) Using `Many to One`_ to get the solution of examples 26 and 28"
msgstr ""

msgid "31) Using `Many to Many`_ to get the solution of examples 25 to 28"
msgstr ""

msgid "32) Using `Combinations`_ to get the solution of examples 25 to 27"
msgstr ""

msgid "Equvalences between signatures"
msgstr ""

#, python-brace-format
msgid ""
"The following examples find the path for "
":math:`\\{6\\}\\rightarrow\\{10\\}`"
msgstr ""

msgid "33) Using `One to One`_"
msgstr ""

msgid "34) Using `One to Many`_"
msgstr ""

msgid "35) Using `Many to One`_"
msgstr ""

msgid "36) Using `Many to Many`_"
msgstr ""

msgid "37) Using `Combinations`_"
msgstr ""

msgid ""
"`Boost: Dijkstra shortest paths "
"<https://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html>`__"
msgstr ""

#, python-format
msgid "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
msgstr ""

msgid "``pgr_dijkstraCost``"
msgstr ""

msgid ""
"``pgr_dijkstraCost`` - Total cost of the shortest path using Dijkstra "
"algorithm."
msgstr ""

msgid "pgr_dijkstraCost(Combinations)"
msgstr ""

msgid ""
"The ``pgr_dijkstraCost`` function summarizes of the cost of the shortest "
"path using Dijkstra Algorithm."
msgstr ""

msgid "pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""

msgid ""
"pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vids**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_dijkstraCost(`Edges SQL`_, **start vids**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_dijkstraCost(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""

msgid "pgr_dijkstraCost(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

msgid "``pgr_dijkstraCostMatrix``"
msgstr ""

msgid ""
"``pgr_dijkstraCostMatrix`` - Calculates a cost matrix using "
":doc:`pgr_dijkstra`."
msgstr ""

msgid "Using Dijkstra algorithm, calculate and return a cost matrix."
msgstr ""

msgid "pgr_dijkstraCostMatrix(`Edges SQL`_, **start vids**, [``directed``])"
msgstr ""

msgid "``pgr_dijkstraNear`` - Proposed"
msgstr ""

msgid ""
"``pgr_dijkstraNear``  Using Dijkstra's algorithm, finds the route that "
"leads to the nearest vertex."
msgstr ""

msgid ""
"Given a graph, a starting vertex and a set of ending vertices, this "
"function finds the shortest path from the starting vertex to the nearest "
"ending vertex."
msgstr ""

msgid "Uses Dijkstra algorithm."
msgstr ""

msgid "Works for **directed** and **undirected** graphs."
msgstr ""

msgid "When there are more than one path to the same vertex with same cost:"
msgstr ""

msgid "The algorithm will return just one path"
msgstr ""

msgid "Optionally allows to find more than one path."
msgstr ""

msgid "When more than one path is to be returned:"
msgstr ""

msgid "Results are sorted in increasing order of:"
msgstr ""

msgid "aggregate cost"
msgstr ""

msgid "Within the same value of aggregate costs:"
msgstr ""

msgid "results are sorted by (source, target)"
msgstr ""

msgid "Running time: Dijkstra running time: :math:`drt = O((|E| + |V|)log|V|)`"
msgstr ""

msgid "One to Many; :math:`drt`"
msgstr ""

msgid "Many to One: :math:`drt`"
msgstr ""

msgid "Many to Many: :math:`drt * |Starting vids|`"
msgstr ""

msgid "Combinations: :math:`drt * |Starting vids|`"
msgstr ""

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vid**, **end vids**, [**options "
"A**])"
msgstr ""

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vid**, [**options "
"A**])"
msgstr ""

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vids**, [**options "
"B**])"
msgstr ""

msgid "pgr_dijkstraNear(`Edges SQL`_, `Combinations SQL`_, [**options B**])"
msgstr ""

msgid "**options A:** ``[directed, cap]``"
msgstr ""

msgid "**options B:** ``[directed, cap, global]``"
msgstr ""

msgid "pgr_dijkstraNear(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, cap]``"
msgstr ""

msgid "Departing on car from vertex :math:`6` find the nearest subway station."
msgstr ""

msgid "Using a **directed** graph for car routing."
msgstr ""

#, python-brace-format
msgid "The subway stations are on the following vertices :math:`\\{1, 10, 11\\}`"
msgstr ""

msgid "The defaults used:"
msgstr ""

msgid "`directed => true`"
msgstr ""

msgid "`cap => 1`"
msgstr ""

msgid "The result shows that station at vertex :math:`11` is the nearest."
msgstr ""

msgid "pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""

msgid ""
"Departing on a car from a subway station find the nearest **two** "
"stations to vertex :math:`2`"
msgstr ""

msgid "On line `4`: using the positional parameter: `directed` set to ``true``"
msgstr ""

msgid "In line `5`: using named parameter `cap => 2`"
msgstr ""

msgid ""
"The result shows that station at vertex :math:`10` is the nearest and the"
" next best is :math:`11`."
msgstr ""

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vids**, "
"[**options**])"
msgstr ""

msgid "**options:** ``[directed, cap, global]``"
msgstr ""

msgid "Find the best pedestrian connection between two lines of buses"
msgstr ""

msgid "Using an **undirected** graph for pedestrian routing"
msgstr ""

#, python-brace-format
msgid "The first subway line stations are at :math:`\\{15, 16\\}`"
msgstr ""

#, python-brace-format
msgid "The second subway line stations stops are at :math:`\\{1, 10, 11\\}`"
msgstr ""

msgid "On line `4`: using the named parameter: `directed => false`"
msgstr ""

msgid "`global => true`"
msgstr ""

msgid ""
"For a pedestrian the best connection is to get on/off is at vertex "
":math:`15` of the first subway line and at vertex :math:`10` of the "
"second subway line."
msgstr ""

msgid ""
"Only `one` route is returned because `global` is ``true`` and `cap` is "
"``1``"
msgstr ""

msgid "pgr_dijkstraNear(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr ""

msgid "Find the best car connection between all the stations of two subway lines"
msgstr ""

#, python-brace-format
msgid "The first subway line stations stops are at :math:`\\{1, 10, 11\\}`"
msgstr ""

#, python-brace-format
msgid "The second subway line stations are at :math:`\\{15, 16\\}`"
msgstr ""

msgid "The combinations contents:"
msgstr ""

msgid ""
"lines `3~4` sets the start vertices to be from the first subway line and "
"the ending vertices to be from the second subway line"
msgstr ""

msgid ""
"lines `6~7` sets the start vertices to be from the first subway line and "
"the ending vertices to be from the first subway line"
msgstr ""

msgid "On line `8`: using the named parameter is `global => false`"
msgstr ""

msgid "From the results:"
msgstr ""

#, python-brace-format
msgid ""
"making a connection from the first subway line :math:`\\{1, 10, 11\\}` to"
" the second :math:`\\{15, 16\\}`:"
msgstr ""

#, python-brace-format
msgid ""
"The best connections from all the stations from the first line are: "
":math:`{(1 \\rightarrow 16) (10 \\rightarrow 16) (11 \\rightarrow 16)}`"
msgstr ""

msgid ""
"The best one is :math:`(11 \\rightarrow 16)` with a cost of :math:`1` "
"(lines: `11` and `12`)"
msgstr ""

#, python-brace-format
msgid ""
"making a connection from the second subway line :math:`\\{15, 16\\}` to "
"the first :math:`\\{1, 10, 11\\}`:"
msgstr ""

#, python-brace-format
msgid ""
"The best connections from all the stations from the second line are: "
":math:`{(15 \\rightarrow 10) (16 \\rightarrow 11)}`"
msgstr ""

msgid ""
"Both are equally good as they have the same cost. (lines: `13` and `14` "
"and lines: `15` and `16`)"
msgstr ""

msgid "Dijkstra optional parameters"
msgstr ""

msgid "Near optional parameters"
msgstr ""

msgid "``cap``"
msgstr ""

msgid "Find at most ``cap`` number of nearest shortest paths"
msgstr ""

msgid "``global``"
msgstr ""

msgid "When ``true``: only ``cap`` limit results will be returned"
msgstr ""

msgid "When ``false``: ``cap`` limit per ``Start vid`` will be returned"
msgstr ""

#, python-format
msgid "Wikipedia: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
msgstr ""

msgid "``pgr_dijkstraNearCost`` - Proposed"
msgstr ""

msgid ""
"``pgr_dijkstraNearCost``  Using dijkstra algorithm, finds the route that"
" leads to the nearest vertex."
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vids**, "
"[**options A**])"
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vid**, "
"[**options A**])"
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vids**, "
"[**options B**])"
msgstr ""

msgid "pgr_dijkstraNearCost(`Edges SQL`_, `Combinations SQL`_, [**options B**])"
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vids**, "
"[**options**])"
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vid**, "
"[**options**])"
msgstr ""

msgid ""
"Departing on a car from a subway station find the nearest **two** "
"stations to vertex :math:`6`"
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vids**, "
"[**options**])"
msgstr ""

msgid "pgr_dijkstraNearCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr ""

msgid ""
"The best one is :math:`(11 \\rightarrow 16)` with a cost of :math:`1` "
"(lines: `1`)"
msgstr ""

msgid "Both are equally good as they have the same cost. (lines: `12` and `13`)"
msgstr ""

msgid "``pgr_dijkstraVia``"
msgstr ""

msgid "``pgr_dijkstraVia``  Route that goes through a list of vertices."
msgstr ""

#, python-brace-format
msgid ""
"Given a list of vertices and a graph, this function is equivalent to "
"finding the shortest path between :math:`vertex_i` and "
":math:`vertex_{i+1}` for all :math:`i < size\\_of(via\\;vertices)`."
msgstr ""

msgid "Route"
msgstr ""

msgid "is a sequence of paths."
msgstr ""

msgid "Path"
msgstr ""

msgid "is a section of the route."
msgstr ""

msgid "One Via"
msgstr ""

msgid "pgr_dijkstraVia(`Edges SQL`_, **via vertices**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, strict, U_turn_on_edge]``"
msgstr ""

msgid "Returns set of |via-result|"
msgstr ""

#, python-brace-format
msgid ""
"Find the route that visits the vertices :math:`\\{5, 1, 8\\}` in that "
"order on an directed graph."
msgstr ""

msgid "Via optional parameters"
msgstr ""

msgid "When ``true`` departing from a visited vertex will not try to avoid"
msgstr ""

msgid "Identifier of a path. Has value **1** for the first path."
msgstr ""

msgid ""
"Identifier of the edge used to go from ``node`` to the next node in the "
"path sequence."
msgstr ""

msgid "-1 for the last node of the path."
msgstr ""

msgid "-2 for the last node of the route."
msgstr ""

msgid "``route_agg_cost``"
msgstr ""

msgid ""
"Total cost from ``start_vid`` of ``seq = 1`` to ``end_vid`` of the "
"current ``seq``."
msgstr ""

#, python-brace-format
msgid ""
"All this examples are about the route that visits the vertices "
":math:`\\{5, 7, 1, 8, 15\\}` in that order on a **directed** graph."
msgstr ""

msgid "The main query"
msgstr ""

msgid "Aggregate cost of the third path."
msgstr ""

msgid "Route's aggregate cost of the route at the end of the third path."
msgstr ""

msgid "Nodes visited in the route."
msgstr ""

msgid "The aggregate costs of the route when the visited vertices are reached."
msgstr ""

msgid "Status of \"passes in front\" or \"visits\" of the nodes."
msgstr ""

msgid ":doc:`via-category`."
msgstr ""

msgid ":doc:`dijkstra-family`."
msgstr ""

msgid "``pgr_drivingDistance`` - Returns the driving distance from a start node."
msgstr ""

msgid "pgr_drivingDistance(Single vertex)"
msgstr ""

msgid "Added ``depth`` and ``start_vid`` result columns."
msgstr ""

msgid "pgr_drivingDistance(Multiple vertices)"
msgstr ""

msgid "Result column name change: ``from_v`` to ``start_vid``."
msgstr ""

msgid "Added ``depth`` and ``pred`` result columns."
msgstr ""

msgid "Signature change:"
msgstr ""

msgid "pgr_drivingDistance(single vertex)"
msgstr ""

msgid "New official signature:"
msgstr ""

msgid "pgr_drivingDistance(multiple vertices)"
msgstr ""

msgid ""
"Using the Dijkstra algorithm, extracts all the nodes that have costs less"
" than or equal to the value ``distance``. The edges extracted will "
"conform to the corresponding spanning tree."
msgstr ""

msgid ""
"pgr_drivingDistance(`Edges SQL`_, **Root vid**, **distance**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_drivingDistance(`Edges SQL`_, **Root vids**, **distance**, "
"[**options**])"
msgstr ""

msgid "**options:** [directed, equicost]"
msgstr ""

msgid "Single Vertex"
msgstr ""

msgid "From vertex :math:`11` for a distance of :math:`3.0`"
msgstr ""

msgid "Multiple Vertices"
msgstr ""

#, python-brace-format
msgid ""
"From vertices :math:`\\{11, 16\\}` for a distance of :math:`3.0` with "
"equi-cost on a directed graph"
msgstr ""

msgid "Driving distance optional parameters"
msgstr ""

msgid "``equicost``"
msgstr ""

msgid ""
"When ``true`` the node will only appear in the closest ``start_vid`` "
"list. Tie brakes are arbitrary."
msgstr ""

msgid ""
"When ``false`` which resembles several calls using the single vertex "
"signature."
msgstr ""

msgid "end-before"
msgstr ""

#, python-brace-format
msgid ""
"From vertices :math:`\\{11, 16\\}` for a distance of :math:`3.0` on an "
"undirected graph"
msgstr ""

msgid "``pgr_edgeColoring`` - Experimental"
msgstr ""

msgid ""
"``pgr_edgeColoring``  Returns the edge coloring of undirected and loop-"
"free graphs"
msgstr ""

msgid ""
"Edge Coloring is an algorithm used for coloring of the edges for the "
"vertices in the graph. It is an assignment of colors to the edges of the "
"graph so that no two adjacent edges have the same color."
msgstr ""

msgid "The implementation is for **undirected** and **loop-free** graphs"
msgstr ""

msgid "loop free"
msgstr ""

msgid "no self-loops and no parallel edges."
msgstr ""

msgid "Provides the color to be assigned to all the edges present in the graph."
msgstr ""

msgid ""
"At most :math:`\\Delta + 1` colors are used, where :math:`\\Delta` is the"
" degree of the graph."
msgstr ""

msgid ""
"This is optimal for some graphs, and by Vizing's theorem it uses at most "
"one color more than the optimal for all others."
msgstr ""

msgid ""
"the chromatic number :math:`x'(G)` (minimum number of colors needed for "
"proper edge coloring of graph) is equal to the degree :math:`\\Delta + 1`"
" of the graph, (:math:`x'(G) = \\Delta`)"
msgstr ""

msgid "The algorithm tries to assign the least possible color to every edge."
msgstr ""

msgid "Does not always produce optimal coloring."
msgstr ""

msgid "The returned rows are ordered in ascending order of the edge identifier."
msgstr ""

msgid "Efficient graph coloring is an NP-Hard problem, and therefore:"
msgstr ""

msgid "In this implelentation the running time: :math:`O(|E|*|V|)`"
msgstr ""

msgid "where :math:`|E|` is the number of edges in the graph,"
msgstr ""

msgid ":math:`|V|` is the number of vertices in the graph."
msgstr ""

msgid "pgr_edgeColoring(`Edges SQL`_)"
msgstr ""

msgid "Graph coloring of pgRouting :doc:`sampledata`"
msgstr ""

msgid ""
"`Boost: Edge Coloring "
"<https://www.boost.org/libs/graph/doc/edge_coloring.html>`__"
msgstr ""

msgid ""
"`Wikipedia: Graph coloring "
"<https://en.wikipedia.org/wiki/Graph_coloring>`__"
msgstr ""

msgid ""
"``pgr_edgeDisjointPaths``  Calculates edge disjoint paths between two "
"groups of vertices."
msgstr ""

msgid "pgr_edgeDisjointPaths(Combinations)"
msgstr ""

msgid ""
"Calculates the edge disjoint paths between two groups of vertices. "
"Utilizes underlying maximum flow algorithms to calculate the paths."
msgstr ""

msgid "The main characterics are:"
msgstr ""

msgid "Calculates the edge disjoint paths between any two groups of vertices."
msgstr ""

msgid ""
"Returns EMPTY SET when source and destination are the same, or cannot be "
"reached."
msgstr ""

msgid "The graph can be directed or undirected."
msgstr ""

msgid "Uses :doc:`pgr_boykovKolmogorov` to calculate the paths."
msgstr ""

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vids**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vids**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""

msgid "pgr_edgeDisjointPaths(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

#, python-brace-format
msgid ""
"Using a combinations table, equivalent to calculating result from "
"vertices :math:`\\{5, 6\\}` to vertices :math:`\\{10, 15, 14\\}` on an "
"undirected graph."
msgstr ""

msgid "Manually assigned vertex combinations on an undirected graph."
msgstr ""

msgid "``pgr_edmondsKarp``"
msgstr ""

msgid ""
"``pgr_edmondsKarp``  Calculates the flow on the graph edges that "
"maximizes the flow from the sources to the targets using Edmonds Karp "
"Algorithm."
msgstr ""

msgid "pgr_edmondsKarp(Combinations)"
msgstr ""

msgid "Renamed from ``pgr_maxFlowEdmondsKarp``"
msgstr ""

msgid "Running time: :math:`O( V * E ^ 2)`"
msgstr ""

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_edmondsKarp(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid ""
"`Boost: Edmonds Karp max flow "
"<https://www.boost.org/libs/graph/doc/edmonds_karp_max_flow.html>`__"
msgstr ""

#, python-format
msgid "https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm"
msgstr ""

msgid "``pgr_edwardMoore`` - Experimental"
msgstr ""

msgid ""
"``pgr_edwardMoore``  Returns the shortest path using Edward-Moore "
"algorithm."
msgstr ""

msgid ""
"Edward Moores Algorithm is an improvement of the Bellman-Ford Algorithm."
" It can compute the shortest paths from a single source vertex to all "
"other vertices in a weighted directed graph. The main difference between "
"Edward Moore's Algorithm and Bellman Ford's Algorithm lies in the run "
"time."
msgstr ""

msgid ""
"The worst-case running time of the algorithm is :math:`O(| V | * | E |)` "
"similar to the time complexity of Bellman-Ford algorithm. However, "
"experiments suggest that this algorithm has an average running time "
"complexity of :math:`O( | E | )` for random graphs. This is significantly"
" faster in terms of computation speed."
msgstr ""

msgid ""
"Thus, the algorithm is at-best, significantly faster than Bellman-Ford "
"algorithm and is at-worst,as good as Bellman-Ford algorithm"
msgstr ""

msgid "The `agg_cost` the non included values `(v, v)` is :math:`0`"
msgstr ""

msgid ""
"For optimization purposes, any duplicated value in the `start vids` or "
"`end vids` are ignored."
msgstr ""

msgid "Running time:"
msgstr ""

msgid "Worst case: :math:`O(| V | * | E |)`"
msgstr ""

msgid "Average case: :math:`O( | E | )`"
msgstr ""

msgid "pgr_edwardMoore(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""

msgid "pgr_edwardMoore(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""

msgid "pgr_edwardMoore(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""

msgid ""
"pgr_edwardMoore(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""

msgid "pgr_edwardMoore(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

msgid "Using a combinations table on an **undirected** graph."
msgstr ""

msgid "https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm"
msgstr ""

msgid "``pgr_extractVertices``"
msgstr ""

msgid "``pgr_extractVertices``  Extracts the vertices information"
msgstr ""

msgid ""
"This is an auxiliary function for extracting the vertex information of "
"the set of edges of a graph."
msgstr ""

msgid ""
"When the edge identifier is given, then it will also calculate the in and"
" out edges"
msgstr ""

msgid "pgr_extractVertices(`Edges SQL`_, [``dryrun``])"
msgstr ""

msgid "RETURNS SETOF |result-extract|"
msgstr ""

msgid "When line geometry is known"
msgstr ""

msgid "(Optional) identifier of the edge."
msgstr ""

msgid "``geom``"
msgstr ""

msgid "``LINESTRING``"
msgstr ""

msgid "Geometry of the edge."
msgstr ""

msgid ""
"This inner query takes precedence over the next two inner query, "
"therefore other columns are ignored when ``geom`` column appears."
msgstr ""

msgid "Ignored columns:"
msgstr ""

msgid "``startpoint``"
msgstr ""

msgid "``endpoint``"
msgstr ""

msgid "When vertex geometry is known"
msgstr ""

msgid ""
"To use this inner query the column ``geom`` should not be part of the set"
" of columns."
msgstr ""

msgid "``POINT``"
msgstr ""

msgid "POINT geometry of the starting vertex."
msgstr ""

msgid "POINT geometry of the ending vertex."
msgstr ""

msgid ""
"This inner query takes precedence over the next inner query, therefore "
"other columns are ignored when ``startpoint`` and ``endpoint`` columns "
"appears."
msgstr ""

msgid "When identifiers of vertices are known"
msgstr ""

msgid ""
"To use this inner query the columns ``geom``, ``startpoint`` and "
"``endpoint`` should not be part of the set of columns."
msgstr ""

msgid "``NULL`` When the ``id`` is not part of the inner query"
msgstr ""

msgid "X value of the point geometry"
msgstr ""

msgid "``NULL`` When no geometry is provided"
msgstr ""

msgid "Geometry of the point"
msgstr ""

msgid ""
"To get the query generated used to get the vertex information, use "
"``dryrun := true``."
msgstr ""

msgid "Create a routing topology"
msgstr ""

msgid "Make sure the database does not have the ``vertices_table``"
msgstr ""

msgid "Clean up the columns of the routing topology to be created"
msgstr ""

msgid ""
"When the ``LINESTRING`` has a SRID then use ``geom::geometry(POINT, "
"<SRID>)``"
msgstr ""

msgid "For big edge tables that are been prepared,"
msgstr ""

msgid "Create it as ``UNLOGGED`` and"
msgstr ""

msgid "After the table is created ``ALTER TABLE .. SET LOGGED``"
msgstr ""

msgid "Inspect the vertices table"
msgstr ""

msgid "Create the routing topology on the edge table"
msgstr ""

msgid "Updating the ``source`` information"
msgstr ""

msgid "Updating the ``target`` information"
msgstr ""

msgid "Inspect the routing topology"
msgstr ""

msgid "**Generated topology**"
msgstr ""

msgid "``pgr_findCloseEdges``"
msgstr ""

msgid "``pgr_findCloseEdges`` - Finds the close edges to a point geometry."
msgstr ""

msgid "``partial`` option is removed."
msgstr ""

msgid ""
"``pgr_findCloseEdges`` - An utility function that finds the closest edge "
"to a point geometry."
msgstr ""

msgid "The geometries must be in the same coordinate system (have the same SRID)."
msgstr ""

msgid ""
"The code to do the calculations can be obtained for further specific "
"adjustments needed by the application."
msgstr ""

msgid "``EMPTY SET`` is returned on dryrun executions"
msgstr ""

msgid "pgr_findCloseEdges(`Edges SQL`_, **point**, **tolerance**, [**options**])"
msgstr ""

msgid "pgr_findCloseEdges(`Edges SQL`_, **points**, **tolerance**, [**options**])"
msgstr ""

msgid "**options:** ``[cap, dryrun]``"
msgstr ""

msgid "Returns set of |result-find|"
msgstr ""

msgid "One point"
msgstr ""

msgid "Get two close edges to points of interest with :math:`pid = 5`"
msgstr ""

msgid "``cap => 2``"
msgstr ""

msgid "Many points"
msgstr ""

msgid "For each points of interests, find the closest edge."
msgstr ""

msgid "**point**"
msgstr ""

msgid "The point geometry"
msgstr ""

msgid "**points**"
msgstr ""

msgid "``POINT[]``"
msgstr ""

msgid "An array of point geometries"
msgstr ""

msgid "**tolerance**"
msgstr ""

msgid "Max distance between geometries"
msgstr ""

msgid "Limit output rows"
msgstr ""

msgid "When ``false`` calculations are performed."
msgstr ""

msgid ""
"When ``true`` calculations are not performed and the query to do the "
"calculations is exposed in a PostgreSQL ``NOTICE``."
msgstr ""

msgid "``geometry``"
msgstr ""

msgid "The ``LINESTRING`` geometry of the edge."
msgstr ""

msgid "When :math:`cap = 1`, it is the closest edge."
msgstr ""

msgid ""
"Value in <0,1> that indicates the relative position from the first end-"
"point of the edge."
msgstr ""

msgid "Value in ``[r, l]`` indicating if the point is:"
msgstr ""

msgid "At the right ``r`` of the segment."
msgstr ""

msgid "When the point is on the line it is considered to be on the right."
msgstr ""

msgid "At the left ``l`` of the segment."
msgstr ""

msgid "``distance``"
msgstr ""

msgid "Distance from the point to the edge."
msgstr ""

msgid "Original ``POINT`` geometry."
msgstr ""

msgid ""
"``LINESTRING`` geometry that connects the original **point** to the "
"closest point of the edge with identifier ``edge_id``"
msgstr ""

msgid "One point in an edge"
msgstr ""

msgid "The green node is the original point."
msgstr ""

msgid "``geom`` has the value of the original point."
msgstr ""

msgid ""
"The geometry ``edge`` is a line that connects the original point with the"
" edge :math:`sp \\rightarrow ep` edge."
msgstr ""

msgid "The point is located at the left of the edge."
msgstr ""

msgid "One point dry run execution"
msgstr ""

msgid "Using the query from the previous example:"
msgstr ""

msgid "Returns ``EMPTY SET``."
msgstr ""

msgid "``dryrun => true``"
msgstr ""

msgid "Generates a PostgreSQL ``NOTICE`` with the code used."
msgstr ""

msgid ""
"The generated code can be used as a starting base code for additional "
"requirements, like taking into consideration the SRID."
msgstr ""

msgid "Many points in an edge"
msgstr ""

msgid "The green nodes are the **original points**"
msgstr ""

msgid ""
"The geometry ``geom``, marked as **g1** and **g2** are the **original "
"points**"
msgstr ""

msgid ""
"The geometry ``edge``, marked as **edge1** and **edge2** is a line that "
"connects the **original point** with the closest point on the :math:`sp "
"\\rightarrow ep` edge."
msgstr ""

msgid "Many points dry run execution"
msgstr ""

msgid "Do not process query"
msgstr ""

msgid ""
"Generate a PostgreSQL ``NOTICE`` with the code used to calculate all "
"columns"
msgstr ""

msgid "Find at most two routes to a given point"
msgstr ""

msgid "Using :doc:`pgr_withPoints`"
msgstr ""

msgid "A point of interest table"
msgstr ""

msgid "Handling points outside the graph."
msgstr ""

msgid "Points of interest"
msgstr ""

msgid ""
"Some times the applications work \"on the fly\" starting from a location "
"that is not a vertex in the graph. Those locations, in pgRrouting are "
"called points of interest."
msgstr ""

msgid ""
"The information needed in the points of interest is ``pid``, ``edge_id``,"
" ``side``, ``fraction``."
msgstr ""

msgid ""
"On this documentation there will be some 6 fixed points of interest and "
"they will be stored on a table."
msgstr ""

msgid "A unique identifier."
msgstr ""

msgid "Identifier of the nearest segment."
msgstr ""

msgid "Is it on the left, right or both sides of the segment ``edge_id``."
msgstr ""

msgid "Where in the segment is the point located."
msgstr ""

msgid "The geometry of the points."
msgstr ""

msgid "The distance between ``geom`` and the segment ``edge_id``."
msgstr ""

msgid ""
"A segment that connects the ``geom`` of the point to the closest point on"
" the segment ``edge_id``."
msgstr ""

msgid "``newPoint``"
msgstr ""

msgid "A point on segment ``edge_id`` that is the closest to ``geom``."
msgstr ""

msgid "Points of interest fill up"
msgstr ""

msgid "Inserting the points of interest."
msgstr ""

msgid "Filling the rest of the table."
msgstr ""

msgid ""
"Any other additional modification: In this manual, point :math:`6` can be"
" reached from both sides."
msgstr ""

msgid "The points of interest:"
msgstr ""

msgid "``pgr_floydWarshall``"
msgstr ""

msgid ""
"``pgr_floydWarshall`` - Returns the sum of the costs of the shortest path"
" for each pair of nodes in the graph using Floyd-Warshall algorithm."
msgstr ""

msgid ""
"The Floyd-Warshall algorithm, also known as Floyd's algorithm, is a good "
"choice to calculate the sum of the costs of the shortest path for each "
"pair of nodes in the graph, for *dense graphs*. We use Boost's "
"implementation which runs in :math:`\\Theta(V^3)` time,"
msgstr ""

msgid "pgr_floydWarshall(`Edges SQL`_, [``directed``])"
msgstr ""

#, python-brace-format
msgid "For a directed subgraph with edges :math:`\\{1, 2, 3, 4\\}`."
msgstr ""

msgid ""
"Boost `Floyd-Warshall "
"<https://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html>`_"
msgstr ""

msgid "``pgr_full_version``"
msgstr ""

msgid "``pgr_full_version``  Get the details of pgRouting version information."
msgstr ""

msgid "Get complete details of pgRouting version information"
msgstr ""

msgid "pgr_full_version()"
msgstr ""

msgid "RETURNS |result-version|"
msgstr ""

msgid "Information about when this documentation was built"
msgstr ""

msgid "``version``"
msgstr ""

msgid "pgRouting version"
msgstr ""

msgid "``build_type``"
msgstr ""

msgid "The Build type"
msgstr ""

msgid "``compile_date``"
msgstr ""

msgid "Compilation date"
msgstr ""

msgid "``library``"
msgstr ""

msgid "Library name and version"
msgstr ""

msgid "``system``"
msgstr ""

msgid "Operative system"
msgstr ""

msgid "``postgreSQL``"
msgstr ""

msgid "pgsql used"
msgstr ""

msgid "``compiler``"
msgstr ""

msgid "Compiler and version"
msgstr ""

msgid "``boost``"
msgstr ""

msgid "Boost version"
msgstr ""

msgid "``hash``"
msgstr ""

msgid "Git hash of pgRouting build"
msgstr ""

msgid "``pgr_hawickCircuits`` - Experimental"
msgstr ""

msgid ""
"``pgr_hawickCircuits``  Returns the list of circuits using hawick "
"circuits algorithm."
msgstr ""

msgid ""
"Hawick Circuit algorithm, is published in 2008 by Ken Hawick and Health "
"A. James. This algorithm solves the problem of detecting and enumerating "
"circuits in graphs. It is capable of circuit enumeration in graphs with "
"directed-arcs, multiple-arcs and self-arcs with a memory efficient and "
"high-performance im-plementation. It is an extension of Johnson's "
"Algorithm of finding all the elementary circuits of a directed graph."
msgstr ""

msgid ""
"There are 2 variations defined in the Boost Graph Library. Here, we have "
"implemented only 2nd as it serves the most suitable and practical "
"usecase. In this variation we get the circuits after filtering out the "
"circuits caused by parallel edges. Parallel edge circuits have more use "
"cases when you want to count the no. of circuits.Maybe in future, we will"
" also implemenent this variation."
msgstr ""

msgid "The algorithm implementation works only for directed graph"
msgstr ""

msgid "It is a variation of Johnson's algorithm for circuit enumeration."
msgstr ""

msgid "The algorithm outputs the distinct circuits present in the graph."
msgstr ""

msgid "Time Complexity: :math:`O((V + E) (c + 1))`"
msgstr ""

msgid ":math:`|c|` is the number of circuits in the graph."
msgstr ""

msgid "pgr_hawickCircuits(`Edges SQL`_)"
msgstr ""

msgid "Circuits present in the pgRouting :doc:`sampledata`"
msgstr ""

msgid "Id of the circuit starting from ``1``"
msgstr ""

msgid "Relative position in the path. Has value ``0`` for beginning of the path"
msgstr ""

msgid "Identifier of the starting vertex of the circuit."
msgstr ""

msgid "Identifier of the ending vertex of the circuit."
msgstr ""

msgid "Identifier of the node in the path from a vid to next vid."
msgstr ""

msgid ""
"`Boost: Hawick Circuit Algorithm "
"<https://www.boost.org/doc/libs/1_78_0/libs/graph/doc/hawick_circuits.html>`__"
msgstr ""

msgid "``pgr_isPlanar`` - Experimental"
msgstr ""

msgid ""
"``pgr_isPlanar``  Returns a boolean depending upon the planarity of the "
"graph."
msgstr ""

#, python-brace-format
msgid ""
"A graph is planar if it can be drawn in two-dimensional space with no two"
" of its edges crossing. Such a drawing of a planar graph is called a "
"plane drawing. Every planar graph also admits a straight-line drawing, "
"which is a plane drawing where each edge is represented by a line "
"segment. When a graph has :math:`K_5` or :math:`K_{3, 3}` as subgraph "
"then the graph is not planar."
msgstr ""

msgid "This implementation use the Boyer-Myrvold Planarity Testing."
msgstr ""

msgid "It will return a boolean value depending upon the planarity of the graph."
msgstr ""

msgid "Applicable only for **undirected** graphs."
msgstr ""

msgid "The algorithm does not considers traversal costs in the calculations."
msgstr ""

msgid "Running time: :math:`O(|V|)`"
msgstr ""

msgid "pgr_isPlanar(`Edges SQL`)"
msgstr ""

msgid "RETURNS ``BOOLEAN``"
msgstr ""

msgid "Returns a boolean ``(pgr_isplanar)``"
msgstr ""

msgid "``pgr_isplanar``"
msgstr ""

msgid "`true` when the graph is planar."
msgstr ""

msgid "`false` when the graph is not planar."
msgstr ""

#, python-brace-format
msgid ""
"The following edges will make the subgraph with vertices {10, 15, 11, 16,"
" 13} a :math:`K_1` graph."
msgstr ""

msgid ""
"The new graph is not planar because it has a :math:`K_5` subgraph. Edges "
"in blue represent :math:`K_5` subgraph."
msgstr ""

msgid ""
"`Boost: Boyer Myrvold "
"<https://www.boost.org/libs/graph/doc/boyer_myrvold.html>`__"
msgstr ""

msgid "``pgr_johnson``"
msgstr ""

msgid ""
"``pgr_johnson`` - Returns the sum of the costs of the shortest path for "
"each pair of nodes in the graph using Johnson algorithm."
msgstr ""

msgid ""
"The Johnson algorithm, is a good choice to calculate the sum of the costs"
" of the shortest path for each pair of nodes in the graph, for *sparse "
"graphs*. It uses the Boost's implementation which runs in :math:`O(V E "
"\\log V)` time,"
msgstr ""

msgid "pgr johnson(`Edges SQL`_, [``directed``])"
msgstr ""

msgid ""
"Boost `Johnson "
"<https://www.boost.org/libs/graph/doc/johnson_all_pairs_shortest.html>`_"
msgstr ""

msgid "``pgr_kingOrdering`` - Experimental"
msgstr ""

msgid "``pgr_kingOrdering``  Returns the King ordering of an undirected graph."
msgstr ""

msgid ""
"In numerical linear algebra and graph theory, the King ordering algorithm"
" is a heuristic designed to reorder the vertices of a graph so as to "
"reduce its bandwidth."
msgstr ""

msgid ""
"The method follows a breadth-first search (BFS) traversal, but with a "
"refinement: at each step, the unvisited neighbors of the current vertex "
"are inserted into the queue in ascending order of their pseudo-degree, "
"where the pseudo-degree of a vertex is the number of edges connecting it "
"to yet-unvisited vertices. This prioritization often yields a smaller "
"bandwidth compared to simpler BFS orderings."
msgstr ""

msgid "The implementation targets undirected graphs."
msgstr ""

msgid ""
"Bandwidth minimization is an NP-complete problem; King ordering provides "
"a practical local minimization approach."
msgstr ""

msgid "The time complexity is: :math:`O(m^2 \\log(m)|E|)`"
msgstr ""

msgid "where :math:`|E|` is the number of edges,"
msgstr ""

msgid ":math:`m` is the maximum degree among all vertices."
msgstr ""

msgid "pgr_kingOrdering(`Edges SQL`_)"
msgstr ""

msgid ""
"`Boost: King Ordering "
"<https://www.boost.org/libs/graph/doc/king_ordering.html>`__"
msgstr ""

msgid "``pgr_kruskal``"
msgstr ""

msgid ""
"``pgr_kruskal``  Minimum spanning tree of a graph using Kruskal's "
"algorithm."
msgstr ""

msgid ""
"This algorithm finds the minimum spanning forest in a possibly "
"disconnected graph using Kruskal's algorithm."
msgstr ""

msgid "EMPTY SET is returned when there are no edges in the graph."
msgstr ""

msgid "pgr_kruskal(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-mst|"
msgstr ""

msgid "Minimum spanning forest"
msgstr ""

msgid ""
"``pgr_kruskalBFS``  Kruskal's algorithm for Minimum Spanning Tree with "
"breadth First Search ordering."
msgstr ""

msgid "Added ``pred`` result columns."
msgstr ""

msgid ""
"Visits and extracts the nodes information in Breath First Search ordering"
" of the Minimum Spanning Tree created using Kruskal's algorithm."
msgstr ""

msgid "Returned tree nodes from a root vertex are on Breath First Search order"
msgstr ""

msgid "Breath First Search Running time: :math:`O(E + V)`"
msgstr ""

msgid "pgr_kruskalBFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr ""

msgid "pgr_kruskalBFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr ""

msgid "The Minimum Spanning Tree having as root vertex :math:`6`"
msgstr ""

#, python-brace-format
msgid ""
"The Minimum Spanning Tree starting on vertices :math:`\\{9, 6\\}` with "
":math:`depth \\leq 3`"
msgstr ""

msgid "``pgr_kruskalDD``  Catchament nodes using Kruskal's algorithm."
msgstr ""

msgid ""
"Using Kruskal's algorithm, extracts the nodes that have aggregate costs "
"less than or equal to a **distance** from a **root** vertex (or vertices)"
" within the calculated minimum spanning tree."
msgstr ""

msgid "Returned tree nodes from a root vertex are on Depth First Search order."
msgstr ""

msgid "Depth First Search running time: :math:`O(E + V)`"
msgstr ""

msgid "pgr_kruskalDD(`Edges SQL`_, **root vid**, **distance**)"
msgstr ""

msgid "pgr_kruskalDD(`Edges SQL`_, **root vids**, **distance**)"
msgstr ""

msgid ""
"The Minimum Spanning Tree starting on vertex :math:`6` with "
":math:`distance \\leq 3.5`"
msgstr ""

#, python-brace-format
msgid ""
"The Minimum Spanning Tree starting on vertices :math:`\\{9, 6\\}` with "
":math:`distance \\leq 3.5`"
msgstr ""

msgid ""
"``pgr_kruskalDFS``  Kruskal's algorithm for Minimum Spanning Tree with "
"Depth First Search ordering."
msgstr ""

msgid ""
"Visits and extracts the nodes information in Depth First Search ordering "
"of the Minimum Spanning Tree created using Kruskal's algorithm."
msgstr ""

msgid "Returned tree nodes from a root vertex are on Depth First Search order"
msgstr ""

msgid "pgr_kruskalDFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr ""

msgid "pgr_kruskalDFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr ""

msgid "``pgr_lengauerTarjanDominatorTree`` - Experimental"
msgstr ""

msgid ""
"``pgr_lengauerTarjanDominatorTree``  Returns the immediate dominator of "
"all vertices."
msgstr ""

msgid ""
"The algorithm calculates the *immediate dominator* of each vertex called "
"**idom**, once **idom** of each vertex is calculated then by making every"
" **idom** of each vertex as its parent, the dominator tree can be built."
msgstr ""

msgid "The algorithm works in directed graph only."
msgstr ""

msgid "The algorithm returns *idom* of each vertex."
msgstr ""

msgid "If the *root vertex* not present in the graph then it returns empty set."
msgstr ""

msgid "Running time: :math:`O((V+E)log(V+E))`"
msgstr ""

msgid "pgr_lengauerTarjanDominatorTree(`Edges SQL`_, **root vertex**)"
msgstr ""

msgid "Returns set of |result-idom|"
msgstr ""

msgid "The dominator tree with root vertex :math:`5`"
msgstr ""

msgid "SQL query as described above."
msgstr ""

msgid "**root vertex**"
msgstr ""

msgid "Returns set of ``(seq, vertex_id, idom)``"
msgstr ""

msgid "``vertex_id``"
msgstr ""

msgid "Identifier of vertex ."
msgstr ""

msgid "``idom``"
msgstr ""

msgid "Immediate dominator of vertex."
msgstr ""

msgid "Dominator tree of another component."
msgstr ""

msgid ""
"`Boost: Lengauer-Tarjan dominator "
"<https://www.boost.org/libs/graph/doc/lengauer_tarjan_dominator.htm>`__"
msgstr ""

msgid ""
"`Wikipedia: dominator tree "
"<https://en.wikipedia.org/wiki/Dominator_(graph_theory)>`__"
msgstr ""

msgid "``pgr_lineGraph`` - Proposed"
msgstr ""

msgid ""
"``pgr_lineGraph``  Transforms the given graph into its corresponding "
"edge-based graph."
msgstr ""

msgid "Works for directed and undirected graphs."
msgstr ""

msgid "Given a graph :math:`G`, its line graph :math:`L(G)` is a graph such that:"
msgstr ""

msgid "Each vertex of :math:`L(G)` represents an edge of :math:`G`."
msgstr ""

msgid ""
"Two vertices of :math:`L(G)` are adjacent if and only if their "
"corresponding edges share a common endpoint in :math:`G`"
msgstr ""

msgid ""
"The ``cost`` and ``reverse_cost`` columns of the result represent "
"existence of the edge."
msgstr ""

msgid "When the graph is directed the result is directed."
msgstr ""

msgid ""
"To get the complete Line Graph use unique identifiers on the double way "
"edges (See `Additional Examples`_)."
msgstr ""

msgid "When the graph is undirected the result is undirected."
msgstr ""

msgid "The ``reverse_cost`` is always :math:`-1`."
msgstr ""

msgid "pgr_lineGraph(`Edges SQL`_, [``directed``])"
msgstr ""

msgid "Returns set of |result-lineg|"
msgstr ""

#, python-brace-format
msgid "For an undirected graph with edges :math:'{2,4,5,8}'"
msgstr ""

msgid "Gives a local identifier for the edge"
msgstr ""

msgid "When `negative`: the source is the reverse edge in the original graph."
msgstr ""

msgid "When `negative`: the target is the reverse edge in the original graph."
msgstr ""

msgid "Weight of the edge (``source``, ``target``)."
msgstr ""

msgid ""
"When `negative`: edge (``source``, ``target``) does not exist, therefore "
"its not part of the graph."
msgstr ""

msgid "Weight of the edge (``target``, ``source``)."
msgstr ""

msgid ""
"When `negative`: edge (``target``, ``source``) does not exist, therefore "
"its not part of the graph."
msgstr ""

msgid "Given the following directed graph"
msgstr ""

#, python-brace-format
msgid ""
":math:`G(V,E) = G(\\{1,2,3,4\\},\\{ 1 \\rightarrow 2, 1 \\rightarrow 4, 2"
" \\rightarrow 3, 3 \\rightarrow 1, 3 \\rightarrow 2, 3 \\rightarrow 4, 4 "
"\\rightarrow 3\\})`"
msgstr ""

msgid "Representation as directed with shared edge identifiers"
msgstr ""

msgid ""
"For the simplicity, the design of the edges table on the database, has "
"the edge's identifiers are represented with 3 digits:"
msgstr ""

msgid "hundreds"
msgstr ""

msgid "the source vertex"
msgstr ""

msgid "tens"
msgstr ""

msgid "always 0, acts as a separator"
msgstr ""

msgid "units"
msgstr ""

msgid "the target vertex"
msgstr ""

msgid "In this image,"
msgstr ""

msgid "Single or double head arrows represent one edge (row) on the edges table."
msgstr ""

msgid "The numbers in the yellow shadow are the edge identifiers."
msgstr ""

msgid ""
"Two pair of edges share the same identifier when the ``reverse_cost`` "
"column is used."
msgstr ""

#, python-brace-format
msgid ""
"Edges :math:`{2 \\rightarrow 3, 3 \\rightarrow 2}` are represented with "
"one edge row with :math:`id=203`."
msgstr ""

#, python-brace-format
msgid ""
"Edges :math:`{3 \\rightarrow 4, 4 \\rightarrow 3}` are represented with "
"one edge row with :math:`id=304`."
msgstr ""

msgid "The graph can be created as follows:"
msgstr ""

msgid "Line Graph of a directed graph represented with shared edges"
msgstr ""

msgid "The result is a directed graph."
msgstr ""

msgid ""
"For :math:`seq=4` from :math:`203 \\leftrightarrow 304` represent two "
"edges"
msgstr ""

msgid "For all the other values of ``seq`` represent one edge."
msgstr ""

msgid ""
"The ``cost`` and ``reverse_cost`` values represent the existence of the "
"edge."
msgstr ""

msgid "When positive: the edge exists."
msgstr ""

msgid "When negative: the edge does not exist."
msgstr ""

msgid "Representation as directed with unique edge identifiers"
msgstr ""

msgid "Single head arrows represent one edge (row) on the edges table."
msgstr ""

msgid "There are no double head arrows"
msgstr ""

msgid ""
"Two pair of edges share the same ending nodes and the ``reverse_cost`` "
"column is not used."
msgstr ""

#, python-brace-format
msgid ""
"Edges :math:`{2 \\rightarrow 3, 3 \\rightarrow 2}` are represented with "
"two edges :math:`id=203` and :math:`id=302` respectively."
msgstr ""

#, python-brace-format
msgid ""
"Edges :math:`{3 \\rightarrow 4, 4 \\rightarrow 3}` are represented with "
"two edges :math:`id=304` and :math:`id=403` respectively."
msgstr ""

msgid "Line Graph of a directed graph represented with unique edges"
msgstr ""

msgid ""
"For :math:`seq=7` from :math:`203 \\leftrightarrow 302` represent two "
"edges."
msgstr ""

msgid ""
"For :math:`seq=8` from :math:`304 \\leftrightarrow 403` represent two "
"edges."
msgstr ""

msgid "wikipedia: `Line Graph <https://en.wikipedia.org/wiki/Line_graph>`__"
msgstr ""

msgid "mathworld: `Line Graph <https://mathworld.wolfram.com/LineGraph.html>`__"
msgstr ""

msgid "``pgr_lineGraphFull`` - Experimental"
msgstr ""

msgid ""
"``pgr_lineGraphFull``  Transforms a given graph into a new graph where "
"all of the vertices from the original graph are converted to line graphs."
msgstr ""

msgid "Version 2.6.0"
msgstr ""

msgid ""
"``pgr_lineGraphFull``, converts original directed graph to a directed "
"line graph by converting each vertex to a complete graph and keeping all "
"the original edges. The new connecting edges have a cost 0 and go between"
" the adjacent original edges, respecting the directionality."
msgstr ""

msgid ""
"A possible application of the resulting graph is **\"routing with two "
"edge restrictions\"**:"
msgstr ""

msgid ""
"Setting a cost of using the vertex when routing between edges on the "
"connecting edge"
msgstr ""

msgid "Forbid the routing between two edges by removing the connecting edge"
msgstr ""

msgid ""
"This is possible because each of the intersections (vertices) in the "
"original graph are now complete graphs that have a new edge for each "
"possible turn across that intersection."
msgstr ""

msgid "This function is for **directed** graphs."
msgstr ""

msgid ""
"Results are undefined when a negative vertex id is used in the input "
"graph."
msgstr ""

msgid ""
"Results are undefined when a duplicated edge id is used in the input "
"graph."
msgstr ""

msgid "Running time: TBD"
msgstr ""

msgid "pgr_lineGraphFull(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-linegf|"
msgstr ""

#, python-brace-format
msgid "Full line graph of subgraph of edges :math:`\\{4, 7, 8, 10\\}`"
msgstr ""

msgid ""
"The examples include the subgraph including edges 4, 7, 8, and 10 with "
"``reverse_cost``."
msgstr ""

msgid "The data"
msgstr ""

msgid ""
"This example displays how this graph transformation works to create "
"additional edges for each possible turn in a graph."
msgstr ""

msgid "|first|"
msgstr ""

msgid "first"
msgstr ""

msgid "The transformation"
msgstr ""

msgid "|second|"
msgstr ""

msgid "second"
msgstr ""

msgid ""
"In the transformed graph, all of the edges from the original graph are "
"still present (yellow), but we now have additional edges for every turn "
"that could be made across vertex 7 (orange)."
msgstr ""

msgid "Creating table that identifies transformed vertices"
msgstr ""

msgid ""
"The vertices in the transformed graph are each created by splitting up "
"the vertices in the original graph. Unless a vertex in the original graph"
" is a leaf vertex, it will generate more than one vertex in the "
"transformed graph. One of the newly created vertices in the transformed "
"graph will be given the same vertex identifier as the vertex that it was "
"created from in the original graph, but the rest of the newly created "
"vertices will have negative vertex ids."
msgstr ""

msgid ""
"Following is an example of how to generate a table that maps the ids of "
"the newly created vertices with the original vertex that they were "
"created from"
msgstr ""

msgid "Store edge results"
msgstr ""

msgid ""
"The first step is to store the results of the ``pgr_lineGraphFull`` call "
"into a table"
msgstr ""

msgid "Create the mapping table"
msgstr ""

msgid "From the original graph's vertex information"
msgstr ""

msgid "Add the new vertices"
msgstr ""

msgid "Filling the mapping table"
msgstr ""

msgid "The positive vertex identifiers are the original identifiers"
msgstr ""

msgid "Inspecting the vertices map"
msgstr ""

msgid ""
"The self loops happen when there is no cost traveling to the ``target`` "
"and the source has an original value."
msgstr ""

msgid "Updating values from self loops"
msgstr ""

msgid "Inspecting the vertices table"
msgstr ""

msgid "Updating from inner self loops"
msgstr ""

msgid "Adding a soft restriction"
msgstr ""

msgid ""
"A soft restriction going from vertex 6 to vertex 3 using edges 4 -> 7 is "
"wanted."
msgstr ""

msgid "Identifying the restriction"
msgstr ""

msgid ""
"Running a :doc:`pgr_dijkstraNear` the edge with cost 0, edge 8, is where "
"the cost will be increased"
msgstr ""

msgid ""
"The edge to be altered is ``WHERE cost = 0 AND seq != 1 AND edge != -1`` "
"from the previous query:"
msgstr ""

msgid "Adding a value to the restriction"
msgstr ""

msgid "Updating the cost to the edge:"
msgstr ""

msgid "Routing from :math:`6` to :math:`3`"
msgstr ""

msgid "Now the route does not use edge 8 and does a U turn on a leaf vertex."
msgstr ""

msgid "Simplifying leaf vertices"
msgstr ""

msgid "In this example, there is no additional cost for traversing a leaf vertex."
msgstr ""

msgid "Using the vertex map give the leaf verices their original value."
msgstr ""

msgid "On the source column"
msgstr ""

msgid "On the target column"
msgstr ""

msgid "Removing self loops on leaf nodes"
msgstr ""

msgid "The self loops of the leaf nodes are"
msgstr ""

msgid "Which can be removed"
msgstr ""

msgid ""
"Routing can be done now using the original vertices id using "
":doc:`pgr_dijkstra`"
msgstr ""

msgid "Complete routing graph"
msgstr ""

msgid "Add edges from the original graph"
msgstr ""

msgid ""
"Add all the edges that are not involved in the line graph process to the "
"new table"
msgstr ""

msgid "Some administrative tasks to get new identifiers for the edges"
msgstr ""

msgid "Add the newly calculated edges"
msgstr ""

msgid "Using the routing graph"
msgstr ""

msgid ""
"When using this method for routing with soft restrictions there will be "
"uturns"
msgstr ""

msgid "Routing from :math:`5` to :math:`1`"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Line_graph"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Complete_graph"
msgstr ""

msgid "``pgr_makeConnected`` - Experimental"
msgstr ""

msgid "``pgr_makeConnected``  Set of edges that will connect the graph."
msgstr ""

msgid ""
"Adds the minimum number of edges needed to make the input graph "
"connected. The algorithm first identifies all of the connected components"
" in the graph, then adds edges to connect those components together in a "
"path. For example, if a graph contains three connected components A, B, "
"and C, make_connected will add two edges. The two edges added might "
"consist of one connecting a vertex in A with a vertex in B and one "
"connecting a vertex in B with a vertex in C."
msgstr ""

msgid ""
"It will give a minimum list of all edges which are needed in the graph to"
" make connect it."
msgstr ""

msgid "The algorithm does not considers geometric topology in the calculations."
msgstr ""

msgid "pgr_makeConnected(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-component-make|"
msgstr ""

msgid "List of edges that are needed to connect the graph."
msgstr ""

msgid ""
"`Boost: make connected "
"<https://www.boost.org/libs/graph/doc/make_connected.html>`__"
msgstr ""

msgid "``pgr_maxCardinalityMatch``"
msgstr ""

msgid ""
"``pgr_maxCardinalityMatch``  Calculates a maximum cardinality matching "
"in a graph."
msgstr ""

msgid "pgr_maxCardinalityMatch(text) returns only ``edge`` column."
msgstr ""

msgid "Deprecated signature"
msgstr ""

msgid "directed => ``false`` when used."
msgstr ""

msgid "Renamed from ``pgr_maximumCardinalityMatching``"
msgstr ""

msgid ""
"A matching or independent edge set in a graph is a set of edges without "
"common vertices."
msgstr ""

msgid ""
"A maximum matching is a matching that contains the largest possible "
"number of edges."
msgstr ""

msgid "There may be many maximum matchings."
msgstr ""

msgid "Calculates one possible maximum cardinality matching in a graph."
msgstr ""

msgid "Running time: :math:`O( E*V * \\alpha(E,V))`"
msgstr ""

msgid ":math:`\\alpha(E,V)` is the inverse of the `Ackermann function`_."
msgstr ""

msgid "pgr_maxCardinalityMatch(`Edges SQL`_)"
msgstr ""

msgid "Using all edges."
msgstr ""

msgid "SQL query, which should return a set of rows with the following columns:"
msgstr ""

msgid ""
"A positive value represents the existence of the edge (``source``, "
"``target``)."
msgstr ""

msgid ""
"A positive value represents the existence of the edge (``target``, "
"``source``)"
msgstr ""

msgid "Identifier of the edge in the original query."
msgstr ""

msgid ""
"`Boost: maximum_matching "
"<https://www.boost.org/libs/graph/doc/maximum_matching.html>`__"
msgstr ""

#, python-format
msgid "https://en.wikipedia.org/wiki/Matching_%28graph_theory%29"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Ackermann_function"
msgstr ""

msgid "``pgr_maxFlow``"
msgstr ""

msgid ""
"``pgr_maxFlow``  Calculates the maximum flow in a directed graph from "
"the source(s) to the targets(s) using the Push Relabel algorithm."
msgstr ""

msgid "pgr_maxFlow(Combinations)"
msgstr ""

msgid "Calculates the maximum flow from the sources to the targets."
msgstr ""

msgid ""
"When the maximum flow is **0** then there is no flow and **0** is "
"returned."
msgstr ""

msgid "Uses the :doc:`pgr_pushRelabel <pgr_pushRelabel>` algorithm."
msgstr ""

msgid "Running time: :math:`O( V ^ 3)`"
msgstr ""

msgid "pgr_maxFlow(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_maxFlow(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_maxFlow(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_maxFlow(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_maxFlow(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "RETURNS ``BIGINT``"
msgstr ""

msgid "Maximum flow possible from the source(s) to the target(s)"
msgstr ""

msgid ""
"`Boost: push relabel max flow "
"<https://www.boost.org/libs/graph/doc/push_relabel_max_flow.html>`__"
msgstr ""

#, python-format
msgid "https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm"
msgstr ""

msgid "``pgr_maxFlowMinCost`` - Experimental"
msgstr ""

msgid ""
"``pgr_maxFlowMinCost``  Calculates the edges that minimizes the total "
"cost of the maximum flow on a graph"
msgstr ""

msgid "pgr_maxFlowMinCost(Combinations)"
msgstr ""

msgid "|Boost| Boost Graph Inside."
msgstr ""

msgid "**TODO** check which statement is true:"
msgstr ""

msgid "The cost value of all input edges must be nonnegative."
msgstr ""

msgid "Process is done when the cost value of all input edges is nonnegative."
msgstr ""

msgid "Process is done on edges with nonnegative cost."
msgstr ""

msgid "Running time: :math:`O(U * (E + V * logV))`"
msgstr ""

msgid "where :math:`U` is the value of the max flow."
msgstr ""

msgid ""
":math:`U` is upper bound on number of iterations. In many real world "
"cases number of iterations is much smaller than :math:`U`."
msgstr ""

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_maxFlowMinCost(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "Returns set of |result-flow-mincost|"
msgstr ""

msgid "``pgr_maxFlowMinCost_Cost`` - Experimental"
msgstr ""

msgid ""
"``pgr_maxFlowMinCost_Cost``  Calculates the minimum total cost of the "
"maximum flow on a graph"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(Combinations)"
msgstr ""

msgid "**The cost value of all input edges must be nonnegative.**"
msgstr ""

msgid "When the maximum flow is 0 then there is no flow and **0** is returned."
msgstr ""

msgid "Uses :doc:`pgr_maxFlowMinCost`."
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "RETURNS FLOAT"
msgstr ""

msgid "Minimum Cost Maximum Flow possible from the source(s) to the target(s)"
msgstr ""

msgid "``pgr_pickDeliver`` - Experimental"
msgstr ""

msgid "``pgr_pickDeliver`` - Pickup and delivery Vehicle Routing Problem"
msgstr ""

msgid ""
"Problem: Distribute and optimize the pickup-delivery pairs into a fleet "
"of vehicles."
msgstr ""

msgid "Optimization problem is NP-hard."
msgstr ""

msgid "pickup and Delivery with time windows."
msgstr ""

msgid "All vehicles are equal."
msgstr ""

msgid "Same Starting location."
msgstr ""

msgid "Same Ending location which is the same as Starting location."
msgstr ""

msgid "All vehicles travel at the same speed."
msgstr ""

msgid "A customer is for doing a pickup or doing a deliver."
msgstr ""

msgid "has an open time."
msgstr ""

msgid "has a closing time."
msgstr ""

msgid "has a service time."
msgstr ""

msgid "has an (x, y) location."
msgstr ""

msgid "There is a customer where to deliver a pickup."
msgstr ""

msgid "travel time between customers is distance / speed"
msgstr ""

msgid "pickup and delivery pair is done with the same vehicle."
msgstr ""

msgid "All trucks depart at time 0."
msgstr ""

msgid "the algorithm will raise an exception when"
msgstr ""

msgid "If there is a pickup-deliver pair than violates time window"
msgstr ""

msgid "The speed, max_cycles, ma_capacity have illegal values"
msgstr ""

msgid ""
"Six different initial will be optimized - the best solution found will be"
" result"
msgstr ""

msgid "Signature"
msgstr ""

msgid ""
"pgr_pickDeliver(`Orders SQL`_, `Vehicles SQL`_, `Matrix SQL`_, "
"[**options**])"
msgstr ""

msgid "**options:** ``[factor, max_cycles, initial_sol]``"
msgstr ""

msgid "Returns set of |result-pickdrop|"
msgstr ""

msgid "Solve the following problem"
msgstr ""

msgid "Given the vehicles:"
msgstr ""

msgid "and the orders:"
msgstr ""

msgid "The parameters are:"
msgstr ""

msgid "A `SELECT` statement that returns the following columns:"
msgstr ""

msgid "id, demand"
msgstr ""

msgid "p_node_id, p_open, p_close, [p_service,]"
msgstr ""

msgid "d_node_id, d_open, d_close, [d_service,]"
msgstr ""

msgid "id, capacity"
msgstr ""

msgid "start_node_id, start_open, start_close [, start_service,]"
msgstr ""

msgid "[end_node_id, end_open, end_close, end_service]"
msgstr ""

msgid "``pgr_pickDeliverEuclidean`` - Experimental"
msgstr ""

msgid "``pgr_pickDeliverEuclidean`` - Pickup and delivery Vehicle Routing Problem"
msgstr ""

msgid "Replaces ``pgr_gsoc_vrppdtw``"
msgstr ""

msgid "Pickup and Delivery:"
msgstr ""

msgid "capacitated"
msgstr ""

msgid "with time windows."
msgstr ""

msgid "have (x, y) start and ending locations."
msgstr ""

msgid "have a start and ending service times."
msgstr ""

msgid "An order is for doing a pickup and a a deliver."
msgstr ""

msgid "has (x, y) pickup and delivery locations."
msgstr ""

msgid "has opening and closing times for the pickup and delivery locations."
msgstr ""

msgid "has a pickup and deliver service times."
msgstr ""

msgid "Six different optional different initial solutions"
msgstr ""

msgid "the best solution found will be result"
msgstr ""

msgid "pgr_pickDeliverEuclidean(`Orders SQL`_, `Vehicles SQL`_, [**options**])"
msgstr ""

msgid "p_x, p_y, p_open, p_close, [p_service,]"
msgstr ""

msgid "d_x, d_y, d_open, d_close, [d_service]"
msgstr ""

msgid "start_x, start_y, start_open, start_close [, start_service, ]"
msgstr ""

msgid "[ end_x, end_y, end_open, end_close, end_service ]"
msgstr ""

msgid ""
"This data example **lc101** is from data published at "
"https://www.sintef.no/projectweb/top/pdptw/li-lim-benchmark/"
msgstr ""

msgid "There are 25 vehicles in the problem all with the same characteristics."
msgstr ""

msgid "The original orders"
msgstr ""

msgid ""
"The data comes in different rows for the pickup and the delivery of the "
"same order."
msgstr ""

msgid "The original data needs to be converted to an appropriate table:"
msgstr ""

msgid "The query"
msgstr ""

msgid ""
"Showing only the relevant information to compare with the best solution "
"information published on "
"https://www.sintef.no/projectweb/top/pdptw/100-customers/"
msgstr ""

msgid "The best solution found for **lc101** is a travel time: 828.94"
msgstr ""

msgid "This implementation's travel time: 854.54"
msgstr ""

msgid "``pgr_prim``"
msgstr ""

msgid "``pgr_prim``  Minimum spanning forest of a graph using Prim's algorithm."
msgstr ""

msgid ""
"This algorithm finds the minimum spanning forest in a possibly "
"disconnected graph using Prim's algorithm."
msgstr ""

msgid "Prim's running time: :math:`O(E * log V)`"
msgstr ""

msgid "pgr_prim(`Edges SQL`_)"
msgstr ""

msgid "Minimum spanning forest of a subgraph"
msgstr ""

msgid ""
"`Boost: Prim's algorithm documentation "
"<https://www.boost.org/libs/graph/doc/prim_minimum_spanning_tree.html>`__"
msgstr ""

msgid ""
"``pgr_primBFS``  Prim's algorithm for Minimum Spanning Tree with Depth "
"First Search ordering."
msgstr ""

msgid ""
"Visits and extracts the nodes information in Breath First Search ordering"
" of the Minimum Spanning Tree created using Prims's algorithm."
msgstr ""

msgid "pgr_primBFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr ""

msgid "pgr_primBFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr ""

msgid "``pgr_primDD``  Catchament nodes using Prim's algorithm."
msgstr ""

msgid ""
"Using Prim's algorithm, extracts the nodes that have aggregate costs less"
" than or equal to a distance from a root vertex (or vertices) within the "
"calculated minimum spanning tree."
msgstr ""

msgid "pgr_primDD(`Edges SQL`_, **root vid**, **distance**)"
msgstr ""

msgid "pgr_primDD(`Edges SQL`_, **root vids**, **distance**)"
msgstr ""

msgid ""
"``pgr_primDFS``  Prim algorithm for Minimum Spanning Tree with Depth "
"First Search ordering."
msgstr ""

msgid ""
"Visits and extracts the nodes information in Depth First Search ordering "
"of the Minimum Spanning Tree created using Prims's algorithm."
msgstr ""

msgid "pgr_primDFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr ""

msgid "pgr_primDFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr ""

msgid "``pgr_pushRelabel``"
msgstr ""

msgid ""
"``pgr_pushRelabel``  Calculates the flow on the graph edges that "
"maximizes the flow from the sources to the targets using Push Relabel "
"Algorithm."
msgstr ""

msgid "pgr_pushRelabel(Combinations)"
msgstr ""

msgid "Renamed from ``pgr_maxFlowPushRelabel``"
msgstr ""

msgid "pgr_pushRelabel(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_pushRelabel(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_pushRelabel(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_pushRelabel(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_pushRelabel(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "``pgr_separateCrossing``"
msgstr ""

msgid ""
"``pgr_separateCrossing`` - From crossing geometries generates geometries "
"that do not cross."
msgstr ""

msgid "Proposed function."
msgstr ""

msgid "This is an auxiliary function for separating crossing edges."
msgstr ""

msgid "pgr_separateCrossing(`Edges SQL`_, [``tolerance``, ``dryrun``])"
msgstr ""

msgid "RETURNS |result-separate|"
msgstr ""

msgid "Get the segments of the crossing geometries"
msgstr ""

msgid "``tolerance``"
msgstr ""

msgid "0.01"
msgstr ""

msgid "Used in ST_Snap before ST_Split"
msgstr ""

msgid "Get the code for further refinement."
msgstr ""

msgid ""
"When there are special details that need to be taken care of because of "
"the final application or the quality of the data, the code can be "
"obtained On a PostgreSQL ``NOTICE`` using the ``dryrun`` flag."
msgstr ""

msgid "``pgr_separateTouching``"
msgstr ""

msgid ""
"``pgr_separateTouching`` - From touching geometries generates geometries "
"that are properly connected at endpoints"
msgstr ""

msgid ""
"This is an auxiliary function for processing geometries that touch but "
"don't share exact endpoints, splitting them at their intersection points "
"to improve network connectivity."
msgstr ""

msgid "pgr_separateTouching(`Edges SQL`_, [``tolerance``, ``dryrun``])"
msgstr ""

msgid "``pgr_sequentialVertexColoring`` - Proposed"
msgstr ""

msgid ""
"``pgr_sequentialVertexColoring``  Returns the vertex coloring of an "
"undirected graph, using greedy approach."
msgstr ""

msgid ""
"Sequential vertex coloring algorithm is a graph coloring algorithm in "
"which color identifiers are assigned to the vertices of a graph in a "
"sequential manner, such that no edge connects two identically colored "
"vertices."
msgstr ""

msgid "The implementation is applicable only for **undirected** graphs."
msgstr ""

msgid ""
"Provides the color to be assigned to all the vertices present in the "
"graph."
msgstr ""

msgid "Color identifiers values are in the Range :math:`[1, |V|]`"
msgstr ""

msgid "The algorithm tries to assign the least possible color to every vertex."
msgstr ""

msgid ""
"Efficient graph coloring is an NP-Hard problem, and therefore, this "
"algorithm does not always produce optimal coloring. It follows a greedy "
"strategy by iterating through all the vertices sequentially, and "
"assigning the smallest possible color that is not used by its neighbors, "
"to each vertex."
msgstr ""

msgid "The returned rows are ordered in ascending order of the vertex value."
msgstr ""

msgid "Sequential Vertex Coloring Running Time: :math:`O(|V|*(d + k))`"
msgstr ""

msgid ":math:`d` is the maximum degree of the vertices in the graph,"
msgstr ""

msgid ":math:`k` is the number of colors used."
msgstr ""

msgid "pgr_sequentialVertexColoring(`Edges SQL`_)"
msgstr ""

msgid ""
"`Boost: Sequential Vertex Coloring "
"<https://www.boost.org/libs/graph/doc/sequential_vertex_coloring.html>`__"
msgstr ""

msgid "``pgr_sloanOrdering`` - Experimental"
msgstr ""

msgid "``pgr_sloanOrdering``  Returns the Sloan ordering of an undirected graph"
msgstr ""

msgid ""
"The Sloan ordering algorithm reorders the vertices of a graph to reduce "
"bandwidth, profile, and wavefront properties, which is particularly "
"useful for sparse matrix computations and finite element analysis."
msgstr ""

msgid "Finds a pseudoperipheral vertex pair to determine good starting points"
msgstr ""

msgid ""
"Uses a priority-based algorithm that balances vertex degree and distance "
"from the start vertex."
msgstr ""

msgid ""
"Aims to minimize bandwidth (maximum difference between connected vertex "
"indices."
msgstr ""

msgid "Typically produces better orderings than simple breadth-first approaches."
msgstr ""

msgid ""
"Time complexity: :math:`O(V + E)` where V is the number of vertices and "
"E is the number of edges."
msgstr ""

msgid "pgr_sloanOrdering(`Edges SQL`_)"
msgstr ""

msgid ":Example : Sloan ordering without specifying start vertex"
msgstr ""

msgid "New sloan ordering order."
msgstr ""

msgid "Sloan ordering of Original graph from Boost example (vertices 0-9)."
msgstr ""

msgid ""
"`Boost: Sloan Ordering "
"<https://www.boost.org/doc/libs/latest/libs/graph/doc/sloan_ordering.htm>`__"
msgstr ""

msgid "``pgr_stoerWagner`` - Experimental"
msgstr ""

msgid "``pgr_stoerWagner``  The min-cut of graph using stoerWagner algorithm."
msgstr ""

msgid "Version 3.0"
msgstr ""

msgid ""
"In graph theory, the StoerWagner algorithm is a recursive algorithm to "
"solve the minimum cut problem in undirected weighted graphs with non-"
"negative weights. The essential idea of this algorithm is to shrink the "
"graph by merging the most intensive vertices, until the graph only "
"contains two combined vertex sets. At each phase, the algorithm finds the"
" minimum s-t cut for two vertices s and t chosen as its will. Then the "
"algorithm shrinks the edge between s and t to search for non s-t cuts. "
"The minimum cut found in all phases will be the minimum weighted cut of "
"the graph."
msgstr ""

msgid ""
"A cut is a partition of the vertices of a graph into two disjoint "
"subsets. A minimum cut is a cut for which the size or weight of the cut "
"is not larger than the size of any other cut. For an unweighted graph, "
"the minimum cut would simply be the cut with the least edges. For a "
"weighted graph, the sum of all edges' weight on the cut determines "
"whether it is a minimum cut."
msgstr ""

msgid "Sum of the weights of all edges between the two sets is mincut."
msgstr ""

msgid "A **mincut** is a cut having the least weight."
msgstr ""

msgid "Values are returned when graph is connected."
msgstr ""

msgid "When there is no edge in graph then EMPTY SET is return."
msgstr ""

msgid "When the graph is unconnected then EMPTY SET is return."
msgstr ""

msgid ""
"Sometimes a graph has multiple min-cuts, but all have the same weight. "
"The this function determines exactly one of the min-cuts as well as its "
"weight."
msgstr ""

msgid "Running time: :math:`O(V*E + V^2*log V)`."
msgstr ""

msgid "pgr_stoerWagner(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-mincut|"
msgstr ""

msgid "min cut of the main subgraph"
msgstr ""

msgid "Returns set of ``(seq, edge, cost, mincut)``"
msgstr ""

msgid "Edges which divides the set of vertices into two."
msgstr ""

msgid "Cost to traverse of edge."
msgstr ""

msgid "**mincut**"
msgstr ""

msgid "Min-cut weight of a undirected graph."
msgstr ""

msgid "Additional Example:"
msgstr ""

msgid "min cut of an edge"
msgstr ""

msgid "Using :doc:`pgr_connectedComponents`"
msgstr ""

msgid ""
"`Boost: Stoer Wagner min cut "
"<https://www.boost.org/libs/graph/doc/stoer_wagner_min_cut.html>`__"
msgstr ""

#, python-format
msgid "https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm"
msgstr ""

msgid "``pgr_strongComponents``"
msgstr ""

msgid ""
"``pgr_strongComponents``  Strongly connected components of a directed "
"graph using Tarjan's algorithm based on DFS."
msgstr ""

msgid ""
"A strongly connected component of a directed graph is a set of vertices "
"that are all reachable from each other."
msgstr ""

msgid "Works for **directed** graphs."
msgstr ""

msgid "Components are described by vertices identifiers."
msgstr ""

msgid "pgr_strongComponents(`Edges SQL`_)"
msgstr ""

msgid "The strong components of the graph"
msgstr ""

msgid ""
"`Boost: Strong components "
"<https://www.boost.org/libs/graph/doc/strong_components.html>`__"
msgstr ""

msgid ""
"wikipedia: `Strongly connected component "
"<https://en.wikipedia.org/wiki/Strongly_connected_component>`__"
msgstr ""

msgid "``pgr_topologicalSort`` - Experimental"
msgstr ""

msgid ""
"``pgr_topologicalSort``  Linear ordering of the vertices for directed "
"acyclic graphs (DAG)."
msgstr ""

msgid ""
"The topological sort algorithm creates a linear ordering of the vertices "
"such that if edge :math:`(u,v)` appears in the graph, then :math:`v` "
"comes before :math:`u` in the ordering."
msgstr ""

msgid ""
"Process is valid for directed acyclic graphs only. otherwise it will "
"throw warnings."
msgstr ""

msgid "For optimization purposes, if there are more than one answer, the function"
msgstr ""

msgid "will return one of them."
msgstr ""

msgid "The returned values are ordered in topological order:"
msgstr ""

msgid "pgr_topologicalSort(`Edges SQL`_)"
msgstr ""

msgid "Topologically sorting the graph"
msgstr ""

msgid "Sequential value starting from :math:`1`"
msgstr ""

msgid "Linear topological ordering of the vertices"
msgstr ""

msgid "Additional examples"
msgstr ""

msgid "Topologically sorting the one way segments"
msgstr ""

msgid "Graph is not a DAG"
msgstr ""

msgid ""
"`Boost: topological sort "
"<https://www.boost.org/libs/graph/doc/topological_sort.html>`__"
msgstr ""

msgid "``pgr_transitiveClosure`` - Experimental"
msgstr ""

msgid "``pgr_transitiveClosure``  Transitive closure graph of a directed graph."
msgstr ""

msgid ""
"Transforms the input directed graph into the transitive closure of the "
"graph."
msgstr ""

msgid "Process is valid for directed graphs."
msgstr ""

msgid "The transitive closure of an undirected graph produces a cluster graph"
msgstr ""

msgid ""
"Reachability between vertices on an undirected graph happens when they "
"belong to the same connected component. (see "
":doc:`pgr_connectedComponents`)"
msgstr ""

msgid "The returned values are not ordered"
msgstr ""

msgid "The returned graph is compressed"
msgstr ""

msgid "Running time: :math:`O(|V||E|)`"
msgstr ""

msgid "The pgr_transitiveClosure function has the following signature:"
msgstr ""

msgid "pgr_transitiveClosure(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-closure|"
msgstr ""

msgid "Rechability of a subgraph"
msgstr ""

msgid "Identifier of the source of the edges"
msgstr ""

msgid "``target_array``"
msgstr ""

msgid "Identifiers of the targets of the edges"
msgstr ""

msgid "Identifiers of the vertices that are reachable from vertex v."
msgstr ""

msgid ""
"`Boost: transitive closure "
"<https://www.boost.org/libs/graph/doc/transitive_closure.html>`__"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Transitive_closure"
msgstr ""

msgid "``pgr_trsp``"
msgstr ""

msgid "``pgr_trsp`` - routing vertices with restrictions."
msgstr ""

msgid "pgr_trsp(One to One)"
msgstr ""

msgid "pgr_trsp(One to Many)"
msgstr ""

msgid "pgr_trsp(Many to One)"
msgstr ""

msgid "pgr_trsp(Many to Many)"
msgstr ""

msgid "pgr_trsp(Combinations)"
msgstr ""

msgid "Deprecated signatures"
msgstr ""

msgid "pgr_trspViaVertices(text,anyarray,boolean,boolean,text)"
msgstr ""

msgid "New prototypes"
msgstr ""

msgid "pgr_trspViaVertices"
msgstr ""

msgid "pgr_trspViaEdges"
msgstr ""

msgid ""
"Turn restricted shortest path (TRSP) is an algorithm that receives turn "
"restrictions in form of a query like those found in real world navigable "
"road networks."
msgstr ""

msgid ""
"It does no guarantee the shortest path as it might contain restriction "
"paths."
msgstr ""

msgid "The general algorithm is as follows:"
msgstr ""

msgid "Execute a Dijkstra."
msgstr ""

msgid "If the solution passes thru a restriction then."
msgstr ""

msgid "Execute the **TRSP** algorithm with restrictions."
msgstr ""

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vids**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vids**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vids**, **end vids**,"
" [``directed``])"
msgstr ""

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, `Combinations SQL`_, "
"[``directed``])"
msgstr ""

msgid "From vertex :math:`6` to vertex :math:`10` on an undirected graph."
msgstr ""

#, python-brace-format
msgid ""
"From vertex :math:`6` to vertices :math:`\\{10, 1\\}` on an undirected "
"graph."
msgstr ""

#, python-brace-format
msgid "From vertices :math:`\\{6, 1\\}` to vertex :math:`8` on a directed graph."
msgstr ""

#, python-brace-format
msgid ""
"From vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 8\\}` on an "
"undirected graph."
msgstr ""

msgid "Using a combinations table on an undirected graph."
msgstr ""

msgid ""
"`Deprecated documentation "
"<https://docs.pgrouting.org/3.3/en/pgr_trsp.html>`_"
msgstr ""

msgid "``pgr_trspVia``"
msgstr ""

msgid ""
"``pgr_trspVia`` Route that goes through a list of vertices with "
"restrictions."
msgstr ""

#, python-brace-format
msgid ""
"Given a list of vertices and a graph, this function is equivalent to "
"finding the shortest path between :math:`vertex_i` and "
":math:`vertex_{i+1}` for all :math:`i < size\\_of(via\\;vertices)` trying"
" not to use restricted paths."
msgstr ""

msgid "The paths represents the sections of the route."
msgstr ""

msgid "Execute a :doc:`pgr_dijkstraVia`."
msgstr ""

msgid ""
"For the set of sub paths of the solution that pass through a restriction "
"then"
msgstr ""

msgid "Execute the **TRSP** algorithm with restrictions for the paths."
msgstr ""

msgid "**NOTE** when this is done, ``U_turn_on_edge`` flag is ignored."
msgstr ""

msgid ""
"pgr_trspVia(`Edges SQL`_, `Restrictions SQL`_, **via vertices**, "
"[**options**])"
msgstr ""

#, python-brace-format
msgid ""
"All this examples are about the route that visits the vertices "
":math:`\\{5, 7, 1, 8, 15\\}` in that order on a directed graph."
msgstr ""

msgid "Simulation of how algorithm works."
msgstr ""

msgid "The algorithm performs a :doc:`pgr_dijkstraVia`"
msgstr ""

msgid ""
"Detects which of the sub paths pass through a restriction in this case is"
" for the ``path_id = 5`` from ``6`` to ``3`` because the path :math:`15 "
"\\rightarrow 1` is restricted."
msgstr ""

msgid "Executes the :doc:`pgr_trsp` algorithm for the conflicting paths."
msgstr ""

msgid ""
"From the :doc:`pgr_dijkstraVia` result it removes the conflicting paths "
"and builds the solution with the results of the :doc:`pgr_trsp` "
"algorithm:"
msgstr ""

msgid "Getting the same result as ``pgr_trspVia``:"
msgstr ""

msgid "Example 8"
msgstr ""

msgid "Sometimes ``U_turn_on_edge`` flag is ignored when is set to ``false``."
msgstr ""

msgid ""
"The first step, doing a :doc:`pgr_dijkstraVia` does consider not making a"
" U turn on the same edge. But the path :math:`16 \\rightarrow 13` (Rows 4"
" and 5) is restricted and the result is using it."
msgstr ""

msgid ""
"When executing the :doc:`pgr_trsp` algorithm for the conflicting path, "
"there is no ``U_turn_on_edge`` flag."
msgstr ""

msgid ""
"Therefore the result ignores the ``U_turn_on_edge`` flag when set to "
"``false``."
msgstr ""

msgid ":doc:`via-category`"
msgstr ""

msgid "``pgr_trspVia_withPoints``"
msgstr ""

msgid ""
"``pgr_trspVia_withPoints`` - Route that goes through a list of vertices "
"and/or points with restrictions."
msgstr ""

#, python-brace-format
msgid ""
"Given a graph, a set of restriction on the graph edges, a set of points "
"on the graphs edges and a list of vertices, this function is equivalent "
"to finding the shortest path between :math:`vertex_i` and "
":math:`vertex_{i+1}` (where :math:`vertex` can be a vertex or a point on "
"the graph) for all :math:`i < size\\_of(via\\;vertices)` trying not to "
"use restricted paths."
msgstr ""

msgid "is a sequence of paths"
msgstr ""

msgid "Build the Graph with the new points."
msgstr ""

msgid "The points identifiers will be converted to negative values."
msgstr ""

msgid "The vertices identifiers will remain positive."
msgstr ""

msgid "Execute a :doc:`pgr_withPointsVia`."
msgstr ""

msgid "For the set of paths of the solution that pass through a restriction then"
msgstr ""

msgid "Execute the **TRSP** algorithm with restrictions for the path."
msgstr ""

msgid "Do not use negative values on identifiers of the inner queries."
msgstr ""

msgid ""
"pgr_trspVia_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**via vertices**, [**driving side**,] [**options**])"
msgstr ""

msgid "**options:** ``[directed, strict, U_turn_on_edge, details]``"
msgstr ""

#, python-brace-format
msgid ""
"Find the route that visits the vertices :math:`\\{-6, 15, -5\\}` in that "
"order on an directed graph."
msgstr ""

msgid "When positive it is considered a vertex identifier"
msgstr ""

msgid "When negative it is considered a point identifier"
msgstr ""

msgid "[**driving side**]"
msgstr ""

msgid ""
"Value in [``r``, ``R``, ``l``, ``L``, ``b``, ``B``] indicating if the "
"driving side is:"
msgstr ""

msgid "For directed graph:"
msgstr ""

msgid "[``r``, ``R``] for right driving side"
msgstr ""

msgid "[``l``, ``L``] for left driving side"
msgstr ""

msgid "For undirected graph:"
msgstr ""

msgid "[``b``, ``B``] for both driving sides"
msgstr ""

msgid "Default values when parameter is missing:"
msgstr ""

msgid "[``r``, ``R``] for directed graph"
msgstr ""

msgid "[``l``, ``L``] for undirected graph"
msgstr ""

msgid "With points optional parameters"
msgstr ""

msgid "``details``"
msgstr ""

msgid "For showing points stops."
msgstr ""

msgid "When ``true`` the results will include the points that are in the path."
msgstr ""

msgid ""
"When ``false`` the results will not include the points that are in the "
"path."
msgstr ""

msgid ""
"When ``start_vid``, ``end_vid`` and ``node`` columns have negative "
"values, the identifier is for a Point."
msgstr ""

msgid "Use ``pgr_findCloseEdges`` for points on the fly"
msgstr ""

msgid "Using :doc:`pgr_findCloseEdges`:"
msgstr ""

msgid ""
"Visit from vertex :math:`1` to the two locations on the graph of point "
"`(2.9, 1.8)` in order of closeness to the graph."
msgstr ""

msgid "Point :math:`-1` corresponds to the closest edge from point `(2.9, 1.8)`."
msgstr ""

msgid ""
"Point :math:`-2` corresponds to the next close edge from point `(2.9, "
"1.8)`."
msgstr ""

msgid ""
"Point :math:`-2` is visited on the route to from vertex :math:`1` to "
"Point :math:`-1` (See row where :math:`seq = 4`)."
msgstr ""

msgid "Usage variations"
msgstr ""

#, python-brace-format
msgid ""
"All this examples are about the route that visits the vertices "
":math:`\\{-6, 7, -4, 8, -2\\}` in that order on a directed graph."
msgstr ""

msgid "Status of \"passes in front\" or \"visits\" of the nodes and points."
msgstr ""

msgid "The algorithm performs a :doc:`pgr_withPointsVia`"
msgstr ""

msgid ""
"Detects which of the paths pass through a restriction in this case is for"
" the ``path_id = 1`` from ``-6`` to ``15`` because the path :math:`9 "
"\\rightarrow 16` is restricted."
msgstr ""

msgid "Executes the :ref:`TRSP-family:TRSP algorithm` for the conflicting paths."
msgstr ""

msgid ""
"From the :doc:`pgr_withPointsVia` result it removes the conflicting paths"
" and builds the solution with the results of the :doc:`pgr_trsp` "
"algorithm:"
msgstr ""

msgid "Getting the same result as ``pgr_trspVia_withPoints``:"
msgstr ""

msgid ""
"The first step, doing a :doc:`pgr_withPointsVia` does consider not making"
" a U turn on the same edge. But the path :math:`9 \\rightarrow 16` (Rows "
"4 and 5) is restricted and the result is using it."
msgstr ""

msgid ""
"When executing the :doc:`pgr_trsp_withPoints` algorithm for the "
"conflicting path, there is no ``U_turn_on_edge`` flag."
msgstr ""

msgid ""
"Therefore the result ignores the ``U_turn_on_edge`` flag when set to "
"``false``. From the :doc:`pgr_withPointsVia` result it removes the "
"conflicting paths and builds the solution with the results of the "
":doc:`pgr_trsp` algorithm. In this case a U turn is been done using the "
"same edge."
msgstr ""

msgid "``pgr_trsp_withPoints``"
msgstr ""

msgid "``pgr_trsp_withPoints`` Routing Vertex/Point with restrictions."
msgstr ""

msgid ""
"Modify the graph to include points defined by `Points SQL`_. Consider the"
" invalid paths on `Restrictions SQL`_. Using Dijkstra algorithm, find the"
" shortest path."
msgstr ""

msgid "Vertices of the graph are:"
msgstr ""

msgid "**positive** when it belongs to the `Edges SQL`_"
msgstr ""

msgid "**negative** when it belongs to the `Points SQL`_"
msgstr ""

msgid "The `agg_cost` in the non included values `(v, v)` is `0`"
msgstr ""

msgid "The `agg_cost` in the non included values `(u, v)` is :math:`\\infty`"
msgstr ""

msgid ""
"For optimization purposes, any duplicated value in the input arrays of "
"**start vids** or **end vids** or are ignored."
msgstr ""

msgid "Running time: :math:`O(|start\\_vids|\\times(V \\log V + E))`"
msgstr ""

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vid**, **end vid**, [**driving side**,] [**options**])"
msgstr ""

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vid**, **end vids**, [**driving side**,] [**options**])"
msgstr ""

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vids**, **end vid**, [**driving side**,] [**options**])"
msgstr ""

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vids**, **end vids**, [**driving side**,] [**options**])"
msgstr ""

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"`Combinations SQL`_, [**driving side**,] [**options**])"
msgstr ""

msgid "**options:** ``[directed, details]``"
msgstr ""

msgid ""
"From point :math:`1` to vertex :math:`10` with right driving side in "
"directed graph. (with details)"
msgstr ""

msgid ""
"From point :math:`1` to point :math:`3` and vertex :math:`7` on an "
"undirected graph"
msgstr ""

msgid ""
"From point :math:`1` and vertex :math:`6` to point :math:`3` with right "
"driving side in directed graph. (without details)"
msgstr ""

msgid ""
"From point :math:`1` and vertex :math:`6` to point :math:`3` and vertex "
":math:`1` with left side driving."
msgstr ""

msgid "Two combinations"
msgstr ""

msgid ""
"From point :math:`1` to vertex :math:`10`, and from vertex :math:`6` to "
"point :math:`3` with right side driving. (with details)"
msgstr ""

msgid "Use :doc:`pgr_findCloseEdges` in the `Points SQL`_."
msgstr ""

msgid ""
"Find the routes from vertex :math:`1` to the two closest locations on the"
" graph of point `(2.9, 1.8)`."
msgstr ""

#, python-brace-format
msgid ""
"All the examples are about traveling from point :math:`1` and vertex "
":math:`5` to points :math:`\\{2, 3, 6\\}` and vertices :math:`\\{10, "
"11\\}` with restrictions"
msgstr ""

msgid "Passes in front or visits with right side driving."
msgstr ""

msgid "For point :math:`6` and vertex :math:`11`."
msgstr ""

msgid "Passes in front or visits with left side driving."
msgstr ""

msgid "``pgr_turnRestrictedPath`` - Experimental"
msgstr ""

msgid ""
"``pgr_turnRestrictedPath`` Using Yen's algorithm Vertex - Vertex routing "
"with restrictions"
msgstr ""

msgid ""
"Using Yen's algorithm to obtain K shortest paths and analyze the paths to"
" select the paths that do not use the restrictions"
msgstr ""

msgid ""
"pgr_turnRestrictedPath(`Edges SQL`_, `Restrictions SQL`_, **start vid**, "
"**end vid**, **K**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, heap_paths, stop_on_first, strict]``"
msgstr ""

msgid "From vertex :math:`3` to vertex :math:`8` on a directed graph"
msgstr ""

msgid "Special optional parameters"
msgstr ""

msgid "``stop_on_first``"
msgstr ""

msgid "When ``true`` stops on first path found that dos not violate restrictions"
msgstr ""

msgid "When ``false`` returns at most K paths"
msgstr ""

msgid "When ``true`` returns only paths that do not violate restrictions"
msgstr ""

msgid "When ``false`` returns the paths found"
msgstr ""

msgid "From vertex :math:`3` to :math:`8` with ``strict`` flag on."
msgstr ""

msgid "No results because the only path available follows a restriction."
msgstr ""

msgid "From vertex :math:`3` to vertex :math:`8` on an undirected graph"
msgstr ""

msgid "From vertex :math:`3` to vertex :math:`8` with more alternatives"
msgstr ""

msgid "``pgr_version``"
msgstr ""

msgid "``pgr_version``  Query for pgRouting version information."
msgstr ""

msgid "Breaking change on result columns"
msgstr ""

msgid "Support for old signature ends"
msgstr ""

msgid "Returns pgRouting version information."
msgstr ""

msgid "pgr_version()"
msgstr ""

msgid "RETURNS ``TEXT``"
msgstr ""

msgid "pgRouting Version for this documentation"
msgstr ""

msgid "``pgr_vrpOneDepot`` - Experimental"
msgstr ""

msgid "**No documentation available**"
msgstr ""

msgid "**TBD**"
msgstr ""

msgid "TBD"
msgstr ""

msgid ""
"``pgr_withPoints`` - Returns the shortest path in a graph with additional"
" temporary vertices."
msgstr ""

msgid "pgr_withPoints(Combinations)"
msgstr ""

msgid ""
"Modify the graph to include points defined by `Points SQL`_. Using "
"Dijkstra algorithm, find the shortest path."
msgstr ""

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, "
"[**driving side**] [**options**])"
msgstr ""

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, "
"[**driving side**] [**options**])"
msgstr ""

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, "
"[**driving side**] [**options**])"
msgstr ""

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**,"
" [**driving side**] [**options**])"
msgstr ""

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, "
"[**driving side**] [**options**])"
msgstr ""

msgid "**options:** ``[directed, details])``"
msgstr ""

msgid ""
"From point :math:`1` to vertex :math:`10` with right driving side in "
"directed graph. (without details)"
msgstr ""

msgid ""
"Identifier of the starting vertex of the path. Negative value is for "
"points identifier."
msgstr ""

msgid ""
"Array of identifiers of starting vertices. Negative values are for "
"points identifiers."
msgstr ""

msgid ""
"Identifier of the ending vertex of the path. Negative value is for "
"points identifier."
msgstr ""

msgid ""
"Array of identifiers of ending vertices. Negative values are for points "
"identifiers."
msgstr ""

#, python-brace-format
msgid ""
"All the examples are about traveling from point :math:`1` and vertex "
":math:`5` to points :math:`\\{2, 3, 6\\}` and vertices :math:`\\{10, "
"11\\}`"
msgstr ""

msgid ""
"``pgr_withPointsCost`` - Calculates the shortest path and returns only "
"the aggregate cost of the shortest path found, for the combination of "
"points given."
msgstr ""

msgid "pgr_withPointsCost(Combinations)"
msgstr ""

msgid ""
"Modify the graph to include points defined by points_sql. Using Dijkstra "
"algorithm, return only the aggregate cost of the shortest path found."
msgstr ""

msgid ""
"Returns the sum of the costs of the shortest path for pair combination of"
" vertices in the modified graph."
msgstr ""

msgid "The returned values are in the form of a set of |matrix-result|."
msgstr ""

msgid "**positive** when it belongs to the edges_sql"
msgstr ""

msgid "**negative** when it belongs to the points_sql"
msgstr ""

msgid ""
"If the values returned are stored in a table, the unique index would be "
"the pair: `(start_vid, end_vid)`."
msgstr ""

msgid "For **undirected** graphs, the results are **symmetric**."
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vid**, **end "
"vid**, [**driving side**] [**options**])"
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vid**, **end "
"vids**, [**driving side**] [**options**])"
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vids**, **end "
"vid**, [**driving side**] [**options**])"
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vids**, **end "
"vids**, [**driving side**] [**options**])"
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, "
"[**driving side**] [**options**])"
msgstr ""

msgid "**options:** ``[directed]``"
msgstr ""

msgid ""
"There is no **details** flag, unlike the other members of the withPoints "
"family of functions."
msgstr ""

msgid ""
"From point :math:`1` to vertex :math:`10` with right driving side in "
"directed graph."
msgstr ""

msgid ""
"From point :math:`1` and vertex :math:`6` to point :math:`3` with right "
"driving side in directed graph."
msgstr ""

msgid ""
"From point :math:`1` to vertex :math:`10`, and from vertex :math:`6` to "
"point :math:`3` with right side driving."
msgstr ""

msgid ""
"Find the cost of the routes from vertex :math:`1` to the two closest "
"locations on the graph of point `(2.9, 1.8)`."
msgstr ""

msgid "Being close to the graph does not mean have a shorter route."
msgstr ""

msgid "Right side driving topology"
msgstr ""

#, python-brace-format
msgid ""
"Traveling from point :math:`1` and vertex :math:`5` to points "
":math:`\\{2, 3, 6\\}` and vertices :math:`\\{10, 11\\}`"
msgstr ""

msgid "Left side driving topology"
msgstr ""

msgid "Does not matter driving side driving topology"
msgstr ""

msgid ""
"``pgr_withPointsCostMatrix`` - Calculates a cost matrix using "
":doc:`pgr_withPoints`."
msgstr ""

msgid ""
"pgr_withPointsCostMatrix(`Edges SQL`_, `Points SQL`_, **start vids**, "
"[**driving side**] [**options**])"
msgstr ""

#, python-brace-format
msgid ""
"Cost matrix for points :math:`\\{1, 6\\}` and vertices :math:`\\{10, "
"11\\}` on an **undirected** graph"
msgstr ""

msgid "Returning a **symmetrical** cost matrix"
msgstr ""

msgid "Using the default ``side`` value on the **points_sql** query"
msgstr ""

msgid "Using the default ``driving side`` value"
msgstr ""

msgid ""
"Find the matrix cost of the routes from vertex :math:`1` and the two "
"closest locations on the graph of point `(2.9, 1.8)`."
msgstr ""

msgid ""
"``pgr_withPointsDD`` - Returns the driving **distance** from a starting "
"point."
msgstr ""

msgid "Output columns standardized to |result-spantree|"
msgstr ""

msgid "When ``details`` is ``false``:"
msgstr ""

msgid "Points reached within the distance are not included."
msgstr ""

msgid "Deprecated signatures:"
msgstr ""

msgid ""
"Modify the graph to include points and using Dijkstra algorithm, extracts"
" all the nodes and points that have costs less than or equal to the value"
" ``**distance**`` from the starting point. The edges extracted will "
"conform the corresponding spanning tree."
msgstr ""

msgid ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vid**, **distance**,"
" [**driving side**], [**options A**])"
msgstr ""

msgid ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vids**, "
"**distance**, [**driving side**], [**options B**])"
msgstr ""

msgid "**options A:** ``[directed, details]``"
msgstr ""

msgid "**options B:** ``[directed, details, equicost]``"
msgstr ""

msgid ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vid**, **distance**,"
" [**driving side**], [**options**])"
msgstr ""

msgid ""
"Right side driving topology, from point :math:`1` within a distance of "
":math:`3.3` with details."
msgstr ""

msgid ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vids**, "
"**distance**, [**driving side**], [**options**])"
msgstr ""

msgid "**options:** ``[directed, details, equicost]``"
msgstr ""

msgid ""
"From point :math:`1` and vertex :math:`16` within a distance of "
":math:`3.3` with ``equicost`` on a directed graph"
msgstr ""

msgid "Negative values represent a point"
msgstr ""

msgid ""
"Find the driving distance from the two closest locations on the graph of "
"point `(2.9, 1.8)`."
msgstr ""

msgid ""
"Point :math:`-1` corresponds to the closest edge from point :math:`(2.9, "
"1.8)`."
msgstr ""

msgid ""
"Point :math:`-2` corresponds to the next close edge from point "
":math:`(2.9, 1.8)`."
msgstr ""

msgid "Driving side does not matter"
msgstr ""

msgid ""
"From point :math:`1` within a distance of :math:`3.3`, does not matter "
"driving side, with details."
msgstr ""

msgid "``pgr_withPointsKSP``"
msgstr ""

msgid ""
"``pgr_withPointsKSP``  Yen's algorithm for K shortest paths using "
"Dijkstra."
msgstr ""

msgid "pgr_withPointsKSP(One to Many)"
msgstr ""

msgid "pgr_withPointsKSP(Many to One)"
msgstr ""

msgid "pgr_withPointsKSP(Many to Many)"
msgstr ""

msgid "pgr_withPointsKSP(Combinations)"
msgstr ""

msgid ""
"Modifies the graph to include the points defined in the `Points SQL`_ and"
" using Yen algorithm, finds the :math:`K` shortest paths."
msgstr ""

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end "
"vid**, **K**, [**driving side**], [**options**])"
msgstr ""

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end "
"vids**, **K**, [**driving side**], [**options**])"
msgstr ""

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end "
"vid**, **K**, [**driving side**], [**options**])"
msgstr ""

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end "
"vids**, **K**, [**driving side**], [**options**])"
msgstr ""

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, "
"**K**, [**driving side**], [**options**])"
msgstr ""

msgid "**options:** ``[directed, heap_paths, details]``"
msgstr ""

msgid ""
"Get 2 paths from Point :math:`1` to point :math:`2` on a directed graph "
"with **left** side driving."
msgstr ""

msgid "For a directed graph."
msgstr ""

msgid "No details are given about distance of other points of the query."
msgstr ""

msgid "No heap paths are returned."
msgstr ""

msgid ""
"Get 2 paths from point :math:`1` to point :math:`3` and vertex :math:`7` "
"on an undirected graph"
msgstr ""

msgid ""
"Get a path from point :math:`1` and vertex :math:`6` to point :math:`3` "
"on a **directed** graph with **right** side driving and **details** set "
"to **True**"
msgstr ""

msgid ""
"Get a path from point :math:`1` and vertex :math:`6` to point :math:`3` "
"and vertex :math:`1` on a **directed** graph with **left** side driving "
"and **heap_paths** set to **True**"
msgstr ""

msgid "Using a combinations table on an **directed** graph"
msgstr ""

msgid "Number of required paths"
msgstr ""

msgid "withPointsKSP optional parameters"
msgstr ""

msgid ""
"Get :math:`2` paths using left side driving topology, from vertex "
":math:`1` to the closest location on the graph of point `(2.9, 1.8)`."
msgstr ""

msgid "Left driving side"
msgstr ""

msgid ""
"Get :math:`2` paths using left side driving topology, from point "
":math:`1` to point :math:`3` with details."
msgstr ""

msgid "Right driving side"
msgstr ""

msgid ""
"Get :math:`2` paths using right side driving topology from, point "
":math:`1` to point :math:`2` with heap paths and details."
msgstr ""

msgid "``pgr_withPointsVia``"
msgstr ""

msgid ""
"``pgr_withPointsVia`` - Route that goes through a list of vertices and/or"
" points."
msgstr ""

#, python-brace-format
msgid ""
"Given a graph, a set of points on the graphs edges and a list of "
"vertices, this function is equivalent to finding the shortest path "
"between :math:`vertex_i` and :math:`vertex_{i+1}` (where :math:`vertex` "
"can be a vertex or a point on the graph) for all :math:`i < "
"size\\_of(via\\;vertices)`."
msgstr ""

msgid ""
"pgr_withPointsVia(`Edges SQL`_, `Points SQL`_, **via vertices**, "
"[**driving side**] [**options**])"
msgstr ""

#, python-brace-format
msgid ""
"Find the route that visits the vertices :math:`\\{ -6, 15, -1\\}` in that"
" order with right driving side in directed graph.."
msgstr ""

msgid "Use :doc:`pgr_findCloseEdges` in the `Points SQL`_"
msgstr ""

#, python-brace-format
msgid ""
"All this examples are about the route that visits the vertices "
":math:`\\{-1, 7, -3, 16, 15\\}` in that order on a **directed** graph."
msgstr ""

msgid "Prim - Family of functions"
msgstr ""

msgid ""
"The prim algorithm was developed in 1930 by Czech mathematician Vojtch "
"Jarnk. It is a greedy algorithm that finds a minimum spanning tree for a"
" weighted undirected graph. This means it finds a subset of the edges "
"that forms a tree that includes every vertex, where the total weight of "
"all the edges in the tree is minimized. The algorithm operates by "
"building this tree one vertex at a time, from an arbitrary starting "
"vertex, at each step adding the cheapest possible connection from the "
"tree to another vertex."
msgstr ""

msgid ""
"This algorithms find the minimum spanning forest in a possibly "
"disconnected graph; in contrast, the most basic form of Prim's algorithm "
"only finds minimum spanning trees in connected graphs. However, running "
"Prim's algorithm separately for each connected component of the graph, "
"then it is called minimum spanning forest."
msgstr ""

msgid ""
"From boost Graph: \"The algorithm as implemented in Boost.Graph does not "
"produce correct results on graphs with parallel edges.\""
msgstr ""

msgid ""
"Boost: `Prim's algorithm "
"<https://www.boost.org/libs/graph/doc/prim_minimum_spanning_tree.html>`__"
msgstr ""

#, python-format
msgid ""
"Wikipedia: `Prim's algorithm "
"<https://en.wikipedia.org/wiki/Prim%27s_algorithm>`__"
msgstr ""

msgid "Proposed Functions"
msgstr ""

msgid ""
":doc:`pgr_lineGraph` - Transformation algorithm for generating a Line "
"Graph."
msgstr ""

msgid "Reference"
msgstr ""

msgid "Release Notes"
msgstr ""

msgid ""
"To see the full list of changes check the list of `Git commits "
"<https://github.com/pgRouting/pgrouting/commits>`_ on Github."
msgstr ""

msgid "Mayors"
msgstr ""

msgid "pgRouting 4"
msgstr ""

msgid "Minors 4.x"
msgstr ""

msgid "pgRouting 4.0"
msgstr ""

msgid "pgRouting 3"
msgstr ""

msgid "Minors 3.x"
msgstr ""

msgid "pgRouting 3.8"
msgstr ""

msgid "pgRouting 3.8.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.8.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.8.0%22>`__"
msgstr ""

msgid "Promotion to official function of pgRouting."
msgstr ""

msgid "Metric"
msgstr ""

msgid ""
"`#2760 <https://github.com/pgRouting/pgrouting/issues/2760>`__: Promoted "
"to official pgr_degree in version 3.8"
msgstr ""

msgid "Utilities"
msgstr ""

msgid ""
"`#2772 <https://github.com/pgRouting/pgrouting/issues/2772>`__: Promoted "
"to official pgr_extractVertices in version 3.8"
msgstr ""

msgid ""
"`#2774 <https://github.com/pgRouting/pgrouting/issues/2774>`__: Promoted "
"to official pgr_findCloseEdges in version 3.8"
msgstr ""

msgid ""
"`#2873 <https://github.com/pgRouting/pgrouting/issues/2873>`__: Promoted "
"to official pgr_separateCrossing in version 3.8"
msgstr ""

msgid ""
"`#2874 <https://github.com/pgRouting/pgrouting/issues/2874>`__: Promoted "
"to official pgr_separateTouching in version 3.8"
msgstr ""

msgid "Proposed functions"
msgstr ""

msgid "Contraction"
msgstr ""

msgid ""
"`#2790 <https://github.com/pgRouting/pgrouting/issues/2790>`__: "
"pgr_contractionDeadEnd new contraction function"
msgstr ""

msgid ""
"`#2791 <https://github.com/pgRouting/pgrouting/issues/2791>`__: "
"pgr_contractionLinear new contraction function"
msgstr ""

msgid ""
"`#2536 <https://github.com/pgRouting/pgrouting/issues/2536>`__: Support "
"for contraction hierarchies (pgr_contractionHierarchies)"
msgstr ""

msgid ""
"`#2848 <https://github.com/pgRouting/pgrouting/issues/2848>`__: Create "
"pgr_separateCrossing new utility function"
msgstr ""

msgid ""
"`#2849 <https://github.com/pgRouting/pgrouting/issues/2849>`__: Create of"
" pgr_separateTouching new utility function"
msgstr ""

msgid "Official functions changes"
msgstr ""

msgid ""
"`#2786 <https://github.com/pgRouting/pgrouting/issues/2786>`__: "
"pgr_contraction(edges) new signature"
msgstr ""

msgid "C/C++ code enhancements"
msgstr ""

msgid ""
"`#2802 <https://github.com/pgRouting/pgrouting/issues/2802>`__: Code "
"reorganization on pgr_contraction"
msgstr ""

msgid "Other enhancements:"
msgstr ""

msgid "`#2869 <https://github.com/pgRouting/pgrouting/issues/2869>`__:"
msgstr ""

msgid "SQL code enhancements"
msgstr ""

msgid ""
"`#2850 <https://github.com/pgRouting/pgrouting/issues/2850>`__: Rewrite "
"pgr_nodeNetwork"
msgstr ""

msgid "Deprecation of SQL functions"
msgstr ""

msgid ""
"`#2749 <https://github.com/pgRouting/pgrouting/issues/2749>`__: Deprecate"
" pgr_AlphaShape in 3.8"
msgstr ""

msgid ""
"`#2750 <https://github.com/pgRouting/pgrouting/issues/2750>`__: Deprecate"
" pgr_CreateTopology in 3.8"
msgstr ""

msgid ""
"`#2753 <https://github.com/pgRouting/pgrouting/issues/2753>`__: Deprecate"
" pgr_analyzeGraph in 3.8"
msgstr ""

msgid ""
"`#2754 <https://github.com/pgRouting/pgrouting/issues/2754>`__: Deprecate"
" pgr_analyzeOneWay in 3.8"
msgstr ""

msgid ""
"`#2826 <https://github.com/pgRouting/pgrouting/issues/2826>`__: Deprecate"
" pgr_createVerticesTable in 3.8"
msgstr ""

msgid "In the deprecated functions:"
msgstr ""

msgid "Migration section is created."
msgstr ""

msgid "The use of the functions is removed in the documentation."
msgstr ""

msgid "pgRouting 3.7"
msgstr ""

msgid "pgRouting 3.7.3 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.7.3 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.3%22>`__"
msgstr ""

msgid ""
"`#2731 <https://github.com/pgRouting/pgrouting/issues/2731>`__: Build "
"Failure on Ubuntu 22"
msgstr ""

msgid "pgRouting 3.7.2 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.7.2 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.2%22>`__"
msgstr ""

msgid ""
"`#2713 <https://github.com/pgRouting/pgrouting/issues/2713>`__: cmake "
"missing some policies and min version"
msgstr ""

msgid "Using OLD policies: CMP0148, CMP0144, CMP0167"
msgstr ""

msgid "Minimum cmake version 3.12"
msgstr ""

msgid ""
"`#2707 <https://github.com/pgRouting/pgrouting/issues/2707>`__: Build "
"failure in pgRouting 3.7.1 on Alpine"
msgstr ""

msgid ""
"`#2706 <https://github.com/pgRouting/pgrouting/issues/2706>`__: winnie "
"crashing on pgr_betweennessCentrality"
msgstr ""

msgid "pgRouting 3.7.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.7.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.1%22>`__"
msgstr ""

msgid ""
"`#2680 <https://github.com/pgRouting/pgrouting/issues/2680>`__: fails to "
"compile under mingw64 gcc 13.2"
msgstr ""

msgid ""
"`#2689 <https://github.com/pgRouting/pgrouting/issues/2689>`__: When "
"point is a vertex, the withPoints family do not return results."
msgstr ""

msgid "C/C++ code enhancemet"
msgstr ""

msgid "TRSP family"
msgstr ""

msgid "pgRouting 3.7.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.7.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.0%22>`__"
msgstr ""

msgid "Support"
msgstr ""

msgid ""
"`#2656 <https://github.com/pgRouting/pgrouting/issues/2656>`__: Stop "
"support of PostgreSQL12 on pgrouting v3.7"
msgstr ""

msgid "Stopping support of PostgreSQL 12"
msgstr ""

msgid "CI does not test for PostgreSQL 12"
msgstr ""

msgid "pgr_betweennessCentrality"
msgstr ""

msgid ""
"`#2605 <https://github.com/pgRouting/pgrouting/issues/2605>`__: "
"Standardize spanning tree functions output"
msgstr ""

msgid "Functions:"
msgstr ""

msgid "Experimental promoted to proposed."
msgstr ""

msgid ""
"`#2635 <https://github.com/pgRouting/pgrouting/issues/2635>`__: "
"pgr_LineGraph ignores directed flag and use negative values for "
"identifiers."
msgstr ""

msgid "``pgr_lineGraph``"
msgstr ""

msgid "Code enhancement"
msgstr ""

msgid ""
"`#2599 <https://github.com/pgRouting/pgrouting/issues/2599>`__: Driving "
"distance cleanup"
msgstr ""

msgid ""
"`#2607 <https://github.com/pgRouting/pgrouting/issues/2607>`__: Read "
"postgresql data on C++"
msgstr ""

msgid ""
"`#2614 <https://github.com/pgRouting/pgrouting/issues/2614>`__: Clang "
"tidy does not work"
msgstr ""

msgid "pgRouting 3.6"
msgstr ""

msgid "pgRouting 3.6.3 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.6.3 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.3%22>`__"
msgstr ""

msgid "Explicit minimum requirements:"
msgstr ""

msgid "postgres 11.0.0"
msgstr ""

msgid "postgis 3.0.0"
msgstr ""

msgid "g++ 13+ is supported"
msgstr ""

msgid "Code fixes"
msgstr ""

msgid "Fix warnings from cpplint."
msgstr ""

msgid "Fix warnings from clang 18."
msgstr ""

msgid "CI tests"
msgstr ""

msgid "Add a clang tidy test on changed files."
msgstr ""

msgid ""
"Update test not done on versions: 3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.1.0, "
"3.1.1, 3.1.2"
msgstr ""

msgid "Documentation"
msgstr ""

msgid "Results of documentation queries adujsted to boost 1.83.0 version:"
msgstr ""

msgid "pgr_stoerWagner"
msgstr ""

msgid "pgtap tests"
msgstr ""

msgid "bug fixes"
msgstr ""

msgid "pgRouting 3.6.2 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.6.2 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.2%22>`__"
msgstr ""

msgid "Upgrade fix"
msgstr ""

msgid "The upgrade was failing for same minor"
msgstr ""

msgid "Fix warnings from cpplint"
msgstr ""

msgid "Others"
msgstr ""

msgid "Adjust NEWS generator"
msgstr ""

msgid "Name change to `NEWS.md` for better visualization on GitHub"
msgstr ""

msgid "pgRouting 3.6.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.6.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.1%22>`__"
msgstr ""

msgid ""
"`#2588 <https://github.com/pgRouting/pgrouting/issues/2588>`__: pgrouting"
" 3.6.0 fails to build on OSX"
msgstr ""

msgid "pgRouting 3.6.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.6.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.0%22>`__"
msgstr ""

msgid ""
"`#2516 <https://github.com/pgRouting/pgrouting/issues/2516>`__: "
"Standardize output pgr_aStar"
msgstr ""

msgid "Standardize output columns to |short-generic-result|"
msgstr ""

msgid ""
"`#2523 <https://github.com/pgRouting/pgrouting/issues/2523>`__: "
"Standardize output pgr_bdAstar"
msgstr ""

msgid ""
"`#2547 <https://github.com/pgRouting/pgrouting/issues/2547>`__: "
"Standardize output and modifying signature pgr_KSP"
msgstr ""

msgid ""
"`#2548 <https://github.com/pgRouting/pgrouting/issues/2548>`__: "
"Standardize output pgr_drivingDistance"
msgstr ""

msgid "Proposed functions changes"
msgstr ""

msgid ""
"`#2544 <https://github.com/pgRouting/pgrouting/issues/2544>`__: "
"Standardize output and modifying signature pgr_withPointsDD"
msgstr ""

msgid ""
"`#2546 <https://github.com/pgRouting/pgrouting/issues/2546>`__: "
"Standardize output and modifying signature pgr_withPointsKSP"
msgstr ""

msgid ""
"`#2504 <https://github.com/pgRouting/pgrouting/issues/2504>`__: To C++ pg"
" data get, fetch and check."
msgstr ""

msgid "Stopping support for compilation with MSVC."
msgstr ""

msgid ""
"`#2505 <https://github.com/pgRouting/pgrouting/issues/2505>`__: Using "
"namespace."
msgstr ""

msgid ""
"`#2512 <https://github.com/pgRouting/pgrouting/issues/2512>`__: "
"[Dijkstra] Removing duplicate code on Dijkstra."
msgstr ""

msgid ""
"`#2517 <https://github.com/pgRouting/pgrouting/issues/2517>`__: Astar "
"code simplification."
msgstr ""

msgid ""
"`#2521 <https://github.com/pgRouting/pgrouting/issues/2521>`__: Dijkstra "
"code simplification."
msgstr ""

msgid ""
"`#2522 <https://github.com/pgRouting/pgrouting/issues/2522>`__: bdAstar "
"code simplification."
msgstr ""

msgid ""
"`#2490 <https://github.com/pgRouting/pgrouting/issues/2490>`__: Automatic"
" page history links."
msgstr ""

msgid "..rubric:: Standardize SQL"
msgstr ""

msgid ""
"`#2555 <https://github.com/pgRouting/pgrouting/issues/2555>`__: "
"Standardize deprecated messages"
msgstr ""

msgid ""
"On new internal function: do not use named parameters and default "
"parameters."
msgstr ""

msgid "pgRouting 3.5"
msgstr ""

msgid "pgRouting 3.5.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.5.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.5.1%22>`__"
msgstr ""

msgid "Documentation fixes"
msgstr ""

msgid "Changes on the documentation to the following:"
msgstr ""

msgid "pgr_degree"
msgstr ""

msgid "pgr_ksp"
msgstr ""

msgid "Automatic page history links"
msgstr ""

msgid "using bootstrap_version 2 because 3+ does not do dropdowns"
msgstr ""

msgid "Issue fixes"
msgstr ""

msgid ""
"`#2565 <https://github.com/pgRouting/pgrouting/issues/2565>`__: "
"pgr_lengauerTarjanDominatorTree triggers an assertion"
msgstr ""

msgid "SQL enhancements"
msgstr ""

msgid ""
"`#2561 <https://github.com/pgRouting/pgrouting/issues/2561>`__: Not use "
"wildcards on SQL"
msgstr ""

msgid ""
"`#2559 <https://github.com/pgRouting/pgrouting/issues/2559>`__: pgtap "
"test using sampledata"
msgstr ""

msgid "Build fixes"
msgstr ""

msgid "Fix winnie build"
msgstr ""

msgid "Fix clang warnings"
msgstr ""

msgid "Grouping headers of postgres readers"
msgstr ""

msgid "pgRouting 3.5.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.5.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.5.0%22>`__"
msgstr ""

msgid "Dijkstra"
msgstr ""

msgid "pgRouting 3.4"
msgstr ""

msgid "pgRouting 3.4.2 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.4.2 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.2%22>`__"
msgstr ""

msgid ""
"`#2394 <https://github.com/pgRouting/pgrouting/issues/2394>`__: "
"pgr_bdAstar accumulates heuristic cost in visited node cost."
msgstr ""

msgid ""
"`#2427 <https://github.com/pgRouting/pgrouting/issues/2427>`__: "
"pgr_createVerticesTable & pgr_createTopology, variable should be of type "
"Record."
msgstr ""

msgid "pgRouting 3.4.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.4.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.1%22>`__"
msgstr ""

msgid ""
"`#2401 <https://github.com/pgRouting/pgrouting/issues/2401>`__: pgRouting"
" 3.4.0 do not build docs when sphinx is too low or missing"
msgstr ""

msgid ""
"`#2398 <https://github.com/pgRouting/pgrouting/issues/2398>`__: v3.4.0 "
"does not upgrade from 3.3.3"
msgstr ""

msgid "pgRouting 3.4.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.4.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.0%22>`__"
msgstr ""

msgid ""
"`#1891 <https://github.com/pgRouting/pgrouting/issues/1891>`__: pgr_ksp "
"doesn't give all correct shortest path"
msgstr ""

msgid "New proposed functions."
msgstr ""

msgid "With points"
msgstr ""

msgid "pgr_withPointsVia(One Via)"
msgstr ""

msgid "Turn Restrictions"
msgstr ""

msgid "Via with turn restrictions"
msgstr ""

msgid "pgr_trspVia(One Via)"
msgstr ""

msgid "pgr_trspVia_withPoints(One Via)"
msgstr ""

msgid "pgr_trsp_withPoints(One to One)"
msgstr ""

msgid "pgr_trsp_withPoints(One to Many)"
msgstr ""

msgid "pgr_trsp_withPoints(Many to One)"
msgstr ""

msgid "pgr_trsp_withPoints(Many to Many)"
msgstr ""

msgid "pgr_trsp_withPoints(Combinations)"
msgstr ""

msgid "Topology"
msgstr ""

msgid "pgr_findCloseEdges(One point)"
msgstr ""

msgid "pgr_findCloseEdges(Many points)"
msgstr ""

msgid "pgr_cuthillMckeeOrdering"
msgstr ""

msgid "Unclassified"
msgstr ""

msgid "pgr_hawickCircuits"
msgstr ""

msgid "Flow functions"
msgstr ""

msgid "pgr_maxCardinalityMatch(text)"
msgstr ""

msgid "Deprecating: pgr_maxCardinalityMatch(text,boolean)"
msgstr ""

msgid "Deprecated Functions"
msgstr ""

msgid "pgr_trsp(text,integer,float8,integer,float8,boolean,boolean,text)"
msgstr ""

msgid "pgr_trspViaEdges(text,integer[],float[],boolean,boolean,text)"
msgstr ""

msgid "pgRouting 3.3"
msgstr ""

msgid "pgRouting 3.3.5 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.3.5 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.5%22>`__"
msgstr ""

msgid "pgRouting 3.3.4 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.3.4 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.4%22>`__"
msgstr ""

msgid ""
"`#2400 <https://github.com/pgRouting/pgrouting/issues/2400>`__: pgRouting"
" 3.3.3 does not build in focal"
msgstr ""

msgid "pgRouting 3.3.3 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.3.3 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.3%22>`__"
msgstr ""

msgid ""
"Ignoring optional boolean parameter, as the algorithm works only for "
"undirected graphs."
msgstr ""

msgid "pgRouting 3.3.2 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.3.2 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.2%22>`__"
msgstr ""

msgid "Revised documentation"
msgstr ""

msgid "Simplifying table names and table columns, for example:"
msgstr ""

msgid "``edges`` instead of ``edge_table``"
msgstr ""

msgid "Removing unused columns ``category_id`` and ``reverse_category_id``."
msgstr ""

msgid "``combinations`` instead of ``combinations_table``"
msgstr ""

msgid "Using PostGIS standard for geometry column."
msgstr ""

msgid "``geom`` instead of ``the_geom``"
msgstr ""

msgid "Avoiding usage of functions that modify indexes, columns etc on tables."
msgstr ""

msgid "Using ``pgr_extractVertices`` to create a routing topology"
msgstr ""

msgid "Restructure of the pgRouting concepts page."
msgstr ""

msgid ""
"`#2276 <https://github.com/pgRouting/pgrouting/issues/2276>`__: "
"edgeDisjointPaths issues with start_vid and combinations"
msgstr ""

msgid ""
"`#2312 <https://github.com/pgRouting/pgrouting/issues/2312>`__: "
"pgr_extractVertices error when target is not BIGINT"
msgstr ""

msgid ""
"`#2357 <https://github.com/pgRouting/pgrouting/issues/2357>`__: Apply "
"clang-tidy performance-*"
msgstr ""

msgid "pgRouting 3.3.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.3.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.1%22>`__"
msgstr ""

msgid ""
"`#2216 <https://github.com/pgRouting/pgrouting/issues/2216>`__: Warnings "
"when using clang"
msgstr ""

msgid ""
"`#2266 <https://github.com/pgRouting/pgrouting/issues/2266>`__: Error "
"processing restrictions"
msgstr ""

msgid "pgRouting 3.3.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.3.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.0%22>`__"
msgstr ""

msgid ""
"`#2057 <https://github.com/pgRouting/pgrouting/issues/2057>`__: "
"trspViaEdges columns in different order"
msgstr ""

msgid ""
"`#2087 <https://github.com/pgRouting/pgrouting/issues/2087>`__: "
"pgr_extractVertices to proposed"
msgstr ""

msgid ""
"`#2201 <https://github.com/pgRouting/pgrouting/issues/2201>`__: "
"pgr_depthFirstSearch to proposed"
msgstr ""

msgid ""
"`#2202 <https://github.com/pgRouting/pgrouting/issues/2202>`__: "
"pgr_sequentialVertexColoring to proposed"
msgstr ""

msgid ""
"`#2203 <https://github.com/pgRouting/pgrouting/issues/2203>`__: "
"pgr_dijkstraNear and pgr_dijkstraNearCost to proposed"
msgstr ""

msgid "Coloring"
msgstr ""

msgid "Experimental promoted to Proposed"
msgstr ""

msgid "pgr_dijkstraNear"
msgstr ""

msgid "pgr_dijkstraNear(Combinations)"
msgstr ""

msgid "pgr_dijkstraNear(Many to Many)"
msgstr ""

msgid "pgr_dijkstraNear(Many to One)"
msgstr ""

msgid "pgr_dijkstraNear(One to Many)"
msgstr ""

msgid "pgr_dijkstraNearCost"
msgstr ""

msgid "pgr_dijkstraNearCost(Combinations)"
msgstr ""

msgid "pgr_dijkstraNearCost(Many to Many)"
msgstr ""

msgid "pgr_dijkstraNearCost(Many to One)"
msgstr ""

msgid "pgr_dijkstraNearCost(One to Many)"
msgstr ""

msgid "pgr_extractVertices"
msgstr ""

msgid "Traversal"
msgstr ""

msgid "pgr_depthFirstSearch(Multiple vertices)"
msgstr ""

msgid "pgr_depthFirstSearch(Single vertex)"
msgstr ""

msgid "pgRouting 3.2"
msgstr ""

msgid "pgRouting 3.2.2 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.2.2 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.2.2%22>`__"
msgstr ""

msgid ""
"`#2093 <https://github.com/pgRouting/pgrouting/issues/2093>`__: "
"Compilation on Visual Studio"
msgstr ""

msgid ""
"`#2189 <https://github.com/pgRouting/pgrouting/issues/2189>`__: Build "
"error on RHEL 7"
msgstr ""

msgid "pgRouting 3.2.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.2.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.2.1%22>`__"
msgstr ""

msgid ""
"`#1883 <https://github.com/pgRouting/pgrouting/issues/1883>`__: "
"pgr_TSPEuclidean crashes connection on Windows"
msgstr ""

msgid "The solution is to use Boost::graph::metric_tsp_approx"
msgstr ""

msgid ""
"To not break user's code the optional parameters related to the TSP "
"Annaeling are ignored"
msgstr ""

msgid "The function with the annaeling optional parameters is deprecated"
msgstr ""

msgid "pgRouting 3.2.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.2.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.2.0%22>`__"
msgstr ""

msgid ""
"`#1850 <https://github.com/pgRouting/pgrouting/issues/1850>`__: Change "
"Boost min version to 1.56"
msgstr ""

msgid "Removing support for Boost v1.53, v1.54 & v1.55"
msgstr ""

msgid "Dijkstra Near"
msgstr ""

msgid "pgr_isPlanar"
msgstr ""

msgid "pgr_lengauerTarjanDominatorTree"
msgstr ""

msgid "pgr_makeConnected"
msgstr ""

msgid "Astar"
msgstr ""

msgid "Bidirectional Astar"
msgstr ""

msgid "Bidirectional Dijkstra"
msgstr ""

msgid "pgRouting 3.1"
msgstr ""

msgid "pgRouting 3.1.4 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.1.4 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.4%22>`__"
msgstr ""

msgid "Issues fixes"
msgstr ""

msgid "pgRouting 3.1.3 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.1.3 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.3%22>`__"
msgstr ""

msgid ""
"`#1825 <https://github.com/pgRouting/pgrouting/issues/1825>`__: Boost "
"versions are not honored"
msgstr ""

msgid ""
"`#1849 <https://github.com/pgRouting/pgrouting/issues/1849>`__: Boost "
"1.75.0 geometry \"point_xy.hpp\" build error on macOS environment"
msgstr ""

msgid ""
"`#1861 <https://github.com/pgRouting/pgrouting/issues/1861>`__: vrp "
"functions crash server"
msgstr ""

msgid "pgRouting 3.1.2 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.1.2 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.2%22>`__"
msgstr ""

msgid ""
"`#1304 <https://github.com/pgRouting/pgrouting/issues/1304>`__: FreeBSD "
"12 64-bit crashes on pgr_vrOneDepot tests Experimental Function"
msgstr ""

msgid ""
"`#1356 <https://github.com/pgRouting/pgrouting/issues/1356>`__: "
"tools/testers/pg_prove_tests.sh fails when PostgreSQL port is not passed"
msgstr ""

msgid ""
"`#1725 <https://github.com/pgRouting/pgrouting/issues/1725>`__: Server "
"crash on pgr_pickDeliver and pgr_vrpOneDepot on openbsd"
msgstr ""

msgid ""
"`#1760 <https://github.com/pgRouting/pgrouting/issues/1760>`__: TSP "
"server crash on ubuntu 20.04 #1760"
msgstr ""

msgid ""
"`#1770 <https://github.com/pgRouting/pgrouting/issues/1770>`__: Remove "
"warnings when using clang compiler"
msgstr ""

msgid "pgRouting 3.1.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.1.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.1%22>`__"
msgstr ""

msgid ""
"`#1733 <https://github.com/pgRouting/pgrouting/issues/1733>`__: "
"pgr_bdAstar fails when source or target vertex does not exist in the "
"graph"
msgstr ""

msgid ""
"`#1647 <https://github.com/pgRouting/pgrouting/issues/1647>`__: Linear "
"Contraction contracts self loops"
msgstr ""

msgid ""
"`#1640 <https://github.com/pgRouting/pgrouting/issues/1640>`__: "
"pgr_withPoints fails when points_sql is empty"
msgstr ""

msgid ""
"`#1616 <https://github.com/pgRouting/pgrouting/issues/1616>`__: Path "
"evaluation on C++ not updated before the results go back to C"
msgstr ""

msgid ""
"`#1300 <https://github.com/pgRouting/pgrouting/issues/1300>`__: "
"pgr_chinesePostman crash on test data"
msgstr ""

msgid "pgRouting 3.1.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.1.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.0%22>`__"
msgstr ""

msgid "pgr_dijkstra(combinations)"
msgstr ""

msgid "pgr_dijkstraCost(combinations)"
msgstr ""

msgid "Build changes"
msgstr ""

msgid "Minimal requirement for Sphinx: version 1.8"
msgstr ""

msgid "pgRouting 3.0"
msgstr ""

msgid "pgRouting 3.0.6 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.0.6 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.6%22>`__"
msgstr ""

msgid "pgRouting 3.0.5 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.0.5 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.5%22>`__"
msgstr ""

msgid "Backport issue fixes"
msgstr ""

msgid "pgRouting 3.0.4 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.0.4 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.4%22>`__"
msgstr ""

msgid "pgRouting 3.0.3 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.0.3 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.3%22>`__"
msgstr ""

msgid "pgRouting 3.0.2 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.0.2 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.2%22>`__"
msgstr ""

msgid ""
"`#1378 <https://github.com/pgRouting/pgrouting/issues/1378>`__: Visual "
"Studio build failing"
msgstr ""

msgid "pgRouting 3.0.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.0.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.1%22>`__"
msgstr ""

msgid ""
"`#232 <https://github.com/pgRouting/pgrouting/issues/232>`__: Honor "
"client cancel requests in C /C++ code"
msgstr ""

msgid "pgRouting 3.0.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 3.0.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.0%22>`__"
msgstr ""

msgid "Fixed Issues"
msgstr ""

msgid ""
"`#1153 <https://github.com/pgRouting/pgrouting/issues/1153>`__: Renamed "
"pgr_eucledianTSP to pgr_TSPeuclidean"
msgstr ""

msgid ""
"`#1188 <https://github.com/pgRouting/pgrouting/issues/1188>`__: Removed "
"CGAL dependency"
msgstr ""

msgid ""
"`#1002 <https://github.com/pgRouting/pgrouting/issues/1002>`__: Fixed "
"contraction issues:"
msgstr ""

msgid ""
"`#1004 <https://github.com/pgRouting/pgrouting/issues/1004>`__: Contracts"
" when forbidden vertices do not belong to graph"
msgstr ""

msgid ""
"`#1005 <https://github.com/pgRouting/pgrouting/issues/1005>`__: "
"Intermideate results eliminated"
msgstr ""

msgid ""
"`#1006 <https://github.com/pgRouting/pgrouting/issues/1006>`__: No loss "
"of information"
msgstr ""

msgid "New Functions"
msgstr ""

msgid "Kruskal family"
msgstr ""

msgid "pgr_kruskal"
msgstr ""

msgid "pgr_kruskalBFS"
msgstr ""

msgid "pgr_kruskalDD"
msgstr ""

msgid "pgr_kruskalDFS"
msgstr ""

msgid "Prim family"
msgstr ""

msgid "pgr_prim"
msgstr ""

msgid "pgr_primDD"
msgstr ""

msgid "pgr_primDFS"
msgstr ""

msgid "pgr_primBFS"
msgstr ""

msgid "Proposed moved to official on pgRouting"
msgstr ""

msgid "aStar Family"
msgstr ""

msgid "pgr_aStarCost(One to One)"
msgstr ""

msgid "pgr_aStarCost(One to Many)"
msgstr ""

msgid "pgr_aStarCost(Many to One)"
msgstr ""

msgid "pgr_aStarCost(Many to Many)"
msgstr ""

msgid "pgr_aStarCostMatrix"
msgstr ""

msgid "bdAstar Family"
msgstr ""

msgid "pgr_bdAstarCost(One to One)"
msgstr ""

msgid "pgr_bdAstarCost(One to Many)"
msgstr ""

msgid "pgr_bdAstarCost(Many to One)"
msgstr ""

msgid "pgr_bdAstarCost(Many to Many)"
msgstr ""

msgid "pgr_bdAstarCostMatrix"
msgstr ""

msgid "bdDijkstra Family"
msgstr ""

msgid "pgr_bdDijkstraCost(One to One)"
msgstr ""

msgid "pgr_bdDijkstraCost(One to Many)"
msgstr ""

msgid "pgr_bdDijkstraCost(Many to One)"
msgstr ""

msgid "pgr_bdDijkstraCost(Many to Many)"
msgstr ""

msgid "pgr_bdDijkstraCostMatrix"
msgstr ""

msgid "Flow Family"
msgstr ""

msgid "pgr_pushRelabel(One to One)"
msgstr ""

msgid "pgr_pushRelabel(One to Many)"
msgstr ""

msgid "pgr_pushRelabel(Many to One)"
msgstr ""

msgid "pgr_pushRelabel(Many to Many)"
msgstr ""

msgid "pgr_edmondsKarp(One to One)"
msgstr ""

msgid "pgr_edmondsKarp(One to Many)"
msgstr ""

msgid "pgr_edmondsKarp(Many to One)"
msgstr ""

msgid "pgr_edmondsKarp(Many to Many)"
msgstr ""

msgid "pgr_boykovKolmogorov (One to One)"
msgstr ""

msgid "pgr_boykovKolmogorov (One to Many)"
msgstr ""

msgid "pgr_boykovKolmogorov (Many to One)"
msgstr ""

msgid "pgr_boykovKolmogorov (Many to Many)"
msgstr ""

msgid "pgr_maxCardinalityMatching"
msgstr ""

msgid "pgr_edgeDisjointPaths(One to One)"
msgstr ""

msgid "pgr_edgeDisjointPaths(One to Many)"
msgstr ""

msgid "pgr_edgeDisjointPaths(Many to One)"
msgstr ""

msgid "pgr_edgeDisjointPaths(Many to Many)"
msgstr ""

msgid "Components family"
msgstr ""

msgid "pgr_connectedComponents"
msgstr ""

msgid "pgr_strongComponents"
msgstr ""

msgid "pgr_biconnectedComponents"
msgstr ""

msgid "pgr_articulationPoints"
msgstr ""

msgid "pgr_bridges"
msgstr ""

msgid "Contraction:"
msgstr ""

msgid "Removed unnecessary column seq"
msgstr ""

msgid "Bug Fixes"
msgstr ""

msgid "pgr_maxFlowMinCost"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost"
msgstr ""

msgid "pgr_dagShortestpath"
msgstr ""

msgid "VRP category"
msgstr ""

msgid "pgr_pickDeliverEuclidean"
msgstr ""

msgid "pgr_pickDeliver"
msgstr ""

msgid "Chinese Postman family"
msgstr ""

msgid "pgr_chinesePostman"
msgstr ""

msgid "pgr_chinesePostmanCost"
msgstr ""

msgid "Breadth First Search family"
msgstr ""

msgid "Bellman Ford family"
msgstr ""

msgid "Moved to legacy"
msgstr ""

msgid "pgr_labelGraph - Use the components family of functions instead."
msgstr ""

msgid "Max flow - functions were renamed on v2.5.0"
msgstr ""

msgid "pgr_maxFlowPushRelabel"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp"
msgstr ""

msgid "pgr_maximumcardinalitymatching"
msgstr ""

msgid "VRP"
msgstr ""

msgid "pgr_gsoc_vrppdtw"
msgstr ""

msgid "TSP old signatures"
msgstr ""

msgid "pgr_pointsAsPolygon"
msgstr ""

msgid "pgr_alphaShape old signature"
msgstr ""

msgid "pgRouting 2"
msgstr ""

msgid "Minors 2.x"
msgstr ""

msgid "pgRouting 2.6"
msgstr ""

msgid "pgRouting 2.6.3 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.6.3 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.6.3%22>`__"
msgstr ""

msgid ""
"`#1219 <https://github.com/pgRouting/pgrouting/issues/1219>`__: Implicit "
"cast for via_path integer to text"
msgstr ""

msgid ""
"`#1193 <https://github.com/pgRouting/pgrouting/issues/1193>`__: Fixed "
"pgr_pointsAsPolygon breaking when comparing strings in WHERE clause"
msgstr ""

msgid ""
"`#1185 <https://github.com/pgRouting/pgrouting/issues/1185>`__: Improve "
"FindPostgreSQL.cmake"
msgstr ""

msgid "pgRouting 2.6.2 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.6.2 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.6.2%22>`__"
msgstr ""

msgid ""
"`#1152 <https://github.com/pgRouting/pgrouting/issues/1152>`__: Fixes "
"driving distance when vertex is not part of the graph"
msgstr ""

msgid ""
"`#1098 <https://github.com/pgRouting/pgrouting/issues/1098>`__: Fixes "
"windows test"
msgstr ""

msgid ""
"`#1165 <https://github.com/pgRouting/pgrouting/issues/1165>`__: Fixes "
"build for python3 and perl5"
msgstr ""

msgid "pgRouting 2.6.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.6.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.6.1%22>`__"
msgstr ""

msgid "Fixes server crash on several functions."
msgstr ""

msgid "pgr_floydWarshall"
msgstr ""

msgid "pgr_johnson"
msgstr ""

msgid "pgr_bdDijstra"
msgstr ""

msgid "pgr_alphashape"
msgstr ""

msgid "pgr_dijkstraCostMatrix"
msgstr ""

msgid "pgr_drivingDistance"
msgstr ""

msgid "pgr_dijkstraVia (proposed)"
msgstr ""

msgid "pgr_boykovKolmogorov (proposed)"
msgstr ""

msgid "pgr_edgeDisjointPaths (proposed)"
msgstr ""

msgid "pgr_edmondsKarp (proposed)"
msgstr ""

msgid "pgr_maxCardinalityMatch (proposed)"
msgstr ""

msgid "pgr_maxFlow (proposed)"
msgstr ""

msgid "pgr_withPoints (proposed)"
msgstr ""

msgid "pgr_withPointsCost (proposed)"
msgstr ""

msgid "pgr_withPointsKSP (proposed)"
msgstr ""

msgid "pgr_withPointsDD (proposed)"
msgstr ""

msgid "pgr_withPointsCostMatrix (proposed)"
msgstr ""

msgid "pgr_contractGraph (experimental)"
msgstr ""

msgid "pgr_pushRelabel (experimental)"
msgstr ""

msgid "pgr_vrpOneDepot (experimental)"
msgstr ""

msgid "pgr_gsoc_vrppdtw (experimental)"
msgstr ""

msgid "Fixes for deprecated functions where also applied but not tested"
msgstr ""

msgid "Removed compilation warning for g++8"
msgstr ""

msgid "Fixed a fallthrugh on Astar and bdAstar."
msgstr ""

msgid "pgRouting 2.6.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.6.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.6.0%22>`__"
msgstr ""

msgid "pgr_lineGraphFull"
msgstr ""

msgid ""
"Fix pgr_trsp(text,integer,double precision,integer,double "
"precision,boolean,boolean[,text])"
msgstr ""

msgid "without restrictions"
msgstr ""

msgid "calls pgr_dijkstra when both end points have a fraction IN (0,1)"
msgstr ""

msgid "calls pgr_withPoints when at least one fraction NOT IN (0,1)"
msgstr ""

msgid "with restrictions"
msgstr ""

msgid "calls original trsp code"
msgstr ""

msgid "Internal code"
msgstr ""

msgid ""
"Cleaned the internal code of trsp(text,integer,integer,boolean,boolean [,"
" text])"
msgstr ""

msgid "Removed the use of pointers"
msgstr ""

msgid "Internal code can accept BIGINT"
msgstr ""

msgid "Cleaned the internal code of withPoints"
msgstr ""

msgid "pgRouting 2.5"
msgstr ""

msgid "pgRouting 2.5.5 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.5.5 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.5%22>`__"
msgstr ""

msgid "Fixes driving distance when vertex is not part of the graph"
msgstr ""

msgid "Fixes windows test"
msgstr ""

msgid "Fixes build for python3 and perl5"
msgstr ""

msgid "pgRouting 2.5.4 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.5.4 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.4%22>`__"
msgstr ""

msgid "pgRouting 2.5.3 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.5.3 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.3%22>`__"
msgstr ""

msgid ""
"Fix for postgresql 11: Removed a compilation error when compiling with "
"postgreSQL"
msgstr ""

msgid "pgRouting 2.5.2 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.5.2 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.2%22>`__"
msgstr ""

msgid "Fix for postgresql 10.1: Removed a compiler condition"
msgstr ""

msgid "pgRouting 2.5.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.5.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.1%22>`__"
msgstr ""

msgid "Fixed prerequisite minimum version of: cmake"
msgstr ""

msgid "pgRouting 2.5.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.5.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.0%22>`__"
msgstr ""

msgid "enhancement:"
msgstr ""

msgid "pgr_version is now on SQL language"
msgstr ""

msgid "Breaking change on:"
msgstr ""

msgid "pgr_edgeDisjointPaths:"
msgstr ""

msgid "Added path_id, cost and agg_cost columns on the result"
msgstr ""

msgid "Parameter names changed"
msgstr ""

msgid "The many version results are the union of the One to One version"
msgstr ""

msgid "New Signatures"
msgstr ""

msgid "pgr_bdAstar(One to One)"
msgstr ""

msgid "pgr_lineGraph"
msgstr ""

msgid "pgr_bdastar - use pgr_bdAstar instead"
msgstr ""

msgid "Renamed functions"
msgstr ""

msgid "pgr_maxFlowPushRelabel - use pgr_pushRelabel instead"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp -use pgr_edmondsKarp instead"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov - use pgr_boykovKolmogorov instead"
msgstr ""

msgid "pgr_maximumCardinalityMatching - use pgr_maxCardinalityMatch instead"
msgstr ""

msgid "Deprecated Function"
msgstr ""

msgid "pgr_pointToEdgeNode"
msgstr ""

msgid "pgRouting 2.4"
msgstr ""

msgid "pgRouting 2.4.2 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.4.2 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.4.2%22>`__"
msgstr ""

msgid "Improvement"
msgstr ""

msgid "Works for postgreSQL 10"
msgstr ""

msgid "Fixed: Unexpected error column \"cname\""
msgstr ""

msgid "Replace __linux__ with __GLIBC__ for glibc-specific headers and functions"
msgstr ""

msgid "pgRouting 2.4.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.4.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.4.1%22>`__"
msgstr ""

msgid "Fixed compiling error on macOS"
msgstr ""

msgid "Condition error on pgr_withPoints"
msgstr ""

msgid "pgRouting 2.4.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.4.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.4.0%22>`__"
msgstr ""

msgid "Deprecated signatures."
msgstr ""

msgid "pgr_bddijkstra - use pgr_bdDijkstra instead"
msgstr ""

msgid "pgr_pointsToVids"
msgstr ""

msgid "Bug fixes on proposed functions"
msgstr ""

msgid "pgr_withPointsKSP: fixed ordering"
msgstr ""

msgid "TRSP original code is used with no changes on the compilation warnings"
msgstr ""

msgid "pgRouting 2.3"
msgstr ""

msgid "pgRouting 2.3.2 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.3.2 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.3.2%22>`__"
msgstr ""

msgid "Fixed pgr_gsoc_vrppdtw crash when all orders fit on one truck."
msgstr ""

msgid "Fixed pgr_trsp:"
msgstr ""

msgid "Alternate code is not executed when the point is in reality a vertex"
msgstr ""

msgid "Fixed ambiguity on seq"
msgstr ""

msgid "pgRouting 2.3.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.3.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.3.1%22>`__"
msgstr ""

msgid "Leaks on proposed max_flow functions"
msgstr ""

msgid "Regression error on pgr_trsp"
msgstr ""

msgid "Types discrepancy on pgr_createVerticesTable"
msgstr ""

msgid "pgRouting 2.3.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.3.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.3.0%22>`__"
msgstr ""

msgid "pgr_TSP"
msgstr ""

msgid "pgr_eucledianTSP"
msgstr ""

msgid "pgr_maxFlowPushRelabel(One to One)"
msgstr ""

msgid "pgr_maxFlowPushRelabel(One to Many)"
msgstr ""

msgid "pgr_maxFlowPushRelabel(Many to One)"
msgstr ""

msgid "pgr_maxFlowPushRelabel(Many to Many)"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp(One to One)"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp(One to Many)"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp(Many to One)"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp(Many to Many)"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov (One to One)"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov (One to Many)"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov (Many to One)"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov (Many to Many)"
msgstr ""

msgid "pgr_maximumCardinalityMatching"
msgstr ""

msgid "pgr_contractGraph"
msgstr ""

msgid "pgr_tsp - use pgr_TSP or pgr_eucledianTSP instead"
msgstr ""

msgid "pgr_aStar - use pgr_aStar instead"
msgstr ""

msgid "pgr_flip_edges"
msgstr ""

msgid "pgr_vidsToDmatrix"
msgstr ""

msgid "pgr_pointsToDMatrix"
msgstr ""

msgid "pgr_textToPoints"
msgstr ""

msgid "pgRouting 2.2"
msgstr ""

msgid "pgRouting 2.2.4 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.2.4 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.2.4%22>`__"
msgstr ""

msgid "Bogus uses of extern \"C\""
msgstr ""

msgid "Build error on Fedora 24 + GCC 6.0"
msgstr ""

msgid "Regression error pgr_nodeNetwork"
msgstr ""

msgid "pgRouting 2.2.3 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.2.3 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.2.3%22>`__"
msgstr ""

msgid "Fixed compatibility issues with PostgreSQL 9.6."
msgstr ""

msgid "pgRouting 2.2.2 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.2.2 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.2.2%22>`__"
msgstr ""

msgid "Fixed regression error on pgr_drivingDistance"
msgstr ""

msgid "pgRouting 2.2.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.2.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.2.1%22>`__"
msgstr ""

msgid "Server crash fix on pgr_alphaShape"
msgstr ""

msgid "Bug fix on With Points family of functions"
msgstr ""

msgid "pgRouting 2.2.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.2.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.2.0%22>`__"
msgstr ""

msgid "Improvements"
msgstr ""

msgid "pgr_nodeNetwork"
msgstr ""

msgid "Adding a row_where and outall optional parameters"
msgstr ""

msgid "Signature fix"
msgstr ""

msgid "pgr_dijkstra -- to match what is documented"
msgstr ""

msgid "pgr_Johnson"
msgstr ""

msgid "pgr_dijkstraCost(One to One)"
msgstr ""

msgid "pgr_dijkstraCost(One to Many)"
msgstr ""

msgid "pgr_dijkstraCost(Many to One)"
msgstr ""

msgid "pgr_dijkstraCost(Many to Many)"
msgstr ""

msgid "Proposed Functionality"
msgstr ""

msgid "pgr_withPoints(One to One)"
msgstr ""

msgid "pgr_withPoints(One to Many)"
msgstr ""

msgid "pgr_withPoints(Many to One)"
msgstr ""

msgid "pgr_withPoints(Many to Many)"
msgstr ""

msgid "pgr_withPointsCost(One to One)"
msgstr ""

msgid "pgr_withPointsCost(One to Many)"
msgstr ""

msgid "pgr_withPointsCost(Many to One)"
msgstr ""

msgid "pgr_withPointsCost(Many to Many)"
msgstr ""

msgid "pgr_withPointsDD(single vertex)"
msgstr ""

msgid "pgr_withPointsDD(multiple vertices)"
msgstr ""

msgid "pgr_dijkstraVia"
msgstr ""

msgid "pgr_apspWarshall use pgr_floydWarshall instead"
msgstr ""

msgid "pgr_apspJohnson use pgr_Johnson instead"
msgstr ""

msgid "pgr_kDijkstraCost use pgr_dijkstraCost instead"
msgstr ""

msgid "pgr_kDijkstraPath use pgr_dijkstra instead"
msgstr ""

msgid "Renamed and Deprecated Function"
msgstr ""

msgid "pgr_makeDistanceMatrix renamed to _pgr_makeDistanceMatrix"
msgstr ""

msgid "pgRouting 2.1"
msgstr ""

msgid "pgRouting 2.1.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.1.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.1.0%22>`__"
msgstr ""

msgid "Refactored"
msgstr ""

msgid "pgr_dijkstra(One to One)"
msgstr ""

msgid ""
"pgr_alphaShape function now can generate better (multi)polygon with holes"
" and alpha parameter."
msgstr ""

msgid ""
"Proposed functions from Steve Woodbridge, (Classified as Convenience by "
"the author.)"
msgstr ""

msgid ""
"pgr_pointToEdgeNode - convert a point geometry to a vertex_id based on "
"closest edge."
msgstr ""

msgid ""
"pgr_flipEdges - flip the edges in an array of geometries so the connect "
"end to end."
msgstr ""

msgid ""
"pgr_textToPoints - convert a string of x,y;x,y;... locations into point "
"geometries."
msgstr ""

msgid "pgr_pointsToVids - convert an array of point geometries into vertex ids."
msgstr ""

msgid "pgr_pointsToDMatrix - Create a distance matrix from an array of points."
msgstr ""

msgid "pgr_vidsToDMatrix - Create a distance matrix from an array of vertix_id."
msgstr ""

msgid "Added proposed functions from GSoc Projects:"
msgstr ""

msgid "pgr_vrppdtw"
msgstr ""

msgid "pgr_vrponedepot"
msgstr ""

msgid "pgr_getColumnName"
msgstr ""

msgid "pgr_getTableName"
msgstr ""

msgid "pgr_isColumnCndexed"
msgstr ""

msgid "pgr_isColumnInTable"
msgstr ""

msgid "pgr_quote_ident"
msgstr ""

msgid "pgr_versionless"
msgstr ""

msgid "pgr_startPoint"
msgstr ""

msgid "pgr_endPoint"
msgstr ""

msgid "pgr_pointToId"
msgstr ""

msgid "No longer supported"
msgstr ""

msgid "Removed the 1.x legacy functions"
msgstr ""

msgid "Some bug fixes in other functions"
msgstr ""

msgid "Refactoring Internal Code"
msgstr ""

msgid "A C and C++ library for developer was created"
msgstr ""

msgid "encapsulates postgreSQL related functions"
msgstr ""

msgid "encapsulates Boost.Graph graphs"
msgstr ""

msgid "Directed Boost.Graph"
msgstr ""

msgid "Undirected Boost.graph."
msgstr ""

msgid "allow any-integer in the id's"
msgstr ""

msgid "allow any-numerical on the cost/reverse_cost columns"
msgstr ""

msgid ""
"Instead of generating many libraries: - All functions are encapsulated in"
" one library - The library has the prefix 2-1-0"
msgstr ""

msgid "pgRouting 2.0"
msgstr ""

msgid "pgRouting 2.0.1 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.0.1 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.0.1%22>`__"
msgstr ""

msgid "Minor bug fixes."
msgstr ""

msgid "No track of the bug fixes were kept."
msgstr ""

msgid "pgRouting 2.0.0 Release Notes"
msgstr ""

#, python-format
msgid ""
"To see all issues & pull requests closed by this release see the `Github "
"milestone for 2.0.0 "
"<https://github.com/pgRouting/pgrouting/issues?utf8=%E2%9C%93&q=milestone%3A%22Release%202.0.0%22>`__"
msgstr ""

msgid ""
"With the release of pgRouting 2.0.0 the library has abandoned backwards "
"compatibility to `pgRouting 1.0`_ releases. The main Goals for this "
"release are:"
msgstr ""

msgid "Major restructuring of pgRouting."
msgstr ""

msgid "Standardization of the function naming"
msgstr ""

msgid "Preparation of the project for future development."
msgstr ""

msgid "As a result of this effort:"
msgstr ""

msgid "pgRouting has a simplified structure"
msgstr ""

msgid "Significant new functionality has being added"
msgstr ""

msgid "Documentation has being integrated"
msgstr ""

msgid "Testing has being integrated"
msgstr ""

msgid "And made it easier for multiple developers to make contributions."
msgstr ""

msgid "Important Changes"
msgstr ""

msgid ""
"Graph Analytics - tools for detecting and fixing connection some problems"
" in a graph"
msgstr ""

msgid "A collection of useful utility functions"
msgstr ""

msgid ""
"Two new All Pairs Short Path algorithms (pgr_apspJohnson, "
"pgr_apspWarshall)"
msgstr ""

msgid ""
"Bi-directional Dijkstra and A-star search algorithms (pgr_bdAstar, "
"pgr_bdDijkstra)"
msgstr ""

msgid "One to many nodes search (pgr_kDijkstra)"
msgstr ""

msgid "K alternate paths shortest path (pgr_ksp)"
msgstr ""

msgid ""
"New TSP solver that simplifies the code and the build process (pgr_tsp), "
"dropped \"Gaul Library\" dependency"
msgstr ""

msgid "Turn Restricted shortest path (pgr_trsp) that replaces Shooting Star"
msgstr ""

msgid "Dropped support for Shooting Star"
msgstr ""

msgid ""
"Built a test infrastructure that is run before major code changes are "
"checked in"
msgstr ""

msgid ""
"Tested and fixed most all of the outstanding bugs reported against 1.x "
"that existing in the 2.0-dev code base."
msgstr ""

msgid "Improved build process for Windows"
msgstr ""

msgid "Automated testing on Linux and Windows platforms trigger by every commit"
msgstr ""

msgid "Modular library design"
msgstr ""

msgid "Compatibility with PostgreSQL 9.1 or newer"
msgstr ""

msgid "Compatibility with PostGIS 2.0 or newer"
msgstr ""

msgid "Installs as PostgreSQL EXTENSION"
msgstr ""

msgid "Return types re factored and unified"
msgstr ""

msgid "Support for table SCHEMA in function parameters"
msgstr ""

msgid "Support for ``st_`` PostGIS function prefix"
msgstr ""

msgid "Added ``pgr_`` prefix to functions and types"
msgstr ""

msgid "Better documentation: https://docs.pgrouting.org"
msgstr ""

msgid "shooting_star is discontinued"
msgstr ""

msgid "pgRouting 1"
msgstr ""

msgid "pgRouting 1.0"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"1.x "
"<https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release+1.x%22+is%3Aclosed>`_"
" on Github. The following release notes have been copied from the "
"previous ``RELEASE_NOTES`` file and are kept as a reference."
msgstr ""

msgid "Changes for release 1.05"
msgstr ""

msgid "Changes for release 1.03"
msgstr ""

msgid "Much faster topology creation"
msgstr ""

msgid "Changes for release 1.02"
msgstr ""

msgid "Shooting* bug fixes"
msgstr ""

msgid "Compilation problems solved"
msgstr ""

msgid "Changes for release 1.01"
msgstr ""

msgid "Changes for release 1.0"
msgstr ""

msgid "Core and extra functions are separated"
msgstr ""

msgid "Cmake build process"
msgstr ""

msgid "Changes for release 1.0.0b"
msgstr ""

msgid "Additional SQL file with more simple names for wrapper functions"
msgstr ""

msgid "Changes for release 1.0.0a"
msgstr ""

msgid "Shooting* shortest path algorithm for real road networks"
msgstr ""

msgid "Several SQL bugs were fixed"
msgstr ""

msgid "Changes for release 0.9.9"
msgstr ""

msgid "PostgreSQL 8.2 support"
msgstr ""

msgid ""
"Shortest path functions return empty result if they could not find any "
"path"
msgstr ""

msgid "Changes for release 0.9.8"
msgstr ""

msgid "Renumbering scheme was added to shortest path functions"
msgstr ""

msgid "Directed shortest path functions were added"
msgstr ""

msgid "routing_postgis.sql was modified to use dijkstra in TSP search"
msgstr ""

msgid "Function Families"
msgstr ""

msgid "Sample Data"
msgstr ""

msgid ""
"The documentation provides very simple example queries based on a small "
"sample network that resembles a city. To be able to execute the majority "
"of the examples queries, follow the instructions below."
msgstr ""

msgid "Main graph"
msgstr ""

msgid "A graph consists of a set of edges and a set of vertices."
msgstr ""

msgid "The following city is to be inserted into the database:"
msgstr ""

msgid ""
"Information known at this point is the geometry of the edges, cost "
"values, capacity values, category values and some locations that are not "
"in the graph."
msgstr ""

msgid ""
"The process to have working topology starts by inserting the edges. After"
" that everything else is calculated."
msgstr ""

msgid ""
"The database design for the documentation of pgRouting, keeps in the same"
" row 2 segments, one in the direction of the geometry and the second in "
"the opposite direction. Therefore some information has the ``reverse_`` "
"prefix which corresponds to the segment on the opposite direction of the "
"geometry."
msgstr ""

msgid "Identifier of the starting vertex of the geometry ``geom``."
msgstr ""

msgid "Identifier of the ending vertex of the geometry ``geom``"
msgstr ""

msgid "Cost to traverse from `source` to ``target``."
msgstr ""

msgid "Cost to traverse from `target` to ``source``."
msgstr ""

msgid "Flow capacity from `source` to ``target``."
msgstr ""

msgid "Flow capacity from `target` to ``source``."
msgstr ""

msgid "``category``"
msgstr ""

msgid "``reverse_category``"
msgstr ""

msgid ":math:`x` coordinate of the starting vertex of the geometry."
msgstr ""

msgid ""
"For convenience it is saved on the table but can be calculated as "
"``ST_X(ST_StartPoint(geom))``."
msgstr ""

msgid ":math:`y` coordinate of the ending vertex of the geometry."
msgstr ""

msgid ""
"For convenience it is saved on the table but can be calculated as "
"``ST_Y(ST_EndPoint(geom))``."
msgstr ""

msgid "The geometry of the segments."
msgstr ""

msgid "Starting on PostgreSQL 12::"
msgstr ""

msgid ""
"Optionally indexes on different columns can be created. The "
"recommendation is to have"
msgstr ""

msgid "``id`` indexed."
msgstr ""

msgid "``source`` and ``target`` columns indexed to speed up pgRouting queries."
msgstr ""

msgid ""
"``geom`` indexed to speed up geometry processes that might be needed in "
"the front end."
msgstr ""

msgid "For this small example the indexes are skipped, except for ``id``"
msgstr ""

msgid "Edges data"
msgstr ""

msgid "Inserting into the database the information of the edges:"
msgstr ""

msgid ""
"Negative values on the cost, capacity and category means that the edge do"
" not exist."
msgstr ""

msgid "Vertices"
msgstr ""

msgid ""
"The vertex information is calculated based on the identifier of the edge "
"and the geometry and saved on a table. Saving all the information "
"provided by :doc:`pgr_extractVertices`:"
msgstr ""

msgid ""
"In this case the because the ``CREATE`` statement was not used, the "
"definition of an index on the table is needed."
msgstr ""

msgid "The structure of the table is:"
msgstr ""

msgid "Vertices data"
msgstr ""

msgid "The saved information of the vertices is:"
msgstr ""

msgid ""
"Here is where adding more columns to the vertices table can be done. "
"Additional columns names and types will depend on the application."
msgstr ""

msgid "The topology"
msgstr ""

msgid ""
"This queries based on the vertices data create a topology by filling the "
"``source`` and ``target`` columns in the edges table."
msgstr ""

msgid "Topology data"
msgstr ""

msgid "Points outside the graph"
msgstr ""

msgid "Support tables"
msgstr ""

msgid ""
"Many functions can be used with a combinations of ``(source, target)`` "
"pairs when wanting a route from ``source`` to ``target``."
msgstr ""

msgid ""
"For convenience of this documentation, some combinations will be stored "
"on a table:"
msgstr ""

msgid "Inserting the data:"
msgstr ""

msgid "Combinations data"
msgstr ""

msgid "Some functions accept soft restrictions about the segments."
msgstr ""

msgid "Images"
msgstr ""

msgid "Red arrows correspond when ``cost`` > 0 in the edge table."
msgstr ""

msgid "Blue arrows correspond when ``reverse_cost`` > 0 in the edge table."
msgstr ""

msgid "Points are outside the graph."
msgstr ""

msgid "Click on the graph to enlarge."
msgstr ""

msgid "Directed graph with ``cost`` and ``reverse_cost``"
msgstr ""

msgid ""
"When working with city networks, this is recommended for point of view of"
" vehicles."
msgstr ""

msgid "Directed, with cost and reverse_cost"
msgstr ""

msgid "Undirected graph with ``cost`` and ``reverse_cost``"
msgstr ""

msgid ""
"When working with city networks, this is recommended for point of view of"
" pedestrians."
msgstr ""

msgid "Undirected, with cost and reverse cost"
msgstr ""

msgid "Directed graph with ``cost``"
msgstr ""

msgid "Directed, with cost"
msgstr ""

msgid "Undirected graph with ``cost``"
msgstr ""

msgid "Undirected, with cost"
msgstr ""

msgid "Pick & Deliver Data"
msgstr ""

msgid "Spanning Tree - Category"
msgstr ""

msgid ""
"A spanning tree of an undirected graph is a tree that includes all the "
"vertices of G with the minimum possible number of edges."
msgstr ""

msgid ""
"For a disconnected graph, there there is no single tree, but a spanning "
"forest, consisting of a spanning tree of each connected component."
msgstr ""

msgid "Characteristics:"
msgstr ""

msgid ""
"pgRouting community support is available through the `pgRouting website "
"<https://pgrouting.org/support.html>`_, `documentation "
"<https://docs.pgrouting.org>`_, tutorials, mailing lists and others. If "
"youre looking for :ref:`commercial support <support_commercial>`, find "
"below a list of companies providing pgRouting development and consulting "
"services."
msgstr ""

msgid "Reporting Problems"
msgstr ""

msgid ""
"Bugs are reported and managed in an `issue tracker "
"<https://github.com/pgrouting/pgrouting/issues>`_. Please follow these "
"steps:"
msgstr ""

msgid ""
"Search the tickets to see if your problem has already been reported. If "
"so, add any extra context you might have found, or at least indicate that"
" you too are having the problem. This will help us prioritize common "
"issues."
msgstr ""

msgid ""
"If your problem is unreported, create a `new issue "
"<https://github.com/pgRouting/pgrouting/issues/new>`__ for it."
msgstr ""

msgid ""
"In your report include explicit instructions to replicate your issue. The"
" best tickets include the exact SQL necessary to replicate a problem."
msgstr ""

msgid ""
"If you can test older versions of PostGIS for your problem, please do. On"
" your ticket, note the earliest version the problem appears."
msgstr ""

msgid ""
"For the versions where you can replicate the problem, note the operating "
"system and version of pgRouting, PostGIS and PostgreSQL."
msgstr ""

msgid ""
"It is recommended to use the following wrapper on the problem to pin "
"point the step that is causing the problem."
msgstr ""

msgid "Mailing List, Matrix, GIS StackExchange"
msgstr ""

msgid ""
"There are two mailing lists for pgRouting hosted on OSGeo discourse "
"server:"
msgstr ""

msgid ""
"User mailing list: https://discourse.osgeo.org/c/pgrouting/pgrouting-"
"users/"
msgstr ""

msgid ""
"Developer mailing list: https://discourse.osgeo.org/c/pgrouting"
"/pgrouting-dev/"
msgstr ""

msgid "Subscribe: https://discourse.osgeo.org/g/pgrouting-dev"
msgstr ""

msgid ""
"For general questions and topics about how to use pgRouting, please write"
" to the user mailing list."
msgstr ""

msgid ""
"If you want to chat with fellow pgRouting users and contributors, you can"
" join our matrix channel: `pgRouting matrix channel "
"<https://matrix.to/#/#pgrouting:osgeo.org>`_."
msgstr ""

msgid ""
"You can also ask at `GIS StackExchange <https://gis.stackexchange.com/>`_"
" and tag the question with ``pgrouting``. Find all questions tagged with "
"``pgrouting`` under "
"https://gis.stackexchange.com/questions/tagged/pgrouting or subscribe to "
"the `pgRouting questions feed "
"<https://gis.stackexchange.com/feeds/tag?tagnames=pgrouting&sort=newest>`_."
msgstr ""

msgid "Commercial Support"
msgstr ""

msgid ""
"For users who require professional support, development and consulting "
"services, consider contacting any of the following organizations, which "
"have significantly contributed to the development of pgRouting:"
msgstr ""

msgid "**Company**"
msgstr ""

msgid "**Offices in**"
msgstr ""

msgid "**Website**"
msgstr ""

msgid "Germany, Japan"
msgstr ""

msgid "https://georepublic.info"
msgstr ""

msgid "United States"
msgstr ""

msgid "https://www.paragoncorporation.com"
msgstr ""

msgid "Netlab"
msgstr ""

msgid "Capranica, Italy"
msgstr ""

msgid "https://www.osgeo.org/service-providers/netlab/"
msgstr ""

msgid "Transformation - Family of functions"
msgstr ""

msgid ""
"This family of functions is used for transforming a given input graph "
":math:`G(V,E)` into a new graph :math:`G'(V',E')`."
msgstr ""

msgid "Traversal - Family of functions"
msgstr ""

msgid "Additionally there are 2 categories under this family"
msgstr ""

msgid "Utility functions"
msgstr ""

msgid "Via - Category"
msgstr ""

msgid "This category intends to solve the general problem:"
msgstr ""

#, python-brace-format
msgid ""
"Given a graph and a list of vertices, find the shortest path between "
":math:`vertex_i` and :math:`vertex_{i+1}` for all vertices"
msgstr ""

msgid ""
"In other words, find a continuous route that visits all the vertices in "
"the order given."
msgstr ""

msgid "path"
msgstr ""

msgid "represents a section of a **route**."
msgstr ""

msgid "route"
msgstr ""

msgid "is a sequence of **paths**"
msgstr ""

msgid "**Used in:**"
msgstr ""

msgid ""
"Besides the compulsory parameters each function has, there are optional "
"parameters that exist due to the kind of function."
msgstr ""

msgid "Used in all Via functions"
msgstr ""

msgid "Depending on the function one or more inner queries are needed."
msgstr ""

msgid "withPoints - Category"
msgstr ""

msgid "When points are added to the graph."
msgstr ""

msgid ""
"The **with points** category modifies the graph on the fly by adding "
"points on edges as required by the `Points SQL`_ query."
msgstr ""

msgid ""
"The functions within this category give the ability to process between "
"arbitrary points located outside the original graph."
msgstr ""

msgid ""
"This category of functions was thought for routing vehicles, but might as"
" well work for some other application not involving vehicles."
msgstr ""

msgid ""
"When given a point identifier ``pid`` that its being mapped to an edge "
"with an identifier ``edge_id``, with a fraction from the source to the "
"target along the edge ``fraction`` and some additional information about "
"which side of the edge the point is on ``side``, then processing from "
"arbitrary points can be done on fixed networks."
msgstr ""

msgid ""
"All this functions consider as many traits from the \"real world\" as "
"possible:"
msgstr ""

msgid "Kind of graph:"
msgstr ""

msgid "**directed** graph"
msgstr ""

msgid "**undirected** graph"
msgstr ""

msgid "Arriving at the point:"
msgstr ""

msgid "Compulsory arrival on the side of the segment where the point is located."
msgstr ""

msgid "On either side of the segment."
msgstr ""

msgid "Countries with:"
msgstr ""

msgid "**Right** side driving"
msgstr ""

msgid "**Left** side driving"
msgstr ""

msgid "Some points are:"
msgstr ""

msgid ""
"**Permanent**: for example the set of points of clients stored in a table"
" in the data base."
msgstr ""

msgid "The graph has been modified to permanently have those points as vertices."
msgstr ""

msgid "There is a table on the database that describes the points"
msgstr ""

msgid "**Temporal**: for example points given through a web application"
msgstr ""

msgid "The numbering of the points are handled with negative sign."
msgstr ""

msgid ""
"This sign change is to avoid confusion when there is a vertex with the "
"same identifier as the point identifier."
msgstr ""

msgid "Original point identifiers are to be positive."
msgstr ""

msgid "Transformation to negative is done internally."
msgstr ""

msgid "Interpretation of the sign on the node information of the output"
msgstr ""

msgid "positive sign is a vertex of the original graph"
msgstr ""

msgid "negative sign is a point of the `Points SQL`_"
msgstr ""

msgid "About points"
msgstr ""

msgid ""
"For this section the following city (see :doc:`sampledata`) some "
"interesting points such as restaurant, supermarket, post office, etc. "
"will be used as example."
msgstr ""

msgid "The graph is **directed**"
msgstr ""

msgid "Red arrows show the ``(source, target)`` of the edge on the edge table"
msgstr ""

msgid "Blue arrows show the ``(target, source)`` of the edge on the edge table"
msgstr ""

msgid ""
"Each point location shows where it is located with relation of the edge "
"``(source, target)``"
msgstr ""

msgid "On the right for points **2** and **4**."
msgstr ""

msgid "On the left for points **1**, **3** and **5**."
msgstr ""

msgid "On both sides for point **6**."
msgstr ""

msgid ""
"The representation on the data base follows the `Points SQL`_ "
"description, and for this example:"
msgstr ""

msgid "Driving side"
msgstr ""

msgid "In the following images:"
msgstr ""

msgid "The squared vertices are the temporary vertices,"
msgstr ""

msgid "The temporary vertices are added according to the driving side,"
msgstr ""

msgid ""
"visually showing the differences on how depending on the driving side the"
" data is interpreted."
msgstr ""

msgid "Point **1** located on edge ``(6, 5)``"
msgstr ""

msgid "Point **2** located on edge ``(16, 17)``"
msgstr ""

msgid "Point **3** located on edge ``(8, 12)``"
msgstr ""

msgid "Point **4** located on edge ``(1, 3)``"
msgstr ""

msgid "Point **5** located on edge ``(10, 11)``"
msgstr ""

msgid "Point **6** located on edges ``(6, 7)`` and ``(7, 6)``"
msgstr ""

msgid "Point **1** located on edge ``(5, 6)``"
msgstr ""

msgid "Point **2** located on edge ``(17, 16)``"
msgstr ""

msgid "Point **4** located on edge ``(3, 1)``"
msgstr ""

msgid "Like having all points to be considered in both sides ``b``"
msgstr ""

msgid "Preferred usage on **undirected** graphs"
msgstr ""

msgid "On the :doc:`TRSP-family` this option is not valid"
msgstr ""

msgid "Point **1** located on edge ``(5, 6)`` and ``(6, 5)``"
msgstr ""

msgid "Point **2** located on edge ``(17, 16)``and ``16, 17``"
msgstr ""

msgid "Point **4** located on edge ``(3, 1)`` and ``(1, 3)``"
msgstr ""

msgid "Creating temporary vertices"
msgstr ""

msgid ""
"This section will demonstrate how a temporary vertex is created "
"internally on the graph."
msgstr ""

msgid "Problem"
msgstr ""

msgid "For edge:"
msgstr ""

msgid "insert point:"
msgstr ""

msgid "On a right hand side driving network"
msgstr ""

msgid "Arrival to point ``-2`` can be achieved only via vertex **16**."
msgstr ""

msgid "Does not affects edge ``(17, 16)``, therefore the edge is kept."
msgstr ""

msgid "It only affects the edge ``(16, 17)``, therefore the edge is removed."
msgstr ""

msgid "Create two new edges:"
msgstr ""

msgid ""
"Edge ``(16, -2)`` with cost ``0.4`` (original cost * fraction == :math:`1"
" * 0.4`)"
msgstr ""

msgid "Edge ``(-2, 17)`` with cost ``0.6`` (the remaining cost)"
msgstr ""

msgid "The total cost of the additional edges is equal to the original cost."
msgstr ""

msgid "If more points are on the same edge, the process is repeated recursevly."
msgstr ""

msgid "On a left hand side driving network"
msgstr ""

msgid "Arrival to point ``-2`` can be achieved only via vertex **17**."
msgstr ""

msgid "Does not affects edge ``(16, 17)``, therefore the edge is kept."
msgstr ""

msgid "It only affects the edge ``(17, 16)``, therefore the edge is removed."
msgstr ""

msgid ""
"Work with the original edge ``(16, 17)`` as the fraction is a fraction of"
" the original:"
msgstr ""

msgid "Flip the Edges and add them to the graph:"
msgstr ""

msgid ""
"Edge ``(17, -2)`` becomes ``(-2, 16)`` with cost ``0.4`` and is added to "
"the graph."
msgstr ""

msgid ""
"Edge ``(-2, 16)`` becomes ``(17, -2)`` with cost ``0.6`` and is added to "
"the graph."
msgstr ""

msgid "When driving side does not matter"
msgstr ""

msgid "Arrival to point ``-2`` can be achieved via vertices **16** or **17**."
msgstr ""

msgid ""
"Affects the edges ``(16, 17)`` and ``(17, 16)``, therefore the edges are "
"removed."
msgstr ""

msgid "Create four new edges:"
msgstr ""

msgid "Flip the Edges and add all the edges to the graph:"
msgstr ""

msgid "Edge ``(16, -2)`` is added to the graph."
msgstr ""

msgid "Edge ``(-2, 17)`` is added to the graph."
msgstr ""

msgid ""
"Edge ``(16, -2)`` becomes ``(-2, 16)`` with cost ``0.4`` and is added to "
"the graph."
msgstr ""

msgid ""
"Edge ``(-2, 17)`` becomes ``(17, -2)`` with cost ``0.6`` and is added to "
"the graph."
msgstr ""

msgid "withPoints - Family of functions"
msgstr ""

msgid ""
"This family of functions belongs to the :doc:`withPoints-category` and "
"the functions that compose them are based one way or another on dijkstra "
"algorithm."
msgstr ""

msgid "Depending on the name:"
msgstr ""

msgid "pgr_withPoints is pgr_dijkstra **with points**"
msgstr ""

msgid "pgr_withPointsCost is pgr_dijkstraCost **with points**"
msgstr ""

msgid "pgr_withPointsCostMatrix is pgr_dijkstraCostMatrix **with points**"
msgstr ""

msgid "pgr_withPointsKSP is pgr_ksp **with points**"
msgstr ""

msgid "pgr_withPointsDD is pgr_drivingDistance **with points**"
msgstr ""

msgid "pgr_withPointsvia is pgr_dijkstraVia **with points**"
msgstr ""

#~ msgid "pgRouting 4.0.0 Release Notes"
#~ msgstr ""

#~ msgid "It is expected to terminate faster than pgr_aStar"
#~ msgstr ""

#~ msgid ""
#~ "The ``pgr_aStarCost`` function summarizes of"
#~ " the cost of the shortest path "
#~ "using the A* algorithm."
#~ msgstr ""

#~ msgid ""
#~ "The results are equivalent to the "
#~ "union of the results of the "
#~ "pgr_bdAStar(One to One) on the:"
#~ msgstr ""

#~ msgid ""
#~ "The ``pgr_bdAstarCost`` function summarizes of"
#~ " the cost of the shortest path "
#~ "using the bidirectional A* algorithm."
#~ msgstr ""

#~ msgid ""
#~ "``pgr_bdAstarCostMatrix`` - Calculates the a"
#~ " cost matrix using :doc:`pgr_aStar`."
#~ msgstr ""

#~ msgid "Using internally the :doc:`pgr_bdAstar` algorithm"
#~ msgstr ""

#~ msgid "Signature change on pgr_bdDijsktra(One to One)"
#~ msgstr ""

#~ msgid ""
#~ "The ``pgr_bdDijkstraCost`` function summarizes "
#~ "of the cost of the shortest path"
#~ " using the bidirectional Dijkstra "
#~ "Algorithm."
#~ msgstr ""

#~ msgid ""
#~ "Boost `floyd-Warshall "
#~ "<https://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html>`_"
#~ msgstr ""

#~ msgid "New experimental functions"
#~ msgstr ""

#~ msgid ""
#~ "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__:"
#~ " pgr_trspviaedges"
#~ msgstr ""

#~ msgid ""
#~ "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__:"
#~ " pgr_trspviavertices"
#~ msgstr ""

#~ msgid ""
#~ "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__"
#~ " _pgr_alphashape(text,double precision)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_checkverttab(text,text[],integer,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_createindex(text,text,text,integer,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_createindex(text,text,text,text,integer,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__"
#~ " _pgr_dagshortestpath(text,anyarray,anyarray,boolean,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__"
#~ " _pgr_dagshortestpath(text,text,boolean,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__"
#~ " _pgr_dijkstranear(text,anyarray,anyarray,bigint,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__"
#~ " _pgr_dijkstranear(text,anyarray,bigint,bigint,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2730 <https://github.com/pgRouting/pgrouting/issues/2730>`__"
#~ " _pgr_dijkstranear(text,bigint,anyarray,bigint,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2735 <https://github.com/pgRouting/pgrouting/issues/2735>`__"
#~ " _pgr_drivingdistance(text,anyarray,double "
#~ "precision,boolean,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_endpoint(geometry)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_getcolumnname(text,text,integer,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_getcolumnname(text,text,text,integer,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_getcolumntype(text,text,integer,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_getcolumntype(text,text,text,integer,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_gettablename(text,integer,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_iscolumnindexed(text,text,integer,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_iscolumnindexed(text,text,text,integer,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_iscolumnintable(text,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2899 <https://github.com/pgRouting/pgrouting/issues/2899>`__"
#~ " _pgr_maxcardinalitymatch(text,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_startpoint(geometry)"
#~ msgstr ""

#~ msgid ""
#~ "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__"
#~ " _pgr_trspviavertices(text,integer[],boolean,boolean,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " "
#~ "_pgr_trspvia_withpoints(text,text,text,anyarray,boolean,boolean,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " "
#~ "_pgr_trsp_withpoints(text,text,text,anyarray,anyarray,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " "
#~ "_pgr_trsp_withpoints(text,text,text,text,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__"
#~ " _pgr_tspeuclidean(text,bigint,bigint,double "
#~ "precision,integer,integer,integer,double precision,double "
#~ "precision,double precision,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2861 <https://github.com/pgRouting/pgrouting/issues/2861>`__"
#~ " _pgr_versionless(text,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__"
#~ " _pgr_withpointsdd(text,text,anyarray,double "
#~ "precision,boolean,character,boolean,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__"
#~ " "
#~ "_pgr_withpointsksp(text,text,anyarray,anyarray,integer,character,boolean,boolean,boolean,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__"
#~ " "
#~ "_pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__"
#~ " "
#~ "_pgr_withpointsksp(text,text,text,integer,character,boolean,boolean,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2741 <https://github.com/pgRouting/pgrouting/issues/2741>`__"
#~ " _pgr_withpointsvia(text,bigint[],double precision[],boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2741 <https://github.com/pgRouting/pgrouting/issues/2741>`__"
#~ " "
#~ "_pgr_withpointsvia(text,text,anyarray,boolean,boolean,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2899 <https://github.com/pgRouting/pgrouting/issues/2899>`__"
#~ " pgr_maxcardinalitymatch(text,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2681 <https://github.com/pgRouting/pgrouting/issues/2681>`__"
#~ " pgr_trspviaedges(text,integer[],double "
#~ "precision[],boolean,boolean,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2682 <https://github.com/pgRouting/pgrouting/issues/2682>`__"
#~ " pgr_trspviavertices(text,anyarray,boolean,boolean,text)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " "
#~ "pgr_trspvia_withpoints(text,text,text,anyarray,boolean,boolean,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " "
#~ "pgr_trsp_withpoints(text,text,text,anyarray,anyarray,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " "
#~ "pgr_trsp_withpoints(text,text,text,anyarray,bigint,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " "
#~ "pgr_trsp_withpoints(text,text,text,bigint,anyarray,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " "
#~ "pgr_trsp_withpoints(text,text,text,bigint,bigint,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " pgr_trsp_withpoints(text,text,text,text,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2901 <https://github.com/pgRouting/pgrouting/issues/2901>`__"
#~ " pgr_tspeuclidean(text,bigint,bigint,double "
#~ "precision,integer,integer,integer,double precision,double "
#~ "precision,double precision,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " pgr_withpointscostmatrix(text,text,anyarray,boolean,character)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " pgr_withpointscost(text,text,anyarray,anyarray,boolean,character)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " pgr_withpointscost(text,text,anyarray,bigint,boolean,character)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " pgr_withpointscost(text,text,bigint,anyarray,boolean,character)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " pgr_withpointscost(text,text,bigint,bigint,boolean,character)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " pgr_withpointscost(text,text,text,boolean,character)"
#~ msgstr ""

#~ msgid ""
#~ "`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__"
#~ " pgr_withpointsdd(text,text,anyarray,double "
#~ "precision,boolean,character,boolean,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2890 <https://github.com/pgRouting/pgrouting/issues/2890>`__"
#~ " pgr_withpointsdd(text,text,bigint,double "
#~ "precision,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2895 <https://github.com/pgRouting/pgrouting/issues/2895>`__"
#~ " "
#~ "pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " "
#~ "pgr_withpoints(text,text,anyarray,anyarray,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " "
#~ "pgr_withpoints(text,text,anyarray,bigint,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " "
#~ "pgr_withpoints(text,text,bigint,anyarray,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " pgr_withpoints(text,text,bigint,bigint,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " pgr_withpoints(text,text,text,boolean,character,boolean)"
#~ msgstr ""

#~ msgid ""
#~ "`#2919 <https://github.com/pgRouting/pgrouting/issues/2919>`__"
#~ " "
#~ "pgr_withpointsvia(text,text,anyarray,boolean,boolean,boolean,character,boolean)"
#~ msgstr ""

#~ msgid "_pgr_drivingdistance => _pgr_drivingdistancev4"
#~ msgstr ""

#~ msgid "_pgr_withpointsdd => _pgr_withpointsddv4"
#~ msgstr ""

#~ msgid "_pgr_withpointsksp => _pgr_withpointsksp_v4"
#~ msgstr ""

#~ msgid "_pgr_trspvia_withpoints => _pgr_trspvia_withpoints_v4"
#~ msgstr ""

#~ msgid "_pgr_trsp_withpoints => _pgr_trsp_withpoints_v4"
#~ msgstr ""

#~ msgid "_pgr_withpointsvia => _pgr_withpointsvia_v4"
#~ msgstr ""

#~ msgid ""
#~ "`#2748 <https://github.com/pgRouting/pgrouting/issues/2748>`__"
#~ " _pgr_alphashape"
#~ msgstr ""

#~ msgid ""
#~ "`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__"
#~ " _pgr_dagshortestpath"
#~ msgstr ""

#~ msgid "New experimental function"
#~ msgstr ""

#~ msgid "Using this standard all versions of boost will work"
#~ msgstr ""

#~ msgid "The user's documentation is build by default"
#~ msgstr ""

#~ msgid "To build only English: `-DES=ON -DSV=OFF -DZH_HANS=OFF`"
#~ msgstr ""

#~ msgid ""
#~ "Documentation output changed location to "
#~ "`build/doc/_build/<format>` directory"
#~ msgstr ""

#~ msgid ""
#~ "``pgr_kingOrdering``  Returns the King "
#~ "ordering of an undirected graphs"
#~ msgstr ""

#~ msgid ""
#~ "The method follows a breadth-first "
#~ "search (BFS) traversal,but with a "
#~ "refinement: at each step, the unvisited"
#~ " neighbors of the current vertex are"
#~ " inserted into the queue in ascending"
#~ " order of their pseudo-degree, where"
#~ " the pseudo-degree of a vertex "
#~ "is the number of edges connecting "
#~ "it to yet-unvisited vertices. This "
#~ "prioritization often yields a smaller "
#~ "bandwidth compared to simpler BFS "
#~ "orderings."
#~ msgstr ""

#~ msgid "|boost| graph inside."
#~ msgstr ""

#~ msgid ""
#~ "``pgr_sloanOrdering``  Returns the sloan "
#~ "ordering of an undirected graph"
#~ msgstr ""

#~ msgid ""
#~ "Aims to mininimize bandwidth (maximum "
#~ "difference between connected vertex indices."
#~ msgstr ""

#~ msgid "Run time is 0.115846 seconds."
#~ msgstr ""

#~ msgid "|Boost| Boost Graph inside"
#~ msgstr ""

#~ msgid "..rubric::Summary"
#~ msgstr ""

#~ msgid "..graphviz::"
#~ msgstr ""

#~ msgid "..literalinclude::sloanOrdering.queries"
#~ msgstr ""

#~ msgid "start-after"
#~ msgstr ""

#~ msgid "--q3"
#~ msgstr ""

#~ msgid "--q4"
#~ msgstr ""

#~ msgid "The doxygen documentation is build by default"
#~ msgstr ""

#~ msgid "The HTML documentation is build by default"
#~ msgstr ""

#~ msgid ""
#~ "The translated languages (en, es, sv,"
#~ " zh_Hans) HTML documentation is build "
#~ "by default"
#~ msgstr ""

#~ msgid "User's Documentation is not build when"
#~ msgstr ""

#~ msgid "Developers's Documentation is not build when"
#~ msgstr ""

#~ msgid ""
#~ "`#2913 <https://github.com/pgRouting/pgrouting/issues/2913>`__:"
#~ " pgr_DAGshortestPath"
#~ msgstr ""

#~ msgid ""
#~ "`#2909 <https://github.com/pgRouting/pgrouting/issues/2909>`__:"
#~ " pgr_turnRestrictedPaths"
#~ msgstr ""

#~ msgid "Internally uses the :doc:`pgr_bdAstar` algorithm"
#~ msgstr ""

#~ msgid ""
#~ "It is well-known that the shortest"
#~ " paths between a single source and"
#~ " all other vertices can be found "
#~ "using Breadth First Search in "
#~ ":math:`O(|E|)` in an unweighted graph, "
#~ "i.e. the distance is the minimal "
#~ "number of edges that you need to"
#~ " traverse from the source to another"
#~ " vertex. We can interpret such a "
#~ "graph also as a weighted graph, "
#~ "where every edge has the weight "
#~ ":math:`1`. If not all edges in "
#~ "graph have the same weight, that "
#~ "we need a more general algorithm, "
#~ "like Dijkstra's Algorithm which runs in"
#~ " :math:`O(|E|log|V|)` time."
#~ msgstr ""

#~ msgid "..rubric:: Version 3.0.0"
#~ msgstr ""

