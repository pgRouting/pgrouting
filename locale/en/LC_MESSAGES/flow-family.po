# SOME DESCRIPTIVE TITLE.
# Copyright (C) pgRouting Contributors - Version v3.3.4
# This file is distributed under the same license as the pgRouting package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pgRouting v3.3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-06 14:22-0500\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

msgid ""
"**Supported versions:** `Latest <https://docs.pgrouting.org/latest/en"
"/flow-family.html>`__ (`3.3 <https://docs.pgrouting.org/3.3/en/flow-"
"family.html>`__) `3.2 <https://docs.pgrouting.org/3.2/en/flow-"
"family.html>`__ `3.1 <https://docs.pgrouting.org/3.1/en/flow-"
"family.html>`__ `3.0 <https://docs.pgrouting.org/3.0/en/flow-"
"family.html>`__"
msgstr ""

msgid ""
"**Unsupported versions:** `2.6 <https://docs.pgrouting.org/2.6/en/flow-"
"family.html>`__ `2.5 <https://docs.pgrouting.org/2.5/en/flow-"
"family.html>`__ `2.4 <https://docs.pgrouting.org/2.4/en/flow-"
"family.html>`__ `2.3 "
"<https://docs.pgrouting.org/2.3/en/src/max_flow/doc/maxFlow.html>`__"
msgstr ""

msgid "Flow - Family of functions"
msgstr ""

msgid ""
":doc:`pgr_maxFlow` - Only the Max flow calculation using Push and Relabel"
" algorithm."
msgstr ""

msgid ""
":doc:`pgr_boykovKolmogorov` - Boykov and Kolmogorov with details of flow "
"on edges."
msgstr ""

msgid ""
":doc:`pgr_edmondsKarp` - Edmonds and Karp algorithm with details of flow "
"on edges."
msgstr ""

msgid ""
":doc:`pgr_pushRelabel` - Push and relabel algorithm with details of flow "
"on edges."
msgstr ""

msgid "Applications"
msgstr ""

msgid ""
":doc:`pgr_edgeDisjointPaths` - Calculates edge disjoint paths between two"
" groups of vertices."
msgstr ""

msgid ""
":doc:`pgr_maxCardinalityMatch` - Calculates a maximum cardinality "
"matching in a graph."
msgstr ""

msgid "Experimental"
msgstr ""

msgid "Possible server crash"
msgstr ""

msgid "These functions might create a server crash"
msgstr ""

msgid "Experimental functions"
msgstr ""

msgid "They are not officially of the current release."
msgstr ""

msgid "They likely will not be officially be part of the next release:"
msgstr ""

msgid "The functions might not make use of ANY-INTEGER and ANY-NUMERICAL"
msgstr ""

msgid "Name might change."
msgstr ""

msgid "Signature might change."
msgstr ""

msgid "Functionality might change."
msgstr ""

msgid "pgTap tests might be missing."
msgstr ""

msgid "Might need c/c++ coding."
msgstr ""

msgid "May lack documentation."
msgstr ""

msgid "Documentation if any might need to be rewritten."
msgstr ""

msgid "Documentation examples might need to be automatically generated."
msgstr ""

msgid "Might need a lot of feedback from the comunity."
msgstr ""

msgid "Might depend on a proposed function of pgRouting"
msgstr ""

msgid "Might depend on a deprecated function of pgRouting"
msgstr ""

msgid ":doc:`pgr_maxFlowMinCost` - Details of flow and cost on edges."
msgstr ""

msgid ":doc:`pgr_maxFlowMinCost_Cost` - Only the Min Cost calculation."
msgstr ""

msgid "Flow Functions General Information"
msgstr ""

msgid "**The main characteristics are:**"
msgstr ""

msgid "The graph is **directed**."
msgstr ""

msgid "Process is done only on edges with positive capacities."
msgstr ""

msgid ""
"When the maximum flow is 0 then there is no flow and **EMPTY SET** is "
"returned."
msgstr ""

msgid "There is no flow when a **source** is the same as a **target**."
msgstr ""

msgid "Any duplicated value in the source(s) or target(s) are ignored."
msgstr ""

msgid "Calculates the flow/residual capacity for each edge. In the output"
msgstr ""

msgid "Edges with zero flow are omitted."
msgstr ""

msgid ""
"Creates a **super source** and edges to all the source(s), and a **super "
"target** and the edges from all the targets(s)."
msgstr ""

msgid ""
"The maximum flow through the graph is guaranteed to be the value returned"
" by :doc:`pgr_maxFlow <pgr_maxFlow>` when executed with the same "
"parameters and can be calculated:"
msgstr ""

msgid "By aggregation of the outgoing flow from the sources"
msgstr ""

msgid "By aggregation of the incoming flow to the targets"
msgstr ""

msgid ""
":doc:`pgr_maxFlow` is the maximum Flow and that maximum is guaranteed to "
"be the same on the functions :doc:`pgr_pushRelabel`, "
":doc:`pgr_edmondsKarp`, :doc:`pgr_boykovKolmogorov`, but the actual flow "
"through each edge may vary."
msgstr ""

msgid "Inner Queries"
msgstr ""

msgid "Edges SQL"
msgstr ""

msgid "Capacity edges"
msgstr ""

msgid ":doc:`pgr_pushRelabel`"
msgstr ""

msgid ":doc:`pgr_edmondsKarp`"
msgstr ""

msgid ":doc:`pgr_boykovKolmogorov`"
msgstr ""

msgid "Column"
msgstr ""

msgid "Type"
msgstr ""

msgid "Default"
msgstr ""

msgid "Description"
msgstr ""

msgid "``id``"
msgstr ""

msgid "**ANY-INTEGER**"
msgstr ""

msgid "Identifier of the edge."
msgstr ""

msgid "``source``"
msgstr ""

msgid "Identifier of the first end point vertex of the edge."
msgstr ""

msgid "``target``"
msgstr ""

msgid "Identifier of the second end point vertex of the edge."
msgstr ""

msgid "``capacity``"
msgstr ""

msgid "Weight of the edge  (``source``, ``target``)"
msgstr ""

msgid "``reverse_capacity``"
msgstr ""

msgid "-1"
msgstr ""

msgid "Weight of the edge (``target``, ``source``)"
msgstr ""

msgid ""
"When negative: edge (``target``, ``source``) does not exist, therefore "
"it's not part of the graph."
msgstr ""

msgid "Where:"
msgstr ""

msgid "ANY-INTEGER"
msgstr ""

msgid "``SMALLINT``, ``INTEGER``, ``BIGINT``"
msgstr ""

msgid "ANY-NUMERICAL"
msgstr ""

msgid "``SMALLINT``, ``INTEGER``, ``BIGINT``, ``REAL``, ``FLOAT``"
msgstr ""

msgid "Capacity-Cost edges"
msgstr ""

msgid ":doc:`pgr_maxFlowMinCost`"
msgstr ""

msgid ":doc:`pgr_maxFlowMinCost_Cost`"
msgstr ""

msgid "Capacity of the edge  (``source``, ``target``)"
msgstr ""

msgid "Capacity of the edge (``target``, ``source``)"
msgstr ""

msgid "``cost``"
msgstr ""

msgid "**ANY-NUMERICAL**"
msgstr ""

msgid "Weight of the edge  (``source``, ``target``) if it exist"
msgstr ""

msgid "``reverse_cost``"
msgstr ""

msgid ":math:`-1`"
msgstr ""

msgid "Weight of the edge (``target``, ``source``) if it exist"
msgstr ""

msgid "Cost edges"
msgstr ""

msgid ":doc:`pgr_edgeDisjointPaths`"
msgstr ""

msgid "Weight of the edge (``source``, ``target``)"
msgstr ""

msgid "Combinations SQL"
msgstr ""

msgid "Parameter"
msgstr ""

msgid "Identifier of the departure vertex."
msgstr ""

msgid "Identifier of the arrival vertex."
msgstr ""

msgid "Result Columns"
msgstr ""

msgid "Used in"
msgstr ""

msgid "**seq**"
msgstr ""

msgid "``INT``"
msgstr ""

msgid "Sequential value starting from **1**."
msgstr ""

msgid "**edge**"
msgstr ""

msgid "``BIGINT``"
msgstr ""

msgid "Identifier of the edge in the original query (edges_sql)."
msgstr ""

msgid "**start_vid**"
msgstr ""

msgid "**end_vid**"
msgstr ""

msgid "**flow**"
msgstr ""

msgid "Flow through the edge in the direction (``start_vid``, ``end_vid``)."
msgstr ""

msgid "**residual_capacity**"
msgstr ""

msgid ""
"Residual capacity of the edge in the direction (``start_vid``, "
"``end_vid``)."
msgstr ""

msgid "For :doc:`pgr_maxFlowMinCost`"
msgstr ""

msgid "**source**"
msgstr ""

msgid "**target**"
msgstr ""

msgid "Flow through the edge in the direction (source, target)."
msgstr ""

msgid "Residual capacity of the edge in the direction (source, target)."
msgstr ""

msgid "**cost**"
msgstr ""

msgid "``FLOAT``"
msgstr ""

msgid ""
"The cost of sending this flow through the edge in the direction (source, "
"target)."
msgstr ""

msgid "**agg_cost**"
msgstr ""

msgid "The aggregate cost."
msgstr ""

msgid "Adcanced Documentation"
msgstr ""

msgid ""
"A flow network is a directed graph where each edge has a capacity and a "
"flow. The flow through an edge must not exceed the capacity of the edge. "
"Additionally, the incoming and outgoing flow of a node must be equal "
"except for source which only has outgoing flow, and the destination(sink)"
" which only has incoming flow."
msgstr ""

msgid ""
"Maximum flow algorithms calculate the maximum flow through the graph and "
"the flow of each edge."
msgstr ""

msgid ""
"The maximum flow through the graph is guaranteed to be the same with all "
"implementations, but the actual flow through each edge may vary."
msgstr ""

msgid "Given the following query:"
msgstr ""

msgid "pgr_maxFlow :math:`(edges\\_sql, source\\_vertex, sink\\_vertex)`"
msgstr ""

msgid ""
"where :math:`edges\\_sql = \\{(id_i, source_i, target_i, capacity_i, "
"reverse\\_capacity_i)\\}`"
msgstr ""

msgid "Graph definition"
msgstr ""

msgid "The weighted directed graph, :math:`G(V,E)`, is defined as:"
msgstr ""

msgid "the set of vertices  :math:`V`"
msgstr ""

msgid ""
":math:`source\\_vertex  \\cup  sink\\_vertex  \\bigcup  source_i  "
"\\bigcup  target_i`"
msgstr ""

msgid "the set of edges :math:`E`"
msgstr ""

msgid ""
":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, capacity_i) "
"\\text{ when } capacity > 0 \\} & \\quad  \\text{ if } reverse\\_capacity"
" = \\varnothing \\\\ \\text{ } & \\quad \\text{ } \\\\ \\{(source_i, "
"target_i, capacity_i) \\text{ when } capacity > 0 \\} & \\text{ } \\\\ "
"\\cup \\{(target_i, source_i, reverse\\_capacity_i) \\text{ when } "
"reverse\\_capacity_i > 0)\\} & \\quad \\text{ if } reverse\\_capacity "
"\\neq \\varnothing \\\\ \\end{cases}`"
msgstr ""

msgid "Maximum flow problem"
msgstr ""

msgid "Given:"
msgstr ""

msgid ":math:`G(V,E)`"
msgstr ""

msgid ":math:`source\\_vertex \\in V` the source vertex"
msgstr ""

msgid ":math:`sink\\_vertex \\in V` the sink vertex"
msgstr ""

msgid "Then:"
msgstr ""

msgid ":math:`pgr\\_maxFlow(edges\\_sql, source, sink) = \\boldsymbol{\\Phi}`"
msgstr ""

msgid ""
":math:`\\boldsymbol{\\Phi} = {(id_i, edge\\_id_i, source_i, target_i, "
"flow_i, residual\\_capacity_i)}`"
msgstr ""

msgid ""
":math:`\\boldsymbol{\\Phi}` is a subset of the original edges with their "
"residual capacity and flow. The maximum flow through the graph can be "
"obtained by aggregating on the source or sink and summing the flow "
"from/to it. In particular:"
msgstr ""

msgid ":math:`id_i = i`"
msgstr ""

msgid ":math:`edge\\_id = id_i` in edges_sql"
msgstr ""

msgid ":math:`residual\\_capacity_i = capacity_i - flow_i`"
msgstr ""

msgid "See Also"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Maximum_flow_problem"
msgstr ""

msgid "Indices and tables"
msgstr ""

msgid ":ref:`genindex`"
msgstr ""

msgid ":ref:`search`"
msgstr ""

