# SOME DESCRIPTIVE TITLE.
# Copyright (C) pgRouting Contributors - Version v3.7.0-dev
# This file is distributed under the same license as the pgRouting package.
# Regina Obe <regina@arrival3d.com>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: pgRouting v3.6.0-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-13 17:23+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "BFS - Category"
msgstr ""

msgid ":doc:`pgr_kruskalBFS`"
msgstr ""

msgid ":doc:`pgr_primBFS`"
msgstr ""

msgid "Traversal using breadth first search."
msgstr ""

msgid "It's implementation is only on **undirected** graph."
msgstr ""

msgid "Process is done only on edges with positive costs."
msgstr ""

msgid "When the graph is connected"
msgstr ""

msgid "The resulting edges make up a tree"
msgstr ""

msgid "When the graph is not connected,"
msgstr ""

msgid "Finds a minimum spanning tree for each connected component."
msgstr ""

msgid "The resulting edges make up a forest."
msgstr ""

msgid "Parameters"
msgstr ""

msgid "Parameter"
msgstr ""

msgid "Type"
msgstr ""

msgid "Description"
msgstr ""

msgid "`Edges SQL`_"
msgstr ""

msgid "``TEXT``"
msgstr ""

msgid "`Edges SQL`_ as described below."
msgstr ""

msgid "**root vid**"
msgstr ""

msgid "``BIGINT``"
msgstr ""

msgid "Identifier of the root vertex of the tree."
msgstr ""

msgid ""
"When value is :math:`0` then gets the spanning forest starting in aleatory "
"nodes for each tree in the forest."
msgstr ""

msgid "**root vids**"
msgstr ""

msgid "``ARRAY`` [ **ANY-INTEGER** ]"
msgstr ""

msgid "Array of identifiers of the root vertices."
msgstr ""

msgid ":math:`0` values are ignored"
msgstr ""

msgid "For optimization purposes, any duplicated value is ignored."
msgstr ""

msgid "Where:"
msgstr ""

msgid "ANY-INTEGER"
msgstr ""

msgid "SMALLINT, INTEGER, BIGINT"
msgstr ""

msgid "ANY-NUMERIC"
msgstr ""

msgid "SMALLINT, INTEGER, BIGINT, REAL, FLOAT, NUMERIC"
msgstr ""

msgid "BFS optional parameters"
msgstr ""

msgid "Default"
msgstr ""

msgid "``max_depth``"
msgstr ""

msgid ":math:`9223372036854775807`"
msgstr ""

msgid "Upper limit of the depth of the tree."
msgstr ""

msgid "When negative throws an error."
msgstr ""

msgid "Inner Queries"
msgstr ""

msgid "Edges SQL"
msgstr ""

msgid "Column"
msgstr ""

msgid "``id``"
msgstr ""

msgid "**ANY-INTEGER**"
msgstr ""

msgid "Identifier of the edge."
msgstr ""

msgid "``source``"
msgstr ""

msgid "Identifier of the first end point vertex of the edge."
msgstr ""

msgid "``target``"
msgstr ""

msgid "Identifier of the second end point vertex of the edge."
msgstr ""

msgid "``cost``"
msgstr ""

msgid "**ANY-NUMERICAL**"
msgstr ""

msgid "Weight of the edge (``source``, ``target``)"
msgstr ""

msgid "``reverse_cost``"
msgstr ""

msgid "-1"
msgstr ""

msgid "Weight of the edge (``target``, ``source``)"
msgstr ""

msgid ""
"When negative: edge (``target``, ``source``) does not exist, therefore it's "
"not part of the graph."
msgstr ""

msgid "``SMALLINT``, ``INTEGER``, ``BIGINT``"
msgstr ""

msgid "ANY-NUMERICAL"
msgstr ""

msgid "``SMALLINT``, ``INTEGER``, ``BIGINT``, ``REAL``, ``FLOAT``"
msgstr ""

msgid "Result columns"
msgstr ""

msgid "Returns set of ``(seq, depth, start_vid, node, edge, cost, agg_cost)``"
msgstr ""

msgid "``seq``"
msgstr ""

msgid "Sequential value starting from :math:`1`."
msgstr ""

msgid "``depth``"
msgstr ""

msgid "Depth of the ``node``."
msgstr ""

msgid ":math:`0` when ``node`` = ``start_vid``."
msgstr ""

msgid "``start_vid``"
msgstr ""

msgid "Identifier of the root vertex."
msgstr ""

msgid "``node``"
msgstr ""

msgid "Identifier of ``node`` reached using ``edge``."
msgstr ""

msgid "``edge``"
msgstr ""

msgid "Identifier of the ``edge`` used to arrive to ``node``."
msgstr ""

msgid ":math:`-1` when ``node`` = ``start_vid``."
msgstr ""

msgid "``FLOAT``"
msgstr ""

msgid "Cost to traverse ``edge``."
msgstr ""

msgid "``agg_cost``"
msgstr ""

msgid "Aggregate cost from ``start_vid`` to ``node``."
msgstr ""

msgid "See Also"
msgstr ""

msgid ""
"`Boost: Prim's algorithm <https://www.boost.org/libs/graph/doc/"
"prim_minimum_spanning_tree.html>`__"
msgstr ""

msgid ""
"`Boost: Kruskal's algorithm <https://www.boost.org/libs/graph/doc/"
"kruskal_min_spanning_tree.html>`__"
msgstr ""

msgid ""
"`Wikipedia: Prim's algorithm <https://en.wikipedia.org/wiki/"
"Prim%27s_algorithm>`__"
msgstr ""

msgid ""
"`Wikipedia: Kruskal's algorithm <https://en.wikipedia.org/wiki/"
"Kruskal's_algorithm>`__"
msgstr ""

msgid "Indices and tables"
msgstr ""

msgid ":ref:`genindex`"
msgstr ""

msgid ":ref:`search`"
msgstr ""

msgid "DFS - Category"
msgstr ""

msgid "Traversal using Depth First Search."
msgstr ""

msgid ":doc:`pgr_kruskalDFS`"
msgstr ""

msgid ":doc:`pgr_primDFS`"
msgstr ""

msgid "Proposed"
msgstr ""

msgid "Proposed functions for next mayor release."
msgstr ""

msgid "They are not officially in the current release."
msgstr ""

msgid "They will likely officially be part of the next mayor release:"
msgstr ""

msgid "The functions make use of ANY-INTEGER and ANY-NUMERICAL"
msgstr ""

msgid "Name might not change. (But still can)"
msgstr ""

msgid "Signature might not change. (But still can)"
msgstr ""

msgid "Functionality might not change. (But still can)"
msgstr ""

msgid "pgTap tests have being done. But might need more."
msgstr ""

msgid "Documentation might need refinement."
msgstr ""

msgid ""
":doc:`pgr_depthFirstSearch` - Depth first search traversal of the graph."
msgstr ""

msgid "In general:"
msgstr ""

msgid "K shortest paths - Category"
msgstr ""

msgid ":doc:`pgr_KSP` - Yen's algorithm based on pgr_dijkstra"
msgstr ""

msgid ":doc:`pgr_withPointsKSP` - Yen's algorithm based on pgr_withPoints"
msgstr ""

msgid "TRSP - Family of functions"
msgstr ""

msgid "When points are also given as input:"
msgstr ""

msgid ":doc:`pgr_trsp` - Vertex - Vertex routing with restrictions."
msgstr ""

msgid ":doc:`pgr_trspVia` - Via Vertices routing with restrictions."
msgstr ""

msgid ":doc:`pgr_trsp_withPoints` - Vertex/Point routing with restrictions."
msgstr ""

msgid ""
":doc:`pgr_trspVia_withPoints` - Via Vertex/point routing with restrictions."
msgstr ""

msgid ""
"Read the :doc:`migration` about how to migrate from the deprecated TRSP "
"functionality to the new signatures or replacement functions."
msgstr ""

msgid "Experimental"
msgstr ""

msgid "Possible server crash"
msgstr ""

msgid "These functions might create a server crash"
msgstr ""

msgid "Experimental functions"
msgstr ""

msgid "They are not officially of the current release."
msgstr ""

msgid "They likely will not be officially be part of the next release:"
msgstr ""

msgid "The functions might not make use of ANY-INTEGER and ANY-NUMERICAL"
msgstr ""

msgid "Name might change."
msgstr ""

msgid "Signature might change."
msgstr ""

msgid "Functionality might change."
msgstr ""

msgid "pgTap tests might be missing."
msgstr ""

msgid "Might need c/c++ coding."
msgstr ""

msgid "May lack documentation."
msgstr ""

msgid "Documentation if any might need to be rewritten."
msgstr ""

msgid "Documentation examples might need to be automatically generated."
msgstr ""

msgid "Might need a lot of feedback from the comunity."
msgstr ""

msgid "Might depend on a proposed function of pgRouting"
msgstr ""

msgid "Might depend on a deprecated function of pgRouting"
msgstr ""

msgid ":doc:`pgr_turnRestrictedPath` - Routing with restrictions."
msgstr ""

msgid "Introduction"
msgstr ""

msgid ""
"Road restrictions are a sequence of road segments that can not be taken in a "
"sequential manner. Some restrictions are implicit on a directed graph, for "
"example, one way roads where the wrong way edge is not even inserted on the "
"graph. But normally on turns like no left turn or no right turn, hence the "
"name turn restrictions, there are sometimes restrictions."
msgstr ""

msgid "TRSP algorithm"
msgstr ""

msgid ""
"The internal TRSP algorithm performs a lookahead over the dijkstra algorithm "
"in order to find out if the attempted path has a restriction. This allows "
"the algorithm to pass twice on the same vertex."
msgstr ""

msgid "`Edges SQL`_ query as described."
msgstr ""

msgid "`Restrictions SQL`_"
msgstr ""

msgid "`Restrictions SQL`_ query as described."
msgstr ""

msgid "**via vertices**"
msgstr ""

msgid "``ARRAY[`` **ANY-INTEGER** ``]``"
msgstr ""

msgid "Array of ordered vertices identifiers that are going to be visited."
msgstr ""

msgid "Restrictions"
msgstr ""

msgid ""
"On road networks, there are restrictions such as left or right turn "
"restrictions, no U turn restrictions."
msgstr ""

msgid ""
"A restriction is a sequence of edges, called path and that path is to be "
"avoided."
msgstr ""

msgid "**Restrictions on the road network**"
msgstr ""

msgid "These restrictions are represented on a table as follows:"
msgstr ""

msgid ""
"The table has an identifier, which maybe is needed for the administration of "
"the restrictions, but the algorithms do not need that information. If given "
"it will be ignored."
msgstr ""

msgid "Restrictions SQL"
msgstr ""

msgid "``path``"
msgstr ""

msgid "``ARRAY`` [**ANY-INTEGER**]"
msgstr ""

msgid ""
"Sequence of edge identifiers that form a path that is not allowed to be "
"taken. - Empty arrays or ``NULL`` arrays are ignored. - Arrays that have a "
"``NULL`` element will raise an exception."
msgstr ""

msgid "``Cost``"
msgstr ""

msgid "Cost of taking the forbidden path."
msgstr ""

msgid "Traveling Sales Person - Family of functions"
msgstr ""

msgid ":doc:`pgr_TSP` - When input is given as matrix cell information."
msgstr ""

msgid ":doc:`pgr_TSPeuclidean` - When input are coordinates."
msgstr ""

msgid "Table of Contents"
msgstr ""

msgid "General Information"
msgstr ""

msgid "Problem Definition"
msgstr ""

msgid "The travelling salesperson problem (TSP) asks the following question:"
msgstr ""

msgid ""
"*Given a list of cities and the distances between each pair of cities, which "
"is the shortest possible route that visits each city exactly once and "
"returns to the origin city?*"
msgstr ""

msgid "Origin"
msgstr ""

msgid ""
"The traveling sales person problem was studied in the 18th century by "
"mathematicians **Sir William Rowam Hamilton** and **Thomas Penyngton "
"Kirkman**."
msgstr ""

msgid ""
"A discussion about the work of Hamilton & Kirkman can be found in the book "
"**Graph Theory (Biggs et al. 1976)**."
msgstr ""

msgid "ISBN-13: 978-0198539162"
msgstr ""

msgid "ISBN-10: 0198539169"
msgstr ""

msgid ""
"It is believed that the general form of the TSP have been first studied by "
"Kalr Menger in Vienna and Harvard. The problem was later promoted by "
"Hassler, Whitney & Merrill at Princeton. A detailed description about the "
"connection between Menger & Whitney, and the development of the TSP can be "
"found in `On the history of combinatorial optimization (till 1960) <https://"
"homepages.cwi.nl/~lex/files/histco.ps>`__"
msgstr ""

msgid "To calculate the number of different tours through :math:`n` cities:"
msgstr ""

msgid "Given a starting city,"
msgstr ""

msgid "There are :math:`n-1` choices for the second city,"
msgstr ""

msgid "And :math:`n-2` choices for the third city, etc."
msgstr ""

msgid "Multiplying these together we get :math:`(n-1)! = (n-1) (n-2) . . 1`."
msgstr ""

msgid ""
"Now since the travel costs do not depend on the direction taken around the "
"tour:"
msgstr ""

msgid "this number by 2"
msgstr ""

msgid ":math:`(n-1)!/2`."
msgstr ""

msgid "Characteristics"
msgstr ""

msgid "This problem is an NP-hard optimization problem."
msgstr ""

msgid "Metric Algorithm is used"
msgstr ""

msgid ""
"Implementation generates solutions that *are twice as long as the optimal "
"tour in the worst case* when:"
msgstr ""

msgid "Graph is undirected"
msgstr ""

msgid "Graph is fully connected"
msgstr ""

msgid "Graph where traveling costs on edges obey the triangle inequality."
msgstr ""

msgid "On an undirected graph:"
msgstr ""

msgid "The traveling costs are symmetric:"
msgstr ""

msgid ""
"Traveling costs from ``u`` to ``v`` are just as much as traveling from ``v`` "
"to ``u``"
msgstr ""

msgid "TSP optional parameters"
msgstr ""

msgid "``start_id``"
msgstr ""

msgid "``0``"
msgstr ""

msgid "The first visiting vertex"
msgstr ""

msgid "When `0` any vertex can become the first visiting vertex."
msgstr ""

msgid "``end_id``"
msgstr ""

msgid "Last visiting vertex before returning to ``start_vid``."
msgstr ""

msgid ""
"When ``0`` any vertex can become the last visiting vertex before returning "
"to ``start_id``."
msgstr ""

msgid ""
"When ``NOT 0`` and ``start_id = 0`` then it is the first and last vertex"
msgstr ""

msgid "References"
msgstr ""

msgid ""
"`Boost's metric appro's metric approximation <https://www.boost.org/libs/"
"graph/doc/metric_tsp_approx.html>`__"
msgstr ""

msgid "`University of Waterloo TSP <https://www.math.uwaterloo.ca/tsp/>`__"
msgstr ""

msgid ""
"`Wikipedia: Traveling Salesman Problem <https://en.wikipedia.org/wiki/"
"Traveling_salesman_problem>`__"
msgstr ""

msgid "Vehicle Routing Functions - Category (Experimental)"
msgstr ""

msgid "Pickup and delivery problem"
msgstr ""

msgid ":doc:`pgr_pickDeliver` - Pickup & Delivery using a Cost Matrix"
msgstr ""

msgid ""
":doc:`pgr_pickDeliverEuclidean` - Pickup & Delivery with Euclidean distances"
msgstr ""

msgid "Distribution problem"
msgstr ""

msgid ":doc:`pgr_vrpOneDepot` - From a single depot, distributes orders"
msgstr ""

msgid "Contents"
msgstr ""

msgid ""
"Vehicle Routing Problems `VRP` are **NP-hard** optimization problem, it "
"generalises the travelling salesman problem (TSP)."
msgstr ""

msgid "The objective of the VRP is to minimize the total route cost."
msgstr ""

msgid "There are several variants of the VRP problem,"
msgstr ""

msgid "**pgRouting does not try to implement all variants.**"
msgstr ""

msgid ""
"Capacitated Vehicle Routing Problem `CVRP` where The vehicles have limited "
"carrying capacity of the goods."
msgstr ""

msgid ""
"Vehicle Routing Problem with Time Windows `VRPTW` where the locations have "
"time windows within which the vehicle's visits must be made."
msgstr ""

msgid ""
"Vehicle Routing Problem with Pickup and Delivery `VRPPD` where a number of "
"goods need to be moved from certain pickup locations to other delivery "
"locations."
msgstr ""

msgid "Limitations"
msgstr ""

msgid "No multiple time windows for a location."
msgstr ""

msgid "Less vehicle used is considered better."
msgstr ""

msgid "Less total duration is better."
msgstr ""

msgid "Less wait time is better."
msgstr ""

msgid "Pick & Delivery"
msgstr ""

msgid ""
"Problem: `CVRPPDTW` Capacitated Pick and Delivery Vehicle Routing problem "
"with Time Windows"
msgstr ""

msgid "Times are relative to `0`"
msgstr ""

msgid "The vehicles"
msgstr ""

msgid "have start and ending service duration times."
msgstr ""

msgid "have opening and closing times for the start and ending locations."
msgstr ""

msgid "have a capacity."
msgstr ""

msgid "The orders"
msgstr ""

msgid "Have pick up and delivery locations."
msgstr ""

msgid "Have opening and closing times for the pickup and delivery locations."
msgstr ""

msgid "Have pickup and delivery duration service times."
msgstr ""

msgid ""
"have a demand request for moving goods from the pickup location to the "
"delivery location."
msgstr ""

msgid "Time based calculations:"
msgstr ""

msgid "Travel time between customers is :math:`distance / speed`"
msgstr ""

msgid "Pickup and delivery order pair is done by the same vehicle."
msgstr ""

msgid "A pickup is done before the delivery."
msgstr ""

msgid "Pick & deliver"
msgstr ""

msgid "Used in :doc:`pgr_pickDeliverEuclidean`"
msgstr ""

msgid "`Orders SQL`_"
msgstr ""

msgid "`Orders SQL`_ as described below."
msgstr ""

msgid "`Vehicles SQL`_"
msgstr ""

msgid "`Vehicles SQL`_ as described below."
msgstr ""

msgid "Used in :doc:`pgr_pickDeliver`"
msgstr ""

msgid "`Matrix SQL`_"
msgstr ""

msgid "`Matrix SQL`_ as described below."
msgstr ""

msgid "Pick-Deliver optional parameters"
msgstr ""

msgid "``factor``"
msgstr ""

msgid "``NUMERIC``"
msgstr ""

msgid "1"
msgstr ""

msgid "Travel time multiplier. See :ref:`pd_factor`"
msgstr ""

msgid "``max_cycles``"
msgstr ""

msgid "``INTEGER``"
msgstr ""

msgid "10"
msgstr ""

msgid "Maximum number of cycles to perform on the optimization."
msgstr ""

msgid "``initial_sol``"
msgstr ""

msgid "4"
msgstr ""

msgid "Initial solution to be used."
msgstr ""

msgid "``1`` One order per truck"
msgstr ""

msgid "``2`` Push front order."
msgstr ""

msgid "``3`` Push back order."
msgstr ""

msgid "``4`` Optimize insert."
msgstr ""

msgid ""
"``5`` Push back order that allows more orders to be inserted at the back"
msgstr ""

msgid ""
"``6`` Push front order that allows more orders to be inserted at the front"
msgstr ""

msgid "Orders SQL"
msgstr ""

msgid "Common columns for the orders SQL in both implementations:"
msgstr ""

msgid "|ANY-INTEGER|"
msgstr ""

msgid "Identifier of the pick-delivery order pair."
msgstr ""

msgid "``demand``"
msgstr ""

msgid "|ANY-NUMERICAL|"
msgstr ""

msgid "Number of units in the order"
msgstr ""

msgid "``p_open``"
msgstr ""

msgid "The time, relative to 0, when the pickup location opens."
msgstr ""

msgid "``p_close``"
msgstr ""

msgid "The time, relative to 0, when the pickup location closes."
msgstr ""

msgid "[``p_service``]"
msgstr ""

msgid "The duration of the loading at the pickup location."
msgstr ""

msgid "When missing: 0 time units are used"
msgstr ""

msgid "``d_open``"
msgstr ""

msgid "The time, relative to 0, when the delivery location opens."
msgstr ""

msgid "``d_close``"
msgstr ""

msgid "The time, relative to 0, when the delivery location closes."
msgstr ""

msgid "[``d_service``]"
msgstr ""

msgid "The duration of the unloading at the delivery location."
msgstr ""

msgid ""
"For :doc:`pgr_pickDeliver` the pickup and delivery identifiers of the "
"locations are needed:"
msgstr ""

msgid "``p_node_id``"
msgstr ""

msgid ""
"The node identifier of the pickup, must match a vertex identifier in the "
"`Matrix SQL`_."
msgstr ""

msgid "``d_node_id``"
msgstr ""

msgid ""
"The node identifier of the delivery, must match a vertex identifier in the "
"`Matrix SQL`_."
msgstr ""

msgid ""
"For :doc:`pgr_pickDeliverEuclidean` the :math:`(x, y)` values of the "
"locations are needed:"
msgstr ""

msgid "``p_x``"
msgstr ""

msgid ":math:`x` value of the pick up location"
msgstr ""

msgid "``p_y``"
msgstr ""

msgid ":math:`y` value of the pick up location"
msgstr ""

msgid "``d_x``"
msgstr ""

msgid ":math:`x` value of the delivery location"
msgstr ""

msgid "``d_y``"
msgstr ""

msgid ":math:`y` value of the delivery location"
msgstr ""

msgid "Vehicles SQL"
msgstr ""

msgid "Common columns for the vehicles SQL in both implementations:"
msgstr ""

msgid "Identifier of the vehicle."
msgstr ""

msgid "``capacity``"
msgstr ""

msgid "Maiximum capacity units"
msgstr ""

msgid "``start_open``"
msgstr ""

msgid "The time, relative to 0, when the starting location opens."
msgstr ""

msgid "``start_close``"
msgstr ""

msgid "The time, relative to 0, when the starting location closes."
msgstr ""

msgid "[``start_service``]"
msgstr ""

msgid "The duration of the loading at the starting location."
msgstr ""

msgid "When missing: A duration of :math:`0` time units is used."
msgstr ""

msgid "[``end_open``]"
msgstr ""

msgid "The time, relative to 0, when the ending location opens."
msgstr ""

msgid "When missing: The value of ``start_open`` is used"
msgstr ""

msgid "[``end_close``]"
msgstr ""

msgid "The time, relative to 0, when the ending location closes."
msgstr ""

msgid "When missing: The value of ``start_close`` is used"
msgstr ""

msgid "[``end_service``]"
msgstr ""

msgid "The duration of the loading at the ending location."
msgstr ""

msgid "When missing: A duration in ``start_service`` is used."
msgstr ""

msgid ""
"For :doc:`pgr_pickDeliver` the starting and ending identifiers of the "
"locations are needed:"
msgstr ""

msgid "``start_node_id``"
msgstr ""

msgid ""
"The node identifier of the start location, must match a vertex identifier in "
"the `Matrix SQL`_."
msgstr ""

msgid "[``end_node_id``]"
msgstr ""

msgid ""
"The node identifier of the end location, must match a vertex identifier in "
"the `Matrix SQL`_."
msgstr ""

msgid "When missing: ``end_node_id`` is used."
msgstr ""

msgid "``start_x``"
msgstr ""

msgid ":math:`x` value of the starting location"
msgstr ""

msgid "``start_y``"
msgstr ""

msgid ":math:`y` value of the starting location"
msgstr ""

msgid "[``end_x``]"
msgstr ""

msgid ":math:`x` value of the ending location"
msgstr ""

msgid "When missing: ``start_x`` is used."
msgstr ""

msgid "[``end_y``]"
msgstr ""

msgid ":math:`y` value of the ending location"
msgstr ""

msgid "When missing: ``start_y`` is used."
msgstr ""

msgid "Matrix SQL"
msgstr ""

msgid "Set of |matrix-result|"
msgstr ""

msgid "Identifier of the starting vertex."
msgstr ""

msgid "``end_vid``"
msgstr ""

msgid "Identifier of the ending vertex."
msgstr ""

msgid "Aggregate cost from ``start_vid`` to ``end_vid``."
msgstr ""

msgid "Sequential value starting from **1**."
msgstr ""

msgid "``vehicle_seq``"
msgstr ""

msgid ""
"Sequential value starting from **1** for current vehicles. The :math:`n_{th}"
"` vehicle in the solution."
msgstr ""

msgid "Value :math:`-2` indicates it is the summary row."
msgstr ""

msgid "``vehicle_id``"
msgstr ""

msgid "BIGINT"
msgstr ""

msgid "Current vehicle identifier."
msgstr ""

msgid "Sumary row has the **total capacity violations**."
msgstr ""

msgid ""
"A capacity violation happens when overloading or underloading a vehicle."
msgstr ""

msgid "``stop_seq``"
msgstr ""

msgid "INTEGER"
msgstr ""

msgid ""
"Sequential value starting from **1** for the stops made by the current "
"vehicle. The :math:`m_{th}` stop of the current vehicle."
msgstr ""

msgid "Sumary row has the **total time windows violations**."
msgstr ""

msgid ""
"A time window violation happens when arriving after the location has closed."
msgstr ""

msgid "``stop_type``"
msgstr ""

msgid "Kind of stop location the vehicle is at"
msgstr ""

msgid ":math:`-1`: at the solution summary row"
msgstr ""

msgid ":math:`1`: Starting location"
msgstr ""

msgid ":math:`2`: Pickup location"
msgstr ""

msgid ":math:`3`: Delivery location"
msgstr ""

msgid ":math:`6`: Ending location and indicates the vehicle's summary row"
msgstr ""

msgid "``order_id``"
msgstr ""

msgid "Pickup-Delivery order pair identifier."
msgstr ""

msgid ""
"Value :math:`-1`: When no order is involved on the current stop location."
msgstr ""

msgid "``cargo``"
msgstr ""

msgid "Cargo units of the vehicle when leaving the stop."
msgstr ""

msgid "Value :math:`-1` on solution summary row."
msgstr ""

msgid "``travel_time``"
msgstr ""

msgid "Travel time from previous ``stop_seq`` to current ``stop_seq``."
msgstr ""

msgid "Summary has the **total traveling time**:"
msgstr ""

msgid "The sum of all the ``travel_time``."
msgstr ""

msgid "``arrival_time``"
msgstr ""

msgid "Time spent waiting for current location to open."
msgstr ""

msgid ":math:`-1`: at the solution summary row."
msgstr ""

msgid ":math:`0`: at the starting location."
msgstr ""

msgid "``wait_time``"
msgstr ""

msgid "Summary row has the **total waiting time**:"
msgstr ""

msgid "The sum of all the ``wait_time``."
msgstr ""

msgid "``service_time``"
msgstr ""

msgid "Service duration at current location."
msgstr ""

msgid "Summary row has the **total service time**:"
msgstr ""

msgid "The sum of all the ``service_time``."
msgstr ""

msgid "``departure_time``"
msgstr ""

msgid "The time at which the vehicle departs from the stop."
msgstr ""

msgid ":math:`arrival\\_time + wait\\_time + service\\_time`."
msgstr ""

msgid "The ending location has the **total time** used by the current vehicle."
msgstr ""

msgid "Summary row has the **total solution time**:"
msgstr ""

msgid ""
":math:`total\\ traveling\\ time + total\\ waiting\\ time + total\\ service\\ "
"time`."
msgstr ""

msgid "Summary Row"
msgstr ""

msgid "Continues the sequence"
msgstr ""

msgid "**total capacity violations**:"
msgstr ""

msgid "**total time windows violations**:"
msgstr ""

msgid ":math:`-1`"
msgstr ""

msgid "**total traveling time**:"
msgstr ""

msgid "**total waiting time**:"
msgstr ""

msgid "**total service time**:"
msgstr ""

msgid "Handling Parameters"
msgstr ""

msgid ""
"To define a problem, several considerations have to be done, to get "
"consistent results. This section gives an insight of how parameters are to "
"be considered."
msgstr ""

msgid "`Capacity and Demand Units Handling`_"
msgstr ""

msgid "`Locations`_"
msgstr ""

msgid "`Time Handling`_"
msgstr ""

msgid "`Factor Handling`_"
msgstr ""

msgid "Capacity and Demand Units Handling"
msgstr ""

msgid "The `capacity` of a vehicle, can be measured in:"
msgstr ""

msgid "Volume units like :math:`m^3`."
msgstr ""

msgid "Area units like :math:`m^2` (when no stacking is allowed)."
msgstr ""

msgid "Weight units like :math:`kg`."
msgstr ""

msgid "Number of boxes that fit in the vehicle."
msgstr ""

msgid "Number of seats in the vehicle"
msgstr ""

msgid ""
"The `demand` request of the pickup-deliver orders must use the same units as "
"the units used in the vehicle's `capacity`."
msgstr ""

msgid ""
"To handle problems like: 10 (equal dimension) boxes of apples and 5 kg of "
"feathers that are to be transported (not packed in boxes)."
msgstr ""

msgid ""
"If the vehicle's **capacity** is measured in `boxes`, a conversion of `kg of "
"feathers` to `number of boxes` is needed."
msgstr ""

msgid ""
"If the vehicle's **capacity** is measured in `kg`, a conversion of `box of "
"apples` to `kg` is needed."
msgstr ""

msgid "Showing how the 2 possible conversions can be done"
msgstr ""

msgid ""
"Let: - :math:`f\\_boxes`: number of boxes needed for `1` kg of feathers. - :"
"math:`a\\_weight`: weight of `1` box of apples."
msgstr ""

msgid "Capacity Units"
msgstr ""

msgid "apples"
msgstr ""

msgid "feathers"
msgstr ""

msgid "boxes"
msgstr ""

msgid ":math:`5 * f\\_boxes`"
msgstr ""

msgid "kg"
msgstr ""

msgid ":math:`10 * a\\_weight`"
msgstr ""

msgid "5"
msgstr ""

msgid "Locations"
msgstr ""

msgid "When using :doc:`pgr_pickDeliverEuclidean`:"
msgstr ""

msgid "The vehicles have :math:`(x, y)` pairs for start and ending locations."
msgstr ""

msgid "The orders Have :math:`(x, y)` pairs for pickup and delivery locations."
msgstr ""

msgid "When using :doc:`pgr_pickDeliver`:"
msgstr ""

msgid "The vehicles have identifiers for the start and ending locations."
msgstr ""

msgid "The orders have identifiers for the pickup and delivery locations."
msgstr ""

msgid "All the identifiers are indices to the given matrix."
msgstr ""

msgid "Time Handling"
msgstr ""

msgid ""
"The times are relative to **0**. All time units have to be converted to a "
"**0** reference and the same time units."
msgstr ""

msgid ""
"Suppose that a vehicle's driver starts the shift at 9:00 am and ends the "
"shift at 4:30 pm and the service time duration is 10 minutes with 30 seconds."
msgstr ""

msgid "Meaning of 0"
msgstr ""

msgid "time units"
msgstr ""

msgid "9:00 am"
msgstr ""

msgid "4:30 pm"
msgstr ""

msgid "10 min 30 secs"
msgstr ""

msgid "0:00 am"
msgstr ""

msgid "hours"
msgstr ""

msgid "9"
msgstr ""

msgid "16.5"
msgstr ""

msgid ":math:`10.5 / 60 = 0.175`"
msgstr ""

msgid "minutes"
msgstr ""

msgid ":math:`9*60 = 54`"
msgstr ""

msgid ":math:`16.5*60 = 990`"
msgstr ""

msgid "10.5"
msgstr ""

msgid "0"
msgstr ""

msgid "7.5"
msgstr ""

msgid ":math:`7.5*60 = 540`"
msgstr ""

msgid "Factor handling"
msgstr ""

msgid ""
"``factor`` acts as a multiplier to convert from distance values to time "
"units the matrix values or the euclidean values."
msgstr ""

msgid "When the values are already in the desired time units"
msgstr ""

msgid "``factor`` should be **1**"
msgstr ""

msgid "When ``factor`` > 1 the travel times are faster"
msgstr ""

msgid "When ``factor`` < 1 the travel times are slower"
msgstr ""

msgid "For the :doc:`pgr_pickDeliverEuclidean`:"
msgstr ""

msgid ""
"Working with time units in seconds, and x/y in lat/lon: Factor: would depend "
"on the location of the points and on the average velocity say 25m/s is the "
"velocity."
msgstr ""

msgid "Latitude"
msgstr ""

msgid "Conversion"
msgstr ""

msgid "Factor"
msgstr ""

msgid "45"
msgstr ""

msgid "1 longitude degree is (78846.81m)/(25m/s)"
msgstr ""

msgid "3153 s"
msgstr ""

msgid "1 longitude degree is (111319.46 m)/(25m/s)"
msgstr ""

msgid "4452 s"
msgstr ""

msgid "For the :doc:`pgr_pickDeliver`:"
msgstr ""

msgid ""
"Given :math:`v = d / t` therefore :math:`t = d / v` And the ``factor`` "
"becomes :math:`1 / v`"
msgstr ""

msgid "v"
msgstr ""

msgid "Velocity"
msgstr ""

msgid "d"
msgstr ""

msgid "Distance"
msgstr ""

msgid "t"
msgstr ""

msgid "Time"
msgstr ""

msgid ""
"For the following equivalences :math:`10m/s \\approx 600m/min \\approx 36 km/"
"hr`"
msgstr ""

msgid ""
"Working with time units in seconds and the matrix been in meters: For a "
"1000m lenght value on the matrix:"
msgstr ""

msgid "Units"
msgstr ""

msgid "velocity"
msgstr ""

msgid "Result"
msgstr ""

msgid "seconds"
msgstr ""

msgid ":math:`10 m/s`"
msgstr ""

msgid ":math:`\\frac{1}{10m/s}`"
msgstr ""

msgid ":math:`0.1s/m`"
msgstr ""

msgid ":math:`1000m * 0.1s/m = 100s`"
msgstr ""

msgid ":math:`600 m/min`"
msgstr ""

msgid ":math:`\\frac{1}{600m/min}`"
msgstr ""

msgid ":math:`0.0016min/m`"
msgstr ""

msgid ":math:`1000m * 0.0016min/m = 1.6min`"
msgstr ""

msgid "Hours"
msgstr ""

msgid ":math:`36 km/hr`"
msgstr ""

msgid ":math:`\\frac{1}{36 km/hr}`"
msgstr ""

msgid ":math:`0.0277hr/km`"
msgstr ""

msgid ":math:`1km * 0.0277hr/km = 0.0277hr`"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Vehicle_routing_problem"
msgstr ""

msgid "The queries use the :doc:`sampledata` network."
msgstr ""

msgid "A* - Family of functions"
msgstr ""

msgid ""
"The A* (pronounced \"A Star\") algorithm is based on Dijkstra's algorithm "
"with a heuristic that allow it to solve most shortest path problems by "
"evaluation only a sub-set of the overall graph."
msgstr ""

msgid ":doc:`pgr_aStar` - A* algorithm for the shortest path."
msgstr ""

msgid ":doc:`pgr_aStarCost` - Get the aggregate cost of the shortest paths."
msgstr ""

msgid ":doc:`pgr_aStarCostMatrix` - Get the cost matrix of the shortest paths."
msgstr ""

msgid "The main Characteristics are:"
msgstr ""

msgid "Process works for directed and undirected graphs."
msgstr ""

msgid "Ordering is:"
msgstr ""

msgid "first by ``start_vid`` (if exists)"
msgstr ""

msgid "then by ``end_vid``"
msgstr ""

msgid "Values are returned when there is a path."
msgstr ""

msgid "Let :math:`v` and :math:`u` be nodes on the graph:"
msgstr ""

msgid "If there is no path from :math:`v` to :math:`u`:"
msgstr ""

msgid "no corresponding row is returned"
msgstr ""

msgid "``agg_cost`` from :math:`v` to :math:`u` is :math:`\\infty`"
msgstr ""

msgid "There is no path when :math:`v = u` therefore"
msgstr ""

msgid "``agg_cost`` from `v` to `u` is :math:`0`"
msgstr ""

msgid "When :math:`(x,y)` coordinates for the same vertex identifier differ:"
msgstr ""

msgid "A random selection of the vertex's :math:`(x,y)` coordinates is used."
msgstr ""

msgid "Running time: :math:`O((E + V) * \\log V)`"
msgstr ""

msgid "aStar optional parameters"
msgstr ""

msgid "``heuristic``"
msgstr ""

msgid "Heuristic number. Current valid values 0~5."
msgstr ""

msgid "0: :math:`h(v) = 0` (Use this value to compare with pgr_dijkstra)"
msgstr ""

msgid "1: :math:`h(v) = abs(max(\\Delta x, \\Delta y))`"
msgstr ""

msgid "2: :math:`h(v) = abs(min(\\Delta x, \\Delta y))`"
msgstr ""

msgid "3: :math:`h(v) = \\Delta x * \\Delta x + \\Delta y * \\Delta y`"
msgstr ""

msgid "4: :math:`h(v) = sqrt(\\Delta x * \\Delta x + \\Delta y * \\Delta y)`"
msgstr ""

msgid "5: :math:`h(v) = abs(\\Delta x) + abs(\\Delta y)`"
msgstr ""

msgid "``1``"
msgstr ""

msgid "For units manipulation. :math:`factor > 0`."
msgstr ""

msgid "``epsilon``"
msgstr ""

msgid "For less restricted results. :math:`epsilon >= 1`."
msgstr ""

msgid ""
"See :ref:`heuristics <astar_heuristics>` available and :ref:`factor "
"<astar_factor>` handling."
msgstr ""

msgid "Advanced documentation"
msgstr ""

msgid "Heuristic"
msgstr ""

msgid "Currently the heuristic functions available are:"
msgstr ""

msgid "where :math:`\\Delta x = x_1 - x_0` and :math:`\\Delta y = y_1 - y_0`"
msgstr ""

msgid "Analysis 1"
msgstr ""

msgid ""
"Working with cost/reverse_cost as length in degrees, x/y in lat/lon: Factor "
"= 1 (no need to change units)"
msgstr ""

msgid "Analysis 2"
msgstr ""

msgid ""
"Working with cost/reverse_cost as length in meters, x/y in lat/lon: Factor = "
"would depend on the location of the points:"
msgstr ""

msgid "1 longitude degree is 78846.81 m"
msgstr ""

msgid "78846"
msgstr ""

msgid "1 longitude degree is 111319.46 m"
msgstr ""

msgid "111319"
msgstr ""

msgid "Analysis 3"
msgstr ""

msgid ""
"Working with cost/reverse_cost as time in seconds, x/y in lat/lon: Factor: "
"would depend on the location of the points and on the average speed say 25m/"
"s is the speed."
msgstr ""

msgid ":doc:`bdAstar-family`"
msgstr ""

msgid "https://www.boost.org/libs/graph/doc/astar_search.html"
msgstr ""

msgid "https://en.wikipedia.org/wiki/A*_search_algorithm"
msgstr ""

msgid "All Pairs - Family of Functions"
msgstr ""

msgid "The following functions work on all vertices pair combinations"
msgstr ""

msgid ":doc:`pgr_floydWarshall` - Floyd-Warshall's algorithm."
msgstr ""

msgid ":doc:`pgr_johnson` - Johnson's algorithm"
msgstr ""

msgid "The main characteristics are:"
msgstr ""

msgid "It does not return a path."
msgstr ""

msgid ""
"Returns the sum of the costs of the shortest path for each pair of nodes in "
"the graph."
msgstr ""

msgid ""
"Boost returns a :math:`V \\times V` matrix, where the infinity values. "
"Represent the distance between vertices for which there is no path."
msgstr ""

msgid ""
"We return only the non infinity values in form of a set of `(start_vid, "
"end_vid, agg_cost)`."
msgstr ""

msgid ""
"Let be the case the values returned are stored in a table, so the unique "
"index would be the pair: `(start_vid, end_vid)`."
msgstr ""

msgid "For the undirected graph, the results are symmetric."
msgstr ""

msgid "The `agg_cost` of `(u, v)` is the same as for `(v, u)`."
msgstr ""

msgid "When `start_vid` = `end_vid`, the `agg_cost` = 0."
msgstr ""

msgid "**Recommended, use a bounding box of no more than 3500 edges.**"
msgstr ""

msgid "Optional parameters"
msgstr ""

msgid "``directed``"
msgstr ""

msgid "``BOOLEAN``"
msgstr ""

msgid "``true``"
msgstr ""

msgid "When ``true`` the graph is considered `Directed`"
msgstr ""

msgid "When ``false`` the graph is considered as `Undirected`."
msgstr ""

msgid "Performance"
msgstr ""

msgid "The following tests:"
msgstr ""

msgid "non server computer"
msgstr ""

msgid "with AMD 64 CPU"
msgstr ""

msgid "4G memory"
msgstr ""

msgid "trusty"
msgstr ""

msgid "posgreSQL version 9.3"
msgstr ""

msgid "Data"
msgstr ""

msgid "The following data was used"
msgstr ""

msgid "Data processing was done with osm2pgrouting-alpha"
msgstr ""

msgid "Results"
msgstr ""

msgid "Test"
msgstr ""

msgid "One"
msgstr ""

msgid ""
"This test is not with a bounding box The density of the passed graph is "
"extremely low. For each <SIZE> 30 tests were executed to get the average The "
"tested query is:"
msgstr ""

msgid "The results of this tests are presented as:"
msgstr ""

msgid "SIZE"
msgstr ""

msgid "is the number of edges given as input."
msgstr ""

msgid "EDGES"
msgstr ""

msgid "is the total number of records in the query."
msgstr ""

msgid "DENSITY"
msgstr ""

msgid "is the density of the data :math:`\\dfrac{E}{V \\times (V-1)}`."
msgstr ""

msgid "OUT ROWS"
msgstr ""

msgid "is the number of records returned by the queries."
msgstr ""

msgid "Floyd-Warshall"
msgstr ""

msgid "is the average execution time in seconds of pgr_floydWarshall."
msgstr ""

msgid "Johnson"
msgstr ""

msgid "is the average execution time in seconds of pgr_johnson."
msgstr ""

msgid "500"
msgstr ""

msgid "0.18E-7"
msgstr ""

msgid "1346"
msgstr ""

msgid "0.14"
msgstr ""

msgid "0.13"
msgstr ""

msgid "1000"
msgstr ""

msgid "0.36E-7"
msgstr ""

msgid "2655"
msgstr ""

msgid "0.23"
msgstr ""

msgid "0.18"
msgstr ""

msgid "1500"
msgstr ""

msgid "0.55E-7"
msgstr ""

msgid "4110"
msgstr ""

msgid "0.37"
msgstr ""

msgid "0.34"
msgstr ""

msgid "2000"
msgstr ""

msgid "0.73E-7"
msgstr ""

msgid "5676"
msgstr ""

msgid "0.56"
msgstr ""

msgid "2500"
msgstr ""

msgid "0.89E-7"
msgstr ""

msgid "7177"
msgstr ""

msgid "0.84"
msgstr ""

msgid "0.51"
msgstr ""

msgid "3000"
msgstr ""

msgid "1.07E-7"
msgstr ""

msgid "8778"
msgstr ""

msgid "1.28"
msgstr ""

msgid "0.68"
msgstr ""

msgid "3500"
msgstr ""

msgid "1.24E-7"
msgstr ""

msgid "10526"
msgstr ""

msgid "2.08"
msgstr ""

msgid "0.95"
msgstr ""

msgid "4000"
msgstr ""

msgid "1.41E-7"
msgstr ""

msgid "12484"
msgstr ""

msgid "3.16"
msgstr ""

msgid "1.24"
msgstr ""

msgid "4500"
msgstr ""

msgid "1.58E-7"
msgstr ""

msgid "14354"
msgstr ""

msgid "4.49"
msgstr ""

msgid "1.47"
msgstr ""

msgid "5000"
msgstr ""

msgid "1.76E-7"
msgstr ""

msgid "16503"
msgstr ""

msgid "6.05"
msgstr ""

msgid "1.78"
msgstr ""

msgid "5500"
msgstr ""

msgid "1.93E-7"
msgstr ""

msgid "18623"
msgstr ""

msgid "7.53"
msgstr ""

msgid "2.03"
msgstr ""

msgid "6000"
msgstr ""

msgid "2.11E-7"
msgstr ""

msgid "20710"
msgstr ""

msgid "8.47"
msgstr ""

msgid "2.37"
msgstr ""

msgid "6500"
msgstr ""

msgid "2.28E-7"
msgstr ""

msgid "22752"
msgstr ""

msgid "9.99"
msgstr ""

msgid "2.68"
msgstr ""

msgid "7000"
msgstr ""

msgid "2.46E-7"
msgstr ""

msgid "24687"
msgstr ""

msgid "11.82"
msgstr ""

msgid "3.12"
msgstr ""

msgid "7500"
msgstr ""

msgid "2.64E-7"
msgstr ""

msgid "26861"
msgstr ""

msgid "13.94"
msgstr ""

msgid "3.60"
msgstr ""

msgid "8000"
msgstr ""

msgid "2.83E-7"
msgstr ""

msgid "29050"
msgstr ""

msgid "15.61"
msgstr ""

msgid "4.09"
msgstr ""

msgid "8500"
msgstr ""

msgid "3.01E-7"
msgstr ""

msgid "31693"
msgstr ""

msgid "17.43"
msgstr ""

msgid "4.63"
msgstr ""

msgid "9000"
msgstr ""

msgid "3.17E-7"
msgstr ""

msgid "33879"
msgstr ""

msgid "19.19"
msgstr ""

msgid "5.34"
msgstr ""

msgid "9500"
msgstr ""

msgid "3.35E-7"
msgstr ""

msgid "36287"
msgstr ""

msgid "20.77"
msgstr ""

msgid "6.24"
msgstr ""

msgid "10000"
msgstr ""

msgid "3.52E-7"
msgstr ""

msgid "38491"
msgstr ""

msgid "23.26"
msgstr ""

msgid "6.51"
msgstr ""

msgid "Two"
msgstr ""

msgid ""
"This test is with a bounding box The density of the passed graph higher than "
"of the Test One. For each <SIZE> 30 tests were executed to get the average "
"The tested edge query is:"
msgstr ""

msgid "The tested queries"
msgstr ""

msgid "is the size of the bounding box."
msgstr ""

msgid "0.001"
msgstr ""

msgid "44"
msgstr ""

msgid "0.0608"
msgstr ""

msgid "1197"
msgstr ""

msgid "0.10"
msgstr ""

msgid "0.002"
msgstr ""

msgid "99"
msgstr ""

msgid "0.0251"
msgstr ""

msgid "4330"
msgstr ""

msgid "0.003"
msgstr ""

msgid "223"
msgstr ""

msgid "0.0122"
msgstr ""

msgid "18849"
msgstr ""

msgid "0.12"
msgstr ""

msgid "0.004"
msgstr ""

msgid "358"
msgstr ""

msgid "0.0085"
msgstr ""

msgid "71834"
msgstr ""

msgid "0.16"
msgstr ""

msgid "0.005"
msgstr ""

msgid "470"
msgstr ""

msgid "0.0070"
msgstr ""

msgid "116290"
msgstr ""

msgid "0.22"
msgstr ""

msgid "0.19"
msgstr ""

msgid "0.006"
msgstr ""

msgid "639"
msgstr ""

msgid "0.0055"
msgstr ""

msgid "207030"
msgstr ""

msgid "0.27"
msgstr ""

msgid "0.007"
msgstr ""

msgid "843"
msgstr ""

msgid "0.0043"
msgstr ""

msgid "346930"
msgstr ""

msgid "0.64"
msgstr ""

msgid "0.38"
msgstr ""

msgid "0.008"
msgstr ""

msgid "996"
msgstr ""

msgid "0.0037"
msgstr ""

msgid "469936"
msgstr ""

msgid "0.90"
msgstr ""

msgid "0.49"
msgstr ""

msgid "0.009"
msgstr ""

msgid "1146"
msgstr ""

msgid "0.0032"
msgstr ""

msgid "613135"
msgstr ""

msgid "1.26"
msgstr ""

msgid "0.62"
msgstr ""

msgid "0.010"
msgstr ""

msgid "1360"
msgstr ""

msgid "0.0027"
msgstr ""

msgid "849304"
msgstr ""

msgid "1.87"
msgstr ""

msgid "0.82"
msgstr ""

msgid "0.011"
msgstr ""

msgid "1573"
msgstr ""

msgid "0.0024"
msgstr ""

msgid "1147101"
msgstr ""

msgid "2.65"
msgstr ""

msgid "1.04"
msgstr ""

msgid "0.012"
msgstr ""

msgid "1789"
msgstr ""

msgid "0.0021"
msgstr ""

msgid "1483629"
msgstr ""

msgid "3.72"
msgstr ""

msgid "1.35"
msgstr ""

msgid "0.013"
msgstr ""

msgid "1975"
msgstr ""

msgid "0.0019"
msgstr ""

msgid "1846897"
msgstr ""

msgid "4.86"
msgstr ""

msgid "1.68"
msgstr ""

msgid "0.014"
msgstr ""

msgid "2281"
msgstr ""

msgid "0.0017"
msgstr ""

msgid "2438298"
msgstr ""

msgid "7.08"
msgstr ""

msgid "2.28"
msgstr ""

msgid "0.015"
msgstr ""

msgid "2588"
msgstr ""

msgid "0.0015"
msgstr ""

msgid "3156007"
msgstr ""

msgid "10.28"
msgstr ""

msgid "2.80"
msgstr ""

msgid "0.016"
msgstr ""

msgid "2958"
msgstr ""

msgid "0.0013"
msgstr ""

msgid "4090618"
msgstr ""

msgid "14.67"
msgstr ""

msgid "3.76"
msgstr ""

msgid "0.017"
msgstr ""

msgid "3247"
msgstr ""

msgid "0.0012"
msgstr ""

msgid "4868919"
msgstr ""

msgid "18.12"
msgstr ""

msgid "4.48"
msgstr ""

msgid ":doc:`pgr_johnson`"
msgstr ""

msgid ":doc:`pgr_floydWarshall`"
msgstr ""

msgid ""
"Boost `floyd-Warshall <https://www.boost.org/libs/graph/doc/"
"floyd_warshall_shortest.html>`__"
msgstr ""

msgid "Bidirectional A* - Family of functions"
msgstr ""

msgid ""
"The bidirectional A* (pronounced \"A Star\") algorithm is based on the A* "
"algorithm."
msgstr ""

msgid ":doc:`pgr_bdAstar` - Bidirectional A* algorithm for obtaining paths."
msgstr ""

msgid ""
":doc:`pgr_bdAstarCost` - Bidirectional A* algorithm to calculate the cost of "
"the paths."
msgstr ""

msgid ""
":doc:`pgr_bdAstarCostMatrix` - Bidirectional A* algorithm to calculate a "
"cost matrix of paths."
msgstr ""

msgid ""
"Based on A* algorithm, the bidirectional search finds a shortest path from a "
"starting vertex (``start_vid``) to an ending vertex (``end_vid``). It runs "
"two simultaneous searches: one forward from the ``start_vid``, and one "
"backward from the ``end_vid``, stopping when the two meet in the middle. "
"This implementation can be used with a directed graph and an undirected "
"graph."
msgstr ""

msgid ""
"For large graphs where there is a path bewtween the starting vertex and "
"ending vertex:"
msgstr ""

msgid "It is expected to terminate faster than pgr_astar"
msgstr ""

msgid ":doc:`aStar-family`"
msgstr ""

msgid "Previous versions of this page"
msgstr ""

msgid "Bidirectional Dijkstra - Family of functions"
msgstr ""

msgid ""
":doc:`pgr_bdDijkstra` - Bidirectional Dijkstra algorithm for the shortest "
"paths."
msgstr ""

msgid ""
":doc:`pgr_bdDijkstraCost` - Bidirectional Dijkstra to calculate the cost of "
"the shortest paths"
msgstr ""

msgid ""
":doc:`pgr_bdDijkstraCostMatrix` - Bidirectional Dijkstra algorithm to create "
"a matrix of costs of the shortest paths."
msgstr ""

msgid "Synopsis"
msgstr ""

msgid ""
"Based on Dijkstra's algorithm, the bidirectional search finds a shortest "
"path a starting vertex to an ending vertex."
msgstr ""

msgid ""
"It runs two simultaneous searches: one forward from the source, and one "
"backward from the target, stopping when the two meet in the middle."
msgstr ""

msgid ""
"This implementation can be used with a directed graph and an undirected "
"graph."
msgstr ""

msgid ""
"A negative value on a cost column is interpreted as the edge does not exist."
msgstr ""

msgid "When there is no path:"
msgstr ""

msgid "When the starting vertex and ending vertex are the same."
msgstr ""

msgid ""
"The **aggregate cost** of the non included values :math:`(v, v)` is :math:`0`"
msgstr ""

msgid ""
"When the starting vertex and ending vertex are the different and there is no "
"path:"
msgstr ""

msgid ""
"The **aggregate cost** the non included values :math:`(u, v)` is :math:"
"`\\infty`"
msgstr ""

msgid ""
"For optimization purposes, any duplicated value in the starting vertices or "
"on the ending vertices are ignored."
msgstr ""

msgid "Running time (worse case scenario): :math:`O((V \\log V + E))`"
msgstr ""

msgid "It is expected to terminate faster than pgr_dijkstra"
msgstr ""

msgid "Chinese Postman Problem - Family of functions (Experimental)"
msgstr ""

msgid ":doc:`pgr_chinesePostman`"
msgstr ""

msgid ":doc:`pgr_chinesePostmanCost`"
msgstr ""

msgid "**The main characteristics are:**"
msgstr ""

msgid "Process is done only on edges with **positive** costs."
msgstr ""

msgid "Running time: :math:`O(E * (E + V * logV))`"
msgstr ""

msgid "Graph must be connected."
msgstr ""

msgid ""
"An Edges SQL that represents a **directed** graph with the following columns"
msgstr ""

msgid "Coloring - Family of functions"
msgstr ""

msgid ""
":doc:`pgr_sequentialVertexColoring` - Vertex coloring algorithm using greedy "
"approach."
msgstr ""

msgid ""
":doc:`pgr_bipartite` - Bipartite graph algorithm using a DFS-based coloring "
"approach."
msgstr ""

msgid ""
":doc:`pgr_edgeColoring` - Edge Coloring algorithm using Vizing's theorem."
msgstr ""

msgid "Returns set of ``(vertex_id, color_id)``"
msgstr ""

msgid "``vertex_id``"
msgstr ""

msgid "Identifier of the vertex."
msgstr ""

msgid "``color_id``"
msgstr ""

msgid "Identifier of the color of the vertex."
msgstr ""

msgid "The minimum value of color is 1."
msgstr ""

msgid "Returns set of ``(edge_id, color_id)``"
msgstr ""

msgid "``edge_id``"
msgstr ""

msgid "Identifier of the color of the edge."
msgstr ""

msgid ""
"`Boost: Sequential Vertex Coloring algorithm documentation <https://www."
"boost.org/libs/graph/doc/sequential_vertex_coloring.html>`__"
msgstr ""

msgid ""
"`Wikipedia: Graph coloring <https://en.wikipedia.org/wiki/Graph_coloring>`__"
msgstr ""

msgid ""
"`Boost: is_bipartite <https://www.boost.org/libs/graph/doc/is_bipartite."
"html>`__"
msgstr ""

msgid ""
"`Wikipedia: bipartite graph <https://en.wikipedia.org/wiki/"
"Bipartite_graph>`__"
msgstr ""

msgid ""
"`Boost: Edge Coloring Algorithm documentation <https://www.boost.org/libs/"
"graph/doc/edge_coloring.html>`__"
msgstr ""

msgid ""
"`Wikipedia: Graph Coloring <https://en.wikipedia.org/wiki/Graph_coloring>`__"
msgstr ""

msgid "Components - Family of functions"
msgstr ""

msgid ""
":doc:`pgr_connectedComponents` - Connected components of an undirected graph."
msgstr ""

msgid ""
":doc:`pgr_strongComponents` - Strongly connected components of a directed "
"graph."
msgstr ""

msgid ""
":doc:`pgr_biconnectedComponents` - Biconnected components of an undirected "
"graph."
msgstr ""

msgid ""
":doc:`pgr_articulationPoints` - Articulation points of an undirected graph."
msgstr ""

msgid ":doc:`pgr_bridges` - Bridges of an undirected graph."
msgstr ""

msgid ":doc:`pgr_makeConnected` - Details of edges to make graph connected."
msgstr ""

msgid "Contraction - Family of functions"
msgstr ""

msgid ":doc:`pgr_contraction`"
msgstr ""

msgid ""
"In large graphs, like the road graphs, or electric networks, graph "
"contraction can be used to speed up some graph algorithms. Contraction "
"reduces the size of the graph by removing some of the vertices and edges "
"and, for example, might add edges that represent a sequence of original "
"edges decreasing the total time and space used in graph algorithms."
msgstr ""

msgid ""
"This implementation gives a flexible framework for adding contraction "
"algorithms in the future, currently, it supports two algorithms:"
msgstr ""

msgid "Dead end contraction"
msgstr ""

msgid "Linear contraction"
msgstr ""

msgid "Allowing the user to:"
msgstr ""

msgid "Forbid contraction on a set of nodes."
msgstr ""

msgid ""
"Decide the order of the contraction algorithms and set the maximum number of "
"times they are to be executed."
msgstr ""

msgid "Contraction of the leaf nodes of the graph."
msgstr ""

msgid "Dead end"
msgstr ""

msgid "A node is considered a **dead end** node when"
msgstr ""

msgid "On undirected graphs:"
msgstr ""

msgid "The number of adjacent vertices is 1."
msgstr ""

msgid "On directed graphs:"
msgstr ""

msgid "There are no outgoing edges and has at least one incoming edge."
msgstr ""

msgid "There are no incoming edges and has at least one outgoing edge."
msgstr ""

msgid ""
"When the conditions are true then the `Operation: Dead End Contraction`_ can "
"be done."
msgstr ""

msgid "Dead end vertex on undirected graph"
msgstr ""

msgid "The green nodes are `dead end`_ nodes"
msgstr ""

msgid "The blue nodes have an unlimited number of edges."
msgstr ""

msgid "Node"
msgstr ""

msgid "Adjecent nodes"
msgstr ""

msgid "Number of adjacent nodes"
msgstr ""

msgid ":math:`a`"
msgstr ""

msgid ":math:`\\{u\\}`"
msgstr ""

msgid ":math:`b`"
msgstr ""

msgid ":math:`\\{v\\}`"
msgstr ""

msgid "Dead end vertex on directed graph"
msgstr ""

msgid ""
"The blue nodes have an unlimited number of incoming and/or outgoing edges."
msgstr ""

msgid "Number of incoming edges"
msgstr ""

msgid "Number of outgoing edges"
msgstr ""

msgid ":math:`c`"
msgstr ""

msgid ":math:`\\{v, w\\}`"
msgstr ""

msgid "2"
msgstr ""

msgid ":math:`d`"
msgstr ""

msgid ":math:`\\{x\\}`"
msgstr ""

msgid ":math:`e`"
msgstr ""

msgid ":math:`\\{x, y\\}`"
msgstr ""

msgid ""
"From above, nodes :math:`\\{a, b, d\\}` are dead ends because the number of "
"adjacent vertices is 1. No further checks are needed for those nodes."
msgstr ""

msgid ""
"On the following table, nodes :math:`\\{c, e\\}` because the even that the "
"number of adjacent vertices is not 1 for"
msgstr ""

msgid "Operation: Dead End Contraction"
msgstr ""

msgid ""
"The dead end contraction will stop until there are no more dead end nodes. "
"For example from the following graph where :math:`w` is the `dead end`_ node:"
msgstr ""

msgid ""
"After contracting :math:`w`, node :math:`v` is now a `dead end`_ node and is "
"contracted:"
msgstr ""

msgid ""
"After contracting :math:`v`, stop. Node :math:`u` has the information of "
"nodes that were contrcted."
msgstr ""

msgid "Node :math:`u` has the information of nodes that were contracted."
msgstr ""

msgid "In the algorithm, linear contraction is represented by 2."
msgstr ""

msgid "Linear"
msgstr ""

msgid ""
"In case of an undirected graph, a node is considered a `linear` node when"
msgstr ""

msgid "The number of adjacent vertices is 2."
msgstr ""

msgid "In case of a directed graph, a node is considered a `linear` node when"
msgstr ""

msgid "Linearity is symmetrical"
msgstr ""

msgid "Linear vertex on undirected graph"
msgstr ""

msgid "The green nodes are `linear`_ nodes"
msgstr ""

msgid "The blue nodes have an unlimited number of incoming and outgoing edges."
msgstr ""

msgid "Undirected"
msgstr ""

msgid ":math:`v`"
msgstr ""

msgid ":math:`\\{u, w\\}`"
msgstr ""

msgid "Linear vertex on directed graph"
msgstr ""

msgid "The white node is not linear because the linearity is not symetrical."
msgstr ""

msgid "It is possible to go :math:`y \\rightarrow c \\rightarrow z`"
msgstr ""

msgid "It's not possible to go :math:`z \\rightarrow c \\rightarrow y`"
msgstr ""

msgid "Is symmetrical?"
msgstr ""

msgid ":math:`\\{u, v\\}`"
msgstr ""

msgid "yes"
msgstr ""

msgid ":math:`\\{w, x\\}`"
msgstr ""

msgid ":math:`\\{y, z\\}`"
msgstr ""

msgid "no"
msgstr ""

msgid "Operation: Linear Contraction"
msgstr ""

msgid ""
"The linear contraction will stop when there are no more linear nodes. For "
"example from the following graph where :math:`v` and :math:`w` are `linear`_ "
"nodes:"
msgstr ""

msgid "Contracting :math:`w`,"
msgstr ""

msgid "The vertex :math:`w` is removed from the graph"
msgstr ""

msgid ""
"The edges :math:`v \\rightarrow w` and :math:`w \\rightarrow z` are removed "
"from the graph."
msgstr ""

msgid ""
"A new edge :math:`v \\rightarrow z` is inserted represented with red color."
msgstr ""

msgid "Contracting :math:`v`:"
msgstr ""

msgid "The vertex :math:`v` is removed from the graph"
msgstr ""

msgid ""
"The edges :math:`u \\rightarrow v` and :math:`v \\rightarrow z` are removed "
"from the graph."
msgstr ""

msgid ""
"A new edge :math:`u \\rightarrow z` is inserted represented with red color."
msgstr ""

msgid ""
"Edge :math:`u \\rightarrow z` has the information of nodes that were "
"contracted."
msgstr ""

msgid "The cycle"
msgstr ""

msgid ""
"Contracting a graph, can be done with more than one operation. The order of "
"the operations affect the resulting contracted graph, after applying one "
"operation, the set of vertices that can be contracted by another operation "
"changes."
msgstr ""

msgid ""
"This implementation, cycles ``max_cycles`` times through "
"``operations_order`` ."
msgstr ""

msgid "Contracting sample data"
msgstr ""

msgid ""
"In this section, building and using a contracted graph will be shown by "
"example."
msgstr ""

msgid "The :doc:`sampledata` for an undirected graph is used"
msgstr ""

msgid "a dead end operation first followed by a linear operation."
msgstr ""

msgid "Construction of the graph in the database"
msgstr ""

msgid "Original Data"
msgstr ""

msgid ""
"The following query shows the original data involved in the contraction "
"operation."
msgstr ""

msgid "The original graph:"
msgstr ""

msgid "Contraction results"
msgstr ""

msgid ""
"The results do not represent the contracted graph. They represent the "
"changes done to the graph after applying the contraction algorithm."
msgstr ""

msgid ""
"Observe that vertices, for example, :math:`6` do not appear in the results "
"because it was not affected by the contraction algorithm."
msgstr ""

msgid "After doing the dead end contraction operation:"
msgstr ""

msgid "After doing the linear contraction operation to the graph above:"
msgstr ""

msgid "The process to create the contraction graph on the database:"
msgstr ""

msgid "Add additional columns"
msgstr ""

msgid ""
"Adding extra columns to the ``edge_table`` and ``edge_table_vertices_pgr`` "
"tables, where:"
msgstr ""

msgid "``contracted_vertices``"
msgstr ""

msgid "The vertices set belonging to the vertex/edge"
msgstr ""

msgid "``is_contracted``"
msgstr ""

msgid "On the vertex table"
msgstr ""

msgid ""
"when ``true`` the vertex is contracted, its not part of the contracted graph."
msgstr ""

msgid ""
"when ``false`` the vertex is not contracted, its part of the contracted "
"graph."
msgstr ""

msgid "``is_new``"
msgstr ""

msgid "On the edge table"
msgstr ""

msgid ""
"when ``true`` the edge was generated by the contraction algorithm. its part "
"of the contracted graph."
msgstr ""

msgid ""
"when ``false`` the edge is an original edge, might be or not part of the "
"contracted graph."
msgstr ""

msgid "Store contraction information"
msgstr ""

msgid "Store the `contraction results`_ in a table"
msgstr ""

msgid "The vertex table update"
msgstr ""

msgid ""
"Use ``is_contracted`` column to indicate the vertices that are contracted."
msgstr ""

msgid ""
"Fill ``contracted_vertices`` with the information from the results tha "
"belong to the vertices."
msgstr ""

msgid "The modified vertices table:"
msgstr ""

msgid "The edge table update"
msgstr ""

msgid "Insert the new edges generated by pgr_contraction."
msgstr ""

msgid "The modified ``edge_table``."
msgstr ""

msgid "The contracted graph"
msgstr ""

msgid "Vertices that belong to the contracted graph."
msgstr ""

msgid "Edges that belong to the contracted graph."
msgstr ""

msgid "Contracted graph"
msgstr ""

msgid "Using the contracted graph"
msgstr ""

msgid "Using the contracted graph with ``pgr_dijkstra``"
msgstr ""

msgid ""
"There are three cases when calculating the shortest path between a given "
"source and target in a contracted graph:"
msgstr ""

msgid "Case 1: Both source and target belong to the contracted graph."
msgstr ""

msgid "Case 2: Source and/or target belong to an edge subgraph."
msgstr ""

msgid "Case 3: Source and/or target belong to a vertex."
msgstr ""

msgid ""
"Using the `Edges that belong to the contracted graph.`_ on lines 11 to 20."
msgstr ""

msgid "Case 1"
msgstr ""

msgid ""
"When both source and target belong to the contracted graph, a path is found."
msgstr ""

msgid "Case 2"
msgstr ""

msgid ""
"When source and/or target belong to an edge subgraph then a path is not "
"found."
msgstr ""

msgid ""
"In this case, the contracted graph do not have an edge connecting with node :"
"math:`4`."
msgstr ""

msgid "Case 3"
msgstr ""

msgid "When source and/or target belong to a vertex then a path is not found."
msgstr ""

msgid ""
"In this case, the contracted graph do not have an edge connecting with node :"
"math:`7` and of node :math:`4` of the second case."
msgstr ""

msgid "Refining the above function to include nodes that belong to an edge."
msgstr ""

msgid "The vertices that need to be expanded are calculated on lines 11 to 17."
msgstr ""

msgid ""
"Adding to the contracted graph that additional section on lines 26 to 28."
msgstr ""

msgid ""
"When source and/or target belong to an edge subgraph, now, a path is found."
msgstr ""

msgid "The routing graph now has an edge connecting with node :math:`4`."
msgstr ""

msgid ""
"In this case, the contracted graph do not have an edge connecting with node :"
"math:`7`."
msgstr ""

msgid "The vertices that need to be expanded are calculated on lines 19 to 24."
msgstr ""

msgid ""
"Adding to the contracted graph that additional section on lines 38 to 40."
msgstr ""

msgid ""
"The code change do not affect this case so when source and/or target belong "
"to an edge subgraph, a path is still found."
msgstr ""

msgid "When source and/or target belong to a vertex, now, a path is found."
msgstr ""

msgid "Now, the routing graph has an edge connecting with node :math:`7`."
msgstr ""

msgid ":doc:`sampledata`"
msgstr ""

msgid ""
"https://www.cs.cmu.edu/afs/cs/academic/class/15210-f12/www/lectures/"
"lecture16.pdf"
msgstr ""

msgid "https://algo2.iti.kit.edu/documents/routeplanning/geisberger_dipl.pdf"
msgstr ""

msgid "Cost - Category"
msgstr ""

msgid ":doc:`pgr_aStarCost`"
msgstr ""

msgid ":doc:`pgr_bdAstarCost`"
msgstr ""

msgid ":doc:`pgr_dijkstraCost`"
msgstr ""

msgid ":doc:`pgr_bdDijkstraCost`"
msgstr ""

msgid ":doc:`pgr_dijkstraNearCost`"
msgstr ""

msgid ":doc:`pgr_withPointsCost`"
msgstr ""

msgid "Each function works as part of the family it belongs to."
msgstr ""

msgid ""
"Returns the sum of the costs of the shortest path of each pair combination "
"of nodes requested."
msgstr ""

msgid ""
"Let be the case the values returned are stored in a table, so the unique "
"index would be the pair: ``(start_vid, end_vid)``."
msgstr ""

msgid ""
"Depending on the function and its parameters, the results can be symmetric."
msgstr ""

msgid ""
"The **aggregate cost** of :math:`(u, v)` is the same as for :math:`(v, u)`."
msgstr ""

msgid ""
"Any duplicated value in the start or end vertex identifiers are ignored."
msgstr ""

msgid "The returned values are ordered:"
msgstr ""

msgid "``start_vid`` ascending"
msgstr ""

msgid "``end_vid`` ascending"
msgstr ""

msgid "Cost Matrix - Category"
msgstr ""

msgid ":doc:`pgr_aStarCostMatrix`"
msgstr ""

msgid ":doc:`pgr_dijkstraCostMatrix`"
msgstr ""

msgid ":doc:`pgr_bdAstarCostMatrix`"
msgstr ""

msgid ":doc:`pgr_bdDijkstraCostMatrix`"
msgstr ""

msgid "proposed"
msgstr ""

msgid ":doc:`pgr_withPointsCostMatrix`"
msgstr ""

msgid ""
":doc:`TSP-family` needs as input a symmetric cost matrix and no edge `(u, "
"v)` must value :math:`\\infty`."
msgstr ""

msgid ""
"This collection of functions will return a cost matrix in form of a table."
msgstr ""

msgid "Can be used as input to :doc:`pgr_TSP`."
msgstr ""

msgid ""
"Use directly when the resulting matrix is symmetric and there is no :math:"
"`\\infty` value."
msgstr ""

msgid "It will be the users responsibility to make the matrix symmetric."
msgstr ""

msgid "By using geometric or harmonic average of the non symmetric values."
msgstr ""

msgid "By using max or min the non symmetric values."
msgstr ""

msgid ""
"By setting the upper triangle to be the mirror image of the lower triangle."
msgstr ""

msgid ""
"By setting the lower triangle to be the mirror image of the upper triangle."
msgstr ""

msgid "It is also the users responsibility to fix an :math:`\\infty` value."
msgstr ""

msgid ""
"Returns the sum of the costs of the shortest path for pair combination of "
"nodes in the graph."
msgstr ""

msgid ""
"When the starting vertex and ending vertex are the same, there is no path."
msgstr ""

msgid "The aggregate cost in the non included values `(v, v)` is `0`."
msgstr ""

msgid ""
"When the starting vertex and ending vertex are the different and there is no "
"path."
msgstr ""

msgid ""
"The aggregate cost in the non included values `(u, v)` is :math:`\\infty`."
msgstr ""

msgid "Let be the case the values returned are stored in a table:"
msgstr ""

msgid "The unique index would be the pair: ``(start_vid, end_vid)``."
msgstr ""

msgid "The aggregate cost of `(u, v)` is the same as for `(v, u)`."
msgstr ""

msgid "Any duplicated value in the **start vids** are ignored."
msgstr ""

msgid "Used in:"
msgstr ""

msgid "`Edges SQL`_ as described below"
msgstr ""

msgid "**start vids**"
msgstr ""

msgid "``ARRAY[BIGINT]``"
msgstr ""

msgid "Array of identifiers of starting vertices."
msgstr ""

msgid "`Points SQL`_"
msgstr ""

msgid "`Points SQL`_ as described below"
msgstr ""

msgid "Points SQL"
msgstr ""

msgid "``pid``"
msgstr ""

msgid "**value**"
msgstr ""

msgid "Identifier of the point."
msgstr ""

msgid ""
"Use with positive value, as internally will be converted to negative value"
msgstr ""

msgid "If column is present, it can not be NULL."
msgstr ""

msgid ""
"If column is not present, a sequential negative **value** will be given "
"automatically."
msgstr ""

msgid "Identifier of the \"closest\" edge to the point."
msgstr ""

msgid "``fraction``"
msgstr ""

msgid ""
"Value in <0,1> that indicates the relative postition from the first end "
"point of the edge."
msgstr ""

msgid "``side``"
msgstr ""

msgid "``CHAR``"
msgstr ""

msgid "``b``"
msgstr ""

msgid "Value in [``b``, ``r``, ``l``, ``NULL``] indicating if the point is:"
msgstr ""

msgid "In the right ``r``,"
msgstr ""

msgid "In the left ``l``,"
msgstr ""

msgid "In both sides ``b``, ``NULL``"
msgstr ""

msgid ":doc:`TSP-family`"
msgstr ""

msgid "Dijkstra - Family of functions"
msgstr ""

msgid ":doc:`pgr_dijkstra` - Dijkstra's algorithm for the shortest paths."
msgstr ""

msgid ":doc:`pgr_dijkstraCost` - Get the aggregate cost of the shortest paths."
msgstr ""

msgid ""
":doc:`pgr_dijkstraCostMatrix` - Use pgr_dijkstra to create a costs matrix."
msgstr ""

msgid ""
":doc:`pgr_drivingDistance` - Use pgr_dijkstra to calculate catchament "
"information."
msgstr ""

msgid ""
":doc:`pgr_KSP` - Use Yen algorithm with pgr_dijkstra to get the K shortest "
"paths."
msgstr ""

msgid ":doc:`pgr_dijkstraVia` - Get a route of a seuence of vertices."
msgstr ""

msgid ":doc:`pgr_dijkstraNear` - Get the route to the nearest vertex."
msgstr ""

msgid ":doc:`pgr_dijkstraNearCost` - Get the cost to the nearest vertex."
msgstr ""

msgid ""
"Dijkstra's algorithm, conceived by Dutch computer scientist Edsger Dijkstra "
"in 1956. It is a graph search algorithm that solves the shortest path "
"problem for a graph with non-negative edge path costs, producing a shortest "
"path from a starting vertex to an ending vertex. This implementation can be "
"used with a directed graph and an undirected graph."
msgstr ""

msgid "Running time: :math:`O(| start\\ vids | * (V \\log V + E))`"
msgstr ""

msgid "The Dijkstra family functions are based on the Dijkstra algorithm."
msgstr ""

msgid "`Combinations SQL`_"
msgstr ""

msgid "`Combinations SQL`_ as described below"
msgstr ""

msgid "**start vid**"
msgstr ""

msgid "Identifier of the starting vertex of the path."
msgstr ""

msgid "**end vid**"
msgstr ""

msgid "Identifier of the ending vertex of the path."
msgstr ""

msgid "**end vids**"
msgstr ""

msgid "Array of identifiers of ending vertices."
msgstr ""

msgid "Combinations SQL"
msgstr ""

msgid "Identifier of the departure vertex."
msgstr ""

msgid "Identifier of the arrival vertex."
msgstr ""

msgid "The problem definition (Advanced documentation)"
msgstr ""

msgid "Given the following query:"
msgstr ""

msgid "pgr_dijkstra(:math:`sql, start_{vid}, end_{vid}, directed`)"
msgstr ""

msgid ""
"where :math:`sql = \\{(id_i, source_i, target_i, cost_i, reverse\\_cost_i)\\}"
"`"
msgstr ""

msgid "and"
msgstr ""

msgid ":math:`source = \\bigcup source_i`,"
msgstr ""

msgid ":math:`target = \\bigcup target_i`,"
msgstr ""

msgid "The graphs are defined as follows:"
msgstr ""

msgid "Directed graph"
msgstr ""

msgid "The weighted directed graph, :math:`G_d(V,E)`, is definied by:"
msgstr ""

msgid "the set of vertices :math:`V`"
msgstr ""

msgid ":math:`V = source \\cup target \\cup {start_{vid}} \\cup  {end_{vid}}`"
msgstr ""

msgid "the set of edges :math:`E`"
msgstr ""

msgid ""
":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, cost_i) "
"\\text{ when } cost >=0 \\} & \\quad \\text{if } reverse\\_cost = "
"\\varnothing \\\\ \\text{ } \\text{ }  & \\quad \\text{ } \\\\ \\text{ } "
"\\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\} &  \\quad "
"\\text{ } \\\\ \\cup \\{(target_i, source_i, reverse\\_cost_i) "
"\\text{ when } reverse\\_cost_i>=0 \\} & \\quad \\text{if } reverse\\_cost "
"\\neq \\varnothing \\\\ \\end{cases}`"
msgstr ""

msgid "Undirected graph"
msgstr ""

msgid "The weighted undirected graph, :math:`G_u(V,E)`, is definied by:"
msgstr ""

msgid ":math:`V = source \\cup target \\cup {start_v{vid}} \\cup  {end_{vid}}`"
msgstr ""

msgid ""
":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, cost_i) "
"\\text{ when } cost >=0 \\}  & \\quad \\text{ } \\\\ \\cup \\{(target_i, "
"source_i, cost_i) \\text{ when } cost >=0 \\}  & \\quad \\text{ if } "
"reverse\\_cost = \\varnothing \\\\ \\text{ } \\text{ }  & \\text{ } \\\\ "
"\\text{ } \\{(source_i, target_i, cost_i) \\text{ when } cost >=0 \\} & "
"\\text{ } \\\\ \\cup \\{(target_i, source_i, cost_i) \\text{ when } cost >=0 "
"\\} & \\text{ } \\\\ \\cup \\{(target_i, source_i, reverse\\_cost_i) "
"\\text{ when } reverse\\_cost_i >=0)\\} & \\text{ } \\\\ \\cup \\{(source_i, "
"target_i, reverse\\_cost_i) \\text{ when } reverse\\_cost_i >=0)\\} & \\quad "
"\\text{ if } reverse\\_cost \\neq \\varnothing \\\\ \\end{cases}`"
msgstr ""

msgid "The problem"
msgstr ""

msgid "Given:"
msgstr ""

msgid ":math:`start_{vid} \\in V` a starting vertex"
msgstr ""

msgid ":math:`end_{vid} \\in V` an ending vertex"
msgstr ""

msgid ""
":math:`G(V,E) = \\begin{cases} G_d(V,E) & \\quad \\text{ if6 } directed = "
"true \\\\ G_u(V,E) & \\quad \\text{ if5 } directed = false \\\\ \\end{cases}`"
msgstr ""

msgid "Then:"
msgstr ""

msgid ""
":math:`\\boldsymbol{\\pi} = \\{(path\\_seq_i, node_i, edge_i, cost_i, "
"agg\\_cost_i)\\}`"
msgstr ""

msgid "where:"
msgstr ""

msgid ":math:`path\\_seq_i = i`"
msgstr ""

msgid ":math:`path\\_seq_{| \\pi |} = | \\pi |`"
msgstr ""

msgid ":math:`node_i \\in V`"
msgstr ""

msgid ":math:`node_1 = start_{vid}`"
msgstr ""

msgid ":math:`node_{| \\pi |}  = end_{vid}`"
msgstr ""

msgid ""
":math:`\\forall i \\neq | \\pi |, \\quad (node_i, node_{i+1}, cost_i) \\in E`"
msgstr ""

msgid ""
":math:`edge_i  = \\begin{cases}  id_{(node_i, node_{i+1},cost_i)}  &\\quad  "
"\\text{when } i \\neq | \\pi | \\\\ -1 &\\quad  \\text{when } i = | \\pi | \\"
"\\ \\end{cases}`"
msgstr ""

msgid ":math:`cost_i = cost_{(node_i, node_{i+1})}`"
msgstr ""

msgid ""
":math:`agg\\_cost_i  = \\begin{cases}  0   &\\quad  \\text{when } i = 1  \\"
"\\ \\displaystyle\\sum_{k=1}^{i}  cost_{(node_{k-1}, node_k)}  &\\quad  "
"\\text{when } i \\neq 1 \\\\ \\end{cases}`"
msgstr ""

msgid ""
"In other words: The algorithm returns a the shortest path between :math:"
"`start_{vid}` and :math:`end_{vid}`, if it exists, in terms of a sequence of "
"nodes and of edges,"
msgstr ""

msgid ""
":math:`path\\_seq` indicates the relative position in the path of the :math:"
"`node` or :math:`edge`."
msgstr ""

msgid ":math:`cost` is the cost of the edge to be used to go to the next node."
msgstr ""

msgid ""
":math:`agg\\_cost` is the cost from the :math:`start_{vid}` up to the node."
msgstr ""

msgid "If there is no path, the resulting set is empty."
msgstr ""

msgid "Driving Distance - Category"
msgstr ""

msgid ""
":doc:`pgr_drivingDistance` - Driving Distance based on Dijkstra's algorithm"
msgstr ""

msgid ":doc:`pgr_primDD` - Driving Distance based on Prim's algorithm"
msgstr ""

msgid ":doc:`pgr_kruskalDD` - Driving Distance based on Kruskal's algorithm"
msgstr ""

msgid "Post pocessing"
msgstr ""

msgid ":doc:`pgr_alphaShape` - Alpha shape computation"
msgstr ""

msgid ":doc:`pgr_withPointsDD` - Driving Distance based on pgr_withPoints"
msgstr ""

msgid "Calculate nodes that are within a distance."
msgstr ""

msgid ""
"Extracts all the nodes that have costs less than or equal to the value "
"distance."
msgstr ""

msgid "The edges extracted will conform to the corresponding spanning tree."
msgstr ""

msgid "Edge :math:`(u, v)` will not be included when:"
msgstr ""

msgid "The distance from the **root** to :math:`u` > limit distance."
msgstr ""

msgid "The distance from the **root** to :math:`v` > limit distance."
msgstr ""

msgid ""
"No new nodes are created on the graph, so when is within the limit and is "
"not within the limit, the edge is not included."
msgstr ""

msgid "Edges SQL as described below."
msgstr ""

msgid "**Root vid**"
msgstr ""

msgid "**Root vids**"
msgstr ""

msgid "``ARRAY[ANY-INTEGER]``"
msgstr ""

msgid "**distance**"
msgstr ""

msgid "Upper limit for the inclusion of a node in the result."
msgstr ""

msgid "Returns set of |result-spantree|"
msgstr ""

msgid ":math:`depth-1` is the depth of ``pred``"
msgstr ""

msgid "``pred``"
msgstr ""

msgid "Predecessor of ``node``."
msgstr ""

msgid "When ``node`` = ``start_vid`` then has the value ``node``."
msgstr ""

msgid "Identifier of the ``edge`` used to arrive from ``pred`` to ``node``."
msgstr ""

msgid "Experimental Functions"
msgstr ""

msgid "Families"
msgstr ""

msgid ":doc:`flow-family`"
msgstr ""

msgid ":doc:`pgr_maxFlowMinCost` - Details of flow and cost on edges."
msgstr ""

msgid ":doc:`pgr_maxFlowMinCost_Cost` - Only the Min Cost calculation."
msgstr ""

msgid ":doc:`chinesePostmanProblem-family`"
msgstr ""

msgid ":doc:`coloring-family`"
msgstr ""

msgid ":doc:`transformation-family`"
msgstr ""

msgid ""
":doc:`pgr_lineGraphFull` - Transformation algorithm for generating a Line "
"Graph out of each vertex in the input graph."
msgstr ""

msgid ":doc:`traversal-family`"
msgstr ""

msgid ""
":doc:`pgr_breadthFirstSearch` - Breath first search traversal of the graph."
msgstr ""

msgid ""
":doc:`pgr_binaryBreadthFirstSearch` - Breath first search traversal of the "
"graph."
msgstr ""

msgid ":doc:`components-family`"
msgstr ""

msgid ":doc:`ordering-family`"
msgstr ""

msgid ""
":doc:`pgr_cuthillMckeeOrdering` - Return reverse Cuthill-McKee ordering of "
"an undirected graph."
msgstr ""

msgid ":doc:`TRSP-family`"
msgstr ""

msgid "categories"
msgstr ""

msgid ":doc:`VRP-category`"
msgstr ""

msgid "Unclassified"
msgstr ""

msgid ":doc:`pgr_bellmanFord`"
msgstr ""

msgid ":doc:`pgr_dagShortestPath`"
msgstr ""

msgid ":doc:`pgr_edwardMoore`"
msgstr ""

msgid ":doc:`pgr_isPlanar`"
msgstr ""

msgid ":doc:`pgr_stoerWagner`"
msgstr ""

msgid ":doc:`pgr_topologicalSort`"
msgstr ""

msgid ":doc:`pgr_transitiveClosure`"
msgstr ""

msgid ":doc:`pgr_lengauerTarjanDominatorTree`"
msgstr ""

msgid ":doc:`pgr_hawickCircuits`"
msgstr ""

msgid "Flow - Family of functions"
msgstr ""

msgid ""
":doc:`pgr_maxFlow` - Only the Max flow calculation using Push and Relabel "
"algorithm."
msgstr ""

msgid ""
":doc:`pgr_boykovKolmogorov` - Boykov and Kolmogorov with details of flow on "
"edges."
msgstr ""

msgid ""
":doc:`pgr_edmondsKarp` - Edmonds and Karp algorithm with details of flow on "
"edges."
msgstr ""

msgid ""
":doc:`pgr_pushRelabel` - Push and relabel algorithm with details of flow on "
"edges."
msgstr ""

msgid "Applications"
msgstr ""

msgid ""
":doc:`pgr_edgeDisjointPaths` - Calculates edge disjoint paths between two "
"groups of vertices."
msgstr ""

msgid ""
":doc:`pgr_maxCardinalityMatch` - Calculates a maximum cardinality matching "
"in a graph."
msgstr ""

msgid "Flow Functions General Information"
msgstr ""

msgid "The graph is **directed**."
msgstr ""

msgid "Process is done only on edges with positive capacities."
msgstr ""

msgid ""
"When the maximum flow is 0 then there is no flow and **EMPTY SET** is "
"returned."
msgstr ""

msgid "There is no flow when a **source** is the same as a **target**."
msgstr ""

msgid "Any duplicated value in the source(s) or target(s) are ignored."
msgstr ""

msgid "Calculates the flow/residual capacity for each edge. In the output"
msgstr ""

msgid "Edges with zero flow are omitted."
msgstr ""

msgid ""
"Creates a **super source** and edges to all the source(s), and a **super "
"target** and the edges from all the targets(s)."
msgstr ""

msgid ""
"The maximum flow through the graph is guaranteed to be the value returned "
"by :doc:`pgr_maxFlow <pgr_maxFlow>` when executed with the same parameters "
"and can be calculated:"
msgstr ""

msgid "By aggregation of the outgoing flow from the sources"
msgstr ""

msgid "By aggregation of the incoming flow to the targets"
msgstr ""

msgid ""
":doc:`pgr_maxFlow` is the maximum Flow and that maximum is guaranteed to be "
"the same on the functions :doc:`pgr_pushRelabel`, :doc:`pgr_edmondsKarp`, :"
"doc:`pgr_boykovKolmogorov`, but the actual flow through each edge may vary."
msgstr ""

msgid "Capacity edges"
msgstr ""

msgid ":doc:`pgr_pushRelabel`"
msgstr ""

msgid ":doc:`pgr_edmondsKarp`"
msgstr ""

msgid ":doc:`pgr_boykovKolmogorov`"
msgstr ""

msgid "``reverse_capacity``"
msgstr ""

msgid "Capacity-Cost edges"
msgstr ""

msgid ":doc:`pgr_maxFlowMinCost`"
msgstr ""

msgid ":doc:`pgr_maxFlowMinCost_Cost`"
msgstr ""

msgid "Capacity of the edge (``source``, ``target``)"
msgstr ""

msgid "Capacity of the edge (``target``, ``source``)"
msgstr ""

msgid "Weight of the edge (``source``, ``target``) if it exist"
msgstr ""

msgid "Weight of the edge (``target``, ``source``) if it exist"
msgstr ""

msgid "Cost edges"
msgstr ""

msgid ":doc:`pgr_edgeDisjointPaths`"
msgstr ""

msgid "Used in"
msgstr ""

msgid "**seq**"
msgstr ""

msgid "``INT``"
msgstr ""

msgid "**edge**"
msgstr ""

msgid "Identifier of the edge in the original query (edges_sql)."
msgstr ""

msgid "**start_vid**"
msgstr ""

msgid "**end_vid**"
msgstr ""

msgid "**flow**"
msgstr ""

msgid "Flow through the edge in the direction (``start_vid``, ``end_vid``)."
msgstr ""

msgid "**residual_capacity**"
msgstr ""

msgid ""
"Residual capacity of the edge in the direction (``start_vid``, ``end_vid``)."
msgstr ""

msgid "For :doc:`pgr_maxFlowMinCost`"
msgstr ""

msgid "**source**"
msgstr ""

msgid "**target**"
msgstr ""

msgid "Flow through the edge in the direction (source, target)."
msgstr ""

msgid "Residual capacity of the edge in the direction (source, target)."
msgstr ""

msgid "**cost**"
msgstr ""

msgid ""
"The cost of sending this flow through the edge in the direction (source, "
"target)."
msgstr ""

msgid "**agg_cost**"
msgstr ""

msgid "The aggregate cost."
msgstr ""

msgid "Advanced Documentation"
msgstr ""

msgid ""
"A flow network is a directed graph where each edge has a capacity and a "
"flow. The flow through an edge must not exceed the capacity of the edge. "
"Additionally, the incoming and outgoing flow of a node must be equal except "
"for source which only has outgoing flow, and the destination(sink) which "
"only has incoming flow."
msgstr ""

msgid ""
"Maximum flow algorithms calculate the maximum flow through the graph and the "
"flow of each edge."
msgstr ""

msgid ""
"The maximum flow through the graph is guaranteed to be the same with all "
"implementations, but the actual flow through each edge may vary."
msgstr ""

msgid "pgr_maxFlow :math:`(edges\\_sql, source\\_vertex, sink\\_vertex)`"
msgstr ""

msgid ""
"where :math:`edges\\_sql = \\{(id_i, source_i, target_i, capacity_i, "
"reverse\\_capacity_i)\\}`"
msgstr ""

msgid "Graph definition"
msgstr ""

msgid "The weighted directed graph, :math:`G(V,E)`, is defined as:"
msgstr ""

msgid "the set of vertices  :math:`V`"
msgstr ""

msgid ""
":math:`source\\_vertex  \\cup  sink\\_vertex  \\bigcup  source_i  \\bigcup  "
"target_i`"
msgstr ""

msgid ""
":math:`E = \\begin{cases} \\text{ } \\{(source_i, target_i, capacity_i) "
"\\text{ when } capacity > 0 \\} & \\quad  \\text{ if } reverse\\_capacity = "
"\\varnothing \\\\ \\text{ } & \\quad \\text{ } \\\\ \\{(source_i, target_i, "
"capacity_i) \\text{ when } capacity > 0 \\} & \\text{ } \\\\ \\cup "
"\\{(target_i, source_i, reverse\\_capacity_i) \\text{ when } "
"reverse\\_capacity_i > 0)\\} & \\quad \\text{ if } reverse\\_capacity \\neq "
"\\varnothing \\\\ \\end{cases}`"
msgstr ""

msgid "Maximum flow problem"
msgstr ""

msgid ":math:`G(V,E)`"
msgstr ""

msgid ":math:`source\\_vertex \\in V` the source vertex"
msgstr ""

msgid ":math:`sink\\_vertex \\in V` the sink vertex"
msgstr ""

msgid ":math:`pgr\\_maxFlow(edges\\_sql, source, sink) = \\boldsymbol{\\Phi}`"
msgstr ""

msgid ""
":math:`\\boldsymbol{\\Phi} = {(id_i, edge\\_id_i, source_i, target_i, "
"flow_i, residual\\_capacity_i)}`"
msgstr ""

msgid ""
":math:`\\boldsymbol{\\Phi}` is a subset of the original edges with their "
"residual capacity and flow. The maximum flow through the graph can be "
"obtained by aggregating on the source or sink and summing the flow from/to "
"it. In particular:"
msgstr ""

msgid ":math:`id_i = i`"
msgstr ""

msgid ":math:`edge\\_id = id_i` in edges_sql"
msgstr ""

msgid ":math:`residual\\_capacity_i = capacity_i - flow_i`"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Maximum_flow_problem"
msgstr ""

msgid ""
"pgRouting extends the `PostGIS <https://postgis.net>`__/`PostgreSQL <https://"
"www.postgresql.org>`__ geospatial database to provide geospatial routing and "
"other network analysis functionality."
msgstr ""

msgid "This is the manual for pgRouting |release|."
msgstr ""

msgid "Creative Commons Attribution-Share Alike 3.0 License"
msgstr ""

msgid ""
"The pgRouting Manual is licensed under a `Creative Commons Attribution-Share "
"Alike 3.0 License <https://creativecommons.org/licenses/by-sa/3.0/>`_. Feel "
"free to use this material any way you like, but we ask that you attribute "
"credit to the pgRouting Project and wherever possible, a link back to "
"https://pgrouting.org. For other licenses used in pgRouting see the :ref:"
"`license` page."
msgstr ""

msgid "General"
msgstr ""

msgid ":doc:`sampledata` that is used in the examples of this manual."
msgstr ""

msgid "Pgrouting Concepts"
msgstr ""

msgid ":doc:`routingFunctions`"
msgstr ""

msgid ":doc:`allpairs-family`"
msgstr ""

msgid ":doc:`bdDijkstra-family`"
msgstr ""

msgid ":doc:`contraction-family`"
msgstr ""

msgid ":doc:`dijkstra-family`"
msgstr ""

msgid ":doc:`kruskal-family`"
msgstr ""

msgid ":doc:`pgr_kruskal`"
msgstr ""

msgid ":doc:`pgr_kruskalDD`"
msgstr ""

msgid ":doc:`prim-family`"
msgstr ""

msgid ":doc:`pgr_prim`"
msgstr ""

msgid ":doc:`pgr_primDD`"
msgstr ""

msgid ":doc:`reference`"
msgstr ""

msgid ":doc:`pgr_version`"
msgstr ""

msgid ":doc:`pgr_full_version`"
msgstr ""

msgid ":doc:`topology-functions`"
msgstr ""

msgid ""
"The following functions modify the database directly therefore the user must "
"have special permissions given by the administrators to use them."
msgstr ""

msgid ":doc:`pgr_createTopology` - create a topology based on the geometry."
msgstr ""

msgid ""
":doc:`pgr_createVerticesTable` - reconstruct the vertices table based on the "
"source and target information."
msgstr ""

msgid ""
":doc:`pgr_analyzeGraph` - to analyze the edges and vertices of the edge "
"table."
msgstr ""

msgid ":doc:`pgr_analyzeOneWay` - to analyze directionality of the edges."
msgstr ""

msgid ":doc:`pgr_nodeNetwork` - to create nodes to a not noded edge table."
msgstr ""

msgid ":doc:`pgr_trsp` - Turn Restriction Shortest Path (TRSP)"
msgstr ""

msgid "Functions by categories"
msgstr ""

msgid ":doc:`cost-category`"
msgstr ""

msgid ":doc:`costMatrix-category`"
msgstr ""

msgid ":doc:`drivingDistance-category`"
msgstr ""

msgid ":doc:`KSP-category`"
msgstr ""

msgid ":doc:`spanningTree-family`"
msgstr ""

msgid ":doc:`BFS-category`"
msgstr ""

msgid ":doc:`DFS-category`"
msgstr ""

msgid "Available Functions but not official pgRouting functions"
msgstr ""

msgid ":doc:`proposed`"
msgstr ""

msgid ":doc:`experimental`"
msgstr ""

msgid ":doc:`release_notes`"
msgstr ""

msgid "pgRouting 3.7.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.7.0 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.7.0%22>`__"
msgstr ""

msgid "Official functions changes"
msgstr ""

msgid ""
"`#2605 <https://github.com/pgRouting/pgrouting/pull/2605>`__ Standarize "
"spanning tree functions output"
msgstr ""

msgid "Functions:"
msgstr ""

msgid "``pgr_kruskalDD``"
msgstr ""

msgid "``pgr_kruskalDFS``"
msgstr ""

msgid "``pgr_kruskalBFS``"
msgstr ""

msgid "``pgr_primDD``"
msgstr ""

msgid "``pgr_primDFS``"
msgstr ""

msgid "``pgr_primBFS``"
msgstr ""

msgid "Standarizing output columns to |result-spantree|"
msgstr ""

msgid "Added ``pred`` result columns."
msgstr ""

msgid "Experimental promoted to proposed."
msgstr ""

msgid ""
"`#2635 <https://github.com/pgRouting/pgrouting/pull/2635>`__ pgr_LineGraph "
"ignores directed flag and use negative values for identifiers."
msgstr ""

msgid "``pgr_lineGraph``"
msgstr ""

msgid "Promoted to **proposed** signature."
msgstr ""

msgid "Works for directed and undirected graphs."
msgstr ""

msgid "Code enhancement"
msgstr ""

msgid ""
"`#2599 <https://github.com/pgRouting/pgrouting/pull/2599>`__ Driving "
"distance cleanup"
msgstr ""

msgid ""
"`#2607 <https://github.com/pgRouting/pgrouting/pull/2607>`__ Read postgresql "
"data on C++"
msgstr ""

msgid ""
"`#2614 <https://github.com/pgRouting/pgrouting/pull/2614>`__ Clang tidy does "
"not work"
msgstr ""

msgid "All releases"
msgstr ""

msgid "Kruskal - Family of functions"
msgstr ""

msgid "Boost Graph Inside"
msgstr ""

msgid ""
"Kruskal's algorithm is a greedy minimum spanning tree algorithm that in each "
"cycle finds and adds the edge of the least possible weight that connects any "
"two trees in the forest."
msgstr ""

msgid "**The main Characteristics are:**"
msgstr ""

msgid "The total weight of all the edges in the tree or forest is minimized."
msgstr ""

msgid "Kruskal's running time: :math:`O(E * log E)`"
msgstr ""

msgid "Migration guide"
msgstr ""

msgid ""
"Several functions are having changes on the signatures, and/or have been "
"replaced by new functions."
msgstr ""

msgid "Results can be different because of the changes."
msgstr ""

msgid "All deprecated functions will be removed on next mayor version 4.0.0"
msgstr ""

msgid "Migration of functions"
msgstr ""

msgid "Migrating functions"
msgstr ""

msgid "Migration of ``pgr_aStar``"
msgstr ""

msgid ""
"Starting from `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__"
msgstr ""

msgid "Signatures to be migrated:"
msgstr ""

msgid "``pgr_aStar`` (`One to One`)"
msgstr ""

msgid "``pgr_aStar`` (`One to Many`)"
msgstr ""

msgid "``pgr_aStar`` (`Many to One`)"
msgstr ""

msgid "Before Migration"
msgstr ""

msgid "Output columns were |old-generic-result|"
msgstr ""

msgid ""
"Depending on the overload used, the columns ``start_vid`` and ``end_vid`` "
"might be missing:"
msgstr ""

msgid ""
"``pgr_aStar`` (`One to One`) does not have ``start_vid`` and ``end_vid``."
msgstr ""

msgid "``pgr_aStar`` (`One to Many`) does not have ``start_vid``."
msgstr ""

msgid "``pgr_aStar`` (`Many to One`) does not have ``end_vid``."
msgstr ""

msgid "Migration"
msgstr ""

msgid "Be aware of the existence of the additional columns."
msgstr ""

msgid "In ``pgr_aStar`` (`One to One`)"
msgstr ""

msgid "``start_vid`` contains the **start vid** parameter value."
msgstr ""

msgid "``end_vid`` contains the **end vid** parameter value."
msgstr ""

msgid "In ``pgr_aStar`` (`One to Many`)"
msgstr ""

msgid "In ``pgr_aStar`` (`Many to One`)"
msgstr ""

msgid "If needed filter out the added columns, for example:"
msgstr ""

msgid ""
"If needed add the new columns, similar to the following example where "
"``pgr_dijkstra`` is used, and the function had to be modified to be able to "
"return the new columns:"
msgstr ""

msgid ""
"In `v3.0 <https://docs.pgrouting.org/3.0/en/contraction-family.html#case-1-"
"both-source-and-target-belong-to-the-contracted-graph>`__ the function "
"``my_dijkstra`` uses ``pgr_dijkstra``."
msgstr ""

msgid ""
"Starting from `v3.5 <https://docs.pgrouting.org/3.5/en/contraction-family."
"html#case-1-both-source-and-target-belong-to-the-contracted-graph>`__ the "
"function ``my_dijkstra`` returns the new additional columns of "
"``pgr_dijkstra``."
msgstr ""

msgid "Migration of ``pgr_bdAstar``"
msgstr ""

msgid "``pgr_bdAstar`` (`One to One`)"
msgstr ""

msgid "``pgr_bdAstar`` (`One to Many`)"
msgstr ""

msgid "``pgr_bdAstar`` (`Many to One`)"
msgstr ""

msgid ""
"``pgr_bdAstar`` (`One to One`) does not have ``start_vid`` and ``end_vid``."
msgstr ""

msgid "``pgr_bdAstar`` (`One to Many`) does not have ``start_vid``."
msgstr ""

msgid "``pgr_bdAstar`` (`Many to One`) does not have ``end_vid``."
msgstr ""

msgid "In ``pgr_bdAstar`` (`One to One`)"
msgstr ""

msgid "In ``pgr_bdAstar`` (`One to Many`)"
msgstr ""

msgid "In ``pgr_bdAstar`` (`Many to One`)"
msgstr ""

msgid "Migration of ``pgr_dijkstra``"
msgstr ""

msgid ""
"Starting from `v3.5.0 <https://docs.pgrouting.org/3.5/en/migration.html>`__"
msgstr ""

msgid "``pgr_dijkstra`` (`One to One`)"
msgstr ""

msgid "``pgr_dijkstra`` (`One to Many`)"
msgstr ""

msgid "``pgr_dijkstra`` (`Many to One`)"
msgstr ""

msgid ""
"``pgr_dijkstra`` (`One to One`) does not have ``start_vid`` and ``end_vid``."
msgstr ""

msgid "``pgr_dijkstra`` (`One to Many`) does not have ``start_vid``."
msgstr ""

msgid "``pgr_dijkstra`` (`Many to One`) does not have ``end_vid``."
msgstr ""

msgid "In ``pgr_dijkstra`` (`One to One`)"
msgstr ""

msgid "In ``pgr_dijkstra`` (`One to Many`)"
msgstr ""

msgid "In ``pgr_dijkstra`` (`Many to One`)"
msgstr ""

msgid "If needed add the new columns, for example:"
msgstr ""

msgid "Migration of ``pgr_drivingdistance``"
msgstr ""

msgid ""
"Starting from `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__ :"
"doc:`pgr_drivingDistance` result columns are being standardized."
msgstr ""

msgid "from"
msgstr ""

msgid "|result-dij-dd|"
msgstr ""

msgid "to"
msgstr ""

msgid "|result-spantree|"
msgstr ""

msgid "``pgr_drivingdistance`` (Single vertex)"
msgstr ""

msgid "``pgr_drivingdistance`` (Multiple vertices)"
msgstr ""

msgid "Output columns were |result-dij-dd|"
msgstr ""

msgid "Does not have ``start_vid`` and ``depth`` result columns."
msgstr ""

msgid "Has ``from_v`` instead of ``start_vid`` result column."
msgstr ""

msgid "does not have ``depth`` result column."
msgstr ""

msgid "Be aware of the existence and name change of the result columns."
msgstr ""

msgid ""
"Using `this <https://docs.pgrouting.org/3.5/en/pgr_drivingDistance."
"html#single-vertex>`__ example."
msgstr ""

msgid "``depth`` contains the depth of the ``node``."
msgstr ""

msgid "``pred`` contains the predecessor of the ``node``."
msgstr ""

msgid ""
"If needed filter out the added columns, for example, to return the original "
"columns"
msgstr ""

msgid ""
"Using `this <https://docs.pgrouting.org/3.5/en/pgr_drivingDistance."
"html#multiple-vertices>`__ example."
msgstr ""

msgid "The ``from_v`` result column name changes to ``start_vid``."
msgstr ""

msgid ""
"If needed filter out and rename columns, for example, to return the original "
"columns:"
msgstr ""

msgid ""
"Migration of ``pgr_kruskalDD`` / ``pgr_kruskalBFS`` / ``pgr_kruskalDFS``"
msgstr ""

msgid ""
"Starting from `v3.7.0 <https://docs.pgrouting.org/3.7/en/migration.html>`__ :"
"doc:`pgr_kruskalDD`, :doc:`pgr_kruskalBFS` and :doc:`pgr_kruskalDFS` result "
"columns are being standardized."
msgstr ""

msgid "|result-bfs|"
msgstr ""

msgid "Single vertex"
msgstr ""

msgid "Multiple vertices"
msgstr ""

msgid "Output columns were |result-bfs|"
msgstr ""

msgid "Single vertex and Multiple vertices"
msgstr ""

msgid "Do not have ``pred`` result column."
msgstr ""

msgid "Be aware of the existence of `pred` result columns."
msgstr ""

msgid "If needed filter out the added columns"
msgstr ""

msgid "Kruskal single vertex"
msgstr ""

msgid ""
"Using ``pgr_KruskalDD`` as example. Migration is similar to al the affected "
"functions."
msgstr ""

msgid ""
"Comparing with `this <https://docs.pgrouting.org/3.6/en/pgr_kruskalDD."
"html#single-vertex>`__ example."
msgstr ""

msgid ""
"Now column ``pred`` exists and contains the predecessor of the ``node``."
msgstr ""

msgid "Kruskal multiple vertices"
msgstr ""

msgid ""
"Comparing with `this <https://docs.pgrouting.org/3.6/en/pgr_kruskalDD."
"html#multiple-vertex>`__ example."
msgstr ""

msgid "Migration of ``pgr_KSP``"
msgstr ""

msgid ""
"Starting from `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__ :"
"doc:`pgr_KSP` result columns are being standardized."
msgstr ""

msgid "|ksp-result|"
msgstr ""

msgid "|nksp-result|"
msgstr ""

msgid "``pgr_KSP`` (One to One)"
msgstr ""

msgid "Output columns were |ksp-result|"
msgstr ""

msgid "the columns ``start_vid`` and ``end_vid`` do not exist."
msgstr ""

msgid "``pgr_KSP`` (One to One) does not have ``start_vid`` and ``end_vid``."
msgstr ""

msgid ""
"Using `this <https://docs.pgrouting.org/3.5/en/pgr_KSP.html#signatures>`__ "
"example."
msgstr ""

msgid ""
"If needed filter out the added columns, for example, to return the original "
"columns:"
msgstr ""

msgid "Migration of ``pgr_maxCardinalityMatch``"
msgstr ""

msgid ""
":doc:`pgr_maxCardinalityMatch` works only for undirected graphs, therefore "
"the ``directed`` flag has been removed."
msgstr ""

msgid ""
"Starting from `v3.4.0 <https://docs.pgrouting.org/3.4/en/migration.html>`__"
msgstr ""

msgid "Signature to be migrated:"
msgstr ""

msgid "Migration is needed, because:"
msgstr ""

msgid "Use ``cost`` and ``reverse_cost`` on the inner query"
msgstr ""

msgid "Results are ordered"
msgstr ""

msgid "Works for undirected graphs."
msgstr ""

msgid "New signature"
msgstr ""

msgid "``pgr_maxCardinalityMatch(text)`` returns only ``edge`` column."
msgstr ""

msgid "The optional flag ``directed`` is removed."
msgstr ""

msgid "Before migration"
msgstr ""

msgid ""
"Columns used are ``going`` and ``coming`` to represent the existence of an "
"edge."
msgstr ""

msgid ""
"Flag ``directed`` was used to indicate if it was for a **directed** or "
"**undirected** graph."
msgstr ""

msgid "The flag ``directed`` is ignored."
msgstr ""

msgid ""
"Regardless of it's value it gives the result considering the graph as "
"**undirected**."
msgstr ""

msgid ""
"Use the columns ``cost`` and ``reverse_cost`` to represent the existence of "
"an edge."
msgstr ""

msgid "Do not use the flag ``directed``."
msgstr ""

msgid "In the query returns only ``edge`` column."
msgstr ""

msgid "Migration of ``pgr_primDD`` / ``pgr_primBFS`` / ``pgr_primDFS``"
msgstr ""

msgid ""
"Starting from `v3.7.0 <https://docs.pgrouting.org/3.7/en/migration.html>`__ :"
"doc:`pgr_primDD`, :doc:`pgr_primBFS` and :doc:`pgr_primDFS` result columns "
"are being standardized."
msgstr ""

msgid "Prim single vertex"
msgstr ""

msgid ""
"Using ``pgr_primDD`` as example. Migration is similar to al the affected "
"functions."
msgstr ""

msgid ""
"Comparing with `this <https://docs.pgrouting.org/3.6/en/pgr_primDD."
"html#single-vertex>`__ example."
msgstr ""

msgid "Prim multiple vertices"
msgstr ""

msgid ""
"Comparing with `this <https://docs.pgrouting.org/3.6/en/pgr_primDD."
"html#multiple-vertex>`__ example."
msgstr ""

msgid "Migration of ``pgr_withPointsDD``"
msgstr ""

msgid ""
"Starting from `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__ :"
"doc:`pgr_withPointsDD` result columns are being standardized."
msgstr ""

msgid "|result-generic-no-seq|"
msgstr ""

msgid ""
"And ``driving_side`` parameter changed from named optional to unnamed "
"compulsory **driving side** and its validity differ for directed and "
"undirected graphs."
msgstr ""

msgid "``pgr_withPointsDD`` (Single vertex)"
msgstr ""

msgid "``pgr_withPointsDD`` (Multiple vertices)"
msgstr ""

msgid "Output columns were |result-1-1-no-seq|"
msgstr ""

msgid "Does not have ``start_vid``, ``pred`` and ``depth`` result columns."
msgstr ""

msgid ""
"``driving_side`` parameter was named optional now it is compulsory unnamed."
msgstr ""

msgid "``pgr_withPointsDD`` (`Multiple vertices`)"
msgstr ""

msgid "Output columns were |result-m-1-no-seq|"
msgstr ""

msgid "Does not have ``depth`` and ``pred`` result columns."
msgstr ""

msgid "Driving side was optional"
msgstr ""

msgid "The default values on this query are:"
msgstr ""

msgid "directed"
msgstr ""

msgid "true"
msgstr ""

msgid "driving_side"
msgstr ""

msgid "'b'"
msgstr ""

msgid "details"
msgstr ""

msgid "false"
msgstr ""

msgid "Driving side was named optional"
msgstr ""

msgid "On directed graph ``b`` could be used as **driving side**"
msgstr ""

msgid "On undirected graph ``r`` could be used as **driving side**"
msgstr ""

msgid "Also ``l`` could be used as **driving side**"
msgstr ""

msgid "After Migration"
msgstr ""

msgid "Be aware of the existence of the additional result Columns."
msgstr ""

msgid "New output columns are |result-spantree|"
msgstr ""

msgid ""
"**driving side** parameter is unnamed compulsory, and valid values differ "
"for directed and undirected graphs."
msgstr ""

msgid "Does not have a default value."
msgstr ""

msgid "In directed graph: valid values are [``r``, ``R``, ``l``, ``L``]"
msgstr ""

msgid "In undirected graph: valid values are [``b``, ``B``]"
msgstr ""

msgid "Using an invalid value throws an ``ERROR``."
msgstr ""

msgid ""
"Using `this <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD.html#single-"
"vertex>`__ example."
msgstr ""

msgid ""
"``depth`` contains the **depth** from the ``start_vid`` vertex to the "
"``node``."
msgstr ""

msgid ""
"To migrate, use an unnamed valid value for **driving side** after the "
"**distance** parameter:"
msgstr ""

msgid "To get results from previous versions:"
msgstr ""

msgid "filter out the additional columns, for example;"
msgstr ""

msgid ""
"When ``details => false`` to remove the points use ``WHERE node >= 0 OR cost "
"= 0``"
msgstr ""

msgid ""
"Using `this <https://docs.pgrouting.org/3.5/en/pgr_withPointsDD."
"html#multiple-vertices>`__ example."
msgstr ""

msgid "Filter out the additional columns"
msgstr ""

msgid "Migration of ``pgr_withPointsKSP``"
msgstr ""

msgid ""
"Starting from `v3.6.0 <https://docs.pgrouting.org/3.6/en/migration.html>`__ :"
"doc:`pgr_withPointsKSP` result columns are being standardized."
msgstr ""

msgid ""
"And ``driving side`` parameter changed from named optional to unnamed "
"compulsory **driving side** and its validity differ for directed and "
"undirected graphs."
msgstr ""

msgid "``pgr_withPointsKSP`` (`One to One`)"
msgstr ""

msgid "Output columns were |old-pid-result|"
msgstr ""

msgid "New output columns are |nksp-result|"
msgstr ""

msgid ""
"Using `this <https://docs.pgrouting.org/3.5/en/pgr_withPointsKSP."
"html#signatures>`__ example."
msgstr ""

msgid ""
"If needed filter out the additional columns, for example, to return the "
"original columns:"
msgstr ""

msgid "Migration of turn restrictions"
msgstr ""

msgid "Migration of restrictions"
msgstr ""

msgid "The structure of the restrictions have changed:"
msgstr ""

msgid "Old restrictions structure"
msgstr ""

msgid "On the deprecated signatures:"
msgstr ""

msgid "Column ``rid`` is ignored"
msgstr ""

msgid "``via_path``"
msgstr ""

msgid "Must be in reverse order."
msgstr ""

msgid "Is of type ``TEXT``."
msgstr ""

msgid "When more than one via edge must be separated with ``,``."
msgstr ""

msgid "``target_id``"
msgstr ""

msgid "Is the last edge of the forbidden path."
msgstr ""

msgid "Is of type ``INTEGER``."
msgstr ""

msgid "``to_cost``"
msgstr ""

msgid "Is of type ``FLOAT``."
msgstr ""

msgid "Creation of the old restrictions table"
msgstr ""

msgid "Old restrictions fill up"
msgstr ""

msgid "Old restrictions contents"
msgstr ""

msgid ""
"The restriction with ``rid = 2`` is representing :math:`3 \\rightarrow 5 "
"\\rightarrow9`"
msgstr ""

msgid ":math:`3\\rightarrow5`"
msgstr ""

msgid "is on column ``via_path`` in reverse order"
msgstr ""

msgid "is of type ``TEXT``"
msgstr ""

msgid ":math:`9`"
msgstr ""

msgid "is on column ``target_id``"
msgstr ""

msgid "is of type ``INTEGER``"
msgstr ""

msgid "New restrictions structure"
msgstr ""

msgid "Column ``id`` is ignored"
msgstr ""

msgid "Column ``path``"
msgstr ""

msgid "Is of type ``ARRAY[ANY-INTEGER]``."
msgstr ""

msgid "Contains all the edges involved on the restriction."
msgstr ""

msgid "The array has the ordered edges of the restriction."
msgstr ""

msgid "Column ``cost``"
msgstr ""

msgid "Is of type ``ANY-NUMERICAL``"
msgstr ""

msgid "The creation of the restrictions table"
msgstr ""

msgid "Adding the restrictions"
msgstr ""

msgid "Restrictions data"
msgstr ""

msgid ""
"The restriction with ``rid = 2`` represents the path :math:`3 \\rightarrow5 "
"\\rightarrow9`."
msgstr ""

msgid "By inspection the path is clear."
msgstr ""

msgid ""
"To transform the old restrictions table to the new restrictions structure,"
msgstr ""

msgid "Create a new table with the new restrictions structure."
msgstr ""

msgid "In this migration guide ``new_restrictions`` is been used."
msgstr ""

msgid ""
"For this migration pgRouting supplies an auxiliary function for reversal of "
"an array ``_pgr_array_reverse`` needed for the migration."
msgstr ""

msgid "``_pgr_array_reverse``:"
msgstr ""

msgid "Was created temporally for this migration"
msgstr ""

msgid "Is not documented."
msgstr ""

msgid "Will be removed on the next mayor version 4.0.0"
msgstr ""

msgid "The migrated table contents:"
msgstr ""

msgid "Migration of ``pgr_trsp`` (Vertices)"
msgstr ""

msgid ""
":doc:`pgr_trsp` signatures have changed and many issues have been fixed in "
"the new signatures. This section will show how to migrate from the old "
"signatures to the new replacement functions. This also affects the "
"restrictions."
msgstr ""

msgid "The integral type of the ``Edges SQL`` can only be ``INTEGER``."
msgstr ""

msgid "The floating point type of the ``Edges SQL`` can only be ``FLOAT``."
msgstr ""

msgid "``directed`` flag is compulsory."
msgstr ""

msgid "Does not autodetect if ``reverse_cost`` column exist."
msgstr ""

msgid ""
"User must be careful to match the existence of the column with the value of "
"``has_rcost`` parameter."
msgstr ""

msgid "The restrictions inner query is optional."
msgstr ""

msgid "The output column names are meaningless"
msgstr ""

msgid "Migrate by using:"
msgstr ""

msgid ":doc:`pgr_dijkstra` when there are no restrictions,"
msgstr ""

msgid ":doc:`pgr_trsp` (One to One) when there are restrictions."
msgstr ""

msgid "Migrating ``pgr_trsp`` (Vertices) using ``pgr_dijkstra``"
msgstr ""

msgid "The following query does not have restrictions."
msgstr ""

msgid "A message about deprecation is shown"
msgstr ""

msgid "Deprecated functions will be removed on the next mayor version 4.0.0"
msgstr ""

msgid "Use :doc:`pgr_dijkstra` instead."
msgstr ""

msgid "The types casting has been removed."
msgstr ""

msgid ":doc:`pgr_dijkstra`:"
msgstr ""

msgid "Autodetects if ``reverse_cost`` column is in the edges SQL."
msgstr ""

msgid "Accepts ``ANY-INTEGER`` on integral types"
msgstr ""

msgid "Accepts ``ANY-NUMERICAL`` on floating point types"
msgstr ""

msgid "``directed`` flag has a default value of ``true``."
msgstr ""

msgid "Use the same value that on the original query."
msgstr ""

msgid "In this example it is ``true`` which is the default value."
msgstr ""

msgid "The flag has been omitted and the default is been used."
msgstr ""

msgid ""
"When the need of using strictly the same (meaningless) names and types of "
"the function been migrated then:"
msgstr ""

msgid "``id1`` is the node"
msgstr ""

msgid "``id2`` is the edge"
msgstr ""

msgid "Migrating ``pgr_trsp`` (Vertices) using ``pgr_trsp``"
msgstr ""

msgid "The following query has restrictions."
msgstr ""

msgid "The restrictions are the last parameter of the function"
msgstr ""

msgid "Using the old structure of restrictions"
msgstr ""

msgid "Use :doc:`pgr_trsp` (One to One) instead."
msgstr ""

msgid "The new structure of restrictions is been used."
msgstr ""

msgid "It is the second parameter."
msgstr ""

msgid ":doc:`pgr_trsp`:"
msgstr ""

msgid "Migration of ``pgr_trsp`` (Edges)"
msgstr ""

msgid "The integral types of the ``sql`` can only be ``INTEGER``."
msgstr ""

msgid "The floating point type of the ``sql`` can only be ``FLOAT``."
msgstr ""

msgid "For these migration guide the following points will be used:"
msgstr ""

msgid ":doc:`pgr_withPoints` when there are no restrictions,"
msgstr ""

msgid ":doc:`pgr_trsp_withPoints` (One to One) when there are restrictions."
msgstr ""

msgid "Migrating ``pgr_trsp`` (Edges) using ``pgr_withPoints``"
msgstr ""

msgid "Use :doc:`pgr_withPoints` instead."
msgstr ""

msgid "Do not show details, as the deprecated function does not show details."
msgstr ""

msgid ":doc:`pgr_withPoints`:"
msgstr ""

msgid "On the points query do not include the ``side`` column."
msgstr ""

msgid ""
"When the need of using strictly the same (meaningless) names and types, and "
"node values of the function been migrated then:"
msgstr ""

msgid "Migrating ``pgr_trsp`` (Edges) using ``pgr_trsp_withPoints``"
msgstr ""

msgid "Use :doc:`pgr_trsp_withPoints` instead."
msgstr ""

msgid ":doc:`pgr_trsp_withPoints`:"
msgstr ""

msgid "Migration of ``pgr_trspViaVertices``"
msgstr ""

msgid "The integral types of the ``Edges SQL`` can only be ``INTEGER``."
msgstr ""

msgid ":doc:`pgr_dijkstraVia` when there are no restrictions,"
msgstr ""

msgid ":doc:`pgr_trspVia` when there are restrictions."
msgstr ""

msgid "Migrating ``pgr_trspViaVertices`` using ``pgr_dijkstraVia``"
msgstr ""

msgid "Use :doc:`pgr_dijkstraVia` instead."
msgstr ""

msgid ":doc:`pgr_dijkstraVia`:"
msgstr ""

msgid "``id1`` is the path identifier"
msgstr ""

msgid "``id2`` is the node"
msgstr ""

msgid "``id3`` is the edge"
msgstr ""

msgid "Migrating ``pgr_trspViaVertices`` using ``pgr_trspVia``"
msgstr ""

msgid "Use :doc:`pgr_trspVia` instead."
msgstr ""

msgid ":doc:`pgr_trspVia`:"
msgstr ""

msgid "Migration of ``pgr_trspViaEdges``"
msgstr ""

msgid ""
"And will travel thru the following Via points :math:"
"`4\\rightarrow3\\rightarrow6`"
msgstr ""

msgid ":doc:`pgr_withPointsVia` when there are no restrictions,"
msgstr ""

msgid ":doc:`pgr_trspVia_withPoints` when there are restrictions."
msgstr ""

msgid "Migrating ``pgr_trspViaEdges`` using ``pgr_withPointsVia``"
msgstr ""

msgid "Use :doc:`pgr_withPointsVia` instead."
msgstr ""

msgid ":doc:`pgr_withPointsVia`:"
msgstr ""

msgid "Migrating ``pgr_trspViaEdges`` using ``pgr_trspVia_withPoints``"
msgstr ""

msgid "Use :doc:`pgr_trspVia_withPoints` instead."
msgstr ""

msgid ":doc:`pgr_trspVia_withPoints`:"
msgstr ""

msgid ":doc:`withPoints-category`"
msgstr ""

msgid "Ordering - Family of functions"
msgstr ""

msgid "pgRouting Concepts"
msgstr ""

msgid ""
"This is a simple guide that go through some of the steps for getting started "
"with pgRouting. This guide covers:"
msgstr ""

msgid "Graphs"
msgstr ""

msgid "A graph is an ordered pair :math:`G = (V ,E)` where:"
msgstr ""

msgid ":math:`V` is a set of vertices, also called nodes."
msgstr ""

msgid ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V \\}`"
msgstr ""

msgid "There are different kinds of graphs:"
msgstr ""

msgid ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V\\}`"
msgstr ""

msgid "Undirected simple graph"
msgstr ""

msgid ":math:`E \\subseteq \\{( u, v ) \\mid u , v \\in V, u \\neq v\\}`"
msgstr ""

msgid ":math:`E \\subseteq \\{( u, v ) \\mid (u , v) \\in (V X V) \\}`"
msgstr ""

msgid "Directed simple graph"
msgstr ""

msgid ""
":math:`E \\subseteq \\{( u, v ) \\mid (u , v) \\in (V X V), u \\neq v\\}`"
msgstr ""

msgid "Graphs:"
msgstr ""

msgid "Do not have geometries."
msgstr ""

msgid ""
"Some graph theory problems require graphs to have weights, called **cost** "
"in pgRouting."
msgstr ""

msgid ""
"In pgRouting there are several ways to represent a graph on the database:"
msgstr ""

msgid "With ``cost``"
msgstr ""

msgid "(``id``, ``source``, ``target``, ``cost``)"
msgstr ""

msgid "With ``cost`` and ``reverse_cost``"
msgstr ""

msgid "(``id``, ``source``, ``target``, ``cost``, ``reverse_cost``)"
msgstr ""

msgid ""
"Identifier of the edge. Requirement to use the database in a consistent. "
"manner."
msgstr ""

msgid "Identifier of a vertex."
msgstr ""

msgid "Weight of the edge (``source``, ``target``):"
msgstr ""

msgid ""
"When negative the edge (``source``, ``target``) do not exist on the graph."
msgstr ""

msgid "``cost`` must exist in the query."
msgstr ""

msgid ""
"When negative the edge (``target``, ``source``) do not exist on the graph."
msgstr ""

msgid ""
"The decision of the graph to be **directed** or **undirected** is done when "
"executing a pgRouting algorithm."
msgstr ""

msgid "Graph with ``cost``"
msgstr ""

msgid "The weighted directed graph, :math:`G_d(V,E)`:"
msgstr ""

msgid "Graph data is obtained with a query"
msgstr ""

msgid "``SELECT id, source, target, cost FROM edges``"
msgstr ""

msgid ""
":math:`E = \\{(source_{id}, target_{id}, cost_{id}) \\text{ when } cost_{id} "
"\\ge 0 \\}`"
msgstr ""

msgid "Edges where ``cost`` is non negative are part of the graph."
msgstr ""

msgid ":math:`V = \\{source_{id} \\cup target_{id}\\}`"
msgstr ""

msgid "All vertices in ``source`` and ``target`` are part of the graph."
msgstr ""

msgid ""
"In a directed graph the edge :math:`(source_{id}, target_{id}, cost_{id})` "
"has directionality: :math:`source_{id} \\rightarrow target_{id}`"
msgstr ""

msgid "For the following data:"
msgstr ""

msgid "Edge :math:`2` (:math:`1 \\rightarrow 3`) is not part of the graph."
msgstr ""

msgid "The data is representing the following graph:"
msgstr ""

msgid ""
"In an undirected graph the edge :math:`(source_{id}, target_{id}, "
"cost_{id})` does not have directionality: :math:`source_{id} \\frac{\\;\\;\\;"
"\\;\\;}{} target_{id}`"
msgstr ""

msgid ""
"In terms of a directed graph is like having two edges: :math:`source_{id} "
"\\leftrightarrow target_{id}`"
msgstr ""

msgid ""
"Edge :math:`2` (:math:`1 \\frac{\\;\\;\\;\\;\\;}{} 3`) is not part of the "
"graph."
msgstr ""

msgid "Graph with ``cost`` and ``reverse_cost``"
msgstr ""

msgid "The weighted directed graph, :math:`G_d(V,E)`, is defined by:"
msgstr ""

msgid "``SELECT id, source, target, cost, reverse_cost FROM edges``"
msgstr ""

msgid "The set of edges :math:`E`:"
msgstr ""

msgid ""
":math:`E = \\begin{split} \\begin{align} & {\\{(source_{id}, target_{id}, "
"cost_{id}) \\text{ when } cost_{id} >=0 \\}} \\\\ & \\cup \\\\ & "
"{\\{(target_{id}, source_{id}, reverse\\_cost_{id}) \\text{ when } "
"reverse\\_cost_{id} >=0 \\}} \\end{align} \\end{split}`"
msgstr ""

msgid ""
"Edges :math:`(source \\rightarrow target)` where ``cost`` is non negative "
"are part of the graph."
msgstr ""

msgid ""
"Edges :math:`(target \\rightarrow source)` where ``reverse_cost`` is non "
"negative are part of the graph."
msgstr ""

msgid "The set of vertices :math:`V`:"
msgstr ""

msgid "In a directed graph both edges have directionality"
msgstr ""

msgid ""
"edge :math:`(source_{id}, target_{id}, cost_{id})` has directionality: :math:"
"`source_{id} \\rightarrow target_{id}`"
msgstr ""

msgid ""
"edge :math:`(target_{id}, source_{id}, reverse\\_cost_{id})` has "
"directionality: :math:`target_{id} \\rightarrow source_{id}`"
msgstr ""

msgid "Edges not part of the graph:"
msgstr ""

msgid ":math:`2` (:math:`1 \\rightarrow 3`)"
msgstr ""

msgid ":math:`3` (:math:`3 \\rightarrow 2`)"
msgstr ""

msgid "In a directed graph both edges do not have directionality"
msgstr ""

msgid ""
"Edge :math:`(source_{id}, target_{id}, cost_{id})` is :math:`source_{id} "
"\\frac{\\;\\;\\;\\;\\;}{} target_{id}`"
msgstr ""

msgid ""
"Edge :math:`(target_{id}, source_{id}, reverse\\_cost_{id})` is :math:"
"`target_{id} \\frac{\\;\\;\\;\\;\\;}{} source_{id}`"
msgstr ""

msgid "In terms of a directed graph is like having four edges:"
msgstr ""

msgid ":math:`source_i \\leftrightarrow target_i`"
msgstr ""

msgid ":math:`target_i \\leftrightarrow source_i`"
msgstr ""

msgid ":math:`2` (:math:`1 \\frac{\\;\\;\\;\\;\\;}{} 3`)"
msgstr ""

msgid ":math:`3` (:math:`3 \\frac{\\;\\;\\;\\;\\;}{} 2`)"
msgstr ""

msgid "Graphs without geometries"
msgstr ""

msgid ""
"Personal relationships, genealogy, file dependency problems can be solved "
"using pgRouting. Those problems, normally, do not come with geometries "
"associated with the graph."
msgstr ""

msgid "Wiki example"
msgstr ""

msgid ""
"Solve the example problem taken from `wikipedia <https://en.wikipedia.org/"
"wiki/Dijkstra%27s_algorithm>`__):"
msgstr ""

msgid "Problem is to find the shortest path from :math:`1` to :math:`5`."
msgstr ""

msgid "Is an undirected graph."
msgstr ""

msgid ""
"Although visually looks like to have geometries, the drawing is not to scale."
msgstr ""

msgid "No geometries associated to the vertices or edges"
msgstr ""

msgid "Has 6 vertices :math:`\\{1,2,3,4,5,6\\}`"
msgstr ""

msgid "Has 9 edges:"
msgstr ""

msgid ""
":math:`\\begin{split} \\begin{align} E = & \\{(1,2,7), (1,3,9), (1,6,14), \\"
"\\ & (2,3,10), (2,4,13), \\\\ & (3,4,11), (3,6,2), \\\\ & (4,5,6), \\\\ & "
"(5,6,9) \\} \\end{align} \\end{split}`"
msgstr ""

msgid "The graph can be represented in many ways for example:"
msgstr ""

msgid "Prepare the database"
msgstr ""

msgid ""
"Create a database for the example, access the database and install "
"pgRouting: ::"
msgstr ""

msgid "Create a table"
msgstr ""

msgid ""
"The basic elements needed to perform basic routing on an undirected graph "
"are:"
msgstr ""

msgid "SMALLINT, INTEGER, BIGINT, REAL, FLOAT"
msgstr ""

msgid "Using this table design for this example:"
msgstr ""

msgid "Insert the data"
msgstr ""

msgid "Find the shortest path"
msgstr ""

msgid "To solve this example :doc:`pgr_dijkstra` is used:"
msgstr ""

msgid ""
"To go from :math:`1` to :math:`5` the path goes thru the following "
"vertices: :math:`1 \\rightarrow 3 \\rightarrow 6 \\rightarrow 5`"
msgstr ""

msgid "Vertex information"
msgstr ""

msgid "To obtain the vertices information, use :doc:`pgr_extractVertices`"
msgstr ""

msgid "Graphs with geometries"
msgstr ""

msgid "Create a routing Database"
msgstr ""

msgid ""
"The first step is to create a database and load pgRouting in the database."
msgstr ""

msgid "Typically create a database for each project."
msgstr ""

msgid ""
"Once having the database to work in, load your data and build the routing "
"application in that database."
msgstr ""

msgid "Load Data"
msgstr ""

msgid "There are several ways to load your data into pgRouting."
msgstr ""

msgid "Manually creating a database."
msgstr ""

msgid "`Graphs without geometries`_"
msgstr ""

msgid ":doc:`sampledata`: a small graph used in the documentation examples"
msgstr ""

msgid ""
"Using `osm2pgrouting <https://workshop.pgrouting.org/latest/en/basic/data."
"html>`__"
msgstr ""

msgid "There are various open source tools that can help, like:"
msgstr ""

msgid "shp2pgsql"
msgstr ""

msgid "postgresql shapefile loader"
msgstr ""

msgid "ogr2ogr"
msgstr ""

msgid "vector data conversion utility"
msgstr ""

msgid "osm2pgsql"
msgstr ""

msgid "load OSM data into postgresql"
msgstr ""

msgid ""
"Please note that these tools will **not** import the data in a structure "
"compatible with pgRouting and when this happens the topology needs to be "
"adjusted."
msgstr ""

msgid "Breakup a segments on each segment-segment intersection"
msgstr ""

msgid ""
"When missing, add columns and assign values to ``source``, ``target``, "
"``cost``, ``reverse_cost``."
msgstr ""

msgid "Connect a disconnected graph."
msgstr ""

msgid "Create the complete graph topology"
msgstr ""

msgid "Create one or more graphs based on the application to be developed."
msgstr ""

msgid "Create a contracted graph for the high speed roads"
msgstr ""

msgid "Create graphs per state/country"
msgstr ""

msgid "In few words:"
msgstr ""

msgid "Prepare the graph"
msgstr ""

msgid ""
"What and how to prepare the graph, will depend on the application and/or on "
"the quality of the data and/or on how close the information is to have a "
"topology usable by pgRouting and/or some other factors not mentioned."
msgstr ""

msgid ""
"The steps to prepare the graph involve geometry operations using `PostGIS "
"<https://postgis.net/>`__ and some others involve graph operations like :doc:"
"`pgr_contraction` to contract a graph."
msgstr ""

msgid ""
"The `workshop <https://workshop.pgrouting.org/latest>`__ has a step by step "
"on how to prepare a graph using Open Street Map data, for a small "
"application."
msgstr ""

msgid "The use of indexes on the database design in general:"
msgstr ""

msgid "Have the geometries indexed."
msgstr ""

msgid "Have the identifiers columns indexed."
msgstr ""

msgid ""
"Please consult the `PostgreSQL <https://www.postgresql.org/docs/>`__ "
"documentation and the `PostGIS <https://postgis.net/>`__ documentation."
msgstr ""

msgid "Build a routing topology"
msgstr ""

msgid ""
"The basic information to use the majority of the pgRouting functions ``id, "
"source, target, cost, [reverse_cost]`` is what in pgRouting is called the "
"routing topology."
msgstr ""

msgid ""
"``reverse_cost`` is optional but strongly recommended to have in order to "
"reduce the size of the database due to the size of the geometry columns. "
"Having said that, in this documentation ``reverse_cost`` is used in this "
"documentation."
msgstr ""

msgid ""
"When the data comes with geometries and there is no routing topology, then "
"this step is needed."
msgstr ""

msgid ""
"All the start and end vertices of the geometries need an identifier that is "
"to be stored in a ``source`` and ``target`` columns of the table of the "
"data. Likewise, ``cost`` and ``reverse_cost`` need to have the value of "
"traversing the edge in both directions."
msgstr ""

msgid ""
"If the columns do not exist they need to be added to the table in question. "
"(see `ALTER TABLE <https://www.postgresql.org/docs/current/sql-altertable."
"html>`__)"
msgstr ""

msgid ""
"The function :doc:`pgr_extractVertices` is used to create a vertices table "
"based on the edge identifier and the geometry of the edge of the graph."
msgstr ""

msgid ""
"Finally using the data stored on the vertices tables the ``source`` and "
"``target`` are filled up."
msgstr ""

msgid "See :doc:`sampledata` for an example for building a topology."
msgstr ""

msgid ""
"Data coming from OSM and using `osm2pgrouting <https://github.com/pgRouting/"
"osm2pgrouting>`__ as an import tool, comes with the routing topology. See an "
"example of using ``osm2pgrouting`` on the `workshop <https://workshop."
"pgrouting.org/latest/en/basic/data.html>`__."
msgstr ""

msgid "Adjust costs"
msgstr ""

msgid ""
"For this example the ``cost`` and ``reverse_cost`` values are going to be "
"the double of the length of the geometry."
msgstr ""

msgid "Update costs to length of geometry"
msgstr ""

msgid ""
"Suppose that ``cost`` and ``reverse_cost`` columns in the sample data "
"represent:"
msgstr ""

msgid ":math:`1` when the edge exists in the graph"
msgstr ""

msgid ":math:`-1` when the edge does not exist in the graph"
msgstr ""

msgid "Using that information updating to the length of the geometries:"
msgstr ""

msgid "Which gives the following results:"
msgstr ""

msgid ""
"Note that to be able to follow the documentation examples, everything is "
"based on the original graph."
msgstr ""

msgid "Returning to the original data:"
msgstr ""

msgid "Update costs based on codes"
msgstr ""

msgid "Other datasets, can have a column with values like"
msgstr ""

msgid "``FT`` vehicle flow on the direction of the geometry"
msgstr ""

msgid "``TF`` vehicle flow opposite of the direction of the geometry"
msgstr ""

msgid "``B`` vehicle flow on both directions"
msgstr ""

msgid "Preparing a code column for the example:"
msgstr ""

msgid "Adjusting the costs based on the codes:"
msgstr ""

msgid "Check the Routing Topology"
msgstr ""

msgid "There are lots of possible problems in a graph."
msgstr ""

msgid "The data used may not have been designed with routing in mind."
msgstr ""

msgid "A graph has some very specific requirements."
msgstr ""

msgid "The graph is disconnected."
msgstr ""

msgid "There are unwanted intersections."
msgstr ""

msgid "The graph is too large and needs to be contracted."
msgstr ""

msgid "A sub graph is needed for the application."
msgstr ""

msgid ""
"and many other problems that the pgRouting user, that is the application "
"developer might encounter."
msgstr ""

msgid "Crossing edges"
msgstr ""

msgid "To get the crossing edges:"
msgstr ""

msgid ""
"That information is correct, for example, when in terms of vehicles, is it a "
"tunnel or bridge crossing over another road."
msgstr ""

msgid "It might be incorrect, for example:"
msgstr ""

msgid ""
"When it is actually an intersection of roads, where vehicles can make turns."
msgstr ""

msgid ""
"When in terms of electrical lines, the electrical line is able to switch "
"roads even on a tunnel or bridge."
msgstr ""

msgid "When it is incorrect, it needs fixing:"
msgstr ""

msgid "For vehicles and pedestrians"
msgstr ""

msgid ""
"If the data comes from OSM and was imported to the database using "
"``osm2pgrouting``, the fix needs to be done in the `OSM portal <https://www."
"openstreetmap.org>`__ and the data imported again."
msgstr ""

msgid ""
"In general when the data comes from a supplier that has the data prepared "
"for routing vehicles, and there is a problem, the data is to be fixed from "
"the supplier"
msgstr ""

msgid "For very specific applications"
msgstr ""

msgid ""
"The data is correct when from the point of view of routing vehicles or "
"pedestrians."
msgstr ""

msgid "The data needs a local fix for the specific application."
msgstr ""

msgid ""
"Once analyzed one by one the crossings, for the ones that need a local fix, "
"the edges need to be `split <https://postgis.net/docs/ST_Split.html>`__."
msgstr ""

msgid ""
"The new edges need to be added to the edges table, the rest of the "
"attributes need to be updated in the new edges, the old edges need to be "
"removed and the routing topology needs to be updated."
msgstr ""

msgid "Adding split edges"
msgstr ""

msgid ""
"For each pair of crossing edges a process similar to this one must be "
"performed."
msgstr ""

msgid ""
"The columns inserted and the way are calculated are based on the "
"application. For example, if the edges have a trait **name**, then that "
"column is to be copied."
msgstr ""

msgid "For pgRouting calculations"
msgstr ""

msgid ""
"**factor** based on the position of the intersection of the edges can be "
"used to adjust the ``cost`` and ``reverse_cost`` columns."
msgstr ""

msgid ""
"Capacity information, used in the :doc:`flow-family` functions does not need "
"to change when splitting edges."
msgstr ""

msgid "Adding new vertices"
msgstr ""

msgid ""
"After adding all the split edges required by the application, the newly "
"created vertices need to be added to the vertices table."
msgstr ""

msgid "Updating edges topology"
msgstr ""

msgid "Removing the surplus edges"
msgstr ""

msgid ""
"Once all significant information needed by the application has been "
"transported to the new edges, then the crossing edges can be deleted."
msgstr ""

msgid ""
"There are other options to do this task, like creating a view, or a "
"materialized view."
msgstr ""

msgid "Updating vertices topology"
msgstr ""

msgid "To keep the graph consistent, the vertices topology needs to be updated"
msgstr ""

msgid "Checking for crossing edges"
msgstr ""

msgid "There are no crossing edges on the graph."
msgstr ""

msgid "Disconnected graphs"
msgstr ""

msgid "To get the graph connectivity:"
msgstr ""

msgid ""
"In this example, the component :math:`2` consists of vertices :math:`\\{2, "
"4\\}` and both vertices are also part of the dead end result set."
msgstr ""

msgid "This graph needs to be connected."
msgstr ""

msgid ""
"With the original graph of this documentation, there would be 3 components "
"as the crossing edge in this graph is a different component."
msgstr ""

msgid "Prepare storage for connection information"
msgstr ""

msgid "Save the vertices connection information"
msgstr ""

msgid "Save the edges connection information"
msgstr ""

msgid "Get the closest vertex"
msgstr ""

msgid ""
"Using :doc:`pgr_findCloseEdges` the closest vertex to component :math:`1` is "
"vertex :math:`4`. And the closest edge to vertex :math:`4` is edge :math:"
"`14`."
msgstr ""

msgid ""
"The ``edge`` can be used to connect the components, using the ``fraction`` "
"information about the edge :math:`14` to split the connecting edge."
msgstr ""

msgid "Connecting components"
msgstr ""

msgid "There are three basic ways to connect the components"
msgstr ""

msgid "From the vertex to the starting point of the edge"
msgstr ""

msgid "From the vertex to the ending point of the edge"
msgstr ""

msgid "From the vertex to the closest vertex on the edge"
msgstr ""

msgid "This solution requires the edge to be split."
msgstr ""

msgid "The following query shows the three ways to connect the components:"
msgstr ""

msgid "Checking components"
msgstr ""

msgid ""
"Ignoring the edge that requires further work. The graph is now fully "
"connected as there is only one component."
msgstr ""

msgid "Contraction of a graph"
msgstr ""

msgid "The graph can be reduced in size using :doc:`contraction-family`"
msgstr ""

msgid ""
"When to contract will depend on the size of the graph, processing times, "
"correctness of the data, on the final application, or any other factor not "
"mentioned."
msgstr ""

msgid ""
"A fairly good method of finding out if contraction can be useful is because "
"of the number of dead ends and/or the number of linear edges."
msgstr ""

msgid ""
"A complete method on how to contract and how to use the contracted graph is "
"described on :doc:`contraction-family`"
msgstr ""

msgid "Dead ends"
msgstr ""

msgid "To get the dead ends:"
msgstr ""

msgid ""
"That information is correct, for example, when the dead end is on the limit "
"of the imported graph."
msgstr ""

msgid ""
"Visually node :math:`4` looks to be as start/ending of 3 edges, but it is "
"not."
msgstr ""

msgid "Is that correct?"
msgstr ""

msgid "Is there such a small curb:"
msgstr ""

msgid "That does not allow a vehicle to use that visual intersection?"
msgstr ""

msgid ""
"Is the application for pedestrians and therefore the pedestrian can easily "
"walk on the small curb?"
msgstr ""

msgid ""
"Is the application for the electricity and the electrical lines than can "
"easily be extended on top of the small curb?"
msgstr ""

msgid ""
"Is there a big cliff and from eagles view look like the dead end is close to "
"the segment?"
msgstr ""

msgid ""
"When there are many dead ends, to speed up, the :doc:`contraction-family` "
"functions can be used to divide the problem."
msgstr ""

msgid "Linear edges"
msgstr ""

msgid "To get the linear edges:"
msgstr ""

msgid ""
"This information is correct, for example, when the application is taking "
"into account speed bumps, stop signals."
msgstr ""

msgid ""
"When there are many linear edges, to speed up, the :doc:`contraction-family` "
"functions can be used to divide the problem."
msgstr ""

msgid "Function's structure"
msgstr ""

msgid ""
"Once the graph preparation work has been done above, it is time to use a"
msgstr ""

msgid "The general form of a pgRouting function call is:"
msgstr ""

msgid "\\ \\"
msgstr ""

msgid "pgr_<name>(`Inner queries`_, **parameters**, [ ``Optional parameters``)"
msgstr ""

msgid ""
"`Inner queries`_: Are compulsory parameters that are ``TEXT`` strings "
"containing SQL queries."
msgstr ""

msgid ""
"**parameters**: Additional compulsory parameters needed by the function."
msgstr ""

msgid ""
"``Optional parameters``: Are non compulsory **named** parameters that have a "
"default value when omitted."
msgstr ""

msgid ""
"The compulsory parameters are positional parameters, the optional parameters "
"are named parameters."
msgstr ""

msgid "For example, for this :doc:`pgr_dijkstra` signature:"
msgstr ""

msgid ""
"pgr_dijkstra(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr ""

msgid "`Edges SQL`_:"
msgstr ""

msgid "Is the first parameter."
msgstr ""

msgid "It is compulsory."
msgstr ""

msgid "It is an inner query."
msgstr ""

msgid ""
"It has no name, so **Edges SQL** gives an idea of what kind of inner query "
"needs to be used"
msgstr ""

msgid "**start vid**:"
msgstr ""

msgid "Is the second parameter."
msgstr ""

msgid ""
"It has no name, so **start vid** gives an idea of what the second "
"parameter's value should contain."
msgstr ""

msgid "Is the third parameter."
msgstr ""

msgid ""
"It has no name, so **end vid** gives an idea of what the third parameter's "
"value should contain"
msgstr ""

msgid "Is the fourth parameter."
msgstr ""

msgid "It is optional."
msgstr ""

msgid "It has a name."
msgstr ""

msgid ""
"The full description of the parameters are found on the `Parameters`_ "
"section of each function."
msgstr ""

msgid "Function's overloads"
msgstr ""

msgid "A function might have different overloads. The most common are called:"
msgstr ""

msgid "`One to One`_"
msgstr ""

msgid "`One to Many`_"
msgstr ""

msgid "`Many to One`_"
msgstr ""

msgid "`Many to Many`_"
msgstr ""

msgid "`Combinations`_"
msgstr ""

msgid "Depending on the overload the parameters types change."
msgstr ""

msgid "**One**: **ANY-INTEGER**"
msgstr ""

msgid "**Many**: ``ARRAY`` [**ANY-INTEGER**]"
msgstr ""

msgid ""
"Depending of the function the overloads may vary. But the concept of "
"parameter type change remains the same."
msgstr ""

msgid "One to One"
msgstr ""

msgid "When routing from:"
msgstr ""

msgid "From **one** starting vertex"
msgstr ""

msgid "to **one** ending vertex"
msgstr ""

msgid "One to Many"
msgstr ""

msgid "to **many** ending vertices"
msgstr ""

msgid "Many to One"
msgstr ""

msgid "From **many** starting vertices"
msgstr ""

msgid "Many to Many"
msgstr ""

msgid "Combinations"
msgstr ""

msgid "From **many** different starting vertices"
msgstr ""

msgid "to **many** different ending vertices"
msgstr ""

msgid "Every tuple specifies a pair of a start vertex and an end vertex"
msgstr ""

msgid "Users can define the combinations as desired."
msgstr ""

msgid "Needs a `Combinations SQL`_"
msgstr ""

msgid ""
"There are several kinds of valid inner queries and also the columns returned "
"are depending of the function. Which kind of inner query will depend on the "
"function(s) requirements. To simplify variety of types, **ANY-INTEGER** and "
"**ANY-NUMERICAL** is used."
msgstr ""

msgid "Edges SQL for"
msgstr ""

msgid ":doc:`withPoints-family`"
msgstr ""

msgid "Some uncategorised functions"
msgstr ""

msgid "General without ``id``"
msgstr ""

msgid "General with (X,Y)"
msgstr ""

msgid ""
"When negative: edge (``source``, ``target``) does not exist, therefore it's "
"not part of the graph."
msgstr ""

msgid "Weight of the edge (``target``, ``source``),"
msgstr ""

msgid "``x1``"
msgstr ""

msgid "X coordinate of ``source`` vertex."
msgstr ""

msgid "``y1``"
msgstr ""

msgid "Y coordinate of ``source`` vertex."
msgstr ""

msgid "``x2``"
msgstr ""

msgid "X coordinate of ``target`` vertex."
msgstr ""

msgid "``y2``"
msgstr ""

msgid "Y coordinate of ``target`` vertex."
msgstr ""

msgid "Flow"
msgstr ""

msgid "Edges SQL for :doc:`flow-family`"
msgstr ""

msgid "Edges SQL for the following functions of :doc:`flow-family`"
msgstr ""

msgid "Used in combination signatures"
msgstr ""

msgid "Points SQL for"
msgstr ""

msgid ""
"The main parameter of the majority of the pgRouting functions is a query "
"that selects the edges of the graph."
msgstr ""

msgid ""
"Depending on the family or category of a function it will have additional "
"parameters, some of them are compulsory and some are optional."
msgstr ""

msgid ""
"The compulsory parameters are nameless and must be given in the required "
"order. The optional parameters are named parameters and will have a default "
"value."
msgstr ""

msgid "Parameters for the Via functions"
msgstr ""

msgid ":doc:`pgr_dijkstraVia`"
msgstr ""

msgid "SQL query as described."
msgstr ""

msgid "When ``true`` Graph is considered `Directed`"
msgstr ""

msgid "When ``false`` the graph is considered as Undirected."
msgstr ""

msgid "``strict``"
msgstr ""

msgid "``false``"
msgstr ""

msgid "When ``true`` if a path is missing stops and returns **EMPTY SET**"
msgstr ""

msgid "When ``false`` ignores missing paths returning all paths found"
msgstr ""

msgid "``U_turn_on_edge``"
msgstr ""

msgid ""
"When ``true`` departing from a visited vertex will not try to avoid using "
"the edge used to reach it. In other words, U turn using the edge with same "
"identifier is allowed."
msgstr ""

msgid ""
"When ``false`` when a departing from a visited vertex tries to avoid using "
"the edge used to reach it. In other words, U turn using the edge with same "
"identifier is used when no other path is found."
msgstr ""

msgid "For the TRSP functions"
msgstr ""

msgid ":doc:`pgr_trsp`"
msgstr ""

msgid "Array of identifiers of destination vertices."
msgstr ""

msgid ""
"There are several kinds of columns returned are depending of the function."
msgstr ""

msgid "Result columns for a path"
msgstr ""

msgid "Used in functions that return one path solution"
msgstr ""

msgid ""
"Returns set of ``(seq, path_seq [, start_vid] [, end_vid], node, edge, cost, "
"agg_cost)``"
msgstr ""

msgid "``path_seq``"
msgstr ""

msgid ""
"Relative position in the path. Has value **1** for the beginning of a path."
msgstr ""

msgid ""
"Identifier of the starting vertex. Returned when multiple starting vetrices "
"are in the query."
msgstr ""

msgid ""
"Identifier of the ending vertex. Returned when multiple ending vertices are "
"in the query."
msgstr ""

msgid "Identifier of the node in the path from ``start_vid`` to ``end_vid``."
msgstr ""

msgid ""
"Identifier of the edge used to go from ``node`` to the next node in the path "
"sequence. **-1** for the last node of the path."
msgstr ""

msgid ""
"Cost to traverse from ``node`` using ``edge`` to the next node in the path "
"sequence."
msgstr ""

msgid "Used in functions the following:"
msgstr ""

msgid ":doc:`pgr_withPoints`"
msgstr ""

msgid ""
"Returns set of ``(seq, path_seq [, start_pid] [, end_pid], node, edge, cost, "
"agg_cost)``"
msgstr ""

msgid "Relative position in the path."
msgstr ""

msgid "**1** For the first row of the path."
msgstr ""

msgid "``start_pid``"
msgstr ""

msgid "Identifier of a starting vertex/point of the path."
msgstr ""

msgid "When positive is the identifier of the starting vertex."
msgstr ""

msgid "When negative is the identifier of the starting point."
msgstr ""

msgid "Returned on `Many to One`_ and `Many to Many`_"
msgstr ""

msgid "``end_pid``"
msgstr ""

msgid "Identifier of an ending vertex/point of the path."
msgstr ""

msgid "When positive is the identifier of the ending vertex."
msgstr ""

msgid "When negative is the identifier of the ending point."
msgstr ""

msgid "Returned on `One to Many`_ and `Many to Many`_"
msgstr ""

msgid "Identifier of the node in the path from ``start_pid`` to ``end_pid``."
msgstr ""

msgid "When positive is the identifier of the a vertex."
msgstr ""

msgid "When negative is the identifier of the a point."
msgstr ""

msgid ""
"Identifier of the edge used to go from ``node`` to the next node in the path "
"sequence."
msgstr ""

msgid "**-1** for the last row of the path."
msgstr ""

msgid "**0** For the first row of the path."
msgstr ""

msgid ":doc:`pgr_dijkstraNear`"
msgstr ""

msgid ""
"Returns ``(seq, path_seq, start_vid, end_vid, node, edge, cost, agg_cost)``"
msgstr ""

msgid "Identifier of the starting vertex of the current path."
msgstr ""

msgid "Identifier of the ending vertex of the current path."
msgstr ""

msgid "Multiple paths"
msgstr ""

msgid "Selective for multiple paths."
msgstr ""

msgid "The columns depend on the function call."
msgstr ""

msgid ""
"Set of ``(seq, path_id, path_seq [, start_vid] [, end_vid], node, edge, "
"cost, agg_cost)``"
msgstr ""

msgid "``path_id``"
msgstr ""

msgid "Path identifier."
msgstr ""

msgid ""
"Has value **1** for the first of a path from ``start_vid`` to ``end_vid``."
msgstr ""

msgid "Non selective for multiple paths"
msgstr ""

msgid "Regardless of the call, al the columns are returned."
msgstr ""

msgid ""
"Returns set of ``(seq, path_id, path_seq, start_vid, end_vid, node, edge, "
"cost, agg_cost)``"
msgstr ""

msgid "Result columns for cost functions"
msgstr ""

msgid "Used in the following"
msgstr ""

msgid ""
"When start_vid or end_vid columns have negative values, the identifier is "
"for a Point."
msgstr ""

msgid "Result columns for flow functions"
msgstr ""

msgid "Edges SQL for the following"
msgstr ""

msgid "Result columns for spanning tree functions"
msgstr ""

msgid "Returns set of ``(edge, cost)``"
msgstr ""

msgid "Cost to traverse the edge."
msgstr ""

msgid "Performance Tips"
msgstr ""

msgid "For the Routing functions"
msgstr ""

msgid ""
"To get faster results bound the queries to an area of interest of routing."
msgstr ""

msgid ""
"In this example Use an inner query SQL that does not include some edges in "
"the routing function and is within the area of the results."
msgstr ""

msgid "How to contribute"
msgstr ""

msgid "Wiki"
msgstr ""

msgid ""
"Edit an existing `pgRouting Wiki <https://github.com/pgRouting/pgrouting/"
"wiki>`__ page."
msgstr ""

msgid "Or create a new Wiki page"
msgstr ""

msgid ""
"Create a page on the `pgRouting Wiki <https://github.com/pgRouting/pgrouting/"
"wiki>`__"
msgstr ""

msgid "Give the title an appropriate name"
msgstr ""

msgid ""
"`Example <https://github.com/pgRouting/pgrouting/wiki/How-to:-Handle-"
"parallel-edges-(KSP)>`__"
msgstr ""

msgid "Adding Functionaity to pgRouting"
msgstr ""

msgid ""
"Consult the `developer's documentation <https://docs.pgrouting.org/doxy/2.4/"
"index.html>`__"
msgstr ""

msgid "Installation"
msgstr ""

msgid ":ref:`install-short`"
msgstr ""

msgid ":ref:`install_get_sources`"
msgstr ""

msgid ":ref:`install_enable_db`"
msgstr ""

msgid ":ref:`install_dependencies`"
msgstr ""

msgid ":ref:`install_configuring`"
msgstr ""

msgid ":ref:`install_build`"
msgstr ""

msgid ":ref:`install_testing`"
msgstr ""

msgid ""
"Instructions for downloading and installing binaries for different operating "
"systems, additional notes and corrections not included in this documentation "
"can be found in `Installation wiki <https://github.com/pgRouting/pgrouting/"
"wiki/Notes-on-Download%2C-Installation-and-building-pgRouting>`__"
msgstr ""

msgid ""
"To use pgRouting PostGIS needs to be installed, please read the information "
"about installation in this `Install Guide <https://www.postgis.us/"
"presentations/postgis_install_guide_22.html>`__"
msgstr ""

msgid "Short Version"
msgstr ""

msgid "Extracting the tar ball"
msgstr ""

msgid "To compile assuming you have all the dependencies in your search path:"
msgstr ""

msgid ""
"Once pgRouting is installed, it needs to be enabled in each individual "
"database you want to use it in."
msgstr ""

msgid "Get the sources"
msgstr ""

msgid ""
"The pgRouting latest release can be found in https://github.com/pgRouting/"
"pgrouting/releases/latest"
msgstr ""

msgid "wget"
msgstr ""

msgid "To download this release:"
msgstr ""

msgid ""
"Go to :ref:`install-short` for more instructions on extracting tar ball and "
"compiling pgRouting."
msgstr ""

msgid "git"
msgstr ""

msgid "To download the repository"
msgstr ""

msgid ""
"Go to :ref:`install-short` for more instructions on compiling pgRouting "
"(there is no tar ball involved while downloading pgRouting repository from "
"GitHub)."
msgstr ""

msgid "Enabling and upgrading in the database"
msgstr ""

msgid "Enabling the database"
msgstr ""

msgid ""
"pgRouting is a PostgreSQL extension and depends on PostGIS to provide "
"functionalities to end user. Below given code demonstrates enabling PostGIS "
"and pgRouting in the database."
msgstr ""

msgid ""
"Checking PostGIS and pgRouting version after enabling them in the database."
msgstr ""

msgid "Upgrading the database"
msgstr ""

msgid ""
"To upgrade pgRouting in the database to version 3.7.0 use the following "
"command:"
msgstr ""

msgid ""
"More information can be found in https://www.postgresql.org/docs/current/sql-"
"createextension.html"
msgstr ""

msgid "Dependencies"
msgstr ""

msgid "Compilation Dependencies"
msgstr ""

msgid ""
"To be able to compile pgRouting, make sure that the following dependencies "
"are met:"
msgstr ""

msgid "C and C++0x compilers"
msgstr ""

msgid ""
"Compiling with Boost 1.56 up to Boost 1.74 requires C++ Compiler with C++03 "
"or C++11 standard support"
msgstr ""

msgid ""
"Compiling with Boost 1.75 requires C++ Compiler with C++14 standard support"
msgstr ""

msgid "Postgresql version = Supported versions by PostgreSQL"
msgstr ""

msgid "The Boost Graph Library (BGL). Version >= 1.56"
msgstr ""

msgid "CMake >= 3.2"
msgstr ""

msgid "optional dependencies"
msgstr ""

msgid "For user's documentation"
msgstr ""

msgid "Sphinx >= 1.1"
msgstr ""

msgid "Latex"
msgstr ""

msgid "For developer's documentation"
msgstr ""

msgid "Doxygen >= 1.7"
msgstr ""

msgid "For testing"
msgstr ""

msgid "pgtap"
msgstr ""

msgid "pg_prove"
msgstr ""

msgid "For using:"
msgstr ""

msgid "PostGIS version >= 2.2"
msgstr ""

msgid "Example: Installing dependencies on linux"
msgstr ""

msgid "Installing the compilation dependencies"
msgstr ""

msgid "Database dependencies"
msgstr ""

msgid "Configuring PostgreSQL"
msgstr ""

msgid "Entering psql console"
msgstr ""

msgid "To exit psql console"
msgstr ""

msgid ""
"Entering psql console directly without switching roles can be done by the "
"following commands"
msgstr ""

msgid "Then use the above given method to exit out of the psql console"
msgstr ""

msgid "Checking PostgreSQL version"
msgstr ""

msgid "or"
msgstr ""

msgid "Enter the psql console using above given method and then enter"
msgstr ""

msgid "Creating PostgreSQL role"
msgstr ""

msgid ""
"Default role provided by PostgreSQL is postgres. To create new roles you can "
"use the above provided commands. The prompt will ask the user to type name "
"of the role and then provide affirmation. Proceed with the steps and you "
"will succeed in creating PostgreSQL role successfully."
msgstr ""

msgid ""
"To add password to the role or change previously created password of the "
"role use the following commands"
msgstr ""

msgid ""
"To get additional details on the flags associated with ``createuser`` below "
"given command can be used"
msgstr ""

msgid "Creating Database in PostgreSQL"
msgstr ""

msgid "Connecting to a PostgreSQL Database"
msgstr ""

msgid "Enter the psql console and type the following commands"
msgstr ""

msgid "Build dependencies"
msgstr ""

msgid "Optional dependencies"
msgstr ""

msgid "For documentation and testing"
msgstr ""

msgid "Configuring"
msgstr ""

msgid "pgRouting uses the `cmake` system to do the configuration."
msgstr ""

msgid "The build directory is different from the source directory"
msgstr ""

msgid "Create the build directory"
msgstr ""

msgid "Configurable variables"
msgstr ""

msgid "To see the variables that can be configured"
msgstr ""

msgid "Configuring The Documentation"
msgstr ""

msgid ""
"Most of the effort of the documentation has been on the HTML files. Some "
"variables for building documentation:"
msgstr ""

msgid "Variable"
msgstr ""

msgid "Comment"
msgstr ""

msgid "WITH_DOC"
msgstr ""

msgid "BOOL=OFF"
msgstr ""

msgid "Turn on/off building the documentation"
msgstr ""

msgid "BUILD_HTML"
msgstr ""

msgid "BOOL=ON"
msgstr ""

msgid "If ON, turn on/off building HTML for user's documentation"
msgstr ""

msgid "BUILD_DOXY"
msgstr ""

msgid "If ON, turn on/off building HTML for developer's documentation"
msgstr ""

msgid "BUILD_LATEX"
msgstr ""

msgid "If ON, turn on/off building PDF"
msgstr ""

msgid "BUILD_MAN"
msgstr ""

msgid "If ON, turn on/off building MAN pages"
msgstr ""

msgid "DOC_USE_BOOTSTRAP"
msgstr ""

msgid "If ON, use sphinx-bootstrap for HTML pages of the users documentation"
msgstr ""

msgid "Configuring cmake to create documentation before building pgRouting"
msgstr ""

msgid "Most of the effort of the documentation has been on the html files."
msgstr ""

msgid "Building"
msgstr ""

msgid "Using ``make`` to build the code and the documentation"
msgstr ""

msgid "The following instructions start from *path/to/pgrouting/build*"
msgstr ""

msgid ""
"We have tested on several platforms, For installing or reinstalling all the "
"steps are needed."
msgstr ""

msgid "The sql signatures are configured and build in the ``cmake`` command."
msgstr ""

msgid "MinGW on Windows"
msgstr ""

msgid "Linux"
msgstr ""

msgid "The following instructions start from *path/to/pgrouting*"
msgstr ""

msgid ""
"To remove the build when the configuration changes, use the following code:"
msgstr ""

msgid "and start the build process as mentioned previously."
msgstr ""

msgid "Testing"
msgstr ""

msgid "Currently there is no :code:`make test` and testing is done as follows"
msgstr ""

msgid "The following instructions start from *path/to/pgrouting/*"
msgstr ""

msgid ""
"pgRouting is an extension of `PostGIS <https://postgis.net>`__ and "
"`PostgreSQL <https://www.postgresql.org>`__ geospatial database and adds "
"routing and other network analysis functionality. A predecessor of pgRouting "
"– pgDijkstra, written by Sylvain Pasche from `Camptocamp <https://camptocamp."
"com>`__, was later extended by Orkney and renamed to pgRouting. The project "
"is now supported and maintained by `Georepublic <https://georepublic."
"info>`__, `Paragon Corporation <https://www.paragoncorporation.com/>`__ and "
"a broad user community."
msgstr ""

msgid ""
"pgRouting is part of `OSGeo Community Projects <https://wiki.osgeo.org/wiki/"
"OSGeo_Community_Projects>`__ from the `OSGeo Foundation <https://www.osgeo."
"org>`__ and included on `OSGeoLive <http://live.osgeo.org/>`__."
msgstr ""

msgid "Licensing"
msgstr ""

msgid "The following licenses can be found in pgRouting:"
msgstr ""

msgid "**License**"
msgstr ""

msgid "GNU General Public License v2.0 or later"
msgstr ""

msgid ""
"Most features of pgRouting are available under `GNU General Public License "
"v2.0 or later <https://spdx.org/licenses/GPL-2.0-or-later.html>`_."
msgstr ""

msgid "Boost Software License - Version 1.0"
msgstr ""

msgid ""
"Some Boost extensions are available under `Boost Software License - Version "
"1.0 <https://www.boost.org/LICENSE_1_0.txt>`_."
msgstr ""

msgid "MIT-X License"
msgstr ""

msgid ""
"Some code contributed by iMaptools.com is available under MIT-X license."
msgstr ""

msgid ""
"The pgRouting Manual is licensed under a `Creative Commons Attribution-Share "
"Alike 3.0 License <https://creativecommons.org/licenses/by-sa/3.0/>`_."
msgstr ""

msgid ""
"In general license information should be included in the header of each "
"source file."
msgstr ""

msgid "Contributors"
msgstr ""

msgid "This Release Contributors"
msgstr ""

msgid "Individuals in this release v3.7.x (in alphabetical order)"
msgstr ""

msgid "(Alphabetical order)"
msgstr ""

msgid "Regina Obe, Vicky Vergara"
msgstr ""

msgid ""
"And all the people that give us a little of their time making comments, "
"finding issues, making pull requests etc. in any of our products: "
"osm2pgrouting, pgRouting, pgRoutingLayer, workshop."
msgstr ""

msgid "Corporate Sponsors in this release (in alphabetical order)"
msgstr ""

msgid ""
"These are corporate entities that have contributed developer time, hosting, "
"or direct monetary funding to the pgRouting project:"
msgstr ""

msgid "`OSGeo <https://www.osgeo.org>`__"
msgstr ""

msgid "`OSGeo UK <https://uk.osgeo.org>`__"
msgstr ""

msgid "`Google Summer of Code <https://summerofcode.withgoogle.com>`__"
msgstr ""

msgid "`Paragon Corporation <https://www.paragoncorporation.com/>`__"
msgstr ""

msgid "Contributors Past & Present:"
msgstr ""

msgid "Individuals (in alphabetical order)"
msgstr ""

msgid ""
"Aasheesh Tiwari, Abhinav Jain, Aditya Pratap Singh, Adrien Berchet, Akio "
"Takubo, Andrea Nardelli, Anthony Tasca, Anton Patrushev, Aryan Gupta, Ashraf "
"Hossain, Ashish Kumar, Cayetano Benavent, Christian Gonzalez, Daniel Kastl, "
"Dave Potts, David Techer, Denis Rykov, Ema Miyawaki, Esteban Zimanyi, "
"Florian Thurkow, Frederic Junod, Gerald Fenoy, Gudesa Venkata Sai Akhil, "
"Hang Wu, Himanshu Raj, Imre Samu, Jay Mahadeokar, Jinfu Leng, Kai Behncke, "
"Kishore Kumar, Ko Nagase, Mahmoud Sakr, Manikata Kondeti, Mario Basa, Martin "
"Wiesenhaan, Maxim Dubinin, Maoguang Wang, Mohamed Bakli, Mohamed Zia, Mukul "
"Priya, Nitish Chauhan, Rajat Shinde, Razequl Islam, Regina Obe, Rohith "
"Reddy, Sarthak Agarwal, Shobhit Chaurasia, Sourabh Garg, Stephen Woodbridge, "
"Swapnil Joshi, Sylvain Housseman, Sylvain Pasche, Veenit Kumar, Vidhan Jain, "
"Virginia Vergara, Yige Huang"
msgstr ""

msgid "Corporate Sponsors (in alphabetical order)"
msgstr ""

msgid "Camptocamp"
msgstr ""

msgid "CSIS (University of Tokyo)"
msgstr ""

msgid "Georepublic"
msgstr ""

msgid "Google Summer of Code"
msgstr ""

msgid "iMaptools"
msgstr ""

msgid "Leopark"
msgstr ""

msgid "Orkney"
msgstr ""

msgid "OSGeo"
msgstr ""

msgid "OSGeo UK"
msgstr ""

msgid "Paragon Corporation"
msgstr ""

msgid "Versaterm Inc."
msgstr ""

msgid "More Information"
msgstr ""

msgid ""
"The latest software, documentation and news items are available at the "
"pgRouting web site https://pgrouting.org."
msgstr ""

msgid ""
"PostgreSQL database server at the PostgreSQL main site https://www."
"postgresql.org."
msgstr ""

msgid "PostGIS extension at the PostGIS project web site https://postgis.net."
msgstr ""

msgid "Boost C++ source libraries at https://www.boost.org."
msgstr ""

msgid ":doc:`migration`"
msgstr ""

msgid "pgr_KSP"
msgstr ""

msgid "``pgr_KSP`` — Yen's algorithm for K shortest paths using Dijkstra."
msgstr ""

msgid "Availability"
msgstr ""

msgid "Version 3.6.0"
msgstr ""

msgid "Result columns standarized to: |nksp-result|"
msgstr ""

msgid "``pgr_ksp`` (One to One)"
msgstr ""

msgid "Added ``start_vid`` and ``end_vid`` result columns."
msgstr ""

msgid "New overload functions:"
msgstr ""

msgid "``pgr_ksp`` (One to Many)"
msgstr ""

msgid "``pgr_ksp`` (Many to One)"
msgstr ""

msgid "``pgr_ksp`` (Many to Many)"
msgstr ""

msgid "``pgr_ksp`` (Combinations)"
msgstr ""

msgid "Version 2.1.0"
msgstr ""

msgid "Signature change"
msgstr ""

msgid "Old signature no longer supported"
msgstr ""

msgid "Version 2.0.0"
msgstr ""

msgid "**Official** function"
msgstr ""

msgid ""
"The K shortest path routing algorithm based on Yen's algorithm. \"K\" is the "
"number of shortest paths desired."
msgstr ""

msgid "Signatures"
msgstr ""

msgid "Summary"
msgstr ""

msgid "pgr_KSP(`Edges SQL`_, **start vid**, **end vid**, **K**, [**options**])"
msgstr ""

msgid ""
"pgr_KSP(`Edges SQL`_, **start vid**, **end vids**, **K**, [**options**])"
msgstr ""

msgid ""
"pgr_KSP(`Edges SQL`_, **start vids**, **end vid**, **K**, [**options**])"
msgstr ""

msgid ""
"pgr_KSP(`Edges SQL`_, **start vids**, **end vids**, **K**, [**options**])"
msgstr ""

msgid "pgr_KSP(`Edges SQL`_, `Combinations SQL`_, **K**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, heap_paths]``"
msgstr ""

msgid "Returns set of |nksp-result|"
msgstr ""

msgid "OR EMPTY SET"
msgstr ""

msgid "Example"
msgstr ""

msgid "Get 2 paths from :math:`6` to :math:`17` on a directed graph."
msgstr ""

msgid ""
"Get 2 paths from vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a "
"directed graph."
msgstr ""

msgid ""
"Get 2 paths from vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a "
"directed graph."
msgstr ""

msgid ""
"Get 2 paths vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 17\\}` on "
"a directed graph."
msgstr ""

msgid "Using a combinations table on an directed graph"
msgstr ""

msgid "The combinations table:"
msgstr ""

msgid "The query:"
msgstr ""

msgid "Identifier of the destination vertex."
msgstr ""

msgid "**K**"
msgstr ""

msgid "Number of required paths."
msgstr ""

msgid "KSP Optional parameters"
msgstr ""

msgid "``heap_paths``"
msgstr ""

msgid "When ``false`` Returns at most K paths."
msgstr ""

msgid "When ``true`` all the calculated paths while processing are returned."
msgstr ""

msgid ""
"Roughly, when the shortest path has ``N`` edges, the heap will contain about "
"than ``N * K`` paths for small value of ``K`` and ``K > 5``."
msgstr ""

msgid ""
"Has value **1** for the first of a path from ``start_vid`` to ``end_vid``"
msgstr ""

msgid "Identifier of the node in the path from ``start_vid`` to ``end_vid``"
msgstr ""

msgid ":math:`0` for the last ``node`` of the path."
msgstr ""

msgid "Aggregate cost from **start vid** to ``node``."
msgstr ""

msgid "Additional Examples"
msgstr ""

msgid "Get 2 paths from :math:`6` to :math:`17` on an undirected graph"
msgstr ""

msgid "Also get the paths in the heap."
msgstr ""

msgid "Get 2 paths using combinations table on an undirected graph"
msgstr ""

msgid ""
"Get 2 paths from vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a "
"undirected graph."
msgstr ""

msgid "https://en.wikipedia.org/wiki/K_shortest_path_routing"
msgstr ""

msgid "``pgr_TSP``"
msgstr ""

msgid "``pgr_TSP`` - Aproximation using *metric* algorithm."
msgstr ""

msgid "Availability:"
msgstr ""

msgid "Version 3.2.1"
msgstr ""

msgid ""
"Metric Algorithm from `Boost library <https://www.boost.org/libs/graph/doc/"
"metric_tsp_approx.html>`__"
msgstr ""

msgid "Simulated Annealing Algorithm no longer supported"
msgstr ""

msgid ""
"The Simulated Annealing Algorithm related parameters are ignored: "
"max_processing_time, tries_per_temperature, max_changes_per_temperature, "
"max_consecutive_non_changes, initial_temperature, final_temperature, "
"cooling_factor, randomize"
msgstr ""

msgid "Version 2.3.0"
msgstr ""

msgid ""
"Can be Used with :doc:`costMatrix-category` functions preferably with "
"`directed => false`."
msgstr ""

msgid "With ``directed => false``"
msgstr ""

msgid "Will generate a graph that:"
msgstr ""

msgid "is undirected"
msgstr ""

msgid "is fully connected (As long as the graph has one component)"
msgstr ""

msgid "all traveling costs on edges obey the triangle inequality."
msgstr ""

msgid "When ``start_vid = 0 OR end_vid = 0``"
msgstr ""

msgid ""
"The solutions generated is garanteed to be *twice as long as the optimal "
"tour in the worst case*"
msgstr ""

msgid "When ``start_vid != 0 AND end_vid != 0 AND start_vid != end_vid``"
msgstr ""

msgid ""
"It is **not garanteed** that the solution will be, in the worse case, twice "
"as long as the optimal tour, due to the fact that `end_vid` is forced to be "
"in a fixed position."
msgstr ""

msgid "With ``directed => true``"
msgstr ""

msgid ""
"It is **not garanteed** that the solution will be, in the worse case, twice "
"as long as the optimal tour"
msgstr ""

msgid "is directed"
msgstr ""

msgid ""
"some (or all) traveling costs on edges might not obey the triangle "
"inequality."
msgstr ""

msgid ""
"As an undirected graph is required, the directed graph is transformed as "
"follows:"
msgstr ""

msgid ""
"edges `(u, v)` and `(v, u)` is considered to be the same edge (denoted `(u, "
"v)`"
msgstr ""

msgid "if ``agg_cost`` differs between one or more instances of edge `(u, v)`"
msgstr ""

msgid ""
"The minimum value of the ``agg_cost`` all instances of edge `(u, v)` is "
"going to be considered as the ``agg_cost`` of edge `(u, v)`"
msgstr ""

msgid ""
"Some (or all) traveling costs on edges will still might not obey the "
"triangle inequality."
msgstr ""

msgid "When the data is incomplete, but it is a connected graph:"
msgstr ""

msgid "the missing values will be calculated with dijkstra algorithm."
msgstr ""

msgid "pgr_TSP(`Matrix SQL`_, ``[start_id, end_id]``)"
msgstr ""

msgid "Returns set of |tsp-result|"
msgstr ""

msgid "OR EMTPY SET"
msgstr ""

msgid "Using :doc:`pgr_dijkstraCostMatrix` to generate the matrix information"
msgstr ""

msgid ""
"**Line 4** Vertices :math:`\\{2, 4, 13, 14\\}` are not included because they "
"are not connected."
msgstr ""

msgid "`Matrix SQL`_ as described below"
msgstr ""

msgid "``ANY-INTEGER``"
msgstr ""

msgid "``ANY-NUMERICAL``"
msgstr ""

msgid "Cost for going from start_vid to end_vid"
msgstr ""

msgid "Returns SET OF ``(seq, node, cost, agg_cost)``"
msgstr ""

msgid "Row sequence."
msgstr ""

msgid "**node**"
msgstr ""

msgid "Identifier of the node/coordinate/point."
msgstr ""

msgid ""
"Cost to traverse from the current ``node`` to the next ``node`` in the path "
"sequence."
msgstr ""

msgid "``0`` for the last row in the tour sequence."
msgstr ""

msgid "Aggregate cost from the ``node`` at ``seq = 1`` to the current node."
msgstr ""

msgid "``0`` for the first row in the tour sequence."
msgstr ""

msgid "Start from vertex :math:`1`"
msgstr ""

msgid "**Line 6** ``start_vid => 1``"
msgstr ""

msgid "Using points of interest to generate an asymetric matrix."
msgstr ""

msgid "To generate an asymmetric matrix:"
msgstr ""

msgid ""
"**Line 4** The ``side`` information of ``pointsOfInterset`` is ignored by "
"not including it in the query"
msgstr ""

msgid "**Line 6** Generating an asymetric matrix with ``directed => true``"
msgstr ""

msgid ""
":math:`min(agg\\_cost(u, v), agg\\_cost(v, u))` is going to be considered as "
"the ``agg_cost``"
msgstr ""

msgid ""
"The solution that can be larger than *twice as long as the optimal tour* "
"because:"
msgstr ""

msgid "Triangle inequality might not be satisfied."
msgstr ""

msgid "``start_id != 0 AND end_id != 0``"
msgstr ""

msgid "Connected incomplete data"
msgstr ""

msgid ""
"Using selected edges :math:`\\{2, 4, 5, 8, 9, 15\\}` the matrix is not "
"complete."
msgstr ""

msgid ""
"Cost value for :math:`17 \\rightarrow 10` do not exist on the matrix, but "
"the value used is taken from :math:`10 \\rightarrow 17`."
msgstr ""

msgid "``pgr_TSPeuclidean``"
msgstr ""

msgid "``pgr_TSPeuclidean`` - Aproximation using *metric* algorithm."
msgstr ""

msgid ""
"The Simulated Annealing Algorithm related parameters are ignored: "
"`max_processing_time`, `tries_per_temperature`, "
"`max_changes_per_temperature`, `max_consecutive_non_changes`, "
"`initial_temperature`, `final_temperature`, `cooling_factor`, `randomize`"
msgstr ""

msgid "Version 3.0.0"
msgstr ""

msgid "Name change from pgr_eucledianTSP"
msgstr ""

msgid "New **Official** function"
msgstr ""

msgid ""
"Any duplicated identifier will be ignored. The coordinates that will be kept"
msgstr ""

msgid "is arbitrarly."
msgstr ""

msgid ""
"The coordinates are quite similar for the same identifier, for example ::"
msgstr ""

msgid ""
"The coordinates are quite different for the same identifier, for example ::"
msgstr ""

msgid "pgr_TSPeuclidean(`Coordinates SQL`_, ``[start_id, end_id]``)"
msgstr ""

msgid "With default values"
msgstr ""

msgid "`Coordinates SQL`_"
msgstr ""

msgid "`Coordinates SQL`_ as described below"
msgstr ""

msgid "Coordinates SQL"
msgstr ""

msgid "``x``"
msgstr ""

msgid "X value of the coordinate."
msgstr ""

msgid "``y``"
msgstr ""

msgid "Y value of the coordinate."
msgstr ""

msgid "Test 29 cities of Western Sahara"
msgstr ""

msgid ""
"This example shows how to make performance tests using University of "
"Waterloo's `example data <https://www.math.uwaterloo.ca/tsp/world/countries."
"html>`__ using the 29 cities of `Western Sahara dataset <https://www.math."
"uwaterloo.ca/tsp/world/wi29.tsp>`__"
msgstr ""

msgid "Creating a table for the data and storing the data"
msgstr ""

msgid "Adding a geometry (for visual purposes)"
msgstr ""

msgid "Total tour cost"
msgstr ""

msgid ""
"Getting a total cost of the tour, compare the value with the length of an "
"optimal tour is 27603, given on the dataset"
msgstr ""

msgid "Getting a geometry of the tour"
msgstr ""

msgid "Visual results"
msgstr ""

msgid ""
"Visualy, The first image is the `optimal solution <https://www.math."
"uwaterloo.ca/tsp/world/witour.html>`__ and the second image is the solution "
"obtained with ``pgr_TSPeuclidean``."
msgstr ""

msgid ":doc:`sampledata` network."
msgstr ""

msgid "``pgr_aStar``"
msgstr ""

msgid "``pgr_aStar`` — Shortest path using the A* algorithm."
msgstr ""

msgid "Standarizing output columns to |short-generic-result|"
msgstr ""

msgid ""
"``pgr_aStar`` (`One to One`_) added ``start_vid`` and ``end_vid`` columns."
msgstr ""

msgid "``pgr_aStar`` (`One to Many`_) added ``end_vid`` column."
msgstr ""

msgid "``pgr_aStar`` (`Many to One`_) added ``start_vid`` column."
msgstr ""

msgid "Version 3.2.0"
msgstr ""

msgid "New **proposed** signature:"
msgstr ""

msgid "``pgr_aStar`` (`Combinations`_)"
msgstr ""

msgid "Version 2.4.0"
msgstr ""

msgid "New **Proposed** signatures:"
msgstr ""

msgid "``pgr_aStar`` (`One to Many`_)"
msgstr ""

msgid "``pgr_aStar`` (`Many to One`_)"
msgstr ""

msgid "``pgr_aStar`` (`Many to Many`_)"
msgstr ""

msgid "Signature change on ``pgr_astar`` (`One to One`_)"
msgstr ""

msgid "**Official** ``pgr_aStar`` (`One to One`_)"
msgstr ""

msgid ""
"The results are equivalent to the union of the results of the `pgr_aStar(` "
"`One to One`_ `)` on the:"
msgstr ""

msgid "pgr_aStar(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_aStar(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_aStar(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_aStar(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_aStar(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr ""

msgid "**options:** ``[directed, heuristic, factor, epsilon]``"
msgstr ""

msgid "Returns set of |short-generic-result|"
msgstr ""

msgid "Optional parameters are `named parameters` and have a default value."
msgstr ""

msgid ""
"From vertex :math:`6` to vertex :math:`12` on a **directed** graph with "
"heuristic :math:`2`"
msgstr ""

msgid ""
"From vertex :math:`6` to vertices :math:`\\{10, 12\\}` on a **directed** "
"graph with heuristic :math:`3` and factor :math:`3.5`"
msgstr ""

msgid ""
"From vertices :math:`\\{6, 8\\}` to vertex :math:`10` on an **undirected** "
"graph with heuristic :math:`4`"
msgstr ""

msgid ""
"From vertices :math:`\\{6, 8\\}` to vertices :math:`\\{10, 12\\}` on a "
"**directed** graph with factor :math:`0.5`"
msgstr ""

msgid ""
"Using a combinations table on a **directed** graph with factor :math:`0.5`."
msgstr ""

msgid "Example 1"
msgstr ""

msgid "Demonstration of repeated values are ignored, and result is sorted."
msgstr ""

msgid "Example 2"
msgstr ""

msgid "Making **start vids** the same as **end vids**."
msgstr ""

msgid "Example 3"
msgstr ""

msgid "Manually assigned vertex combinations."
msgstr ""

msgid "pgr_aStarCost"
msgstr ""

msgid ""
"``pgr_aStarCost`` - Total cost of the shortest path(s) using the A* "
"algorithm."
msgstr ""

msgid "``pgr_aStarCost`` (`Combinations`_)"
msgstr ""

msgid "New **proposed** function"
msgstr ""

msgid ""
"The ``pgr_aStarCost`` function sumarizes of the cost of the shortest path(s) "
"using the A* algorithm."
msgstr ""

msgid ""
"Let be the case the values returned are stored in a table, so the unique "
"index would be the pair: `(start_vid, end_vid)`"
msgstr ""

msgid "For undirected graphs, the results are symmetric."
msgstr ""

msgid "The returned values are ordered in ascending order:"
msgstr ""

msgid "`start_vid` ascending"
msgstr ""

msgid "`end_vid` ascending"
msgstr ""

msgid "pgr_aStarCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_aStarCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""

msgid ""
"pgr_aStarCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_aStarCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr ""

msgid "Returns set of |matrix-result|"
msgstr ""

msgid "pgr_aStarCost(`Edges SQL`_, **start vids**, **end vids**, [options])"
msgstr ""

msgid "``pgr_aStarCostMatrix``"
msgstr ""

msgid ""
"``pgr_aStarCostMatrix`` - Calculates the a cost matrix using :doc:"
"`pgr_aStar`."
msgstr ""

msgid "Using internaly the :doc:`pgr_aStar` algorithm"
msgstr ""

msgid "Returns a cost matrix."
msgstr ""

msgid "No ordering is performed"
msgstr ""

msgid "let `v` and `u` are nodes on the graph:"
msgstr ""

msgid "when there is no path from `v` to `u`:"
msgstr ""

msgid "cost from `v` to `u` is :math:`\\inf`"
msgstr ""

msgid "when :math:`v = u` then"
msgstr ""

msgid "cost from `v` to `u` is :math:`0`"
msgstr ""

msgid "When the graph is **undirected** the cost matrix is symmetric"
msgstr ""

msgid "pgr_aStarCostMatrix(`Edges SQL`_, **start vids**, [**options**])"
msgstr ""

msgid ""
"Symmetric cost matrix for vertices :math:`\\{5, 6, 10, 15\\}` on an "
"**undirected** graph using heuristic :math:`2`"
msgstr ""

msgid "Use with :doc:`pgr_TSP`"
msgstr ""

msgid "``pgr_alphaShape``"
msgstr ""

msgid "``pgr_alphaShape`` — Polygon part of an alpha shape."
msgstr ""

msgid "Breaking change on signature"
msgstr ""

msgid "**Boost 1.54** & **Boost 1.55** are supported"
msgstr ""

msgid "**Boost 1.56+** is preferable"
msgstr ""

msgid "Boost Geometry is stable on Boost 1.56"
msgstr ""

msgid "Added alpha argument with default 0 (use optimal value)"
msgstr ""

msgid "Support to return multiple outer/inner ring"
msgstr ""

msgid "Renamed from version 1.x"
msgstr ""

msgid "Support"
msgstr ""

msgid "Returns the polygon part of an alpha shape."
msgstr ""

msgid "Input is a *geometry* and returns a *geometry*"
msgstr ""

msgid "Uses PostGis ST_DelaunyTriangles"
msgstr ""

msgid ""
"Instead of using CGAL's definition of `alpha` it use the ``spoon_radius``"
msgstr ""

msgid ":math:`spoon\\_radius = \\sqrt alpha`"
msgstr ""

msgid ""
"A Triangle area is considered part of the alpha shape when :math:"
"`circumcenter\\ radius < spoon\\_radius`"
msgstr ""

msgid "The ``alpha`` parameter is the **spoon radius**"
msgstr ""

msgid ""
"When the total number of points is less than 3, returns an EMPTY geometry"
msgstr ""

msgid "pgr_alphaShape(**geometry**, [alpha])"
msgstr ""

msgid "RETURNS ``geometry``"
msgstr ""

msgid ""
"passing a geometry collection with spoon radius :math:`1.5` using the return "
"variable ``geom``"
msgstr ""

msgid "**geometry**"
msgstr ""

msgid "``geometry``"
msgstr ""

msgid "Geometry with at least :math:`3` points"
msgstr ""

msgid "``alpha``"
msgstr ""

msgid "The radius of the spoon."
msgstr ""

msgid "Return Value"
msgstr ""

msgid "Kind of geometry"
msgstr ""

msgid "GEOMETRY COLLECTION"
msgstr ""

msgid "A Geometry collection of Polygons"
msgstr ""

msgid ":doc:`pgr_drivingDistance`"
msgstr ""

msgid "`ST_ConcaveHull <https://postgis.net/docs/ST_ConcaveHull.html>`__"
msgstr ""

msgid "pgr_analyzeGraph"
msgstr ""

msgid "``pgr_analyzeGraph`` — Analyzes the network topology."
msgstr ""

msgid "The function returns:"
msgstr ""

msgid "``OK`` after the analysis has finished."
msgstr ""

msgid "``FAIL`` when the analysis was not completed due to an error."
msgstr ""

msgid "pgr_analyzeGraph(**edge_table**, **tolerance**, [**options**])"
msgstr ""

msgid "**options:** ``[the_geom, id, source, target, rows_where]``"
msgstr ""

msgid "RETURNS ``VARCHAR``"
msgstr ""

msgid "Prerequisites"
msgstr ""

msgid ""
"The edge table to be analyzed must contain a source column and a target "
"column filled with id's of the vertices of the segments and the "
"corresponding vertices table <edge_table>_vertices_pgr that stores the "
"vertices information."
msgstr ""

msgid "Use :doc:`pgr_createVerticesTable` to create the vertices table."
msgstr ""

msgid ""
"Use :doc:`pgr_createTopology` to create the topology and the vertices table."
msgstr ""

msgid "The analyze graph function accepts the following parameters:"
msgstr ""

msgid "edge_table"
msgstr ""

msgid "``text`` Network table name. (may contain the schema name as well)"
msgstr ""

msgid "tolerance"
msgstr ""

msgid ""
"``float8`` Snapping tolerance of disconnected edges. (in projection unit)"
msgstr ""

msgid "the_geom"
msgstr ""

msgid ""
"``text`` Geometry column name of the network table. Default value is "
"``the_geom``."
msgstr ""

msgid "id"
msgstr ""

msgid ""
"``text`` Primary key column name of the network table. Default value is "
"``id``."
msgstr ""

msgid "source"
msgstr ""

msgid ""
"``text`` Source column name of the network table. Default value is "
"``source``."
msgstr ""

msgid "target"
msgstr ""

msgid ""
"``text`` Target column name of the network table. Default value is "
"``target``."
msgstr ""

msgid "rows_where"
msgstr ""

msgid ""
"``text`` Condition to select a subset or rows. Default value is ``true`` to "
"indicate all rows."
msgstr ""

msgid "Uses the vertices table: <edge_table>_vertices_pgr."
msgstr ""

msgid "Fills completely the ``cnt`` and ``chk`` columns of the vertices table."
msgstr ""

msgid ""
"Returns the analysis of the section of the network defined by ``rows_where``"
msgstr ""

msgid "The vertices table is not found."
msgstr ""

msgid ""
"A required column of the Network table is not found or is not of the "
"appropriate type."
msgstr ""

msgid "The condition is not well formed."
msgstr ""

msgid "The names of source , target or id are the same."
msgstr ""

msgid "The SRID of the geometry could not be determined."
msgstr ""

msgid "The Vertices Table"
msgstr ""

msgid ""
"The vertices table can be created with :doc:`pgr_createVerticesTable "
"<pgr_createVerticesTable>` or :doc:`pgr_createTopology <pgr_createTopology>`"
msgstr ""

msgid "The structure of the vertices table is:"
msgstr ""

msgid "``bigint`` Identifier of the vertex."
msgstr ""

msgid "cnt"
msgstr ""

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex."
msgstr ""

msgid "chk"
msgstr ""

msgid "``integer`` Indicator that the vertex might have a problem."
msgstr ""

msgid "ein"
msgstr ""

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"as incoming. See :doc:`pgr_analyzeOneWay <pgr_analyzeOneWay>`."
msgstr ""

msgid "eout"
msgstr ""

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"as outgoing. See :doc:`pgr_analyzeOneWay <pgr_analyzeOneWay>`."
msgstr ""

msgid "``geometry`` Point geometry of the vertex."
msgstr ""

msgid "Usage when the edge table's columns MATCH the default values:"
msgstr ""

msgid "The simplest way to use pgr_analyzeGraph is:"
msgstr ""

msgid "Arguments are given in the order described in the parameters:"
msgstr ""

msgid "We get the same result as the simplest way to use the function."
msgstr ""

msgid "An error would occur when"
msgstr ""

msgid "the arguments are not given in the appropriate order:"
msgstr ""

msgid ""
"In this example, the column ``id`` of the table ``mytable`` is passed to the "
"function as the geometry column, and the geometry column ``the_geom`` is "
"passed to the function as the id column."
msgstr ""

msgid "When using the named notation"
msgstr ""

msgid "The order of the parameters do not matter:"
msgstr ""

msgid ""
"Parameters defined with a default value can be omitted, as long as the value "
"matches the default:"
msgstr ""

msgid "Selecting rows using rows_where parameter"
msgstr ""

msgid ""
"Selecting rows based on the id. Displays the analysis a the section of the "
"network."
msgstr ""

msgid ""
"Selecting the rows where the geometry is near the geometry of row with "
"``id`` = 5"
msgstr ""

msgid ""
"Selecting the rows where the geometry is near the geometry of the row with "
"``gid`` =100 of the table ``othertable``."
msgstr ""

msgid "Usage when the edge table's columns DO NOT MATCH the default values:"
msgstr ""

msgid "For the following table"
msgstr ""

msgid "Using positional notation:"
msgstr ""

msgid ""
"The arguments need to be given in the order described in the parameters:"
msgstr ""

msgid ""
"An error would occur when the arguments are not given in the appropriate "
"order: In this example, the column ``gid`` of the table ``mytable`` is "
"passed to the function as the geometry column, and the geometry column "
"``mygeom`` is passed to the function as the id column."
msgstr ""

msgid ""
"In this scenario omitting a parameter would create an error because the "
"default values for the column names do not match the column names of the "
"table."
msgstr ""

msgid "Selecting rows based on the id."
msgstr ""

msgid ""
"Selecting the rows WHERE the geometry is near the geometry of row with "
"``id`` =5 ."
msgstr ""

msgid ""
"Selecting the rows WHERE the geometry is near the place='myhouse' of the "
"table ``othertable``. (note the use of quote_literal)"
msgstr ""

msgid "The examples use the :doc:`sampledata` network."
msgstr ""

msgid ":doc:`pgr_analyzeOneWay`"
msgstr ""

msgid ":doc:`pgr_createVerticesTable`"
msgstr ""

msgid ":doc:`pgr_nodeNetwork` to create nodes to a not noded edge table."
msgstr ""

msgid "pgr_analyzeOneWay"
msgstr ""

msgid ""
"``pgr_analyzeOneWay`` — Analyzes oneway Sstreets and identifies flipped "
"segments."
msgstr ""

msgid ""
"This function analyzes oneway streets in a graph and identifies any flipped "
"segments."
msgstr ""

msgid ""
"The analyses of one way segments is pretty simple but can be a powerful "
"tools to identifying some the potential problems created by setting the "
"direction of a segment the wrong way. A node is a `source` if it has edges "
"the exit from that node and no edges enter that node. Conversely, a node is "
"a `sink` if all edges enter the node but none exit that node. For a `source` "
"type node it is logically impossible to exist because no vehicle can exit "
"the node if no vehicle and enter the node. Likewise, if you had a `sink` "
"node you would have an infinite number of vehicle piling up on this node "
"because you can enter it but not leave it."
msgstr ""

msgid ""
"So why do we care if the are not feasible? Well if the direction of an edge "
"was reversed by mistake we could generate exactly these conditions. Think "
"about a divided highway and on the north bound lane one segment got entered "
"wrong or maybe a sequence of multiple segments got entered wrong or maybe "
"this happened on a round-about. The result would be potentially a `source` "
"and/or a `sink` node."
msgstr ""

msgid ""
"So by counting the number of edges entering and exiting each node we can "
"identify both `source` and `sink` nodes so that you can look at those areas "
"of your network to make repairs and/or report the problem back to your data "
"vendor."
msgstr ""

msgid ""
"pgr_analyzeOneWay(**geom_table**, **s_in_rules**, **s_out_rules**, "
"**t_in_rules**, **t_out_rules**, [**options**])"
msgstr ""

msgid "**options:** ``[oneway, source, target, two_way_if_null]``"
msgstr ""

msgid "RETURNS ``TEXT``"
msgstr ""

msgid "s_in_rules"
msgstr ""

msgid "``text[]`` source node **in** rules"
msgstr ""

msgid "s_out_rules"
msgstr ""

msgid "``text[]`` source node **out** rules"
msgstr ""

msgid "t_in_rules"
msgstr ""

msgid "``text[]`` target node **in** rules"
msgstr ""

msgid "t_out_rules"
msgstr ""

msgid "``text[]`` target node **out** rules"
msgstr ""

msgid "oneway"
msgstr ""

msgid ""
"``text`` oneway column name name of the network table. Default value is "
"``oneway``."
msgstr ""

msgid "two_way_if_null"
msgstr ""

msgid ""
"``boolean`` flag to treat oneway NULL values as bi-directional. Default "
"value is ``true``."
msgstr ""

msgid ""
"It is strongly recommended to use the named notation. See :doc:"
"`pgr_createVerticesTable` or :doc:`pgr_createTopology` for examples."
msgstr ""

msgid ""
"Fills completely the ``ein`` and ``eout`` columns of the vertices table."
msgstr ""

msgid "The names of source , target or oneway are the same."
msgstr ""

msgid ""
"The rules are defined as an array of text strings that if match the "
"``oneway`` value would be counted as ``true`` for the source or target "
"**in** or **out** condition."
msgstr ""

msgid ""
"The vertices table can be created with :doc:`pgr_createVerticesTable` or :"
"doc:`pgr_createTopology`"
msgstr ""

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex. "
"See :doc:`pgr_analyzeGgraph <pgr_analyzeGraph>`."
msgstr ""

msgid ""
"``integer`` Indicator that the vertex might have a problem. See :doc:"
"`pgr_analyzeGraph <pgr_analyzeGraph>`."
msgstr ""

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"as incoming."
msgstr ""

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"as outgoing."
msgstr ""

msgid ":doc:`pgr_analyzeGraph`"
msgstr ""

msgid "``pgr_articulationPoints``"
msgstr ""

msgid ""
"``pgr_articulationPoints`` - Return the articulation points of an undirected "
"graph."
msgstr ""

msgid "Result columns change: ``seq`` is removed"
msgstr ""

msgid "Version 2.5.0"
msgstr ""

msgid "New **experimental** function"
msgstr ""

msgid ""
"Those vertices that belong to more than one biconnected component are called "
"articulation points or, equivalently, cut vertices. Articulation points are "
"vertices whose removal would increase the number of connected components in "
"the graph. This implementation can only be used with an undirected graph."
msgstr ""

msgid "Works for **undirected** graphs."
msgstr ""

msgid "``node`` ascending"
msgstr ""

msgid "Running time: :math:`O(V + E)`"
msgstr ""

msgid "pgr_articulationPoints(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-node|"
msgstr ""

msgid "The articulation points of the graph"
msgstr ""

msgid "Nodes in red are the articulation points."
msgstr ""

msgid ""
"Boost: `Biconnected components & articulation points <https://www.boost.org/"
"libs/graph/doc/biconnected_components.html>`__"
msgstr ""

msgid ""
"wikipedia: `Biconnected component <https://en.wikipedia.org/wiki/"
"Biconnected_component>`__"
msgstr ""

msgid "``pgr_bdAstar``"
msgstr ""

msgid "``pgr_bdAstar`` — Shortest path using the bidirectional A* algorithm."
msgstr ""

msgid ""
"``pgr_bdAstar`` (`One to One`_) added ``start_vid`` and ``end_vid`` columns."
msgstr ""

msgid "``pgr_bdAstar`` (`One to Many`_) added ``end_vid`` column."
msgstr ""

msgid "``pgr_bdAstar`` (`Many to One`_) added ``start_vid`` column."
msgstr ""

msgid "``pgr_bdAstar`` (`Combinations`_)"
msgstr ""

msgid "``pgr_bdAstar`` (`One to Many`_)"
msgstr ""

msgid "``pgr_bdAstar`` (`Many to One`_)"
msgstr ""

msgid "``pgr_bdAstar`` (`Many to Many`_)"
msgstr ""

msgid "Signature change on ``pgr_bdAstar`` (`One to One`_)"
msgstr ""

msgid "**Official** ``pgr_bdAstar`` (`One to One`_)"
msgstr ""

msgid ""
"The results are equivalent to the union of the results of the `pgr_bdAStar(` "
"`One to One`_ `)` on the:"
msgstr ""

msgid "pgr_bdAstar(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_bdAstar(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_bdAstar(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""

msgid "pgr_bdAstar(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_bdAstar(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr ""

msgid "pgr_bdAstarCost"
msgstr ""

msgid ""
"``pgr_bdAstarCost`` - Total cost of the shortest path(s) using the "
"bidirectional A* algorithm."
msgstr ""

msgid "``pgr_bdAstarCost`` (`Combinations`_)"
msgstr ""

msgid ""
"The ``pgr_bdAstarCost`` function sumarizes of the cost of the shortest "
"path(s) using the bidirectional A* algorithm."
msgstr ""

msgid ""
"pgr_bdAstarCost(`Edges SQL`_, **start vid**, **end vid**, [**options**])"
msgstr ""

msgid ""
"pgr_bdAstarCost(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""

msgid ""
"pgr_bdAstarCost(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""

msgid ""
"pgr_bdAstarCost(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr ""

msgid "pgr_bdAstarCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr ""

msgid "``pgr_bdAstarCostMatrix``"
msgstr ""

msgid ""
"``pgr_bdAstarCostMatrix`` - Calculates the a cost matrix using :doc:"
"`pgr_aStar`."
msgstr ""

msgid "Using internaly the :doc:`pgr_bdAstar` algorithm"
msgstr ""

msgid "pgr_bdAstarCostMatrix(`Edges SQL`_, **start vids**, [**options**])"
msgstr ""

msgid "``pgr_bdDijkstra``"
msgstr ""

msgid ""
"``pgr_bdDijkstra`` — Returns the shortest path(s) using Bidirectional "
"Dijkstra algorithm."
msgstr ""

msgid "pgr_bdDijkstra(`Combinations`_)"
msgstr ""

msgid "New **Proposed** functions:"
msgstr ""

msgid "``pgr_bdDijkstra`` (`One to Many`_)"
msgstr ""

msgid "``pgr_bdDijkstra`` (`Many to One`_)"
msgstr ""

msgid "``pgr_bdDijkstra`` (`Many to Many`_)"
msgstr ""

msgid "Signature change on ``pgr_bdDijsktra`` (`One to One`_)"
msgstr ""

msgid "**Official** ``pgr_bdDijkstra`` (`One to One`_)"
msgstr ""

msgid ""
"pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""

msgid ""
"pgr_bdDijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""

msgid ""
"pgr_bdDijkstra(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""

msgid ""
"pgr_bdDijkstra(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr ""

msgid "pgr_bdDijkstra(`Edges SQL`_, `Combinations SQL`_ , [``directed``])"
msgstr ""

msgid "Returns set of |old-generic-result|"
msgstr ""

msgid "Returns set of |result-1-1|"
msgstr ""

msgid "From vertex :math:`6` to vertex :math:`10` on a **directed** graph"
msgstr ""

msgid "Returns set of |result-1-m|"
msgstr ""

msgid ""
"From vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a **directed** "
"graph"
msgstr ""

msgid "Returns set of |result-m-1|"
msgstr ""

msgid ""
"From vertices :math:`\\{6, 1\\}` to vertex :math:`17` on a **directed** graph"
msgstr ""

msgid ""
"From vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 17\\}` on an "
"**undirected** graph"
msgstr ""

msgid "pgr_bdDijkstra(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

msgid "Using a combinations table on an **undirected** graph"
msgstr ""

msgid ""
"https://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/"
"EPP%20shortest%20path%20algorithms.pdf"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Bidirectional_search"
msgstr ""

msgid "``pgr_bdDijkstraCost``"
msgstr ""

msgid ""
"``pgr_bdDijkstraCost`` — Returns the shortest path(s)'s cost using "
"Bidirectional Dijkstra algorithm."
msgstr ""

msgid "``pgr_bdDijkstraCost`` (`Combinations`_)"
msgstr ""

msgid ""
"The ``pgr_bdDijkstraCost`` function sumarizes of the cost of the shortest "
"path using the bidirectional Dijkstra Algorithm."
msgstr ""

msgid ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vid**, **end vid** , [``directed``])"
msgstr ""

msgid ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""

msgid ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vids**, **end vid** , "
"[``directed``])"
msgstr ""

msgid ""
"pgr_bdDijkstraCost(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""

msgid "pgr_bdDijkstraCost(`Edges SQL`_, `Combinations SQL`_, [ ``directed``])"
msgstr ""

msgid "pgr_bdDijkstraCost(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

msgid "``pgr_bdDijkstraCostMatrix``"
msgstr ""

msgid ""
"``pgr_bdDijkstraCostMatrix`` - Calculates a cost matrix using :doc:"
"`pgr_bdDijkstra`."
msgstr ""

msgid ""
"Using bidirectional Dijkstra algorithm, calculate and return a cost matrix."
msgstr ""

msgid "pgr_bdDijkstraCostMatrix(`Edges SQL`_, **start vids**, [``directed``])"
msgstr ""

msgid ""
"Symmetric cost matrix for vertices :math:`\\{5, 6, 10, 15\\}` on an "
"**undirected** graph"
msgstr ""

msgid "Use with :doc:`pgr_TSP`."
msgstr ""

msgid "``pgr_bellmanFord - Experimental``"
msgstr ""

msgid "``pgr_bellmanFord`` — Shortest path(s) using Bellman-Ford algorithm."
msgstr ""

msgid "New **experimental** signature:"
msgstr ""

msgid "``pgr_bellmanFord`` (`Combinations`_)"
msgstr ""

msgid "New **experimental** signatures:"
msgstr ""

msgid "``pgr_bellmanFord`` (`One to One`_)"
msgstr ""

msgid "``pgr_bellmanFord`` (`One to Many`_)"
msgstr ""

msgid "``pgr_bellmanFord`` (`Many to One`_)"
msgstr ""

msgid "``pgr_bellmanFord`` (`Many to Many`_)"
msgstr ""

msgid ""
"Bellman-Ford's algorithm, is named after Richard Bellman and Lester Ford, "
"who first published it in 1958 and 1956, respectively.It is a graph search "
"algorithm that computes shortest paths from a starting vertex "
"(``start_vid``) to an ending vertex (``end_vid``) in a graph where some of "
"the edge weights may be negative. Though it is more versatile, it is slower "
"than Dijkstra's algorithm.This implementation can be used with a directed "
"graph and an undirected graph."
msgstr ""

msgid ""
"Process is valid for edges with both positive and negative edge weights."
msgstr ""

msgid ""
"When the start vertex and the end vertex are the same, there is no path. The "
"agg_cost would be :math:`0`."
msgstr ""

msgid ""
"When the start vertex and the end vertex are different, and there exists a "
"path between them without having a *negative cycle*. The agg_cost would be "
"some finite value denoting the shortest distance between them."
msgstr ""

msgid ""
"When the start vertex and the end vertex are different, and there exists a "
"path between them, but it contains a *negative cycle*. In such case, "
"agg_cost for those vertices keep on decreasing furthermore, Hence agg_cost "
"can’t be defined for them."
msgstr ""

msgid ""
"When the start vertex and the end vertex are different, and there is no "
"path. The agg_cost is :math:`\\infty`."
msgstr ""

msgid ""
"For optimization purposes, any duplicated value in the `start_vids` or "
"`end_vids` are ignored."
msgstr ""

msgid "Running time: :math:`O(| start\\_vids | * ( V * E))`"
msgstr ""

msgid ""
"pgr_bellmanFord(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""

msgid ""
"pgr_bellmanFord(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""

msgid ""
"pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""

msgid ""
"pgr_bellmanFord(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr ""

msgid "pgr_bellmanFord(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

msgid ""
"From vertex :math:`6` to vertices :math:`\\{ 10, 17\\}` on a **directed** "
"graph"
msgstr ""

msgid "Using a combinations table on an **undirected** graph."
msgstr ""

msgid "https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm"
msgstr ""

msgid "``pgr_biconnectedComponents``"
msgstr ""

msgid ""
"``pgr_biconnectedComponents`` — Biconnected components of an undirected "
"graph."
msgstr ""

msgid "Result columns change:"
msgstr ""

msgid "``n_seq`` is removed"
msgstr ""

msgid "``seq`` changed type to ``BIGINT``"
msgstr ""

msgid ""
"The biconnected components of an undirected graph are the maximal subsets of "
"vertices such that the removal of a vertex from particular component will "
"not disconnect the component. Unlike connected components, vertices may "
"belong to multiple biconnected components. Vertices can be present in "
"multiple biconnected components, but each edge can only be contained in a "
"single biconnected component."
msgstr ""

msgid "Components are described by edges."
msgstr ""

msgid "``component`` ascending."
msgstr ""

msgid "``edge`` ascending."
msgstr ""

msgid "pgr_biconnectedComponents(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-component-E|"
msgstr ""

msgid "The biconnected components of the graph"
msgstr ""

msgid "``component``"
msgstr ""

msgid "Component identifier."
msgstr ""

msgid "Has the value of the minimum edge identifier in the component."
msgstr ""

msgid "Identifier of the edge that belongs to the ``component``."
msgstr ""

msgid ""
"Boost: `Biconnected components <https://www.boost.org/libs/graph/doc/"
"biconnected_components.html>`__"
msgstr ""

msgid "``pgr_binaryBreadthFirstSearch`` - Experimental"
msgstr ""

msgid ""
"``pgr_binaryBreadthFirstSearch`` — Returns the shortest path(s) in a binary "
"graph."
msgstr ""

msgid ""
"Any graph whose edge-weights belongs to the set {0,X}, where 'X' is any non-"
"negative integer, is termed as a 'binary graph'."
msgstr ""

msgid "pgr_binaryBreadthFirstSearch(`Combinations`_)"
msgstr ""

msgid "pgr_binaryBreadthFirstSearch(`One to One`_)"
msgstr ""

msgid "pgr_binaryBreadthFirstSearch(`One to Many`_)"
msgstr ""

msgid "pgr_binaryBreadthFirstSearch(`Many to One`_)"
msgstr ""

msgid "pgr_binaryBreadthFirstSearch(`Many to Many`_)"
msgstr ""

msgid ""
"It is well-known that the shortest paths between a single source and all "
"other vertices can be found using Breadth First Search in :math:`O(|E|)` in "
"an unweighted graph, i.e. the distance is the minimal number of edges that "
"you need to traverse from the source to another vertex. We can interpret "
"such a graph also as a weighted graph, where every edge has the weight :math:"
"`1`. If not alledges in graph have the same weight, that we need a more "
"general algorithm, like Dijkstra's Algorithm which runs in :math:`O(|E|log|"
"V|)` time."
msgstr ""

msgid ""
"However if the weights are more constrained, we can use a faster algorithm. "
"This algorithm, termed as 'Binary Breadth First Search' as well as '0-1 "
"BFS', is a variation of the standard Breadth First Search problem to solve "
"the SSSP (single-source shortest path) problem in :math:`O(|E|)`, if the "
"weights of each edge belongs to the set {0,X}, where 'X' is any non-negative "
"real integer."
msgstr ""

msgid ""
"Process is done only on 'binary graphs'. ('Binary Graph': Any graph whose "
"edge-weights belongs to the set {0,X}, where 'X' is any non-negative real "
"integer.)"
msgstr ""

msgid "Running time: :math:`O(| start\\_vids | * |E|)`"
msgstr ""

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vid**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vid**, **end vids**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vids**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_binaryBreadthFirstSearch(`Edges SQL`_, `Combinations SQL`_, "
"[``directed``])"
msgstr ""

msgid ""
"**Note:** Using the :doc:`sampledata` Network as all weights are same (i.e :"
"math:`1``)"
msgstr ""

msgid "https://cp-algorithms.com/graph/01_bfs.html"
msgstr ""

msgid ""
"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Specialized_variants"
msgstr ""

msgid "pgr_bipartite -Experimental"
msgstr ""

msgid ""
"``pgr_bipartite`` — Disjoint sets of vertices such that no two vertices "
"within the same set are adjacent."
msgstr ""

msgid "New **experimental** signature"
msgstr ""

msgid ""
"A bipartite graph is a graph with two sets of vertices which are connected "
"to each other, but not within themselves. A bipartite graph is possible if "
"the graph coloring is possible using two colors such that vertices in a set "
"are colored with the same color."
msgstr ""

msgid "The algorithm works in undirected graph only."
msgstr ""

msgid "The returned values are not ordered."
msgstr ""

msgid ""
"The algorithm checks graph is bipartite or not. If it is bipartite then it "
"returns the node along with two colors `0` and `1` which represents two "
"different sets."
msgstr ""

msgid "If graph is not bipartite then algorithm returns empty set."
msgstr ""

msgid "pgr_bipartite(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-node-color|"
msgstr ""

msgid "When the graph is bipartite"
msgstr ""

msgid "Additional Example"
msgstr ""

msgid "The odd length cyclic graph can not be bipartite."
msgstr ""

msgid ""
"The edge :math:`5 \\rightarrow 1` will make subgraph with vertices :math:"
"`\\{1, 3, 7, 6, 5\\}` an odd length cyclic graph, as the cycle has 5 "
"vertices."
msgstr ""

msgid "Edges in blue represent odd length cycle subgraph."
msgstr ""

msgid "``pgr_boykovKolmogorov``"
msgstr ""

msgid ""
"``pgr_boykovKolmogorov`` — Calculates the flow on the graph edges that "
"maximizes the flow from the sources to the targets using Boykov Kolmogorov "
"algorithm."
msgstr ""

msgid "New **proposed** signature"
msgstr ""

msgid "``pgr_boykovKolmogorov`` (`Combinations`_)"
msgstr ""

msgid "Renamed from ``pgr_maxFlowBoykovKolmogorov``"
msgstr ""

msgid "**Proposed** function"
msgstr ""

msgid "New **Experimental** function"
msgstr ""

msgid "Running time: Polynomial"
msgstr ""

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_boykovKolmogorov(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_boykovKolmogorov(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "Returns set of |result-flow|"
msgstr ""

msgid "From vertex :math:`11` to vertex :math:`12`"
msgstr ""

msgid "From vertex :math:`11` to vertices :math:`\\{5, 10, 12\\}`"
msgstr ""

msgid "From vertices :math:`\\{11, 3, 17\\}` to vertex :math:`12`"
msgstr ""

msgid ""
"From vertices :math:`\\{11, 3, 17\\}` to vertices :math:`\\{5, 10, 12\\}`"
msgstr ""

msgid ""
"Using a combinations table, equivalent to calculating result from vertices :"
"math:`\\{5, 6\\}` to vertices :math:`\\{10, 15, 14\\}`."
msgstr ""

msgid "https://www.boost.org/libs/graph/doc/boykov_kolmogorov_max_flow.html"
msgstr ""

msgid "``pgr_breadthFirstSearch`` - Experimental"
msgstr ""

msgid ""
"``pgr_breadthFirstSearch`` — Returns the traversal order(s) using Breadth "
"First Search algorithm."
msgstr ""

msgid "``pgr_breadthFirstSearch`` (`Single Vertex`_)"
msgstr ""

msgid "``pgr_breadthFirstSearch`` (`Multiple Vertices`_)"
msgstr ""

msgid ""
"Provides the Breadth First Search traversal order from a root vertex to a "
"particular depth."
msgstr ""

msgid "The implementation will work on any type of graph."
msgstr ""

msgid ""
"Provides the Breadth First Search traversal order from a source node to a "
"target depth level."
msgstr ""

msgid "Running time: :math:`O(E + V)`"
msgstr ""

msgid "pgr_breadthFirstSearch(`Edges SQL`_, **root vid**, [**options**])"
msgstr ""

msgid "pgr_breadthFirstSearch(`Edges SQL`_, **root vids**, [**options**])"
msgstr ""

msgid "**options:** ``[max_depth, directed]``"
msgstr ""

msgid "Returns set of |result-bfs|"
msgstr ""

msgid ""
"From root vertex :math:`6` on a **directed** graph with edges in ascending "
"order of ``id``"
msgstr ""

msgid ""
"From root vertices :math:`\\{12, 6\\}` on an **undirected** graph with "
"**depth** :math:`<= 2` and edges in ascending order of ``id``"
msgstr ""

msgid "DFS optional parameters"
msgstr ""

msgid "Same as `Single vertex`_ with edges in ascending order of ``id``."
msgstr ""

msgid "Same as `Single vertex`_ with edges in descending order of ``id``."
msgstr ""

msgid "The resulting traversal is different."
msgstr ""

msgid ""
"The left image shows the result with ascending order of ids and the right "
"image shows with descending order of the edge identifiers."
msgstr ""

msgid "|ascending| |descending|"
msgstr ""

msgid "ascending"
msgstr ""

msgid "descending"
msgstr ""

msgid ""
"`Boost: Breadth First Search algorithm documentation <https://www.boost.org/"
"libs/graph/doc/breadth_first_search.html>`__"
msgstr ""

msgid ""
"`Wikipedia: Breadth First Search algorithm <https://en.wikipedia.org/wiki/"
"Breadth-first_search>`__"
msgstr ""

msgid "``pgr_bridges``"
msgstr ""

msgid "``pgr_bridges`` - Return the bridges of an undirected graph."
msgstr ""

msgid ""
"A bridge is an edge of an undirected graph whose deletion increases its "
"number of connected components. This implementation can only be used with an "
"undirected graph."
msgstr ""

msgid "``edge`` ascending"
msgstr ""

msgid "Running time: :math:`O(E * (V + E))`"
msgstr ""

msgid "pgr_bridges(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-edge|"
msgstr ""

msgid "The bridges of the graph"
msgstr ""

msgid "Identifier of the edge that is a bridge."
msgstr ""

msgid "https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29"
msgstr ""

msgid "**Supported versions**"
msgstr ""

msgid "``pgr_chinesePostman`` - Experimental"
msgstr ""

msgid ""
"``pgr_chinesePostman`` — Calculates the shortest circuit path which contains "
"every edge in a directed graph and starts and ends on the same vertex."
msgstr ""

msgid "Returns ``EMPTY SET`` on a disconnected graph"
msgstr ""

msgid "pgr_chinesePostman(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-1-1-no-seq|"
msgstr ""

msgid "Returns set of ``(seq, node, edge, cost, agg_cost)``"
msgstr ""

msgid "Sequential value starting from ``1``"
msgstr ""

msgid ""
"Identifier of the edge used to go from ``node`` to the next node in the path "
"sequence. ``-1`` for the last node of the path."
msgstr ""

msgid "Aggregate cost from ``start_v`` to ``node``."
msgstr ""

msgid "``pgr_chinesePostmanCost`` - Experimental"
msgstr ""

msgid ""
"``pgr_chinesePostmanCost`` — Calculates the minimum costs of a circuit path "
"which contains every edge in a directed graph and starts and ends on the "
"same vertex."
msgstr ""

msgid "Return value when the graph if disconnected"
msgstr ""

msgid "pgr_chinesePostmanCost(`Edges SQL`_)"
msgstr ""

msgid "RETURNS ``FLOAT``"
msgstr ""

msgid "``pgr_chinesepostmancost``"
msgstr ""

msgid "Minimum costs of a circuit path."
msgstr ""

msgid "pgr_connectedComponents"
msgstr ""

msgid ""
"``pgr_connectedComponents`` — Connected components of an undirected graph "
"using a DFS-based approach."
msgstr ""

msgid ""
"A connected component of an undirected graph is a set of vertices that are "
"all reachable from each other."
msgstr ""

msgid "Components are described by vertices"
msgstr ""

msgid "``component`` ascending"
msgstr ""

msgid "pgr_connectedComponents(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-component-V|"
msgstr ""

msgid "The connected components of the graph"
msgstr ""

msgid "Has the value of the minimum node identifier in the component."
msgstr ""

msgid "Identifier of the vertex that belongs to the ``component``."
msgstr ""

msgid "Connecting disconnected components"
msgstr ""

msgid ""
"Boost: `Connected components <https://www.boost.org/libs/graph/doc/"
"connected_components.html>`__"
msgstr ""

msgid ""
"wikipedia: `Connected component <https://en.wikipedia.org/wiki/"
"Connected_component_(graph_theory)>`__"
msgstr ""

msgid "``pgr_contraction``"
msgstr ""

msgid ""
"``pgr_contraction`` — Performs graph contraction and returns the contracted "
"vertices and edges."
msgstr ""

msgid "Name change from ``pgr_contractGraph``"
msgstr ""

msgid "Bug fixes"
msgstr ""

msgid ""
"Contraction reduces the size of the graph by removing some of the vertices "
"and edges and, for example, might add edges that represent a sequence of "
"original edges decreasing the total time and space used in graph algorithms."
msgstr ""

msgid "Does not return the full contracted graph"
msgstr ""

msgid "Only changes on the graph are returned"
msgstr ""

msgid "Currnetly there are two types of contraction methods"
msgstr ""

msgid "Dead End Contraction"
msgstr ""

msgid "Linear Contraction"
msgstr ""

msgid "The returned values include"
msgstr ""

msgid "the added edges by linear contraction."
msgstr ""

msgid "the modified vertices by dead end contraction."
msgstr ""

msgid "The returned values are ordered as follows:"
msgstr ""

msgid "column ``id`` ascending when type is ``v``"
msgstr ""

msgid "column ``id`` descending when type is ``e``"
msgstr ""

msgid "The pgr_contraction function has the following signature:"
msgstr ""

msgid "pgr_contraction(`Edges SQL`_, **contraction order**, [**options**])"
msgstr ""

msgid "**options:** ``[ max_cycles, forbidden_vertices, directed]``"
msgstr ""

msgid "Returns set of |result-contract|"
msgstr ""

msgid ""
"Making a dead end and linear contraction in that order on an undirected "
"graph."
msgstr ""

msgid "**contraction Order**"
msgstr ""

msgid "Ordered contraction operations."
msgstr ""

msgid "1 = Dead end contraction"
msgstr ""

msgid "2 = Linear contraction"
msgstr ""

msgid "Contraction optional parameters"
msgstr ""

msgid "``forbidden_vertices``"
msgstr ""

msgid "**Empty**"
msgstr ""

msgid "Identifiers of vertices forbidden for contraction."
msgstr ""

msgid ":math:`1`"
msgstr ""

msgid ""
"Number of times the contraction operations on ``contraction_order`` will be "
"performed."
msgstr ""

msgid "The function returns a single row. The columns of the row are:"
msgstr ""

msgid "``type``"
msgstr ""

msgid "Type of the ``id``."
msgstr ""

msgid "``v`` when the row is a vertex."
msgstr ""

msgid "Column ``id`` has a positive value"
msgstr ""

msgid "``e`` when the row is an edge."
msgstr ""

msgid "Column ``id`` has a negative value"
msgstr ""

msgid "All numbers on this column are ``DISTINCT``"
msgstr ""

msgid "When ``type`` = **'v'**."
msgstr ""

msgid "Identifier of the modified vertex."
msgstr ""

msgid "When ``type`` = **'e'**."
msgstr ""

msgid "Decreasing sequence starting from **-1**."
msgstr ""

msgid ""
"Representing a pseudo `id` as is not incorporated in the set of original "
"edges."
msgstr ""

msgid "Array of contracted vertex identifiers."
msgstr ""

msgid "When ``type`` = **'v'**: :math:`-1`"
msgstr ""

msgid ""
"When ``type`` = **'e'**: Identifier of the source vertex of the current edge "
"(``source``, ``target``)."
msgstr ""

msgid ""
"When ``type`` = **'e'**: Identifier of the target vertex of the current edge "
"(``source``, ``target``)."
msgstr ""

msgid ""
"When ``type`` = **'e'**: Weight of the current edge (``source``, ``target``)."
msgstr ""

msgid "Only dead end contraction"
msgstr ""

msgid "Only linear contraction"
msgstr ""

msgid "pgr_createTopology"
msgstr ""

msgid ""
"``pgr_createTopology`` — Builds a network topology based on the geometry "
"information."
msgstr ""

msgid ""
"``OK`` after the network topology has been built and the vertices table "
"created."
msgstr ""

msgid "``FAIL`` when the network topology was not built due to an error."
msgstr ""

msgid "pgr_createTopology(edge_table, tolerance, [**options**])"
msgstr ""

msgid "**options:** ``[the_geom, id, source, target, rows_where, clean]``"
msgstr ""

msgid "The topology creation function accepts the following parameters:"
msgstr ""

msgid ""
"``text`` Condition to SELECT a subset or rows. Default value is ``true`` to "
"indicate all rows that where ``source`` or ``target`` have a null value, "
"otherwise the condition is used."
msgstr ""

msgid "clean"
msgstr ""

msgid "``boolean`` Clean any previous topology. Default value is ``false``."
msgstr ""

msgid "The ``edge_table`` will be affected"
msgstr ""

msgid "The ``source`` column values will change."
msgstr ""

msgid "The ``target`` column values will change."
msgstr ""

msgid ""
"An index will be created, if it doesn't exists, to speed up the process to "
"the following columns:"
msgstr ""

msgid "``the_geom``"
msgstr ""

msgid "``OK`` after the network topology has been built."
msgstr ""

msgid "Creates a vertices table: <edge_table>_vertices_pgr."
msgstr ""

msgid "Fills ``id`` and ``the_geom`` columns of the vertices table."
msgstr ""

msgid ""
"Fills the source and target columns of the edge table referencing the ``id`` "
"of the vertices table."
msgstr ""

msgid "``FAIL`` when the network topology was not built due to an error:"
msgstr ""

msgid ""
"The vertices table is a requirement of the :doc:`pgr_analyzeGraph` and the :"
"doc:`pgr_analyzeOneWay` functions."
msgstr ""

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex. "
"See :doc:`pgr_analyzeGraph`."
msgstr ""

msgid ""
"``integer`` Indicator that the vertex might have a problem. See :doc:"
"`pgr_analyzeGraph`."
msgstr ""

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"AS incoming. See :doc:`pgr_analyzeOneWay`."
msgstr ""

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"AS outgoing. See :doc:`pgr_analyzeOneWay`."
msgstr ""

msgid "The simplest way to use pgr_createTopology is:"
msgstr ""

msgid "When the arguments are given in the order described in the parameters:"
msgstr ""

msgid "We get the sameresult as the simplest way to use the function."
msgstr ""

msgid ""
"An error would occur when the arguments are not given in the appropriate "
"order: In this example, the column ``id`` of the table ``ege_table`` is "
"passed to the function as the geometry column, and the geometry column "
"``the_geom`` is passed to the function as the id column."
msgstr ""

msgid ""
"Parameters defined with a default value can be omitted, as long as the value "
"matches the default And The order of the parameters would not matter."
msgstr ""

msgid ""
"Selecting the rows where the geometry is near the geometry of row with ``id "
"= 5``."
msgstr ""

msgid ""
"The arguments need to be given in the order described in the parameters."
msgstr ""

msgid ""
"Note that this example uses clean flag. So it recreates the whole vertices "
"table."
msgstr ""

msgid ""
"An error would occur when the arguments are not given in the appropiriate "
"order: In this example, the column ``gid`` of the table ``mytable`` is "
"passed to the function AS the geometry column, and the geometry column "
"``mygeom`` is passed to the function AS the id column."
msgstr ""

msgid ""
"In this scenario omitting a parameter would create an error because the "
"default values for the column names do not match the column names of the "
"table. The order of the parameters do not matter:"
msgstr ""

msgid "Based on id:"
msgstr ""

msgid "Create a routing topology"
msgstr ""

msgid ""
"An alternate method to create a routing topology use :doc:"
"`pgr_extractVertices`"
msgstr ""

msgid "Make sure the database does not have the ``vertices_table``"
msgstr ""

msgid "Clean up the columns of the routing topology to be created"
msgstr ""

msgid "Create the vertices table"
msgstr ""

msgid ""
"When the ``LINESTRING`` has a SRID then use ``geom::geometry(POINT, <SRID>)``"
msgstr ""

msgid "For big edge tables that are been prepared,"
msgstr ""

msgid "Create it as ``UNLOGGED`` and"
msgstr ""

msgid "After the table is created ``ALTER TABLE .. SET LOGGED``"
msgstr ""

msgid "Inspect the vertices table"
msgstr ""

msgid "Create the routing topology on the edge table"
msgstr ""

msgid "Updating the ``source`` information"
msgstr ""

msgid "Updating the ``target`` information"
msgstr ""

msgid "Inspect the routing topology"
msgstr ""

msgid "**Generated topology**"
msgstr ""

msgid "With full output"
msgstr ""

msgid ""
"This example start a clean topology, with 5 edges, and then its incremented "
"to the rest of the edges."
msgstr ""

msgid "The example uses the :doc:`sampledata` network."
msgstr ""

msgid "pgr_createVerticesTable"
msgstr ""

msgid ""
"``pgr_createVerticesTable`` — Reconstructs the vertices table based on the "
"source and target information."
msgstr ""

msgid "``OK`` after the vertices table has been reconstructed."
msgstr ""

msgid "``FAIL`` when the vertices table was not reconstructed due to an error."
msgstr ""

msgid ""
"pgr_createVerticesTable(edge_table, [``the_geom, source, target, "
"rows_where``])"
msgstr ""

msgid ""
"The reconstruction of the vertices table function accepts the following "
"parameters:"
msgstr ""

msgid ""
"``text`` Condition to SELECT a subset or rows. Default value is ``true`` to "
"indicate all rows."
msgstr ""

msgid ""
"Fills ``id`` and ``the_geom`` columns of the vertices table based on the "
"source and target columns of the edge table."
msgstr ""

msgid "The names of source, target are the same."
msgstr ""

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"as incoming. See :doc:`pgr_analyzeOneWay`."
msgstr ""

msgid ""
"``integer`` Number of vertices in the edge_table that reference this vertex "
"as outgoing. See :doc:`pgr_analyzeOneWay`."
msgstr ""

msgid "The simplest way to use pgr_createVerticesTable"
msgstr ""

msgid ""
"An error would occur when the arguments are not given in the appropriate "
"order: In this example, the column source column ``source`` of the table "
"``mytable`` is passed to the function as the geometry column, and the "
"geometry column ``the_geom`` is passed to the function as the source column."
msgstr ""

msgid "Example 4"
msgstr ""

msgid "Using a different ordering"
msgstr ""

msgid "Example 5"
msgstr ""

msgid "Example 6"
msgstr ""

msgid "Example 7"
msgstr ""

msgid ""
"Selecting the rows where the geometry is near the geometry of row with "
"``id`` =5 ."
msgstr ""

msgid "Example 8"
msgstr ""

msgid "Using the following table"
msgstr ""

msgid "Example 9"
msgstr ""

msgid ""
"An error would occur when the arguments are not given in the appropriate "
"order: In this example, the column ``src`` of the table ``mytable`` is "
"passed to the function as the geometry column, and the geometry column "
"``mygeom`` is passed to the function as the source column."
msgstr ""

msgid "Example 10"
msgstr ""

msgid "Example 11"
msgstr ""

msgid "Example 12"
msgstr ""

msgid "Selecting rows based on the gid. (positional notation)"
msgstr ""

msgid "Example 13"
msgstr ""

msgid "Selecting rows based on the gid. (named notation)"
msgstr ""

msgid "Example 14"
msgstr ""

msgid ""
"Selecting the rows where the geometry is near the geometry of row with "
"``gid`` = 5."
msgstr ""

msgid "Example 15"
msgstr ""

msgid "TBD"
msgstr ""

msgid "Example 16"
msgstr ""

msgid "Example 17"
msgstr ""

msgid ""
":doc:`topology-functions` for an overview of a topology for routing "
"algorithms."
msgstr ""

msgid ""
":doc:`pgr_createTopology` <pgr_create_topology>` to create a topology based "
"on the geometry."
msgstr ""

msgid ""
":doc:`pgr_analyzeGraph` to analyze the edges and vertices of the edge table."
msgstr ""

msgid ":doc:`pgr_analyzeOneWay` to analyze directionality of the edges."
msgstr ""

msgid "``pgr_cuthillMckeeOrdering`` - Experimental"
msgstr ""

msgid ""
"``pgr_cuthillMckeeOrdering`` — Returns the reverse Cuthill-Mckee ordering of "
"an undirected graphs"
msgstr ""

msgid "Version 3.4.0"
msgstr ""

msgid ""
"In numerical linear algebra, the Cuthill-McKee algorithm (CM), named after "
"Elizabeth Cuthill and James McKee, is an algorithm to permute a sparse "
"matrix that has a symmetric sparsity pattern into a band matrix form with a "
"small bandwidth."
msgstr ""

msgid ""
"The vertices are basically assigned a breadth-first search order, except "
"that at each step, the adjacent vertices are placed in the queue in order of "
"increasing degree."
msgstr ""

msgid "The implementation is for **undirected** graphs."
msgstr ""

msgid ""
"The bandwidth minimization problems are considered NP-complete problems."
msgstr ""

msgid "The running time complexity is: :math:`O(m log(m)|V|)`"
msgstr ""

msgid "where :math:`|V|` is the number of vertices,"
msgstr ""

msgid ":math:`m` is the maximum degree of the vertices in the graph."
msgstr ""

msgid "pgr_cuthillMckeeOrdering(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-node-order|"
msgstr ""

msgid "Graph ordering of pgRouting :doc:`sampledata`"
msgstr ""

msgid "Returns set of ``(seq, node)``"
msgstr ""

msgid "Sequence of the order starting from 1."
msgstr ""

msgid "New ordering in reverse order."
msgstr ""

msgid ""
"`Boost: Cuthill-McKee Ordering <https://www.boost.org/libs/graph/doc/"
"cuthill_mckee_ordering.html>`__"
msgstr ""

msgid ""
"`Wikipedia: Cuthill-McKee Ordering <https://en.wikipedia.org/wiki/"
"Cuthill%E2%80%93McKee_algorithm>`__"
msgstr ""

msgid "pgr_dagShortestPath - Experimental"
msgstr ""

msgid ""
"``pgr_dagShortestPath`` — Returns the shortest path(s) for weighted directed "
"acyclic graphs(DAG). In particular, the DAG shortest paths algorithm "
"implemented by Boost.Graph."
msgstr ""

msgid "New **experimental** function:"
msgstr ""

msgid "pgr_dagShortestPath(Combinations)"
msgstr ""

msgid ""
"Shortest Path for Directed Acyclic Graph(DAG) is a graph search algorithm "
"that solves the shortest path problem for weighted directed acyclic graph, "
"producing a shortest path from a starting vertex (``start_vid``) to an "
"ending vertex (``end_vid``)."
msgstr ""

msgid ""
"This implementation can only be used with a **directed** graph with no "
"cycles i.e. directed acyclic graph."
msgstr ""

msgid ""
"The algorithm relies on topological sorting the dag to impose a linear "
"ordering on the vertices, and thus is more efficient for DAG's than either "
"the Dijkstra or Bellman-Ford algorithm."
msgstr ""

msgid ""
"Process is valid for weighted directed acyclic graphs only. otherwise it "
"will throw warnings."
msgstr ""

msgid "The `agg_cost` the non included values `(v, v)` is `0`"
msgstr ""

msgid "The `agg_cost` the non included values `(u, v)` is :math:`\\infty`"
msgstr ""

msgid "Running time: :math:`O(| start\\_vids | * (V + E))`"
msgstr ""

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_dagShortestPath(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_dagShortestPath(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "From vertex :math:`5` to vertex :math:`11` on a **directed** graph"
msgstr ""

msgid "From vertex :math:`5` to vertices :math:`\\{7, 11\\}`"
msgstr ""

msgid "From vertices :math:`\\{5, 10\\}` to vertex :math:`11`"
msgstr ""

msgid ""
"From vertices :math:`\\{5, 15\\}` to vertices :math:`\\{11, 17\\}` on an "
"**undirected** graph"
msgstr ""

msgid "Return columns"
msgstr ""

msgid "Making **start_vids** the same as **end_vids**"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Topological_sorting"
msgstr ""

msgid "``pgr_degree`` -- Proposed"
msgstr ""

msgid ""
"``pgr_degree`` — For each vertex in an undirected graph, return the count of "
"edges incident to the vertex."
msgstr ""

msgid "Calculates the degree of the vertices of an **undirected** graph"
msgstr ""

msgid "pgr_degree(`Edges SQL`_ , `Vertex SQL`_, [``dryrun``])"
msgstr ""

msgid "RETURNS SETOF |result-degree|"
msgstr ""

msgid "Extracting the vertex information"
msgstr ""

msgid ""
"pgr_degree can utilize output from `pgr_extractVertices` or can have "
"`pgr_extractVertices` embedded in the call. For decent size networks, it is "
"best to prep your vertices table before hand and use that vertices table for "
"pgr_degree calls."
msgstr ""

msgid "`Vertex SQL`_"
msgstr ""

msgid "`Vertex SQL`_ as described below"
msgstr ""

msgid "``dryrun``"
msgstr ""

msgid "When true do not process and get in a NOTICE the resulting query."
msgstr ""

msgid "Vertex SQL"
msgstr ""

msgid "``in_edges``"
msgstr ""

msgid "``BIGINT[]``"
msgstr ""

msgid ""
"Array of identifiers of the edges that have the vertex ``id`` as *first end "
"point*."
msgstr ""

msgid "When missing, ``out_edges`` must exist."
msgstr ""

msgid "``out_edges``"
msgstr ""

msgid ""
"Array of identifiers of the edges that have the vertex ``id`` as *second end "
"point*."
msgstr ""

msgid "When missing, ``in_edges`` must exist."
msgstr ""

msgid "Vertex identifier"
msgstr ""

msgid "``degree``"
msgstr ""

msgid "Number of edges that are incident to the vertex ``id``"
msgstr ""

msgid "Degree of a sub graph"
msgstr ""

msgid "Dry run execution"
msgstr ""

msgid ""
"To get the query generated used to get the vertex information, use ``dryrun "
"=> true``."
msgstr ""

msgid ""
"The results can be used as base code to make a refinement based on the "
"backend development needs."
msgstr ""

msgid "Degree from an existing table"
msgstr ""

msgid ""
"If you have a vertices table already built using ``pgr_extractVertices`` and "
"want the degree of the whole graph rather than a subset, you can forgo using "
"pgr_degree and work with the ``in_edges`` and ``out_edges`` columns directly."
msgstr ""

msgid ":doc:`pgr_extractVertices`"
msgstr ""

msgid "``pgr_depthFirstSearch`` - Proposed"
msgstr ""

msgid ""
"``pgr_depthFirstSearch`` — Returns a depth first search traversal of the "
"graph. The graph can be directed or undirected."
msgstr ""

msgid "Version 3.3.0"
msgstr ""

msgid "Promoted to **proposed** function"
msgstr ""

msgid "``pgr_depthFirstSearch`` (`Single Vertex`_)"
msgstr ""

msgid "``pgr_depthFirstSearch`` (`Multiple Vertices`_)"
msgstr ""

msgid ""
"Depth First Search algorithm is a traversal algorithm which starts from a "
"root vertex, goes as deep as possible, and backtracks once a vertex is "
"reached with no adjacent vertices or with all visited adjacent vertices. The "
"traversal continues until all the vertices reachable from the root vertex "
"are visited."
msgstr ""

msgid ""
"The implementation works for both **directed** and **undirected** graphs."
msgstr ""

msgid ""
"Provides the Depth First Search traversal order from a root vertex or from a "
"set of root vertices."
msgstr ""

msgid ""
"An optional non-negative maximum depth parameter to limit the results up to "
"a particular depth."
msgstr ""

msgid ""
"For optimization purposes, any duplicated values in the `Root vids` are "
"ignored."
msgstr ""

msgid ""
"It does not produce the shortest path from a root vertex to a target vertex."
msgstr ""

msgid "The aggregate cost of traversal is not guaranteed to be minimal."
msgstr ""

msgid "The returned values are ordered in ascending order of `start_vid`."
msgstr ""

msgid "Depth First Search Running time: :math:`O(E + V)`"
msgstr ""

msgid "pgr_depthFirstSearch(`Edges SQL`_, **root vid**, [**options**])"
msgstr ""

msgid "pgr_depthFirstSearch(`Edges SQL`_, **root vids**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, max_depth]``"
msgstr ""

msgid "Same as `Single vertex`_ but with edges in descending order of ``id``."
msgstr ""

msgid ""
"`Boost: Depth First Search algorithm documentation <https://www.boost.org/"
"libs/graph/doc/depth_first_search.html>`__"
msgstr ""

msgid ""
"`Boost: Undirected DFS algorithm documentation <https://www.boost.org/libs/"
"graph/doc/undirected_dfs.html>`__"
msgstr ""

msgid ""
"`Wikipedia: Depth First Search algorithm <https://en.wikipedia.org/wiki/"
"Depth-first_search>`__"
msgstr ""

msgid "``pgr_dijkstra``"
msgstr ""

msgid "``pgr_dijkstra`` — Shortest path(s) using Dijkstra algorithm."
msgstr ""

msgid "Version 3.5.0"
msgstr ""

msgid ""
"``pgr_dijkstra`` (`One to One`_) added ``start_vid`` and ``end_vid`` columns."
msgstr ""

msgid "``pgr_dijkstra`` (`One to Many`_) added ``end_vid`` column."
msgstr ""

msgid "``pgr_dijkstra`` (`Many to One`_) added ``start_vid`` column."
msgstr ""

msgid "Version 3.1.0"
msgstr ""

msgid "``pgr_dijkstra`` (`Combinations`_)"
msgstr ""

msgid "**Official** functions"
msgstr ""

msgid "Version 2.2.0"
msgstr ""

msgid "New **proposed** functions:"
msgstr ""

msgid "``pgr_dijkstra`` (`One to Many`_)"
msgstr ""

msgid "``pgr_dijkstra`` (`Many to One`_)"
msgstr ""

msgid "``pgr_dijkstra`` (`Many to Many`_)"
msgstr ""

msgid "Signature change on ``pgr_dijkstra`` (`One to One`_)"
msgstr ""

msgid "**Official** ``pgr_dijkstra`` (`One to One`_)"
msgstr ""

msgid "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""

msgid "pgr_dijkstra(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""

msgid "pgr_dijkstra(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""

msgid "pgr_dijkstra(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

msgid "Breaking change on 3.5.0"
msgstr ""

msgid ""
"Read the :doc:`migration` about how to migrate from the old result columns "
"to the new result columns."
msgstr ""

msgid ""
"From vertex :math:`6` to vertices :math:`\\{10, 17\\}` on a **directed**"
msgstr ""

msgid ""
"The examples of this section are based on the :doc:`sampledata` network."
msgstr ""

msgid "For **directed** graphs with ``cost`` and ``reverse_cost`` columns"
msgstr ""

msgid "Directed graph with cost and reverse cost columns"
msgstr ""

msgid "1) Path from :math:`6` to :math:`10`"
msgstr ""

msgid "2) Path from :math:`6` to :math:`7`"
msgstr ""

msgid "3) Path from :math:`12` to :math:`10`"
msgstr ""

msgid "4) Path from :math:`12` to :math:`7`"
msgstr ""

msgid "5) Using `One to Many`_ to get the solution of examples 1 and 2"
msgstr ""

msgid "Paths :math:`\\{6\\}\\rightarrow\\{10, 7\\}`"
msgstr ""

msgid "6) Using `Many to One`_ to get the solution of examples 2 and 4"
msgstr ""

msgid "Paths :math:`\\{6, 12\\}\\rightarrow\\{7\\}`"
msgstr ""

msgid "7) Using `Many to Many`_ to get the solution of examples 1 to 4"
msgstr ""

msgid "Paths :math:`\\{6, 12\\}\\rightarrow\\{10, 7\\}`"
msgstr ""

msgid "8) Using `Combinations`_ to get the solution of examples 1 to 3"
msgstr ""

msgid ""
"Paths :math:`\\{6\\}\\rightarrow\\{10, 7\\}\\cup\\{12\\}\\rightarrow\\{10\\}`"
msgstr ""

msgid "For **undirected** graphs with ``cost`` and ``reverse_cost`` columns"
msgstr ""

msgid "Undirected graph with cost and reverse cost columns"
msgstr ""

msgid "9) Path from :math:`6` to :math:`10`"
msgstr ""

msgid "10) Path from :math:`6` to :math:`7`"
msgstr ""

msgid "11) Path from :math:`12` to :math:`10`"
msgstr ""

msgid "12) Path from :math:`12` to :math:`7`"
msgstr ""

msgid "13) Using `One to Many`_ to get the solution of examples 9 and 10"
msgstr ""

msgid "14) Using `Many to One`_ to get the solution of examples 10 and 12"
msgstr ""

msgid "15) Using `Many to Many`_ to get the solution of examples 9 to 12"
msgstr ""

msgid "16) Using `Combinations`_ to get the solution of examples 9 to 11"
msgstr ""

msgid "For **directed** graphs only with ``cost`` column"
msgstr ""

msgid "Directed graph only with cost column"
msgstr ""

msgid "17) Path from :math:`6` to :math:`10`"
msgstr ""

msgid "18) Path from :math:`6` to :math:`7`"
msgstr ""

msgid "19) Path from :math:`12` to :math:`10`"
msgstr ""

msgid "20) Path from :math:`12` to :math:`7`"
msgstr ""

msgid "21) Using `One to Many`_ to get the solution of examples 17 and 18"
msgstr ""

msgid "22) Using `Many to One`_ to get the solution of examples 18 and 20"
msgstr ""

msgid "23) Using `Many to Many`_ to get the solution of examples 17 to 20"
msgstr ""

msgid "24) Using `Combinations`_ to get the solution of examples 17 to 19"
msgstr ""

msgid "For **undirected** graphs only with ``cost`` column"
msgstr ""

msgid "Undirected graph only with cost column"
msgstr ""

msgid "25) Path from :math:`6` to :math:`10`"
msgstr ""

msgid "26) Path from :math:`6` to :math:`7`"
msgstr ""

msgid "27) Path from :math:`12` to :math:`10`"
msgstr ""

msgid "28) Path from :math:`12` to :math:`7`"
msgstr ""

msgid "29) Using `One to Many`_ to get the solution of examples 25 and 26"
msgstr ""

msgid "30) Using `Many to One`_ to get the solution of examples 26 and 28"
msgstr ""

msgid "31) Using `Many to Many`_ to get the solution of examples 25 to 28"
msgstr ""

msgid "32) Using `Combinations`_ to get the solution of examples 25 to 27"
msgstr ""

msgid "Equvalences between signatures"
msgstr ""

msgid ""
"The following examples find the path for :math:`\\{6\\}\\rightarrow\\{10\\}`"
msgstr ""

msgid "33) Using `One to One`_"
msgstr ""

msgid "34) Using `One to Many`_"
msgstr ""

msgid "35) Using `Many to One`_"
msgstr ""

msgid "36) Using `Many to Many`_"
msgstr ""

msgid "37) Using `Combinations`_"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
msgstr ""

msgid "``pgr_dijkstraCost``"
msgstr ""

msgid ""
"``pgr_dijkstraCost`` - Total cost of the shortest path(s) using Dijkstra "
"algorithm."
msgstr ""

msgid "``pgr_dijkstraCost`` (`Combinations`_)"
msgstr ""

msgid ""
"The ``pgr_dijkstraCost`` function sumarizes of the cost of the shortest "
"path(s) using Dijkstra Algorithm."
msgstr ""

msgid ""
"pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""

msgid ""
"pgr_dijkstraCost(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""

msgid ""
"pgr_dijkstraCost(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""

msgid ""
"pgr_dijkstraCost(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr ""

msgid "pgr_dijkstraCost(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

msgid "``pgr_dijkstraCostMatrix``"
msgstr ""

msgid ""
"``pgr_dijkstraCostMatrix`` - Calculates a cost matrix using :doc:"
"`pgr_dijkstra`."
msgstr ""

msgid "Using Dijkstra algorithm, calculate and return a cost matrix."
msgstr ""

msgid "pgr_dijkstraCostMatrix(`Edges SQL`_, **start vids**, [``directed``])"
msgstr ""

msgid "``pgr_dijkstraNear`` - Proposed"
msgstr ""

msgid ""
"``pgr_dijkstraNear`` — Using Dijkstra's algorithm, finds the route that "
"leads to the nearest vertex."
msgstr ""

msgid ""
"Given a graph, a starting vertex and a set of ending vertices, this function "
"finds the shortest path from the starting vertex to the nearest ending "
"vertex."
msgstr ""

msgid "Uses Dijkstra algorithm."
msgstr ""

msgid "Works for **directed** and **undirected** graphs."
msgstr ""

msgid "When there are more than one path to the same vertex with same cost:"
msgstr ""

msgid "The algorithm will return just one path"
msgstr ""

msgid "Optionally allows to find more than one path."
msgstr ""

msgid "When more than one path is to be returned:"
msgstr ""

msgid "Results are sorted in increasing order of:"
msgstr ""

msgid "aggregate cost"
msgstr ""

msgid "Within the same value of aggregate costs:"
msgstr ""

msgid "results are sorted by (source, target)"
msgstr ""

msgid "Running time: Dijkstra running time: :math:`drt = O((|E| + |V|)log|V|)`"
msgstr ""

msgid "One to Many; :math:`drt`"
msgstr ""

msgid "Many to One: :math:`drt`"
msgstr ""

msgid "Many to Many: :math:`drt * |Starting vids|`"
msgstr ""

msgid "Combinations: :math:`drt * |Starting vids|`"
msgstr ""

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vid**, **end vids**, [**options A**])"
msgstr ""

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vid**, [**options A**])"
msgstr ""

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vids**, [**options B**])"
msgstr ""

msgid "pgr_dijkstraNear(`Edges SQL`_, `Combinations SQL`_, [**options B**])"
msgstr ""

msgid "**options A:** ``[directed, cap]``"
msgstr ""

msgid "**options B:** ``[directed, cap, global]``"
msgstr ""

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vid**, **end vids**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, cap]``"
msgstr ""

msgid "Departing on car from vertex :math:`6` find the nearest subway station."
msgstr ""

msgid "Using a **directed** graph for car routing."
msgstr ""

msgid ""
"The subway stations are on the following vertices :math:`\\{1, 10, 11\\}`"
msgstr ""

msgid "The defaults used:"
msgstr ""

msgid "`directed => true`"
msgstr ""

msgid "`cap => 1`"
msgstr ""

msgid "The result shows that station at vertex :math:`11` is the nearest."
msgstr ""

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vid**, [**options**])"
msgstr ""

msgid ""
"Departing on a car from a subway station find the nearest **two** stations "
"to vertex :math:`2`"
msgstr ""

msgid "On line `4`: using the positional parameter: `directed` set to ``true``"
msgstr ""

msgid "In line `5`: using named parameter `cap => 2`"
msgstr ""

msgid ""
"The result shows that station at vertex :math:`10` is the nearest and the "
"next best is :math:`11`."
msgstr ""

msgid ""
"pgr_dijkstraNear(`Edges SQL`_, **start vids**, **end vids**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, cap, global]``"
msgstr ""

msgid "Find the best pedestrian connection between two lines of buses"
msgstr ""

msgid "Unsing an **undirected** graph for pedestrian routing"
msgstr ""

msgid "The first subway line stations are at :math:`\\{15, 16\\}`"
msgstr ""

msgid "The second subway line stations stops are at :math:`\\{1, 10, 11\\}`"
msgstr ""

msgid "On line `4`: using the named parameter: `directed => false`"
msgstr ""

msgid "`global => true`"
msgstr ""

msgid ""
"For a pedestrian the best connection is to get on/off is at vertex :math:"
"`15` of the first subway line and at vertex :math:`10` of the second subway "
"line."
msgstr ""

msgid ""
"Only `one` route is returned because `global` is ``true`` and `cap` is ``1``"
msgstr ""

msgid "pgr_dijkstraNear(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr ""

msgid ""
"Find the best car connection between all the stations of two subway lines"
msgstr ""

msgid "The first subway line stations stops are at :math:`\\{1, 10, 11\\}`"
msgstr ""

msgid "The second subway line stations are at :math:`\\{15, 16\\}`"
msgstr ""

msgid "The combinations contents:"
msgstr ""

msgid ""
"lines `3~4` sets the start vertices to be from the first subway line and the "
"ending vertices to be from the second subway line"
msgstr ""

msgid ""
"lines `6~7` sets the start vertices to be from the first subway line and the "
"ending vertices to be from the first subway line"
msgstr ""

msgid "On line `8`: using the named parameter is `global => false`"
msgstr ""

msgid "From the results:"
msgstr ""

msgid ""
"making a connection from the first subway line :math:`\\{1, 10, 11\\}` to "
"the second :math:`\\{15, 16\\}`:"
msgstr ""

msgid ""
"The best connections from all the stations from the first line are: :math:"
"`{(1 \\rightarrow 16) (10 \\rightarrow 16) (11 \\rightarrow 16)}`"
msgstr ""

msgid ""
"The best one is :math:`(11 \\rightarrow 16)` with a cost of :math:`1` "
"(lines: `11` and `12`)"
msgstr ""

msgid ""
"making a connection from the second subway line :math:`\\{15, 16\\}` to the "
"first :math:`\\{1, 10, 11\\}`:"
msgstr ""

msgid ""
"The best connections from all the stations from the second line are: :math:"
"`{(15 \\rightarrow 10) (16 \\rightarrow 11)}`"
msgstr ""

msgid ""
"Both are equaly good as they have the same cost. (lines: `13` and `14` and "
"lines: `15` and `16`)"
msgstr ""

msgid "Dijkstra optional parameters"
msgstr ""

msgid "Near optional parameters"
msgstr ""

msgid "``cap``"
msgstr ""

msgid "Find at most ``cap`` number of nearest shortest paths"
msgstr ""

msgid "``global``"
msgstr ""

msgid "When ``true``: only ``cap`` limit results will be returned"
msgstr ""

msgid "When ``false``: ``cap`` limit per ``Start vid`` will be returned"
msgstr ""

msgid "boost: https://www.boost.org/libs/graph/doc/table_of_contents.html"
msgstr ""

msgid "Wikipedia: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
msgstr ""

msgid "``pgr_dijkstraNearCost`` - Proposed"
msgstr ""

msgid ""
"``pgr_dijkstraNearCost`` — Using dijkstra algorithm, finds the route that "
"leads to the nearest vertex."
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vids**, [**options "
"A**])"
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vid**, [**options "
"A**])"
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vids**, [**options "
"B**])"
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, `Combinations SQL`_, [**options B**])"
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vid**, **end vids**, "
"[**options**])"
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vid**, "
"[**options**])"
msgstr ""

msgid ""
"Departing on a car from a subway station find the nearest **two** stations "
"to vertex :math:`6`"
msgstr ""

msgid ""
"pgr_dijkstraNearCost(`Edges SQL`_, **start vids**, **end vids**, "
"[**options**])"
msgstr ""

msgid "pgr_dijkstraNearCost(`Edges SQL`_, `Combinations SQL`_, [**options**])"
msgstr ""

msgid ""
"lines `3~4` sets the start vertices to be from the fisrt subway line and the "
"ending vertices to be from the second subway line"
msgstr ""

msgid ""
"The best one is :math:`(11 \\rightarrow 16)` with a cost of :math:`1` "
"(lines: `1`)"
msgstr ""

msgid "Both are equaly good as they have the same cost. (lines: `12` and `13`)"
msgstr ""

msgid "``pgr_dijkstraVia`` - Proposed"
msgstr ""

msgid "``pgr_dijkstraVia`` — Route that goes through a list of vertices."
msgstr ""

msgid ""
"Given a list of vertices and a graph, this function is equivalent to finding "
"the shortest path between :math:`vertex_i` and :math:`vertex_{i+1}` for all :"
"math:`i < size\\_of(via\\;vertices)`."
msgstr ""

msgid "Route"
msgstr ""

msgid "is a sequence of paths."
msgstr ""

msgid "Path"
msgstr ""

msgid "is a section of the route."
msgstr ""

msgid "One Via"
msgstr ""

msgid "pgr_dijkstraVia(`Edges SQL`_, **via vertices**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, strict, U_turn_on_edge]``"
msgstr ""

msgid "Returns set of |via-result|"
msgstr ""

msgid ""
"Find the route that visits the vertices :math:`\\{5, 1, 8\\}` in that order "
"on an **directed** graph."
msgstr ""

msgid "Via optional parameters"
msgstr ""

msgid "When ``true`` departing from a visited vertex will not try to avoid"
msgstr ""

msgid "Identifier of a path. Has value **1** for the first path."
msgstr ""

msgid "-1 for the last node of the path."
msgstr ""

msgid "-2 for the last node of the route."
msgstr ""

msgid "``route_agg_cost``"
msgstr ""

msgid ""
"Total cost from ``start_vid`` of ``seq = 1`` to ``end_vid`` of the current "
"``seq``."
msgstr ""

msgid ""
"All this examples are about the route that visits the vertices :math:`\\{5, "
"7, 1, 8, 15\\}` in that order on a **directed** graph."
msgstr ""

msgid "The main query"
msgstr ""

msgid "Aggregate cost of the third path."
msgstr ""

msgid "Route's aggregate cost of the route at the end of the third path."
msgstr ""

msgid "Nodes visited in the route."
msgstr ""

msgid "The aggregate costs of the route when the visited vertices are reached."
msgstr ""

msgid "Status of \"passes in front\" or \"visits\" of the nodes."
msgstr ""

msgid ":doc:`via-category`."
msgstr ""

msgid ":doc:`dijkstra-family`."
msgstr ""

msgid "``pgr_drivingDistance``"
msgstr ""

msgid ""
"``pgr_drivingDistance`` - Returns the driving distance from a start node."
msgstr ""

msgid "Added ``depth`` and ``start_vid`` result columns."
msgstr ""

msgid "Result column name change: ``from_v`` to ``start_vid``."
msgstr ""

msgid "Added ``depth`` and ``pred`` result columns."
msgstr ""

msgid "Signature change pgr_drivingDistance(single vertex)"
msgstr ""

msgid "New **Official** pgr_drivingDistance(multiple vertices)"
msgstr ""

msgid "Official:: pgr_drivingDistance(single vertex)"
msgstr ""

msgid ""
"Using the Dijkstra algorithm, extracts all the nodes that have costs less "
"than or equal to the value ``distance``. The edges extracted will conform to "
"the corresponding spaning tree."
msgstr ""

msgid ""
"pgr_drivingDistance(`Edges SQL`_, **Root vid**, **distance**, [``directed``])"
msgstr ""

msgid ""
"pgr_drivingDistance(`Edges SQL`_, **Root vids**, **distance**, [**options**])"
msgstr ""

msgid "**options:** [directed, equicost]"
msgstr ""

msgid "Single Vertex"
msgstr ""

msgid "From vertex :math:`11` for a distance of :math:`3.0`"
msgstr ""

msgid "Multiple Vertices"
msgstr ""

msgid ""
"From vertices :math:`\\{11, 16\\}` for a distance of :math:`3.0` with equi-"
"cost on a directed graph"
msgstr ""

msgid "Driving distance optional parameters"
msgstr ""

msgid "``equicost``"
msgstr ""

msgid ""
"When ``true`` the node will only appear in the closest ``start_vid`` list. "
"Tie brakes are arbitrary."
msgstr ""

msgid ""
"When ``false`` which resembles several calls using the single vertex "
"signature."
msgstr ""

msgid ""
"From vertices :math:`\\{11, 16\\}` for a distance of :math:`3.0` on an "
"undirected graph"
msgstr ""

msgid "pgr_edgeColoring - Experimental"
msgstr ""

msgid ""
"``pgr_edgeColoring`` — Returns the edge coloring of undirected and loop-free "
"graphs"
msgstr ""

msgid ""
"Edge Coloring is an algorithm used for coloring of the edges for the "
"vertices in the graph. It is an assignment of colors to the edges of the "
"graph so that no two adjacent edges have the same color."
msgstr ""

msgid "The implementation is for **undirected** and **loop-free** graphs"
msgstr ""

msgid "loop free"
msgstr ""

msgid "no self-loops and no parallel edges."
msgstr ""

msgid ""
"Provides the color to be assigned to all the edges present in the graph."
msgstr ""

msgid ""
"At most :math:`\\Delta + 1` colors are used, where :math:`\\Delta` is the "
"degree of the graph."
msgstr ""

msgid ""
"This is optimal for some graphs, and by Vizing's theorem it uses at most one "
"color more than the optimal for all others."
msgstr ""

msgid ""
"the chromatic number :math:`x'(G)` (minimum number of colors needed for "
"proper edge coloring of graph) is equal to the degree :math:`\\Delta + 1` of "
"the graph, (:math:`x'(G) = \\Delta`)"
msgstr ""

msgid "The algorithm tries to assign the least possible color to every edge."
msgstr ""

msgid "Does not always produce optimal coloring."
msgstr ""

msgid ""
"The returned rows are ordered in ascending order of the edge identifier."
msgstr ""

msgid "Efficient graph coloring is an NP-Hard problem, and therefore:"
msgstr ""

msgid "In this implelentation the running time: :math:`O(|E|*|V|)`"
msgstr ""

msgid "where :math:`|E|` is the number of edges in the graph,"
msgstr ""

msgid ":math:`|V|` is the number of vertices in the graph."
msgstr ""

msgid "pgr_edgeColoring(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-edge-color|"
msgstr ""

msgid "Graph coloring of pgRouting :doc:`sampledata`"
msgstr ""

msgid "``pgr_edgeDisjointPaths``"
msgstr ""

msgid ""
"``pgr_edgeDisjointPaths`` — Calculates edge disjoint paths between two "
"groups of vertices."
msgstr ""

msgid "New **proposed** function:"
msgstr ""

msgid "pgr_edgeDisjointPaths(Combinations)"
msgstr ""

msgid ""
"Calculates the edge disjoint paths between two groups of vertices. Utilizes "
"underlying maximum flow algorithms to calculate the paths."
msgstr ""

msgid "The main characterics are:"
msgstr ""

msgid "Calculates the edge disjoint paths between any two groups of vertices."
msgstr ""

msgid ""
"Returns EMPTY SET when source and destination are the same, or cannot be "
"reached."
msgstr ""

msgid "The graph can be directed or undirected."
msgstr ""

msgid "Uses :doc:`pgr_boykovKolmogorov` to calculate the paths."
msgstr ""

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vid**, **end vids**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vids**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_edgeDisjointPaths(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

msgid "Returns set of |result-disjoint|"
msgstr ""

msgid "Returns set of |result-disjoint-1-1|"
msgstr ""

msgid "Returns set of |result-disjoint-1-m|"
msgstr ""

msgid "Returns set of |result-disjoint-m-1|"
msgstr ""

msgid "Returns set of |result-disjoint-m-m|"
msgstr ""

msgid ""
"Using a combinations table, equivalent to calculating result from vertices :"
"math:`\\{5, 6\\}` to vertices :math:`\\{10, 15, 14\\}` on an undirected "
"graph."
msgstr ""

msgid "Manually assigned vertex combinations on an undirected graph."
msgstr ""

msgid "``pgr_edmondsKarp``"
msgstr ""

msgid ""
"``pgr_edmondsKarp`` — Calculates the flow on the graph edges that maximizes "
"the flow from the sources to the targets using Edmonds Karp Algorithm."
msgstr ""

msgid "``pgr_edmondsKarp`` (`Combinations`_)"
msgstr ""

msgid "Renamed from ``pgr_maxFlowEdmondsKarp``"
msgstr ""

msgid "Running time: :math:`O( V * E ^ 2)`"
msgstr ""

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_edmondsKarp(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_edmondsKarp(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "https://www.boost.org/libs/graph/doc/edmonds_karp_max_flow.html"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm"
msgstr ""

msgid "``pgr_edwardMoore - Experimental``"
msgstr ""

msgid ""
"``pgr_edwardMoore`` — Returns the shortest path using Edward-Moore algorithm."
msgstr ""

msgid "``pgr_edwardMoore`` (`Combinations`_)"
msgstr ""

msgid "``pgr_edwardMoore`` (`One to One`_)"
msgstr ""

msgid "``pgr_edwardMoore`` (`One to Many`_)"
msgstr ""

msgid "``pgr_edwardMoore`` (`Many to One`_)"
msgstr ""

msgid "``pgr_edwardMoore`` (`Many to Many`_)"
msgstr ""

msgid ""
"Edward Moore’s Algorithm is an improvement of the Bellman-Ford Algorithm. It "
"can compute the shortest paths from a single source vertex to all other "
"vertices in a weighted directed graph. The main difference between Edward "
"Moore's Algorithm and Bellman Ford's Algorithm lies in the run time."
msgstr ""

msgid ""
"The worst-case running time of the algorithm is :math:`O(| V | * | E |)` "
"similar to the time complexity of Bellman-Ford algorithm. However, "
"experiments suggest that this algorithm has an average running time "
"complexity of :math:`O( | E | )` for random graphs. This is significantly "
"faster in terms of computation speed."
msgstr ""

msgid ""
"Thus, the algorithm is at-best, significantly faster than Bellman-Ford "
"algorithm and is at-worst,as good as Bellman-Ford algorithm"
msgstr ""

msgid "The `agg_cost` the non included values `(v, v)` is :math:`0`"
msgstr ""

msgid ""
"For optimization purposes, any duplicated value in the `start vids` or `end "
"vids` are ignored."
msgstr ""

msgid "Running time:"
msgstr ""

msgid "Worst case: :math:`O(| V | * | E |)`"
msgstr ""

msgid "Average case: :math:`O( | E | )`"
msgstr ""

msgid ""
"pgr_edwardMoore(`Edges SQL`_, **start vid**, **end vid**, [``directed``])"
msgstr ""

msgid ""
"pgr_edwardMoore(`Edges SQL`_, **start vid**, **end vids**, [``directed``])"
msgstr ""

msgid ""
"pgr_edwardMoore(`Edges SQL`_, **start vids**, **end vid**, [``directed``])"
msgstr ""

msgid ""
"pgr_edwardMoore(`Edges SQL`_, **start vids**, **end vids**, [``directed``])"
msgstr ""

msgid "pgr_edwardMoore(`Edges SQL`_, `Combinations SQL`_, [``directed``])"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm"
msgstr ""

msgid "pgr_extractVertices -- Proposed"
msgstr ""

msgid "``pgr_extractVertices`` — Extracts the vertices information"
msgstr ""

msgid "Classified as **proposed** function"
msgstr ""

msgid ""
"This is an auxiliary function for extracting the vertex information of the "
"set of edges of a graph."
msgstr ""

msgid ""
"When the edge identifier is given, then it will also calculate the in and "
"out edges"
msgstr ""

msgid "pgr_extractVertices(`Edges SQL`_, [``dryrun``])"
msgstr ""

msgid "RETURNS SETOF |result-extract|"
msgstr ""

msgid "When line geometry is known"
msgstr ""

msgid "(Optional) identifier of the edge."
msgstr ""

msgid "``geom``"
msgstr ""

msgid "``LINESTRING``"
msgstr ""

msgid "Geometry of the edge."
msgstr ""

msgid ""
"This inner query takes precedence over the next two inner query, therefore "
"other columns are ignored when ``geom`` column appears."
msgstr ""

msgid "Ignored columns:"
msgstr ""

msgid "``startpoint``"
msgstr ""

msgid "``endpoint``"
msgstr ""

msgid "When vertex geometry is known"
msgstr ""

msgid ""
"To use this inner query the column ``geom`` should not be part of the set of "
"columns."
msgstr ""

msgid "``POINT``"
msgstr ""

msgid "POINT geometry of the starting vertex."
msgstr ""

msgid "POINT geometry of the ending vertex."
msgstr ""

msgid ""
"This inner query takes precedence over the next inner query, therefore other "
"columns are ignored when ``startpoint`` and ``endpoint`` columns appears."
msgstr ""

msgid "When identifiers of vertices are known"
msgstr ""

msgid ""
"To use this inner query the columns ``geom``, ``startpoint`` and "
"``endpoint`` should not be part of the set of columns."
msgstr ""

msgid "``NULL`` When the ``id`` is not part of the inner query"
msgstr ""

msgid "X value of the point geometry"
msgstr ""

msgid "``NULL`` When no geometry is provided"
msgstr ""

msgid "Geometry of the point"
msgstr ""

msgid ""
"To get the query generated used to get the vertex information, use ``dryrun :"
"= true``."
msgstr ""

msgid "``pgr_findCloseEdges``"
msgstr ""

msgid "``pgr_findCloseEdges`` - Finds the close edges to a point geometry."
msgstr ""

msgid "New **proposed** signatures:"
msgstr ""

msgid "``pgr_findCloseEdges`` (`One point`_)"
msgstr ""

msgid "``pgr_findCloseEdges`` (`Many points`_)"
msgstr ""

msgid ""
"``pgr_findCloseEdges`` - An utility function that finds the closest edge to "
"a point geometry."
msgstr ""

msgid ""
"The geometries must be in the same coordinate system (have the same SRID)."
msgstr ""

msgid ""
"The code to do the calculations can be obtained for further specific "
"adjustments needed by the application."
msgstr ""

msgid "``EMTPY SET`` is returned on dryrun executions"
msgstr ""

msgid ""
"pgr_findCloseEdges(`Edges SQL`_, **point**, **tolerance**, [**options**])"
msgstr ""

msgid ""
"pgr_findCloseEdges(`Edges SQL`_, **points**, **tolerance**, [**options**])"
msgstr ""

msgid "**options:** ``[cap, partial, dryrun]``"
msgstr ""

msgid "Returns set of |result-find|"
msgstr ""

msgid "One point"
msgstr ""

msgid "Default: ``cap => 1``"
msgstr ""

msgid "Maximum one row answer."
msgstr ""

msgid "Default: ``partial => true``"
msgstr ""

msgid "With less calculations as possible."
msgstr ""

msgid "Default: ``dryrun => false``"
msgstr ""

msgid "Process query"
msgstr ""

msgid "Returns"
msgstr ""

msgid "values on ``edge_id``, ``fraction``, ``side`` columns."
msgstr ""

msgid "``NULL`` on ``distance``, ``geom``, ``edge`` columns."
msgstr ""

msgid "Many points"
msgstr ""

msgid ""
"Find at most :math:`2` edges close to all vertices on the points of interest "
"table."
msgstr ""

msgid "One answer per point, as small as possible."
msgstr ""

msgid ""
"Columns ``edge_id``, ``fraction``, ``side`` and ``geom`` are returned with "
"values."
msgstr ""

msgid ""
"``geom`` contains the original point geometry to assist on deterpartialing "
"to which point geometry the row belongs to."
msgstr ""

msgid "**point**"
msgstr ""

msgid "The point geometry"
msgstr ""

msgid "**points**"
msgstr ""

msgid "``POINT[]``"
msgstr ""

msgid "An array of point geometries"
msgstr ""

msgid "**tolerance**"
msgstr ""

msgid "Max distance between geometries"
msgstr ""

msgid "Limit output rows"
msgstr ""

msgid "``partial``"
msgstr ""

msgid ""
"When ``true`` only columns needed for :doc:`withPoints-category` are "
"calculated."
msgstr ""

msgid "When ``false`` all columns are calculated"
msgstr ""

msgid "When ``false`` calculations are performed."
msgstr ""

msgid ""
"When ``true`` calculations are not performed and the query to do the "
"calculations is exposed in a PostgreSQL ``NOTICE``."
msgstr ""

msgid "The ``LINESTRING`` geometry of the edge."
msgstr ""

msgid "When :math:`cap = 1`, it is the closest edge."
msgstr ""

msgid ""
"Value in <0,1> that indicates the relative postition from the first end-"
"point of the edge."
msgstr ""

msgid "Value in ``[r, l]`` indicating if the point is:"
msgstr ""

msgid "In the right ``r``."
msgstr ""

msgid "In the left ``l``."
msgstr ""

msgid "When the point is on the line it is considered to be on the right."
msgstr ""

msgid "``distance``"
msgstr ""

msgid "Distance from point to edge."
msgstr ""

msgid "``NULL`` when ``cap = 1`` on the `One point`_ signature"
msgstr ""

msgid "``POINT`` geometry"
msgstr ""

msgid ""
"`One Point`_: Contains the point on the edge that is ``fraction`` away from "
"the starting point of the edge."
msgstr ""

msgid "`Many Points`_: Contains the corresponding **original point**"
msgstr ""

msgid ""
"``LINESTRING`` geometry from the **original point** to the closest point of "
"the edge with identifier ``edge_id``"
msgstr ""

msgid "One point results"
msgstr ""

msgid "The green nodes is the **original point**"
msgstr ""

msgid ""
"The geometry ``geom`` is a point on the :math:`sp \\rightarrow ep` edge."
msgstr ""

msgid ""
"The geometry ``edge`` is a line that connects the **original point** with "
"``geom``"
msgstr ""

msgid "Many point results"
msgstr ""

msgid "The green nodes are the **original points**"
msgstr ""

msgid ""
"The geometry ``geom``, marked as **g1** and **g2** are the **original "
"points**"
msgstr ""

msgid ""
"The geometry ``edge``, marked as **edge1** and **edge2** is a line that "
"connects the **original point** with the closest point on the :math:`sp "
"\\rightarrow ep` edge."
msgstr ""

msgid "One point examples"
msgstr ""

msgid "At most two answers"
msgstr ""

msgid "``cap => 2``"
msgstr ""

msgid "Maximum two row answer."
msgstr ""

msgid "Understanding the result"
msgstr ""

msgid "``NULL`` on ``geom``, ``edge``"
msgstr ""

msgid "``edge_id`` identifier of the edge close to the **original point**"
msgstr ""

msgid ""
"Two edges are withing :math:`0.5` distance units from the **original "
"point**: :math:`{5, 8}`"
msgstr ""

msgid "For edge :math:`5`:"
msgstr ""

msgid ""
"``fraction``: The closest point from the **original point** is at the :math:"
"`0.8` fraction of the edge :math:`5`."
msgstr ""

msgid ""
"``side``: The **original point** is located to the left side of edge :math:"
"`5`."
msgstr ""

msgid ""
"``distance``: The **original point** is located :math:`0.1` length units "
"from edge :math:`5`."
msgstr ""

msgid "For edge :math:`8`:"
msgstr ""

msgid ""
"``fraction``: The closest point from the **original point** is at the :math:"
"`0.89..` fraction of the edge :math:`8`."
msgstr ""

msgid ""
"``side``: The **original point** is located to the right side of edge :math:"
"`8`."
msgstr ""

msgid ""
"``distance``: The **original point** is located :math:`0.19..` length units "
"from edge :math:`8`."
msgstr ""

msgid "One answer, all columns"
msgstr ""

msgid "``partial => false``"
msgstr ""

msgid "Calculate all columns"
msgstr ""

msgid ""
"``edge_id`` identifier of the edge **closest** to the **original point**"
msgstr ""

msgid ""
"From all edges within :math:`0.5` distance units from the **original "
"point**: :math:`{5}` is the closest one."
msgstr ""

msgid ""
"``geom``: Contains the geometry of the closest point on edge :math:`5` from "
"the **original point**."
msgstr ""

msgid ""
"``edge``: Contains the ``LINESTRING`` geometry of the **original point** to "
"the closest point on on edge :math:`5` ``geom``"
msgstr ""

msgid "At most two answers with all columns"
msgstr ""

msgid "Understanding the result:"
msgstr ""

msgid ""
"``geom``: Contains the geometry of the closest point on edge :math:`8` from "
"the **original point**."
msgstr ""

msgid ""
"``edge``: Contains the ``LINESTRING`` geometry of the **original point** to "
"the closest point on on edge :math:`8` ``geom``"
msgstr ""

msgid "One point dry run execution"
msgstr ""

msgid "Returns ``EMPTY SET``."
msgstr ""

msgid "``partial => true``"
msgstr ""

msgid "Is ignored"
msgstr ""

msgid ""
"Because it is a **dry run** excecution, the code for all calculations are "
"shown on the PostgreSQL ``NOTICE``."
msgstr ""

msgid "``dryrun => true``"
msgstr ""

msgid "Do not process query"
msgstr ""

msgid ""
"Generate a PostgreSQL ``NOTICE`` with the code used to calculate all columns"
msgstr ""

msgid "``cap`` and **original point** are used in the code"
msgstr ""

msgid "Many points examples"
msgstr ""

msgid "At most two answers per point"
msgstr ""

msgid "``NULL`` on ``edge``"
msgstr ""

msgid ""
"``edge_id`` identifier of the edge close to a **original point** (``geom``)"
msgstr ""

msgid ""
"Two edges at most withing :math:`0.5` distance units from each of the "
"**original points**:"
msgstr ""

msgid "For ``POINT(1.8 0.4)`` and ``POINT(0.3 1.8)`` only one edge was found."
msgstr ""

msgid "For the rest of the points two edges were found."
msgstr ""

msgid "For point ``POINT(2.9 1.8)``"
msgstr ""

msgid ""
"Edge :math:`5` is before :math:`8` therefore edge :math:`5` has the shortest "
"distance to ``POINT(2.9 1.8)``."
msgstr ""

msgid "One answer per point, all columns"
msgstr ""

msgid "For the **original point** ``POINT(2.9 1.8)``"
msgstr ""

msgid "Edge :math:`5` is the closest edge to the **original point**"
msgstr ""

msgid ""
"``geom``: Contains the geometry of the **original point** ``POINT(2.9 1.8)``"
msgstr ""

msgid ""
"``edge``: Contains the ``LINESTRING`` geometry of the **original point** "
"(``geom``) to the closest point on on edge."
msgstr ""

msgid "Many points dry run execution"
msgstr ""

msgid "Find at most two routes to a given point"
msgstr ""

msgid "Using :doc:`pgr_withPoints`"
msgstr ""

msgid "A point of interest table"
msgstr ""

msgid "Handling points outside the graph."
msgstr ""

msgid "Points of interest"
msgstr ""

msgid ""
"Some times the applications work \"on the fly\" starting from a location "
"that is not a vertex in the graph. Those locations, in pgRrouting are called "
"points of interest."
msgstr ""

msgid ""
"The information needed in the points of interest is ``pid``, ``edge_id``, "
"``side``, ``fraction``."
msgstr ""

msgid ""
"On this documentation there will be some 6 fixed points of interest and they "
"will be stored on a table."
msgstr ""

msgid "A unique identifier."
msgstr ""

msgid ""
"Identifier of the edge nearest edge that allows an arrival to the point."
msgstr ""

msgid "Is it on the left, right or both sides of the segment ``edge_id``"
msgstr ""

msgid "Where in the segment is the point located."
msgstr ""

msgid "The geometry of the points."
msgstr ""

msgid "``newPoint``"
msgstr ""

msgid "The geometry of the points moved on top of the segment."
msgstr ""

msgid "Points of interest fillup"
msgstr ""

msgid "``pgr_floydWarshall``"
msgstr ""

msgid ""
"``pgr_floydWarshall`` - Returns the sum of the costs of the shortest path "
"for each pair of nodes in the graph using Floyd-Warshall algorithm."
msgstr ""

msgid ""
"The Floyd-Warshall algorithm, also known as Floyd's algorithm, is a good "
"choice to calculate the sum of the costs of the shortest path for each pair "
"of nodes in the graph, for *dense graphs*. We use Boost's implementation "
"which runs in :math:`\\Theta(V^3)` time,"
msgstr ""

msgid "pgr_floydWarshall(`Edges SQL`_, [``directed``])"
msgstr ""

msgid "For a directed subgraph with edges :math:`\\{1, 2, 3, 4\\}`."
msgstr ""

msgid ""
"Boost `floyd-Warshall <https://www.boost.org/libs/graph/doc/"
"floyd_warshall_shortest.html>`_"
msgstr ""

msgid "Queries uses the :doc:`sampledata` network."
msgstr ""

msgid "``pgr_full_version``"
msgstr ""

msgid ""
"``pgr_full_version`` — Get the details of pgRouting version information."
msgstr ""

msgid "New **official** function"
msgstr ""

msgid "Get complete details of pgRouting version information"
msgstr ""

msgid "pgr_full_version()"
msgstr ""

msgid "RETURNS |result-version|"
msgstr ""

msgid "Information about when this documentation was built"
msgstr ""

msgid "``version``"
msgstr ""

msgid "pgRouting version"
msgstr ""

msgid "``build_type``"
msgstr ""

msgid "The Build type"
msgstr ""

msgid "``compile_date``"
msgstr ""

msgid "Compilation date"
msgstr ""

msgid "``library``"
msgstr ""

msgid "Library name and version"
msgstr ""

msgid "``system``"
msgstr ""

msgid "Operative system"
msgstr ""

msgid "``postgreSQL``"
msgstr ""

msgid "pgsql used"
msgstr ""

msgid "``compiler``"
msgstr ""

msgid "Compiler and version"
msgstr ""

msgid "``boost``"
msgstr ""

msgid "Boost version"
msgstr ""

msgid "``hash``"
msgstr ""

msgid "Git hash of pgRouting build"
msgstr ""

msgid "``pgr_hawickCircuits - Experimental``"
msgstr ""

msgid ""
"``pgr_hawickCircuits`` — Returns the list of cirucits using hawick circuits "
"algorithm."
msgstr ""

msgid "``pgr_hawickCircuits``"
msgstr ""

msgid ""
"Hawick Circuit algorithm, is published in 2008 by Ken Hawick and Health A. "
"James. This algorithm solves the problem of detecting and enumerating "
"circuits in graphs. It is capable of circuit enumeration in graphs with "
"directed-arcs, multiple-arcs and self-arcs with a memory efficient and high-"
"performance im-plementation. It is an extension of Johnson's Algorithm of "
"finding all the elementary circuits of a directed graph."
msgstr ""

msgid ""
"There are 2 variations defined in the Boost Graph Library. Here, we have "
"implemented only 2nd as it serves the most suitable and practical usecase. "
"In this variation we get the circuits after filtering out the circuits "
"caused by parallel edges. Parallel edge circuits have more use cases when "
"you want to count the no. of circuits.Maybe in future, we will also "
"implemenent this variation."
msgstr ""

msgid "The algorithm implementation works only for directed graph"
msgstr ""

msgid "It is a variation of Johnson's algorithm for circuit enumeration."
msgstr ""

msgid "The algorithm outputs the distinct circuits present in the graph."
msgstr ""

msgid "Time Complexity: :math:`O((V + E) (c + 1))`"
msgstr ""

msgid ":math:`|c|` is the number of circuts in the graph."
msgstr ""

msgid "pgr_hawickCircuits(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |generic-result|"
msgstr ""

msgid "Circuits present in the pgRouting :doc:`sampledata`"
msgstr ""

msgid "Id of the circuit starting from ``1``"
msgstr ""

msgid "Relative postion in the path. Has value ``0`` for beginning of the path"
msgstr ""

msgid "Identifier of the starting vertex of the circuit."
msgstr ""

msgid "Identifier of the ending vertex of the circuit."
msgstr ""

msgid "Identifier of the node in the path from a vid to next vid."
msgstr ""

msgid ""
"`Boost: Hawick Circuit Algorithm <https://www.boost.org/doc/libs/1_78_0/libs/"
"graph/doc/hawick_circuits.html>`__"
msgstr ""

msgid "``pgr_isPlanar`` - Experimental"
msgstr ""

msgid ""
"``pgr_isPlanar`` — Returns a boolean depending upon the planarity of the "
"graph."
msgstr ""

msgid ""
"A graph is planar if it can be drawn in two-dimensional space with no two of "
"its edges crossing. Such a drawing of a planar graph is called a plane "
"drawing. Every planar graph also admits a straight-line drawing, which is a "
"plane drawing where each edge is represented by a line segment. When a graph "
"has :math:`K_5` or :math:`K_{3, 3}` as subgraph then the graph is not planar."
msgstr ""

msgid "This implementation use the Boyer-Myrvold Planarity Testing."
msgstr ""

msgid ""
"It will return a boolean value depending upon the planarity of the graph."
msgstr ""

msgid "Applicable only for **undirected** graphs."
msgstr ""

msgid "The algorithm does not considers traversal costs in the calculations."
msgstr ""

msgid "Running time: :math:`O(|V|)`"
msgstr ""

msgid "pgr_isPlanar(`Edges SQL`)"
msgstr ""

msgid "RETURNS ``BOOLEAN``"
msgstr ""

msgid "Returns a boolean ``(pgr_isplanar)``"
msgstr ""

msgid "``pgr_isplanar``"
msgstr ""

msgid "`true` when the graph is planar."
msgstr ""

msgid "`false` when the graph is not planar."
msgstr ""

msgid ""
"The following edges will make the subgraph with vertices {10, 15, 11, 16, "
"13} a :math:`K_1` graph."
msgstr ""

msgid ""
"The new graph is not planar because it has a :math:`K_5` subgraph. Edges in "
"blue represent :math:`K_5` subgraph."
msgstr ""

msgid "https://www.boost.org/libs/graph/doc/boyer_myrvold.html"
msgstr ""

msgid "``pgr_johnson``"
msgstr ""

msgid ""
"``pgr_johnson`` - Returns the sum of the costs of the shortest path for each "
"pair of nodes in the graph using Floyd-Warshall algorithm."
msgstr ""

msgid ""
"The Johnson algorithm, is a good choice to calculate the sum of the costs of "
"the shortest path for each pair of nodes in the graph, for *sparse graphs*. "
"It usees the Boost's implementation which runs in :math:`O(V E \\log V)` "
"time,"
msgstr ""

msgid "pgr johnson(`Edges SQL`_, [``directed``])"
msgstr ""

msgid ""
"Boost `Johnson <https://www.boost.org/libs/graph/doc/"
"johnson_all_pairs_shortest.html>`_"
msgstr ""

msgid "``pgr_kruskal``"
msgstr ""

msgid ""
"``pgr_kruskal`` — Minimum spanning tree of a graph using Kruskal's algorithm."
msgstr ""

msgid ""
"This algorithm finds the minimum spanning forest in a possibly disconnected "
"graph using Kruskal's algorithm."
msgstr ""

msgid "EMPTY SET is returned when there are no edges in the graph."
msgstr ""

msgid "pgr_kruskal(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-mst|"
msgstr ""

msgid "Minimum spanning forest"
msgstr ""

msgid ""
"``pgr_kruskalBFS`` — Kruskal's algorithm for Minimum Spanning Tree with "
"breadth First Search ordering."
msgstr ""

msgid "Version 3.7.0"
msgstr ""

msgid ""
"Visits and extracts the nodes information in Breath First Search ordering of "
"the Minimum Spanning Tree created using Kruskal's algorithm."
msgstr ""

msgid "Returned tree nodes from a root vertex are on Breath First Search order"
msgstr ""

msgid "Breath First Search Running time: :math:`O(E + V)`"
msgstr ""

msgid "pgr_kruskalBFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr ""

msgid "pgr_kruskalBFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr ""

msgid "The Minimum Spanning Tree having as root vertex :math:`6`"
msgstr ""

msgid ""
"The Minimum Spanning Tree starting on vertices :math:`\\{9, 6\\}` with :math:"
"`depth \\leq 3`"
msgstr ""

msgid "``pgr_kruskalDD`` — Catchament nodes using Kruskal's algorithm."
msgstr ""

msgid ""
"Using Kruskal's algorithm, extracts the nodes that have aggregate costs less "
"than or equal to a **distance** from a **root** vertex (or vertices) within "
"the calculated minimum spanning tree."
msgstr ""

msgid "Returned tree nodes from a root vertex are on Depth First Search order."
msgstr ""

msgid "Depth First Search running time: :math:`O(E + V)`"
msgstr ""

msgid "pgr_kruskalDD(`Edges SQL`_, **root vid**, **distance**)"
msgstr ""

msgid "pgr_kruskalDD(`Edges SQL`_, **root vids**, **distance**)"
msgstr ""

msgid ""
"The Minimum Spanning Tree starting on vertex :math:`6` with :math:`distance "
"\\leq 3.5`"
msgstr ""

msgid ""
"The Minimum Spanning Tree starting on vertices :math:`\\{9, 6\\}` with :math:"
"`distance \\leq 3.5`"
msgstr ""

msgid ""
"``pgr_kruskalDFS`` — Kruskal's algorithm for Minimum Spanning Tree with "
"Depth First Search ordering."
msgstr ""

msgid ""
"Visits and extracts the nodes information in Depth First Search ordering of "
"the Minimum Spanning Tree created using Kruskal's algorithm."
msgstr ""

msgid "Returned tree nodes from a root vertex are on Depth First Search order"
msgstr ""

msgid "pgr_kruskalDFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr ""

msgid "pgr_kruskalDFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr ""

msgid "pgr_lengauerTarjanDominatorTree -Experimental"
msgstr ""

msgid ""
"``pgr_lengauerTarjanDominatorTree`` — Returns the immediate dominator of all "
"vertices."
msgstr ""

msgid ""
"The algorithm calculates the *immidiate dominator* of each vertex called "
"**idom**, once **idom** of each vertex is calculated then by making every "
"**idom** of each vertex as its parent, the dominator tree can be built."
msgstr ""

msgid "The algorithm works in directed graph only."
msgstr ""

msgid "The algorithm returns *idom* of each vertex."
msgstr ""

msgid ""
"If the *root vertex* not present in the graph then it returns empty set."
msgstr ""

msgid "Running time: :math:`O((V+E)log(V+E))`"
msgstr ""

msgid "pgr_lengauerTarjanDominatorTree(`Edges SQL`_, **root vertex**)"
msgstr ""

msgid "Returns set of |result-idom|"
msgstr ""

msgid "The dominator tree with root vertex :math:`5`"
msgstr ""

msgid "SQL query as described above."
msgstr ""

msgid "**root vertex**"
msgstr ""

msgid "Returns set of ``(seq, vertex_id, idom)``"
msgstr ""

msgid "Identifier of vertex ."
msgstr ""

msgid "``idom``"
msgstr ""

msgid "Immediate dominator of vertex."
msgstr ""

msgid "Dominator tree of another component."
msgstr ""

msgid ""
"`Boost: Lengauer-Tarjan dominator tree algorithm <https://www.boost.org/libs/"
"graph/doc/lengauer_tarjan_dominator.htm>`__"
msgstr ""

msgid ""
"`Wikipedia: dominator tree <https://en.wikipedia.org/wiki/"
"Dominator_(graph_theory)>`__"
msgstr ""

msgid "pgr_lineGraph - Proposed"
msgstr ""

msgid ""
"``pgr_lineGraph`` — Transforms the given graph into its corresponding edge-"
"based graph."
msgstr ""

msgid ""
"Given a graph :math:`G`, its line graph :math:`L(G)` is a graph such that:"
msgstr ""

msgid "Each vertex of :math:`L(G)` represents an edge of :math:`G`."
msgstr ""

msgid ""
"Two vertices of :math:`L(G)` are adjacent if and only if their corresponding "
"edges share a common endpoint in :math:`G`"
msgstr ""

msgid ""
"The ``cost`` and ``reverse_cost`` columns of the result represent existence "
"of the edge."
msgstr ""

msgid "When the graph is directed the result is directed."
msgstr ""

msgid ""
"To get the complete Line Graph use unique identifiers on the double way "
"edges (See `Additional Examples`_)."
msgstr ""

msgid "When the graph is undirected the result is undirected."
msgstr ""

msgid "The ``reverse_cost`` is always :math:`-1`."
msgstr ""

msgid "pgr_lineGraph(`Edges SQL`_, [``directed``])"
msgstr ""

msgid "Returns set of |result-lineg|"
msgstr ""

msgid "For an undirected graph with edges :math:'{2,4,5,8}'"
msgstr ""

msgid "Gives a local identifier for the edge"
msgstr ""

msgid "Identifier of the source vertex of the current edge."
msgstr ""

msgid "When `negative`: the source is the reverse edge in the original graph."
msgstr ""

msgid "Identifier of the target vertex of the current edge."
msgstr ""

msgid "When `negative`: the target is the reverse edge in the original graph."
msgstr ""

msgid "Weight of the edge (``source``, ``target``)."
msgstr ""

msgid ""
"When `negative`: edge (``source``, ``target``) does not exist, therefore "
"it’s not part of the graph."
msgstr ""

msgid "Weight of the edge (``target``, ``source``)."
msgstr ""

msgid ""
"When `negative`: edge (``target``, ``source``) does not exist, therefore "
"it’s not part of the graph."
msgstr ""

msgid "Given the following directed graph"
msgstr ""

msgid ""
":math:`G(V,E) = G(\\{1,2,3,4\\},\\{ 1 \\rightarrow 2, 1 \\rightarrow 4, 2 "
"\\rightarrow 3, 3 \\rightarrow 1, 3 \\rightarrow 2, 3 \\rightarrow 4, 4 "
"\\rightarrow 3\\})`"
msgstr ""

msgid "Representation as directed with shared edge identifiers"
msgstr ""

msgid ""
"For the simplicity, the design of the edges table on the database, has the "
"edge's identifiers are represented with 3 digits:"
msgstr ""

msgid "hundreds"
msgstr ""

msgid "the source vertex"
msgstr ""

msgid "tens"
msgstr ""

msgid "always 0, acts as a separator"
msgstr ""

msgid "units"
msgstr ""

msgid "the target vertex"
msgstr ""

msgid "In this image,"
msgstr ""

msgid ""
"Single or double head arrows represent one edge (row) on the edges table."
msgstr ""

msgid "The numbers in the yellow shadow are the edge identifiers."
msgstr ""

msgid ""
"Two pair of edges share the same identifier when the ``reverse_cost`` column "
"is used."
msgstr ""

msgid ""
"Edges :math:`{2 \\rightarrow 3, 3 \\rightarrow 2}` are represented with one "
"edge row with :math:`id=203`."
msgstr ""

msgid ""
"Edges :math:`{3 \\rightarrow 4, 4 \\rightarrow 3}` are represented with one "
"edge row with :math:`id=304`."
msgstr ""

msgid "The graph can be created as follows:"
msgstr ""

msgid "Line Graph of a directed graph represented with shared edges"
msgstr ""

msgid "The result is a directed graph."
msgstr ""

msgid ""
"For :math:`seq=4` from :math:`203 \\leftrightarrow 304` represent two edges"
msgstr ""

msgid "For all the other values of ``seq`` represent one edge."
msgstr ""

msgid ""
"The ``cost`` and ``reverse_cost`` values represent the existence of the edge."
msgstr ""

msgid "When positive: the edge exists."
msgstr ""

msgid "When negative: the edge does not exist."
msgstr ""

msgid "Representation as directed with unique edge identifiers"
msgstr ""

msgid "Single head arrows represent one edge (row) on the edges table."
msgstr ""

msgid "There are no double head arrows"
msgstr ""

msgid ""
"Two pair of edges share the same ending nodes and the ``reverse_cost`` "
"column is not used."
msgstr ""

msgid ""
"Edges :math:`{2 \\rightarrow 3, 3 \\rightarrow 2}` are represented with two "
"edges :math:`id=203` and :math:`id=302` respectively."
msgstr ""

msgid ""
"Edges :math:`{3 \\rightarrow 4, 4 \\rightarrow 3}` are represented with two "
"edges :math:`id=304` and :math:`id=403` respectively."
msgstr ""

msgid "Line Graph of a directed graph represented with unique edges"
msgstr ""

msgid ""
"For :math:`seq=7` from :math:`203 \\leftrightarrow 302` represent two edges."
msgstr ""

msgid ""
"For :math:`seq=8` from :math:`304 \\leftrightarrow 403` represent two edges."
msgstr ""

msgid "wikipedia: `Line Graph <https://en.wikipedia.org/wiki/Line_graph>`__"
msgstr ""

msgid ""
"mathworld: `Line Graph <https://mathworld.wolfram.com/LineGraph.html>`__"
msgstr ""

msgid "``pgr_lineGraphFull`` - Experimental"
msgstr ""

msgid ""
"``pgr_lineGraphFull`` — Transforms a given graph into a new graph where all "
"of the vertices from the original graph are converted to line graphs."
msgstr ""

msgid "Version 2.6.0"
msgstr ""

msgid ""
"``pgr_lineGraphFull``, converts original directed graph to a directed line "
"graph by converting each vertex to a complete graph and keeping all the "
"original edges. The new connecting edges have a cost 0 and go between the "
"adjacent original edges, respecting the directionality."
msgstr ""

msgid ""
"A possible application of the resulting graph is **\"routing with two edge "
"restrictions\"**:"
msgstr ""

msgid ""
"Setting a cost of using the vertex when routing between edges on the "
"connecting edge"
msgstr ""

msgid "Forbid the routing between two edges by removing the connecting edge"
msgstr ""

msgid ""
"This is possible because each of the intersections (vertices) in the "
"original graph are now complete graphs that have a new edge for each "
"possible turn across that intersection."
msgstr ""

msgid "This function is for **directed** graphs."
msgstr ""

msgid ""
"Results are undefined when a negative vertex id is used in the input graph."
msgstr ""

msgid ""
"Results are undefined when a duplicated edge id is used in the input graph."
msgstr ""

msgid "Running time: TBD"
msgstr ""

msgid "pgr_lineGraphFull(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-linegf|"
msgstr ""

msgid "Full line graph of subgraph of edges :math:`\\{4, 7, 8, 10\\}`"
msgstr ""

msgid ""
"The examples of this section are based on the :doc:`sampledata` network. The "
"examples include the subgraph including edges 4, 7, 8, and 10 with "
"``reverse_cost``."
msgstr ""

msgid "The data"
msgstr ""

msgid ""
"This example displays how this graph transformation works to create "
"additional edges for each possible turn in a graph."
msgstr ""

msgid "|first|"
msgstr ""

msgid "first"
msgstr ""

msgid "The transformation"
msgstr ""

msgid "|second|"
msgstr ""

msgid "second"
msgstr ""

msgid ""
"In the transformed graph, all of the edges from the original graph are still "
"present (yellow), but we now have additional edges for every turn that could "
"be made across vertex 7 (orange)."
msgstr ""

msgid "Creating table that identifies transformed vertices"
msgstr ""

msgid ""
"The vertices in the transformed graph are each created by splitting up the "
"vertices in the original graph. Unless a vertex in the original graph is a "
"leaf vertex, it will generate more than one vertex in the transformed graph. "
"One of the newly created vertices in the transformed graph will be given the "
"same vertex identifier as the vertex that it was created from in the "
"original graph, but the rest of the newly created vertices will have "
"negative vertex ids."
msgstr ""

msgid ""
"Following is an example of how to generate a table that maps the ids of the "
"newly created vertices with the original vertex that they were created from"
msgstr ""

msgid "Store edge results"
msgstr ""

msgid ""
"The first step is to store the results of the ``pgr_lineGraphFull`` call "
"into a table"
msgstr ""

msgid "Create the mapping table"
msgstr ""

msgid "From the original graph's vertex information"
msgstr ""

msgid "Add the new vertices"
msgstr ""

msgid "Filling the mapping table"
msgstr ""

msgid "The positive vertex identifiers are the original identifiers"
msgstr ""

msgid "Inspecting the vertices map"
msgstr ""

msgid ""
"The self loops happen when there is no cost traveling to the ``target`` and "
"the source has an original value."
msgstr ""

msgid "Updating values from self loops"
msgstr ""

msgid "Inspecting the vertices table"
msgstr ""

msgid "Updating from inner self loops"
msgstr ""

msgid "Adding a soft restriction"
msgstr ""

msgid ""
"A soft restriction going from vertex 6 to vertex 3 using edges 4 -> 7 is "
"wanted."
msgstr ""

msgid "Idenifying the restriction"
msgstr ""

msgid ""
"Running a :doc:`pgr_dijkstraNear` the edge with cost 0, edge 8, is where the "
"cost will be increased"
msgstr ""

msgid ""
"The edge to be altered is ``WHERE cost = 0 AND seq != 1 AND edge != -1`` "
"from the previus query:"
msgstr ""

msgid "Adding a value to the restriction"
msgstr ""

msgid "Updating the cost to the edge:"
msgstr ""

msgid "Routing from :math:`6` to :math:`3`"
msgstr ""

msgid "Now the route does not use edge 8 and does a U turn on a leaf vertex."
msgstr ""

msgid "Simplifying leaf vertices"
msgstr ""

msgid ""
"In this example, there is no additional cost for traversing a leaf vertex."
msgstr ""

msgid "Using the vertex map give the leaf verices their original value."
msgstr ""

msgid "On the source column"
msgstr ""

msgid "On the target column"
msgstr ""

msgid "Removing self loops on leaf nodes"
msgstr ""

msgid "The self loops of the leaf nodes are"
msgstr ""

msgid "Which can be removed"
msgstr ""

msgid ""
"Routing can be done now using the original vertices id using :doc:"
"`pgr_dijkstra`"
msgstr ""

msgid "Complete routing graph"
msgstr ""

msgid "Add edges from the original graph"
msgstr ""

msgid ""
"Add all the edges that are not involved in the line graph process to the new "
"table"
msgstr ""

msgid "Some administrative tasks to get new identifiers for the edges"
msgstr ""

msgid "Add the newly calculated edges"
msgstr ""

msgid "Using the routing graph"
msgstr ""

msgid ""
"When using this method for routing with soft restrictions there will be "
"uturns"
msgstr ""

msgid "Routing from :math:`5` to :math:`1`"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Line_graph"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Complete_graph"
msgstr ""

msgid "``pgr_makeConnected`` - Experimental"
msgstr ""

msgid "``pgr_makeConnected`` — Set of edges that will connect the graph."
msgstr ""

msgid ""
"Adds the minimum number of edges needed to make the input graph connected. "
"The algorithm first identifies all of the connected components in the graph, "
"then adds edges to connect those components together in a path. For example, "
"if a graph contains three connected components A, B, and C, make_connected "
"will add two edges. The two edges added might consist of one connecting a "
"vertex in A with a vertex in B and one connecting a vertex in B with a "
"vertex in C."
msgstr ""

msgid ""
"It will give a minimum list of all edges which are needed in the graph to "
"make connect it."
msgstr ""

msgid ""
"The algorithm does not considers geometric topology in the calculations."
msgstr ""

msgid "pgr_makeConnected(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-component-make|"
msgstr ""

msgid ""
"Query done on :doc:`sampledata` network gives the list of edges that are "
"needed to connect the graph."
msgstr ""

msgid "https://www.boost.org/libs/graph/doc/make_connected.html"
msgstr ""

msgid "pgr_maxCardinalityMatch"
msgstr ""

msgid ""
"``pgr_maxCardinalityMatch`` — Calculates a maximum cardinality matching in a "
"graph."
msgstr ""

msgid "Deprecated signature"
msgstr ""

msgid "``pgr_maxCardinalityMatch(text,boolean)``"
msgstr ""

msgid "``directed => false`` when used."
msgstr ""

msgid "Renamed from ``pgr_maximumCardinalityMatching``"
msgstr ""

msgid ""
"A matching or independent edge set in a graph is a set of edges without "
"common vertices."
msgstr ""

msgid ""
"A maximum matching is a matching that contains the largest possible number "
"of edges."
msgstr ""

msgid "There may be many maximum matchings."
msgstr ""

msgid "Calculates one possible maximum cardinality matching in a graph."
msgstr ""

msgid "Running time: :math:`O( E*V * \\alpha(E,V))`"
msgstr ""

msgid ":math:`\\alpha(E,V)` is the inverse of the `Ackermann function`_."
msgstr ""

msgid "pgr_maxCardinalityMatch(`Edges SQL`_)"
msgstr ""

msgid "Using all edges."
msgstr ""

msgid ""
"SQL query, which should return a set of rows with the following columns:"
msgstr ""

msgid ""
"A positive value represents the existence of the edge (``source``, "
"``target``)."
msgstr ""

msgid ""
"A positive value represents the existence of the edge (``target``, "
"``source``)"
msgstr ""

msgid "Identifier of the edge in the original query."
msgstr ""

msgid "https://www.boost.org/libs/graph/doc/maximum_matching.html"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Matching_%28graph_theory%29"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Ackermann_function"
msgstr ""

msgid "``pgr_maxFlow``"
msgstr ""

msgid ""
"``pgr_maxFlow`` — Calculates the maximum flow in a directed graph from the "
"source(s) to the targets(s) using the Push Relabel algorithm."
msgstr ""

msgid "``pgr_maxFlow`` (`Combinations`_)"
msgstr ""

msgid "New **Proposed** function"
msgstr ""

msgid "Calculates the maximum flow from the `source(s)` to the `target(s)`."
msgstr ""

msgid ""
"When the maximum flow is **0** then there is no flow and **0** is returned."
msgstr ""

msgid "Uses the :doc:`pgr_pushRelabel <pgr_pushRelabel>` algorithm."
msgstr ""

msgid "Running time: :math:`O( V ^ 3)`"
msgstr ""

msgid "pgr_maxFlow(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_maxFlow(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_maxFlow(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_maxFlow(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_maxFlow(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "RETURNS ``BIGINT``"
msgstr ""

msgid "Maximum flow possible from the source(s) to the target(s)"
msgstr ""

msgid "https://www.boost.org/libs/graph/doc/push_relabel_max_flow.html"
msgstr ""

msgid ""
"https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm"
msgstr ""

msgid "``pgr_maxFlowMinCost`` - Experimental"
msgstr ""

msgid ""
"``pgr_maxFlowMinCost`` — Calculates the edges that minimizes the total cost "
"of the maximum flow on a graph"
msgstr ""

msgid "``pgr_maxFlowMinCost`` (`Combinations`_)"
msgstr ""

msgid "**TODO** check which statement is true:"
msgstr ""

msgid "The cost value of all input edges must be nonnegative."
msgstr ""

msgid "Process is done when the cost value of all input edges is nonnegative."
msgstr ""

msgid "Process is done on edges with nonnegative cost."
msgstr ""

msgid "Running time: :math:`O(U * (E + V * logV))`"
msgstr ""

msgid "where :math:`U` is the value of the max flow."
msgstr ""

msgid ""
":math:`U` is upper bound on number of iterations. In many real world cases "
"number of iterations is much smaller than :math:`U`."
msgstr ""

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_maxFlowMinCost(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_maxFlowMinCost(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "Returns set of |result-flow-mincost|"
msgstr ""

msgid ""
"https://www.boost.org/libs/graph/doc/"
"successive_shortest_path_nonnegative_weights.html"
msgstr ""

msgid "``pgr_maxFlowMinCost_Cost`` - Experimental"
msgstr ""

msgid ""
"``pgr_maxFlowMinCost_Cost`` — Calculates the minimum total cost of the "
"maximum flow on a graph"
msgstr ""

msgid "``pgr_maxFlowMinCost_Cost`` (`Combinations`_)"
msgstr ""

msgid "**The cost value of all input edges must be nonnegative.**"
msgstr ""

msgid "When the maximum flow is 0 then there is no flow and **0** is returned."
msgstr ""

msgid "Uses :doc:`pgr_maxFlowMinCost`."
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "RETURNS FLOAT"
msgstr ""

msgid "Minimum Cost Maximum Flow possible from the source(s) to the target(s)"
msgstr ""

msgid "pgr_nodeNetwork"
msgstr ""

msgid "``pgr_nodeNetwork`` - Nodes an network edge table."
msgstr ""

msgid "Author"
msgstr ""

msgid "Nicolas Ribot"
msgstr ""

msgid "Copyright"
msgstr ""

msgid "Nicolas Ribot, The source code is released under the MIT-X license."
msgstr ""

msgid ""
"The function reads edges from a not \"noded\" network table and writes the "
"\"noded\" edges into a new table."
msgstr ""

msgid ""
"A common problem associated with bringing GIS data into pgRouting is the "
"fact that the data is often not \"noded\" correctly. This will create "
"invalid topologies, which will result in routes that are incorrect."
msgstr ""

msgid ""
"What we mean by \"noded\" is that at every intersection in the road network "
"all the edges will be broken into separate road segments. There are cases "
"like an over-pass and under-pass intersection where you can not traverse "
"from the over-pass to the under-pass, but this function does not have the "
"ability to detect and accommodate those situations."
msgstr ""

msgid ""
"This function reads the ``edge_table`` table, that has a primary key column "
"``id`` and geometry column named ``the_geom`` and intersect all the segments "
"in it against all the other segments and then creates a table "
"``edge_table_noded``. It uses the ``tolerance`` for deciding that multiple "
"nodes within the tolerance are considered the same node."
msgstr ""

msgid "``float8`` tolerance for coincident points (in projection unit)dd"
msgstr ""

msgid "table_ending"
msgstr ""

msgid "``text`` Suffix for the new table's. Default value is ``noded``."
msgstr ""

msgid "The output table will have for ``edge_table_noded``"
msgstr ""

msgid "``bigint`` Unique identifier for the table"
msgstr ""

msgid "old_id"
msgstr ""

msgid "``bigint`` Identifier of the edge in original table"
msgstr ""

msgid "sub_id"
msgstr ""

msgid "``integer`` Segment number of the original edge"
msgstr ""

msgid ""
"``integer`` Empty source column to be used with :doc:`pgr_createTopology` "
"function"
msgstr ""

msgid ""
"``integer`` Empty target column to be used with :doc:`pgr_createTopology` "
"function"
msgstr ""

msgid "the geom"
msgstr ""

msgid "``geometry`` Geometry column of the noded network"
msgstr ""

msgid "Examples"
msgstr ""

msgid "Let's create the topology for the data in :doc:`sampledata`"
msgstr ""

msgid "Now we can analyze the network."
msgstr ""

msgid ""
"The analysis tell us that the network has a gap and an intersection. We try "
"to fix the problem using:"
msgstr ""

msgid ""
"Inspecting the generated table, we can see that edges 13,14 and 18 has been "
"segmented"
msgstr ""

msgid "We can create the topology of the new network"
msgstr ""

msgid "Now let's analyze the new topology"
msgstr ""

msgid "Images"
msgstr ""

msgid "Before Image"
msgstr ""

msgid "Before image"
msgstr ""

msgid "After Image"
msgstr ""

msgid "After image"
msgstr ""

msgid "Comparing the results"
msgstr ""

msgid "Comparing with the Analysis in the original edge_table, we see that."
msgstr ""

msgid "Before"
msgstr ""

msgid "After"
msgstr ""

msgid "Table name"
msgstr ""

msgid "edge_table_noded"
msgstr ""

msgid "Fields"
msgstr ""

msgid "All original fields"
msgstr ""

msgid "Has only basic fields to do a topology analysis"
msgstr ""

msgid "Edges with 1 dead end: 1,6,24"
msgstr ""

msgid "Edges with 2 dead ends: 17,18"
msgstr ""

msgid ""
"Edge 17's right node is a dead end because there is no other edge sharing "
"that same node. (cnt=1)"
msgstr ""

msgid "Edges with 1 dead end: 1-1 ,6-1,14-2, 18-1 17-1 18-2"
msgstr ""

msgid "Isolated segments"
msgstr ""

msgid "two isolated segments: 17 and 18 both they have 2 dead ends"
msgstr ""

msgid "No Isolated segments"
msgstr ""

msgid "Edge 17 now shares a node with edges 14-1 and 14-2"
msgstr ""

msgid "Edges 18-1 and 18-2 share a node with edges 13-1 and 13-2"
msgstr ""

msgid "Gaps"
msgstr ""

msgid ""
"There is a gap between edge 17 and 14 because edge 14 is near to the right "
"node of edge 17"
msgstr ""

msgid ""
"Edge 14 was segmented Now edges: 14-1 14-2 17 share the same node The "
"tolerance value was taken in account"
msgstr ""

msgid "Intersections"
msgstr ""

msgid "Edges 13 and 18 were intersecting"
msgstr ""

msgid ""
"Edges were segmented, So, now in the interection's point there is a node and "
"the following edges share it: 13-1 13-2 18-1 18-2"
msgstr ""

msgid ""
"Now, we are going to include the segments 13-1, 13-2 14-1, 14-2 ,18-1 and "
"18-2 into our edge-table, copying the data for dir,cost,and reverse cost "
"with tho following steps:"
msgstr ""

msgid ""
"Add a column old_id into edge_table, this column is going to keep track the "
"id of the original edge"
msgstr ""

msgid "Insert only the segmented edges, that is, the ones whose max(sub_id) >1"
msgstr ""

msgid "We recreate the topology:"
msgstr ""

msgid ""
"To get the same analysis results as the topology of edge_table_noded, we do "
"the following query:"
msgstr ""

msgid ""
"To get the same analysis results as the original edge_table, we do the "
"following query:"
msgstr ""

msgid ""
"Or we can analyze everything because, maybe edge 18 is an overpass, edge 14 "
"is an under pass and there is also a street level juction, and the same "
"happens with edges 17 and 13."
msgstr ""

msgid ""
":doc:`topology-functions` for an overview of a topology for routing "
"algorithms. :doc:`pgr_analyzeOneWay` to analyze directionality of the "
"edges. :doc:`pgr_createTopology` to create a topology based on the "
"geometry. :doc:`pgr_analyzeGraph` to analyze the edges and vertices of the "
"edge table."
msgstr ""

msgid "``pgr_pickDeliver`` - Experimental"
msgstr ""

msgid "``pgr_pickDeliver`` - Pickup and delivery Vehicle Routing Problem"
msgstr ""

msgid ""
"Problem: Distribute and optimize the pickup-delivery pairs into a fleet of "
"vehicles."
msgstr ""

msgid "Optimization problem is NP-hard."
msgstr ""

msgid "pickup and Delivery with time windows."
msgstr ""

msgid "All vehicles are equal."
msgstr ""

msgid "Same Starting location."
msgstr ""

msgid "Same Ending location which is the same as Starting location."
msgstr ""

msgid "All vehicles travel at the same speed."
msgstr ""

msgid "A customer is for doing a pickup or doing a deliver."
msgstr ""

msgid "has an open time."
msgstr ""

msgid "has a closing time."
msgstr ""

msgid "has a service time."
msgstr ""

msgid "has an (x, y) location."
msgstr ""

msgid "There is a customer where to deliver a pickup."
msgstr ""

msgid "travel time between customers is distance / speed"
msgstr ""

msgid "pickup and delivery pair is done with the same vehicle."
msgstr ""

msgid "All trucks depart at time 0."
msgstr ""

msgid "the algorithm will raise an exception when"
msgstr ""

msgid "If there is a pickup-deliver pair than violates time window"
msgstr ""

msgid "The speed, max_cycles, ma_capacity have illegal values"
msgstr ""

msgid ""
"Six different initial will be optimized - the best solution found will be "
"result"
msgstr ""

msgid "Signature"
msgstr ""

msgid ""
"pgr_pickDeliver(`Orders SQL`_, `Vehicles SQL`_, `Matrix SQL`_, [**options**])"
msgstr ""

msgid "**options:** ``[factor, max_cycles, initial_sol]``"
msgstr ""

msgid "Returns set of |result-pickdrop|"
msgstr ""

msgid "Solve the following problem"
msgstr ""

msgid "Given the vehicles:"
msgstr ""

msgid "and the orders:"
msgstr ""

msgid "The parameters are:"
msgstr ""

msgid "A `SELECT` statement that returns the following columns:"
msgstr ""

msgid "id, demand"
msgstr ""

msgid "p_node_id, p_open, p_close, [p_service,]"
msgstr ""

msgid "d_node_id, d_open, d_close, [d_service,]"
msgstr ""

msgid "id, capacity"
msgstr ""

msgid "start_node_id, start_open, start_close [, start_service,]"
msgstr ""

msgid "[end_node_id, end_open, end_close, end_service]"
msgstr ""

msgid "``pgr_pickDeliverEuclidean`` - Experimental"
msgstr ""

msgid ""
"``pgr_pickDeliverEuclidean`` - Pickup and delivery Vehicle Routing Problem"
msgstr ""

msgid "Replaces ``pgr_gsoc_vrppdtw``"
msgstr ""

msgid "Pickup and Delivery:"
msgstr ""

msgid "capacitated"
msgstr ""

msgid "with time windows."
msgstr ""

msgid "have (x, y) start and ending locations."
msgstr ""

msgid "have a start and ending service times."
msgstr ""

msgid "An order is for doing a pickup and a a deliver."
msgstr ""

msgid "has (x, y) pickup and delivery locations."
msgstr ""

msgid "has opening and closing times for the pickup and delivery locations."
msgstr ""

msgid "has a pickup and deliver service times."
msgstr ""

msgid "Six different optional different initial solutions"
msgstr ""

msgid "the best solution found will be result"
msgstr ""

msgid "pgr_pickDeliverEuclidean(`Orders SQL`_, `Vehicles SQL`_, [**options**])"
msgstr ""

msgid "p_x, p_y, p_open, p_close, [p_service,]"
msgstr ""

msgid "d_x, d_y, d_open, d_close, [d_service]"
msgstr ""

msgid "start_x, start_y, start_open, start_close [, start_service, ]"
msgstr ""

msgid "[ end_x, end_y, end_open, end_close, end_service ]"
msgstr ""

msgid ""
"This data example **lc101** is from data published at https://www.sintef.no/"
"projectweb/top/pdptw/li-lim-benchmark/"
msgstr ""

msgid "There are 25 vehciles in the problem all with the same characteristics."
msgstr ""

msgid "The original orders"
msgstr ""

msgid ""
"The data comes in different rows for the pickup and the delivery of the same "
"order."
msgstr ""

msgid "The original data needs to be converted to an appropiate table:"
msgstr ""

msgid "The query"
msgstr ""

msgid ""
"Showing only the relevant information to compare with the best solution "
"information published on https://www.sintef.no/projectweb/top/pdptw/100-"
"customers/"
msgstr ""

msgid "The best solution found for **lc101** is a travel time: 828.94"
msgstr ""

msgid "This implementation's travel time: 854.54"
msgstr ""

msgid "``pgr_prim``"
msgstr ""

msgid ""
"``pgr_prim`` — Minimum spanning forest of a graph using Prim's algorithm."
msgstr ""

msgid ""
"This algorithm finds the minimum spanning forest in a possibly disconnected "
"graph using Prim's algorithm."
msgstr ""

msgid "Prim's running time: :math:`O(E * log V)`"
msgstr ""

msgid "pgr_prim(`Edges SQL`_)"
msgstr ""

msgid "Minimum spanning forest of a subgraph"
msgstr ""

msgid ""
"`Boost: Prim's algorithm documentation <https://www.boost.org/libs/graph/doc/"
"prim_minimum_spanning_tree.html>`__"
msgstr ""

msgid ""
"``pgr_primBFS`` — Prim's algorithm for Minimum Spanning Tree with Depth "
"First Search ordering."
msgstr ""

msgid ""
"Visits and extracts the nodes information in Breath First Search ordering of "
"the Minimum Spanning Tree created using Prims's algorithm."
msgstr ""

msgid "pgr_primBFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr ""

msgid "pgr_primBFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr ""

msgid "``pgr_primDD`` — Catchament nodes using Prim's algorithm."
msgstr ""

msgid ""
"Using Prim's algorithm, extracts the nodes that have aggregate costs less "
"than or equal to a distance from a root vertex (or vertices) within the "
"calculated minimum spanning tree."
msgstr ""

msgid "pgr_primDD(`Edges SQL`_, **root vid**, **distance**)"
msgstr ""

msgid "pgr_primDD(`Edges SQL`_, **root vids**, **distance**)"
msgstr ""

msgid ""
"``pgr_primDFS`` — Prim algorithm for Minimum Spanning Tree with Depth First "
"Search ordering."
msgstr ""

msgid ""
"Visits and extracts the nodes information in Depth First Search ordering of "
"the Minimum Spanning Tree created using Prims's algorithm."
msgstr ""

msgid "pgr_primDFS(`Edges SQL`_, **root vid**, [``max_depth``])"
msgstr ""

msgid "pgr_primDFS(`Edges SQL`_, **root vids**, [``max_depth``])"
msgstr ""

msgid "``pgr_pushRelabel``"
msgstr ""

msgid ""
"``pgr_pushRelabel`` — Calculates the flow on the graph edges that maximizes "
"the flow from the sources to the targets using Push Relabel Algorithm."
msgstr ""

msgid "``pgr_pushRelabel`` (`Combinations`_)"
msgstr ""

msgid "Renamed from ``pgr_maxFlowPushRelabel``"
msgstr ""

msgid "pgr_pushRelabel(`Edges SQL`_, **start vid**, **end vid**)"
msgstr ""

msgid "pgr_pushRelabel(`Edges SQL`_, **start vid**, **end vids**)"
msgstr ""

msgid "pgr_pushRelabel(`Edges SQL`_, **start vids**, **end vid**)"
msgstr ""

msgid "pgr_pushRelabel(`Edges SQL`_, **start vids**, **end vids**)"
msgstr ""

msgid "pgr_pushRelabel(`Edges SQL`_, `Combinations SQL`_)"
msgstr ""

msgid "pgr_sequentialVertexColoring - Proposed"
msgstr ""

msgid ""
"``pgr_sequentialVertexColoring`` — Returns the vertex coloring of an "
"undirected graph, using greedy approach."
msgstr ""

msgid "Promoted to **proposed** signature"
msgstr ""

msgid ""
"Sequential vertex coloring algorithm is a graph coloring algorithm in which "
"color identifiers are assigned to the vertices of a graph in a sequential "
"manner, such that no edge connects two identically colored vertices."
msgstr ""

msgid "The implementation is applicable only for **undirected** graphs."
msgstr ""

msgid ""
"Provides the color to be assigned to all the vertices present in the graph."
msgstr ""

msgid "Color identifiers values are in the Range :math:`[1, |V|]`"
msgstr ""

msgid "The algorithm tries to assign the least possible color to every vertex."
msgstr ""

msgid ""
"Efficient graph coloring is an NP-Hard problem, and therefore, this "
"algorithm does not always produce optimal coloring. It follows a greedy "
"strategy by iterating through all the vertices sequentially, and assigning "
"the smallest possible color that is not used by its neighbors, to each "
"vertex."
msgstr ""

msgid "The returned rows are ordered in ascending order of the vertex value."
msgstr ""

msgid "Sequential Vertex Coloring Running Time: :math:`O(|V|*(d + k))`"
msgstr ""

msgid ":math:`d` is the maximum degree of the vertices in the graph,"
msgstr ""

msgid ":math:`k` is the number of colors used."
msgstr ""

msgid "pgr_sequentialVertexColoring(`Edges SQL`_)"
msgstr ""

msgid "pgr_stoerWagner - Experimental"
msgstr ""

msgid "``pgr_stoerWagner`` — The min-cut of graph using stoerWagner algorithm."
msgstr ""

msgid "Version 3.0"
msgstr ""

msgid ""
"In graph theory, the Stoer–Wagner algorithm is a recursive algorithm to "
"solve the minimum cut problem in undirected weighted graphs with non-"
"negative weights. The essential idea of this algorithm is to shrink the "
"graph by merging the most intensive vertices, until the graph only contains "
"two combined vertex sets. At each phase, the algorithm finds the minimum s-t "
"cut for two vertices s and t chosen as its will. Then the algorithm shrinks "
"the edge between s and t to search for non s-t cuts. The minimum cut found "
"in all phases will be the minimum weighted cut of the graph."
msgstr ""

msgid ""
"A cut is a partition of the vertices of a graph into two disjoint subsets. A "
"minimum cut is a cut for which the size or weight of the cut is not larger "
"than the size of any other cut. For an unweighted graph, the minimum cut "
"would simply be the cut with the least edges. For a weighted graph, the sum "
"of all edges' weight on the cut determines whether it is a minimum cut."
msgstr ""

msgid "Sum of the weights of all edges between the two sets is mincut."
msgstr ""

msgid "A **mincut** is a cut having the least weight."
msgstr ""

msgid "Values are returned when graph is connected."
msgstr ""

msgid "When there is no edge in graph then EMPTY SET is return."
msgstr ""

msgid "When the graph is unconnected then EMPTY SET is return."
msgstr ""

msgid ""
"Sometimes a graph has multiple min-cuts, but all have the same weight. The "
"this function determines exactly one of the min-cuts as well as its weight."
msgstr ""

msgid "Running time: :math:`O(V*E + V^2*log V)`."
msgstr ""

msgid "pgr_stoerWagner(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-mincut|"
msgstr ""

msgid "min cut of the main subgraph"
msgstr ""

msgid "Returns set of ``(seq, edge, cost, mincut)``"
msgstr ""

msgid "Edges which divides the set of vertices into two."
msgstr ""

msgid "Cost to traverse of edge."
msgstr ""

msgid "**mincut**"
msgstr ""

msgid "Min-cut weight of a undirected graph."
msgstr ""

msgid "Additional Example:"
msgstr ""

msgid "min cut of an edge"
msgstr ""

msgid "Using :doc:`pgr_connectedComponents`"
msgstr ""

msgid "https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm"
msgstr ""

msgid "``pgr_strongComponents``"
msgstr ""

msgid ""
"``pgr_strongComponents`` — Strongly connected components of a directed graph "
"using Tarjan's algorithm based on DFS."
msgstr ""

msgid ""
"A strongly connected component of a directed graph is a set of vertices that "
"are all reachable from each other."
msgstr ""

msgid "Works for **directed** graphs."
msgstr ""

msgid "Components are described by vertices identifiers."
msgstr ""

msgid "pgr_strongComponents(`Edges SQL`_)"
msgstr ""

msgid "The strong components of the graph"
msgstr ""

msgid ""
"Boost: `Strong components <https://www.boost.org/libs/graph/doc/"
"strong_components.html>`__"
msgstr ""

msgid ""
"wikipedia: `Strongly connected component <https://en.wikipedia.org/wiki/"
"Strongly_connected_component>`__"
msgstr ""

msgid "``pgr_topologicalSort`` - Experimental"
msgstr ""

msgid ""
"``pgr_topologicalSort`` — Linear ordering of the vertices for directed "
"acyclic graphs (DAG)."
msgstr ""

msgid ""
"The topological sort algorithm creates a linear ordering of the vertices "
"such that if edge :math:`(u,v)` appears in the graph, then :math:`v` comes "
"before :math:`u` in the ordering."
msgstr ""

msgid ""
"Process is valid for directed acyclic graphs only. otherwise it will throw "
"warnings."
msgstr ""

msgid ""
"For optimization purposes, if there are more than one answer, the function"
msgstr ""

msgid "will return one of them."
msgstr ""

msgid "The returned values are ordered in topological order:"
msgstr ""

msgid "pgr_topologicalSort(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-toposort|"
msgstr ""

msgid "Topologically sorting the graph"
msgstr ""

msgid "Sequential value starting from :math:`1`"
msgstr ""

msgid "``sorted_v``"
msgstr ""

msgid "Linear topological ordering of the vertices"
msgstr ""

msgid "Additional examples"
msgstr ""

msgid "Topologically sorting the one way segments"
msgstr ""

msgid "Graph is not a DAG"
msgstr ""

msgid "``pgr_transitiveClosure`` - Experimental"
msgstr ""

msgid ""
"``pgr_transitiveClosure`` — Transitive closure graph of a directed graph."
msgstr ""

msgid ""
"Transforms the input directed graph into the transitive closure of the graph."
msgstr ""

msgid "Process is valid for directed graphs."
msgstr ""

msgid "The transitive closure of an undirected graph produces a cluster graph"
msgstr ""

msgid ""
"Reachability between vertices on an undirected graph happens when they "
"belong to the same connected component. (see :doc:`pgr_connectedComponents`)"
msgstr ""

msgid "The returned values are not ordered"
msgstr ""

msgid "The returned graph is compresed"
msgstr ""

msgid "Running time: :math:`O(|V||E|)`"
msgstr ""

msgid "The pgr_transitiveClosure function has the following signature:"
msgstr ""

msgid "pgr_transitiveClosure(`Edges SQL`_)"
msgstr ""

msgid "Returns set of |result-closure|"
msgstr ""

msgid "Rechability of a subgraph"
msgstr ""

msgid "``vid``"
msgstr ""

msgid "Identifier of the source of the edges"
msgstr ""

msgid "``target_array``"
msgstr ""

msgid "Identifiers of the targets of the edges"
msgstr ""

msgid "Identifiers of the vertices that are reachable from vertex v."
msgstr ""

msgid "https://en.wikipedia.org/wiki/Transitive_closure"
msgstr ""

msgid "pgr_trsp - Proposed"
msgstr ""

msgid "``pgr_trsp`` - routing vertices with restrictions."
msgstr ""

msgid "New proposed signatures"
msgstr ""

msgid "``pgr_trsp`` (`One to One`_)"
msgstr ""

msgid "``pgr_trsp`` (`One to Many`_)"
msgstr ""

msgid "``pgr_trsp`` (`Many to One`_)"
msgstr ""

msgid "``pgr_trsp`` (`Many to Many`_)"
msgstr ""

msgid "``pgr_trsp`` (`Combinations`_)"
msgstr ""

msgid "Deprecated signatures"
msgstr ""

msgid "``pgr_trsp(text,integer,integer,boolean,boolean,text)``"
msgstr ""

msgid "``pgr_trsp(text,integer,float,integer,float,boolean,boolean,text)``"
msgstr ""

msgid "``pgr_trspViaVertices(text,anyarray,boolean,boolean,text)``"
msgstr ""

msgid ""
"``pgr_trspviaedges(text,integer[],double precision[],boolean,boolean,text)``"
msgstr ""

msgid "New prototypes"
msgstr ""

msgid "``pgr_trspViaVertices``"
msgstr ""

msgid "``pgr_trspViaEdges``"
msgstr ""

msgid ""
"Turn restricted shortest path (TRSP) is an algorithm that receives turn "
"restrictions in form of a query like those found in real world navigable "
"road networks."
msgstr ""

msgid ""
"It does no guarantee the shortest path as it might contain restriction paths."
msgstr ""

msgid "The general algorithm is as follows:"
msgstr ""

msgid "Execute a Dijkstra."
msgstr ""

msgid "If the solution passes thru a restriction then."
msgstr ""

msgid "Execute the **TRSP** algorithm with restrictions."
msgstr ""

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vid**, **end vids**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vids**, **end vid**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, **start vids**, **end vids**, "
"[``directed``])"
msgstr ""

msgid ""
"pgr_trsp(`Edges SQL`_, `Restrictions SQL`_, `Combinations SQL`_, "
"[``directed``])"
msgstr ""

msgid "From vertex :math:`6` to vertex :math:`10` on an undirected graph."
msgstr ""

msgid ""
"From vertex :math:`6` to vertices :math:`\\{10, 1\\}` on an undirected graph."
msgstr ""

msgid ""
"From vertices :math:`\\{6, 1\\}` to vertex :math:`8` on a directed graph."
msgstr ""

msgid ""
"From vertices :math:`\\{6, 1\\}` to vertices :math:`\\{10, 8\\}` on an "
"undirected graph."
msgstr ""

msgid "Using a combinations table on an undirected graph."
msgstr ""

msgid ""
"`Deprecated documentation <https://docs.pgrouting.org/3.3/en/pgr_trsp.html>`_"
msgstr ""

msgid "``pgr_trspVia`` - Proposed"
msgstr ""

msgid ""
"``pgr_trspVia`` Route that goes through a list of vertices with restrictions."
msgstr ""

msgid "New proposed function:"
msgstr ""

msgid "``pgr_trspVia`` (`One Via`_)"
msgstr ""

msgid ""
"Given a list of vertices and a graph, this function is equivalent to finding "
"the shortest path between :math:`vertex_i` and :math:`vertex_{i+1}` for all :"
"math:`i < size\\_of(via\\;vertices)` trying not to use restricted paths."
msgstr ""

msgid "The paths represents the sections of the route."
msgstr ""

msgid "Execute a :doc:`pgr_dijkstraVia`."
msgstr ""

msgid ""
"For the set of sub paths of the solution that pass through a restriction then"
msgstr ""

msgid "Execute the **TRSP** algorithm with restrictions for the paths."
msgstr ""

msgid "**NOTE** when this is done, ``U_turn_on_edge`` flag is ignored."
msgstr ""

msgid ""
"pgr_trspVia(`Edges SQL`_, `Restrictions SQL`_, **via vertices**, "
"[**options**])"
msgstr ""

msgid ""
"Find the route that visits the vertices :math:`\\{ 5, 1, 8\\}` in that order "
"on an directed graph."
msgstr ""

msgid ""
"All this examples are about the route that visits the vertices :math:`\\{5, "
"7, 1, 8, 15\\}` in that order on a directed graph."
msgstr ""

msgid "Simulation of how algorithm works."
msgstr ""

msgid "The algorithm performs a :doc:`pgr_dijkstraVia`"
msgstr ""

msgid ""
"Detects which of the sub paths pass through a restriction in this case is "
"for the ``path_id = 5`` from ``6`` to ``3`` because the path :math:`15 "
"\\rightarrow 1` is restricted."
msgstr ""

msgid "Executes the :doc:`pgr_trsp` algorithm for the conflicting paths."
msgstr ""

msgid ""
"From the :doc:`pgr_dijkstraVia` result it removes the conflicting paths and "
"builds the solution with the results of the :doc:`pgr_trsp` algorithm:"
msgstr ""

msgid "Getting the same result as ``pgr_trspVia``:"
msgstr ""

msgid "Sometimes ``U_turn_on_edge`` flag is ignored when is set to ``false``."
msgstr ""

msgid ""
"The first step, doing a :doc:`pgr_dijkstraVia` does consider not making a U "
"turn on the same edge. But the path :math:`16 \\rightarrow 13` (Rows 4 and "
"5) is restricted and the result is using it."
msgstr ""

msgid ""
"When executing the :doc:`pgr_trsp` algorithm for the conflicting path, there "
"is no ``U_turn_on_edge`` flag."
msgstr ""

msgid ""
"Therefore the result ignores the ``U_turn_on_edge`` flag when set to "
"``false``."
msgstr ""

msgid ":doc:`via-category`"
msgstr ""

msgid "``pgr_trspVia_withPoints`` - Proposed"
msgstr ""

msgid ""
"``pgr_trspVia_withPoints`` - Route that goes through a list of vertices and/"
"or points with restrictions."
msgstr ""

msgid "``pgr_trspVia_withPoints`` (`One Via`_)"
msgstr ""

msgid ""
"Given a graph, a set of restriction on the graph edges, a set of points on "
"the graphs edges and a list of vertices, this function is equivalent to "
"finding the shortest path between :math:`vertex_i` and :math:`vertex_{i+1}` "
"(where :math:`vertex` can be a vertex or a point on the graph) for all :math:"
"`i < size\\_of(via\\;vertices)` trying not to use restricted paths."
msgstr ""

msgid "is a sequence of paths"
msgstr ""

msgid "Build the Graph with the new points."
msgstr ""

msgid "The points identifiers will be converted to negative values."
msgstr ""

msgid "The vertices identifiers will remain positive."
msgstr ""

msgid "Execute a :doc:`pgr_withPointsVia`."
msgstr ""

msgid ""
"For the set of paths of the solution that pass through a restriction then"
msgstr ""

msgid "Execute the **TRSP** algorithm with restrictions for the path."
msgstr ""

msgid "Do not use negative values on identifiers of the inner queries."
msgstr ""

msgid ""
"pgr_trspVia_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**via vertices**, [**options**])"
msgstr ""

msgid ""
"Find the route that visits the vertices :math:`\\{-6, 15, -5\\}` in that "
"order on an directed graph."
msgstr ""

msgid "When positive it is considered a vertex identifier"
msgstr ""

msgid "When negative it is considered a point identifier"
msgstr ""

msgid "With points optional parameters"
msgstr ""

msgid "``driving_side``"
msgstr ""

msgid "``r``"
msgstr ""

msgid "Value in [``r``, ``l``] indicating if the driving side is:"
msgstr ""

msgid "``r`` for right driving side"
msgstr ""

msgid "``l`` for left driving side"
msgstr ""

msgid "Any other value will be considered as ``r``"
msgstr ""

msgid "``details``"
msgstr ""

msgid "When ``true`` the results will include the points that are in the path."
msgstr ""

msgid ""
"When ``false`` the results will not include the points that are in the path."
msgstr ""

msgid ""
"When ``start_vid``, ``end_vid`` and ``node`` columns have negative values, "
"the identifier is for a Point."
msgstr ""

msgid "Use ``pgr_findCloseEdges`` for points on the fly"
msgstr ""

msgid "Using :doc:`pgr_findCloseEdges`:"
msgstr ""

msgid ""
"Visit from vertex :math:`1` to the two locations on the graph of point "
"`(2.9, 1.8)` in order of closeness to the graph."
msgstr ""

msgid ""
"Point :math:`-1` corresponds to the closest edge from point `(2.9, 1.8)`."
msgstr ""

msgid ""
"Point :math:`-2` corresponds to the next close edge from point `(2.9, 1.8)`."
msgstr ""

msgid ""
"Point :math:`-2` is visited on the route to from vertex :math:`1` to Point :"
"math:`-1` (See row where :math:`seq = 4`)."
msgstr ""

msgid "Usage variations"
msgstr ""

msgid ""
"All this examples are about the route that visits the vertices :math:`\\{-6, "
"7, -4, 8, -2\\}` in that order on a directed graph."
msgstr ""

msgid "Status of \"passes in front\" or \"visits\" of the nodes and points."
msgstr ""

msgid "The algorithm performs a :doc:`pgr_withPointsVia`"
msgstr ""

msgid ""
"Detects which of the paths pass through a restriction in this case is for "
"the ``path_id = 1`` from ``-6`` to ``15`` because the path :math:`9 "
"\\rightarrow 16` is restricted."
msgstr ""

msgid ""
"Executes the :ref:`TRSP-family:TRSP algorithm` for the conflicting paths."
msgstr ""

msgid ""
"From the :doc:`pgr_withPointsVia` result it removes the conflicting paths "
"and builds the solution with the results of the :doc:`pgr_trsp` algorithm:"
msgstr ""

msgid "Getting the same result as ``pgr_trspVia_withPoints``:"
msgstr ""

msgid ""
"The first step, doing a :doc:`pgr_withPointsVia` does consider not making a "
"U turn on the same edge. But the path :math:`9 \\rightarrow 16` (Rows 4 and "
"5) is restricted and the result is using it."
msgstr ""

msgid ""
"When executing the :doc:`pgr_trsp_withPoints` algorithm for the conflicting "
"path, there is no ``U_turn_on_edge`` flag."
msgstr ""

msgid ""
"Therefore the result ignores the ``U_turn_on_edge`` flag when set to "
"``false``. From the :doc:`pgr_withPointsVia` result it removes the "
"conflicting paths and builds the solution with the results of the :doc:"
"`pgr_trsp` algorithm. In this case a U turn is been done using the same edge."
msgstr ""

msgid "pgr_trsp_withPoints - Proposed"
msgstr ""

msgid "``pgr_trsp_withPoints`` Routing Vertex/Point with restrictions."
msgstr ""

msgid "New proposed signatures:"
msgstr ""

msgid "``pgr_trsp_withPoints`` (`One to One`_)"
msgstr ""

msgid "``pgr_trsp_withPoints`` (`One to Many`_)"
msgstr ""

msgid "``pgr_trsp_withPoints`` (`Many to One`_)"
msgstr ""

msgid "``pgr_trsp_withPoints`` (`Many to Many`_)"
msgstr ""

msgid "``pgr_trsp_withPoints`` (`Combinations`_)"
msgstr ""

msgid ""
"Modify the graph to include points defined by points_sql. Using Dijkstra "
"algorithm, find the shortest path(s)"
msgstr ""

msgid "Characteristics:"
msgstr ""

msgid "Vertices of the graph are:"
msgstr ""

msgid "**positive** when it belongs to the `Edges SQL`_"
msgstr ""

msgid "**negative** when it belongs to the `Points SQL`_"
msgstr ""

msgid "Driving side can not be ``b``"
msgstr ""

msgid "The agg_cost the non included values (v, v) is 0"
msgstr ""

msgid "The agg_cost the non included values (u, v) is ∞"
msgstr ""

msgid ""
"For optimization purposes, any duplicated value in the start_vids or "
"end_vids are ignored."
msgstr ""

msgid ""
"The returned values are ordered: - start_vid ascending - end_vid ascending"
msgstr ""

msgid "Running time: :math:`O(|start\\_vids|\\times(V \\log V + E))`"
msgstr ""

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vid**, **end vid**, [**options**])"
msgstr ""

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vid**, **end vids**, [**options**])"
msgstr ""

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vids**, **end vid**, [**options**])"
msgstr ""

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Points SQL`_, "
"**start vids**, **end vids**, [**options**])"
msgstr ""

msgid ""
"pgr_trsp_withPoints(`Edges SQL`_, `Restrictions SQL`_, `Combinations SQL`_, "
"`Points SQL`_, [**options**])"
msgstr ""

msgid "**options:** ``[directed, driving_side, details]``"
msgstr ""

msgid ""
"From point :math:`1` to vertex :math:`10` with details on a left driving "
"side configuration on a directed graph with details."
msgstr ""

msgid "From point :math:`1` to point :math:`3` and vertex :math:`7`."
msgstr ""

msgid "From point :math:`1` and vertex :math:`6` to point :math:`3`."
msgstr ""

msgid ""
"From point :math:`1` and vertex :math:`6` to point :math:`3` and vertex :"
"math:`1`."
msgstr ""

msgid ""
"From point :math:`1` to vertex :math:`10` and from vertex :math:`6` to "
"point :math:`3` with right side driving configuration."
msgstr ""

msgid ""
"Find the routes from vertex :math:`1` to the two closest locations on the "
"graph of point `(2.9, 1.8)`."
msgstr ""

msgid "Pass in front or visits."
msgstr ""

msgid ""
"Which path (if any) passes in front of point :math:`6` or vertex :math:`11` "
"with right side driving topology."
msgstr ""

msgid "Show details on undirected graph."
msgstr ""

msgid ""
"From point :math:`1` and vertex :math:`6` to point :math:`3` to vertex :math:"
"`1` on an undirected graph, with details."
msgstr ""

msgid "pgr_turnRestrictedPath - Experimental"
msgstr ""

msgid ""
"``pgr_turnRestrictedPath`` Using Yen's algorithm Vertex -Vertex routing with "
"restrictions"
msgstr ""

msgid "New experimental function"
msgstr ""

msgid ""
"Using Yen's algorithm to obtain K shortest paths and analyze the paths to "
"select the paths that do not use the restrictions"
msgstr ""

msgid ""
"pgr_turnRestrictedPath(`Edges SQL`_, `Restrictions SQL`_, **start vid**, "
"**end vid**, **K**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, heap_paths, stop_on_first, strict]``"
msgstr ""

msgid "Returns set of |ksp-result|"
msgstr ""

msgid "From vertex :math:`3` to vertex :math:`8` on a directed graph"
msgstr ""

msgid "Special optional parameters"
msgstr ""

msgid "``stop_on_first``"
msgstr ""

msgid ""
"When ``true`` stops on first path found that dos not violate restrictions"
msgstr ""

msgid "When ``false`` returns at most K paths"
msgstr ""

msgid "When ``true`` returns only paths that do not violate restrictions"
msgstr ""

msgid "When ``false`` returns the paths found"
msgstr ""

msgid "From vertex :math:`3` to :math:`8` with ``strict`` flag on."
msgstr ""

msgid "No results because the only path available follows a restriction."
msgstr ""

msgid "From vertex :math:`3` to vertex :math:`8` on an undirected graph"
msgstr ""

msgid "From vertex :math:`3` to vertex :math:`8` with more alternatives"
msgstr ""

msgid "``pgr_version``"
msgstr ""

msgid "``pgr_version`` — Query for pgRouting version information."
msgstr ""

msgid "Breaking change on result columns"
msgstr ""

msgid "Support for old signature ends"
msgstr ""

msgid "Returns pgRouting version information."
msgstr ""

msgid "pgr_version()"
msgstr ""

msgid "pgRouting Version for this documentation"
msgstr ""

msgid "pgr_vrpOneDepot - Experimental"
msgstr ""

msgid "**No documentation available**"
msgstr ""

msgid "**TBD**"
msgstr ""

msgid "``pgr_withPoints`` - Proposed"
msgstr ""

msgid ""
"``pgr_withPoints`` - Returns the shortest path in a graph with additional "
"temporary vertices."
msgstr ""

msgid "pgr_withPoints(Combinations)"
msgstr ""

msgid "**positive** when it belongs to the edges_sql"
msgstr ""

msgid "**negative** when it belongs to the points_sql"
msgstr ""

msgid ""
"When the starting vertex and ending vertex are the same, there is no path. - "
"The agg_cost the non included values (v, v) is 0"
msgstr ""

msgid ""
"When the starting vertex and ending vertex are the different and there is no "
"path: - The agg_cost the non included values (u, v) is ∞"
msgstr ""

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, "
"[**options**])"
msgstr ""

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, "
"[**options**])"
msgstr ""

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, "
"[**options**])"
msgstr ""

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**, "
"[**options**])"
msgstr ""

msgid ""
"pgr_withPoints(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, "
"[**options**])"
msgstr ""

msgid "**options:** ``[directed, driving_side, details])``"
msgstr ""

msgid "Returns set of |old-pid-result|"
msgstr ""

msgid "**options:** [directed, driving_side, details])"
msgstr ""

msgid "From point :math:`1` to vertex :math:`10` with details"
msgstr ""

msgid "Returns set of |pid-1-m|"
msgstr ""

msgid ""
"From point :math:`1` to point :math:`3` and vertex :math:`7` on an "
"undirected graph"
msgstr ""

msgid "Returns set of |pid-m-1|"
msgstr ""

msgid "From point :math:`1` and vertex :math:`6` to point :math:`3`"
msgstr ""

msgid "Returns set of |pid-m-m|"
msgstr ""

msgid ""
"From point :math:`1` and vertex :math:`6` to point :math:`3` and vertex :"
"math:`1`"
msgstr ""

msgid "Two combinations"
msgstr ""

msgid ""
"From point :math:`1` to vertex :math:`10`, and from vertex :math:`6` to "
"point :math:`3` with **right** side driving."
msgstr ""

msgid ""
"Identifier of the starting vertex of the path. Negative value is for point’s "
"identifier."
msgstr ""

msgid ""
"Array of identifiers of starting vertices. Negative values are for point’s "
"identifiers."
msgstr ""

msgid ""
"Identifier of the ending vertex of the path. Negative value is for point’s "
"identifier."
msgstr ""

msgid ""
"Array of identifiers of ending vertices. Negative values are for point’s "
"identifiers."
msgstr ""

msgid "Value in [``r``, ``l``, ``b``] indicating if the driving side is:"
msgstr ""

msgid "``r`` for right driving side."
msgstr ""

msgid "``l`` for left driving side."
msgstr ""

msgid "``b`` for both."
msgstr ""

msgid "Use :doc:`pgr_findCloseEdges` in the `Points SQL`_."
msgstr ""

msgid ""
"All the examples are about traveling from point :math:`1` and vertex :math:"
"`5` to points :math:`\\{2, 3, 6\\}` and vertices :math:`\\{10, 11\\}`"
msgstr ""

msgid "Passes in front or visits with right side driving."
msgstr ""

msgid "For point :math:`6` and vertex :math:`11`."
msgstr ""

msgid "Passes in front or visits with left side driving."
msgstr ""

msgid "``pgr_withPointsCost`` - Proposed"
msgstr ""

msgid ""
"``pgr_withPointsCost`` - Calculates the shortest path and returns only the "
"aggregate cost of the shortest path(s) found, for the combination of points "
"given."
msgstr ""

msgid "pgr_withPointsCost(Combinations)"
msgstr ""

msgid ""
"Modify the graph to include points defined by points_sql. Using Dijkstra "
"algorithm, return only the aggregate cost of the shortest path(s) found."
msgstr ""

msgid ""
"Returns the sum of the costs of the shortest path for pair combination of "
"vertices in the modified graph."
msgstr ""

msgid ""
"The returned values are in the form of a set of `(start_vid, end_vid, "
"agg_cost)`."
msgstr ""

msgid "The `agg_cost` in the non included values `(v, v)` is `0`"
msgstr ""

msgid "The `agg_cost` in the non included values `(u, v)` is :math:`\\infty`"
msgstr ""

msgid ""
"If the values returned are stored in a table, the unique index would be the "
"pair: `(start_vid, end_vid)`."
msgstr ""

msgid "For **undirected** graphs, the results are **symmetric**."
msgstr ""

msgid ""
"For optimization purposes, any duplicated value in the `start_vids` or "
"`end_vids` is ignored."
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, **start vid**, **end vid**, "
"[**options**])"
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, **start vid**, **end vids**, "
"[**options**])"
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, **start vids**, **end vid**, "
"[**options**])"
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, **start vids**, **end "
"vids**, [**options**])"
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, 'Points SQL`_, `Combinations SQL`_, "
"[**options**])"
msgstr ""

msgid "**options:** ``[directed, driving_side]``"
msgstr ""

msgid "Returns set of |matrix-pid|"
msgstr ""

msgid ""
"There is no **details** flag, unlike the other members of the withPoints "
"family of functions."
msgstr ""

msgid "From point :math:`1` to vertex :math:`10` with defaults"
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, "
"[**options**])"
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, "
"[**options**])"
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, **start vids**, **end "
"vids**, [**options**])"
msgstr ""

msgid ""
"From point :math:`15` and vertex :math:`6` to point :math:`3` and vertex :"
"math:`1`"
msgstr ""

msgid ""
"pgr_withPointsCost(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, "
"[**options**])"
msgstr ""

msgid "Identifier of the starting vertex or point."
msgstr ""

msgid "When positive: is a vertex’s identifier."
msgstr ""

msgid "When negative: is a point’s identifier."
msgstr ""

msgid "Identifier of the ending vertex or point."
msgstr ""

msgid ""
"Find the cost of the routes from vertex :math:`1` to the two closest "
"locations on the graph of point `(2.9, 1.8)`."
msgstr ""

msgid "Being close to the graph does not mean have a shorter route."
msgstr ""

msgid "Right side driving topology"
msgstr ""

msgid ""
"Traveling from point :math:`1` and vertex :math:`5` to points :math:`\\{2, "
"3, 6\\}` and vertices :math:`\\{10, 11\\}`"
msgstr ""

msgid "Left side driving topology"
msgstr ""

msgid "Does not matter driving side driving topology"
msgstr ""

msgid "``pgr_withPointsCostMatrix`` - proposed"
msgstr ""

msgid ""
"``pgr_withPointsCostMatrix`` - Calculates a cost matrix using :doc:"
"`pgr_withPoints`."
msgstr ""

msgid ""
"pgr_withPointsCostMatrix(`Edges SQL`_, `Points SQL`_, **start vids**, "
"[**options**])"
msgstr ""

msgid ""
"Cost matrix for points :math:`\\{1, 6\\}` and vertices :math:`\\{10, 11\\}` "
"on an **undirected** graph"
msgstr ""

msgid "Returning a **symmetrical** cost matrix"
msgstr ""

msgid "Using the default ``side`` value on the **points_sql** query"
msgstr ""

msgid "Using the default ``driving_side`` value"
msgstr ""

msgid ""
"Find the matrix cost of the routes from vertex :math:`1` and the two closest "
"locations on the graph of point `(2.9, 1.8)`."
msgstr ""

msgid "``pgr_withPointsDD`` - Proposed"
msgstr ""

msgid ""
"``pgr_withPointsDD`` - Returns the driving **distance** from a starting "
"point."
msgstr ""

msgid ""
"Signature change: ``driving_side`` parameter changed from named optional to "
"unnamed compulsory **driving side**."
msgstr ""

msgid "``pgr_withPointsDD`` (`Single vertex`)"
msgstr ""

msgid "Added ``depth``, ``pred`` and ``start_vid`` column."
msgstr ""

msgid "Added ``depth``, ``pred`` columns."
msgstr ""

msgid "When ``details`` is ``false``:"
msgstr ""

msgid ""
"Only points that are visited are removed, that is, points reached within the "
"distance are included"
msgstr ""

msgid ""
"``pgr_withpointsdd(text,text,bigint,double precision,boolean,character,"
"boolean)``"
msgstr ""

msgid ""
"``pgr_withpointsdd(text,text,anyarray,double precision,boolean,character,"
"boolean,boolean)``"
msgstr ""

msgid ""
"Modify the graph to include points and using Dijkstra algorithm, extracts "
"all the nodes and points that have costs less than or equal to the value "
"``**distance**`` from the starting point. The edges extracted will conform "
"the corresponding spanning tree."
msgstr ""

msgid ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vid**, **distance**, "
"**driving side**, [**options A**])"
msgstr ""

msgid ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vids**, **distance**, "
"**driving side**, [**options B**])"
msgstr ""

msgid "**options A:** ``[directed, details]``"
msgstr ""

msgid "**options B:** ``[directed, details, equicost]``"
msgstr ""

msgid ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vid**, **distance**, "
"**driving side**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, details]``"
msgstr ""

msgid ""
"Right side driving topology, from point :math:`1` within a distance of :math:"
"`3.3` with details."
msgstr ""

msgid ""
"pgr_withPointsDD(`Edges SQL`_, `Points SQL`_, **root vids**, **distance**, "
"**driving side**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, details, equicost]``"
msgstr ""

msgid ""
"From point :math:`1` and vertex :math:`16` within a distance of :math:`3.3` "
"with ``equicost`` on a directed graph"
msgstr ""

msgid "Negative values represent a point"
msgstr ""

msgid "**driving side**"
msgstr ""

msgid ""
"Value in [``r``, ``R``, ``l``, ``L``, ``b``, ``B``] indicating if the "
"driving side is:"
msgstr ""

msgid "``r``, ``R`` for right driving side,"
msgstr ""

msgid "``l``, ``L`` for left driving side."
msgstr ""

msgid "``b``, ``B`` for both."
msgstr ""

msgid "Valid values differ for directed and undirected graphs:"
msgstr ""

msgid "In directed graphs: [``r``, ``R``, ``l``, ``L``]."
msgstr ""

msgid "In undirected graphs: [``b``, ``B``]."
msgstr ""

msgid ""
"Find the driving distance from the two closest locations on the graph of "
"point `(2.9, 1.8)`."
msgstr ""

msgid ""
"Point :math:`-1` corresponds to the closest edge from point :math:`(2.9, "
"1.8)`."
msgstr ""

msgid ""
"Point :math:`-2` corresponds to the next close edge from point :math:`(2.9, "
"1.8)`."
msgstr ""

msgid "Driving side does not matter"
msgstr ""

msgid ""
"From point :math:`1` within a distance of :math:`3.3`, does not matter "
"driving side, with details."
msgstr ""

msgid ":doc:`pgr_alphaShape`"
msgstr ""

msgid "pgr_withPointsKSP - Proposed"
msgstr ""

msgid ""
"``pgr_withPointsKSP`` — Yen's algorithm for K shortest paths using Dijkstra."
msgstr ""

msgid "Standarizing output columns to |nksp-result|"
msgstr ""

msgid "``pgr_withPointsKSP`` (One to One)"
msgstr ""

msgid "New overload functions"
msgstr ""

msgid "``pgr_withPointsKSP`` (One to Many)"
msgstr ""

msgid "``pgr_withPointsKSP`` (Many to One)"
msgstr ""

msgid "``pgr_withPointsKSP`` (Many to Many)"
msgstr ""

msgid "``pgr_withPointsKSP`` (Combinations)"
msgstr ""

msgid ""
"``pgr_withpointsksp(text,text,bigint,bigint,integer,boolean,boolean,char,"
"boolean)``"
msgstr ""

msgid ""
"Modifies the graph to include the points defined in the `Points SQL`_ and "
"using Yen algorithm, finds the :math:`K` shortest paths."
msgstr ""

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vid**, "
"**K**, **driving_side**, [**options**])"
msgstr ""

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vid**, **end vids**, "
"**K**, **driving_side**, [**options**])"
msgstr ""

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vid**, "
"**K**, **driving_side**, [**options**])"
msgstr ""

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, **start vids**, **end vids**, "
"**K**, **driving_side**, [**options**])"
msgstr ""

msgid ""
"pgr_withPointsKSP(`Edges SQL`_, `Points SQL`_, `Combinations SQL`_, **K**, "
"**driving_side**, [**options**])"
msgstr ""

msgid "**options:** ``[directed, heap_paths, details]``"
msgstr ""

msgid ""
"Get 2 paths from Point :math:`1` to point :math:`2` on a directed graph with "
"**left** side driving."
msgstr ""

msgid "For a directed graph."
msgstr ""

msgid "No details are given about distance of other points of the query."
msgstr ""

msgid "No heap paths are returned."
msgstr ""

msgid ""
"Get 2 paths from point :math:`1` to point :math:`3` and vertex :math:`7` on "
"an undirected graph"
msgstr ""

msgid ""
"Get a path from point :math:`1` and vertex :math:`6` to point :math:`3` on a "
"**directed** graph with **right** side driving and **details** set to "
"**True**"
msgstr ""

msgid ""
"Get a path from point :math:`1` and vertex :math:`6` to point :math:`3` and "
"vertex :math:`1` on a **directed** graph with **left** side driving and "
"**heap_paths** set to **True**"
msgstr ""

msgid "Using a combinations table on an **directed** graph"
msgstr ""

msgid "`Points SQL`_ query as described."
msgstr ""

msgid "Number of required paths"
msgstr ""

msgid "**driving_side**"
msgstr ""

msgid "**CHAR**"
msgstr ""

msgid "[``r``, ``R``] for right driving side (for directed graph only)"
msgstr ""

msgid "[``l``, ``L``] for left driving side (for directed graph only)"
msgstr ""

msgid "[``b``, ``B``] for both (only for undirected graph)"
msgstr ""

msgid "withPointsKSP optional parameters"
msgstr ""

msgid ""
"Get :math:`2` paths using left side driving topology, from vertex :math:`1` "
"to the closest location on the graph of point `(2.9, 1.8)`."
msgstr ""

msgid "Left driving side"
msgstr ""

msgid ""
"Get :math:`2` paths using left side driving topology, from point :math:`1` "
"to point :math:`3` with details."
msgstr ""

msgid "Right driving side"
msgstr ""

msgid ""
"Get :math:`2` paths using right side driving topology from, point :math:`1` "
"to point :math:`2` with heap paths and details."
msgstr ""

msgid "``pgr_withPointsVia`` - Proposed"
msgstr ""

msgid ""
"``pgr_withPointsVia`` - Route that goes through a list of vertices and/or "
"points."
msgstr ""

msgid "New **proposed** function ``pgr_withPointsVia`` (`One Via`_)"
msgstr ""

msgid ""
"Given a graph, a set of points on the graphs edges and a list of vertices, "
"this function is equivalent to finding the shortest path between :math:"
"`vertex_i` and :math:`vertex_{i+1}` (where :math:`vertex` can be a vertex or "
"a point on the graph) for all :math:`i < size\\_of(via\\;vertices)`."
msgstr ""

msgid ""
"pgr_withPointsVia(`Edges SQL`_, `Points SQL`_, **via vertices**, "
"[**options**])"
msgstr ""

msgid ""
"Find the route that visits the vertices :math:`\\{ -6, 15, -1\\}` in that "
"order on a **directed** graph."
msgstr ""

msgid "Use :doc:`pgr_findCloseEdges` in the `Points SQL`_"
msgstr ""

msgid ""
"All this examples are about the route that visits the vertices :math:`\\{-1, "
"7, -3, 16, 15\\}` in that order on a **directed** graph."
msgstr ""

msgid "Prim - Family of functions"
msgstr ""

msgid ""
"The prim algorithm was developed in 1930 by Czech mathematician Vojtěch "
"Jarník. It is a greedy algorithm that finds a minimum spanning tree for a "
"weighted undirected graph. This means it finds a subset of the edges that "
"forms a tree that includes every vertex, where the total weight of all the "
"edges in the tree is minimized. The algorithm operates by building this tree "
"one vertex at a time, from an arbitrary starting vertex, at each step adding "
"the cheapest possible connection from the tree to another vertex."
msgstr ""

msgid ""
"This algorithms find the minimum spanning forest in a possibly disconnected "
"graph; in contrast, the most basic form of Prim's algorithm only finds "
"minimum spanning trees in connected graphs. However, running Prim's "
"algorithm separately for each connected component of the graph, then it is "
"called minimum spanning forest."
msgstr ""

msgid ""
"From boost Graph: \"The algorithm as implemented in Boost.Graph does not "
"produce correct results on graphs with parallel edges.\""
msgstr ""

msgid ""
"Boost: `Prim's algorithm <https://www.boost.org/libs/graph/doc/"
"prim_minimum_spanning_tree.html>`__"
msgstr ""

msgid ""
"Wikipedia: `Prim's algorithm <https://en.wikipedia.org/wiki/"
"Prim%27s_algorithm>`__"
msgstr ""

msgid "Proposed Functions"
msgstr ""

msgid ":doc:`pgr_withPoints` - Route from/to points anywhere on the graph."
msgstr ""

msgid ":doc:`pgr_withPointsCost` - Costs of the shortest paths."
msgstr ""

msgid ":doc:`pgr_withPointsCostMatrix` - Costs of the shortest paths."
msgstr ""

msgid ":doc:`pgr_withPointsKSP` - K shortest paths."
msgstr ""

msgid ":doc:`pgr_withPointsDD` - Driving distance."
msgstr ""

msgid ":doc:`pgr_withPointsVia` - Via routing"
msgstr ""

msgid "These proposed functions do not modify the database."
msgstr ""

msgid ""
":doc:`pgr_degree` - Returns a set of vertices and corresponding count of "
"incidet edges to the vertex."
msgstr ""

msgid ""
":doc:`pgr_extractVertices` - Extracts vertex information based on the edge "
"table information."
msgstr ""

msgid ""
":doc:`pgr_lineGraph` - Transformation algorithm for generating a Line Graph."
msgstr ""

msgid ":doc:`pgr_withPointsVia`"
msgstr ""

msgid ":doc:`pgr_trspVia`"
msgstr ""

msgid ":doc:`pgr_trspVia_withPoints`"
msgstr ""

msgid ":doc:`withPoints-family` - Functions based on Dijkstra algorithm."
msgstr ""

msgid "From the :doc:`TRSP-family`:"
msgstr ""

msgid "Utilities"
msgstr ""

msgid ":doc:`pgr_findCloseEdges`"
msgstr ""

msgid "Reference"
msgstr ""

msgid "Release Notes"
msgstr ""

msgid ""
"To see the full list of changes check the list of `Git commits <https://"
"github.com/pgRouting/pgrouting/commits>`_ on Github."
msgstr ""

msgid "Mayors"
msgstr ""

msgid "pgRouting 3"
msgstr ""

msgid "Minors 3.x"
msgstr ""

msgid "pgRouting 3.7"
msgstr ""

msgid "pgRouting 3.6"
msgstr ""

msgid "pgRouting 3.6.2 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.6.2 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.2%22>`__"
msgstr ""

msgid "Upgrade fix"
msgstr ""

msgid "The upgrade was failing for same minor"
msgstr ""

msgid "Code fixes"
msgstr ""

msgid "Fix warnings from cpplint"
msgstr ""

msgid "Others"
msgstr ""

msgid "Adjust NEWS generator"
msgstr ""

msgid "Name change to `NEWS.md` for better visualization on GitHub"
msgstr ""

msgid "pgRouting 3.6.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.6.1 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.1%22>`_"
msgstr ""

msgid ""
"`#2588 <https://github.com/pgRouting/pgrouting/pull/2588>`__ pgrouting 3.6.0 "
"fails to build on OSX"
msgstr ""

msgid "pgRouting 3.6.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.6.0 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.6.0%22>`_"
msgstr ""

msgid ""
"`#2516 <https://github.com/pgRouting/pgrouting/pull/2516>`__ Standarize "
"output pgr_aStar"
msgstr ""

msgid ""
"``pgr_aStar`` (`One to One`) added ``start_vid`` and ``end_vid`` columns."
msgstr ""

msgid "``pgr_aStar`` (`One to Many`) added ``end_vid`` column."
msgstr ""

msgid "``pgr_aStar`` (`Many to One`) added ``start_vid`` column."
msgstr ""

msgid ""
"`#2523 <https://github.com/pgRouting/pgrouting/pull/2523>`__ Standarize "
"output pgr_bdAstar"
msgstr ""

msgid ""
"``pgr_bdAstar`` (`One to One`) added ``start_vid`` and ``end_vid`` columns."
msgstr ""

msgid "``pgr_bdAstar`` (`One to Many`) added ``end_vid`` column."
msgstr ""

msgid "``pgr_bdAstar`` (`Many to One`) added ``start_vid`` column."
msgstr ""

msgid ""
"`#2547 <https://github.com/pgRouting/pgrouting/pull/2547>`__ Standarize "
"output and modifying signature pgr_KSP"
msgstr ""

msgid ""
"`#2548 <https://github.com/pgRouting/pgrouting/pull/2548>`__ Standarize "
"output pgr_drivingdistance"
msgstr ""

msgid "Proposed functions changes"
msgstr ""

msgid ""
"`#2544 <https://github.com/pgRouting/pgrouting/pull/2544>`__ Standarize "
"output and modifying signature pgr_withPointsDD"
msgstr ""

msgid ""
"`#2546 <https://github.com/pgRouting/pgrouting/pull/2546>`__ Standarize "
"output and modifying signature pgr_withPointsKSP"
msgstr ""

msgid "C/C++ code enhancements"
msgstr ""

msgid ""
"`#2504 <https://github.com/pgRouting/pgrouting/pull/2504>`__ To C++ pg data "
"get, fetch and check."
msgstr ""

msgid "Stopping support for compilation with MSVC."
msgstr ""

msgid ""
"`#2505 <https://github.com/pgRouting/pgrouting/pull/2505>`__ Using namespace."
msgstr ""

msgid ""
"`#2512 <https://github.com/pgRouting/pgrouting/pull/2512>`__ [Dijkstra] "
"Removing duplicate code on Dijkstra."
msgstr ""

msgid ""
"`#2517 <https://github.com/pgRouting/pgrouting/pull/2517>`__ Astar code "
"simplification."
msgstr ""

msgid ""
"`#2521 <https://github.com/pgRouting/pgrouting/pull/2521>`__ Dijkstra code "
"simplification."
msgstr ""

msgid ""
"`#2522 <https://github.com/pgRouting/pgrouting/pull/2522>`__ bdAstar code "
"simplification."
msgstr ""

msgid "Documentation"
msgstr ""

msgid ""
"`#2490 <https://github.com/pgRouting/pgrouting/pull/2490>`__ Automatic page "
"history links."
msgstr ""

msgid "..rubric:: SQL standarization"
msgstr ""

msgid ""
"`#2555 <https://github.com/pgRouting/pgrouting/pull/2555>`__ standarize "
"deprecated messages"
msgstr ""

msgid ""
"On new internal function: do not use named parameters and default parameters."
msgstr ""

msgid "pgRouting 3.5"
msgstr ""

msgid "pgRouting 3.5.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.5.1 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.5.1%22>`_"
msgstr ""

msgid "Documentation fixes"
msgstr ""

msgid "Changes on the documentation to the following:"
msgstr ""

msgid "pgr_degree"
msgstr ""

msgid "pgr_dijkstra"
msgstr ""

msgid "pgr_ksp"
msgstr ""

msgid "Automatic page history links"
msgstr ""

msgid "using bootstrap_version 2 because 3+ does not do dropdowns"
msgstr ""

msgid "Issue fixes"
msgstr ""

msgid ""
"`#2565 <https://github.com/pgRouting/pgrouting/issues/2565>`__ "
"pgr_pgr_lengauerTarjanDominatorTree triggers an assertion"
msgstr ""

msgid "SQL enhancements"
msgstr ""

msgid ""
"`#2561 <https://github.com/pgRouting/pgrouting/issues/2561>`__ Not use "
"wildcards on SQL"
msgstr ""

msgid "pgtap tests"
msgstr ""

msgid ""
"`#2559 <https://github.com/pgRouting/pgrouting/issues/2559>`__ pgtap test "
"using sampledata"
msgstr ""

msgid "Build fixes"
msgstr ""

msgid "Fix winnie build"
msgstr ""

msgid "Fix clang warnings"
msgstr ""

msgid "Grouping headers of postgres readers"
msgstr ""

msgid "pgRouting 3.5.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.5.0 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.5.0%22>`_"
msgstr ""

msgid "Dijkstra"
msgstr ""

msgid ""
"``pgr_dijkstra`` (`One to One`) added ``start_vid`` and ``end_vid`` columns."
msgstr ""

msgid "``pgr_dijkstra`` (`One to Many`) added ``end_vid`` column."
msgstr ""

msgid "``pgr_dijkstra`` (`Many to One`) added ``start_vid`` column."
msgstr ""

msgid "pgRouting 3.4"
msgstr ""

msgid "pgRouting 3.4.2 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.4.2 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.2%22>`_"
msgstr ""

msgid ""
"`#2394 <https://github.com/pgRouting/pgrouting/issues/2394>`__: pgr_bdAstar "
"accumulates heuristic cost in visited node cost."
msgstr ""

msgid ""
"`#2427 <https://github.com/pgRouting/pgrouting/issues/2427>`__: "
"pgr_createVerticesTable & pgr_createTopology, variable should be of type "
"Record."
msgstr ""

msgid "pgRouting 3.4.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.4.1 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.1%22>`_"
msgstr ""

msgid ""
"`#2401 <https://github.com/pgRouting/pgrouting/issues/2401>`__: pgRouting "
"3.4.0 do not build docs when sphinx is too low or missing"
msgstr ""

msgid ""
"`#2398 <https://github.com/pgRouting/pgrouting/issues/2398>`__: v3.4.0 does "
"not upgrade from 3.3.3"
msgstr ""

msgid "pgRouting 3.4.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.4.0 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.4.0%22>`_"
msgstr ""

msgid ""
"`#1891 <https://github.com/pgRouting/pgrouting/issues/1891>`__: pgr_ksp "
"doesn't give all correct shortest path"
msgstr ""

msgid "New proposed functions"
msgstr ""

msgid "With points"
msgstr ""

msgid "``pgr_withPointsVia`` (One Via)"
msgstr ""

msgid "Turn Restrictions"
msgstr ""

msgid "Via with turn restrictions"
msgstr ""

msgid "``pgr_trspVia`` (One Via)"
msgstr ""

msgid "``pgr_trspVia_withPoints`` (One Via)"
msgstr ""

msgid "``pgr_trsp``"
msgstr ""

msgid "``pgr_trsp`` (One to One)"
msgstr ""

msgid "``pgr_trsp`` (One to Many)"
msgstr ""

msgid "``pgr_trsp`` (Many to One)"
msgstr ""

msgid "``pgr_trsp`` (Many to Many)"
msgstr ""

msgid "``pgr_trsp`` (Combinations)"
msgstr ""

msgid "``pgr_trsp_withPoints``"
msgstr ""

msgid "``pgr_trsp_withPoints`` (One to One)"
msgstr ""

msgid "``pgr_trsp_withPoints`` (One to Many)"
msgstr ""

msgid "``pgr_trsp_withPoints`` (Many to One)"
msgstr ""

msgid "``pgr_trsp_withPoints`` (Many to Many)"
msgstr ""

msgid "``pgr_trsp_withPoints`` (Combinations)"
msgstr ""

msgid "Topology"
msgstr ""

msgid "``pgr_degree``"
msgstr ""

msgid "``pgr_findCloseEdges`` (One point)"
msgstr ""

msgid "``pgr_findCloseEdges`` (Many points)"
msgstr ""

msgid "New experimental functions"
msgstr ""

msgid "Ordering"
msgstr ""

msgid "``pgr_cuthillMckeeOrdering``"
msgstr ""

msgid "Flow functions"
msgstr ""

msgid "``pgr_maxCardinalityMatch(text)``"
msgstr ""

msgid "Deprecating ``pgr_maxCardinalityMatch(text,boolean)``"
msgstr ""

msgid "Deprecated Functions"
msgstr ""

msgid "``pgr_trsp(text,integer,float8,integer,float8,boolean,boolean,text)``"
msgstr ""

msgid "``pgr_trspViaEdges(text,integer[],float[],boolean,boolean,text)``"
msgstr ""

msgid "pgRouting 3.3"
msgstr ""

msgid "pgRouting 3.3.5 Release Notes"
msgstr ""

msgid "pgRouting 3.3.4 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.3.4 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.4%22>`_"
msgstr ""

msgid ""
"`#2400 <https://github.com/pgRouting/pgrouting/issues/2400>`__: pgRouting "
"3.3.3 does not build in focal"
msgstr ""

msgid "pgRouting 3.3.3 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.3.3 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.3%22>`_"
msgstr ""

msgid ""
"Ignoring optional boolean parameter, as the algorithm works only for "
"undirected graphs."
msgstr ""

msgid "pgRouting 3.3.2 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.3.2 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.2%22>`_"
msgstr ""

msgid "Revised documentation"
msgstr ""

msgid "Simplifying table names and table columns, for example:"
msgstr ""

msgid "``edges`` instead of ``edge_table``"
msgstr ""

msgid "Removing unused columns ``category_id`` and ``reverse_category_id``."
msgstr ""

msgid "``combinations`` instead of ``combinations_table``"
msgstr ""

msgid "Using PostGIS standard for geometry column."
msgstr ""

msgid "``geom`` instead of ``the_geom``"
msgstr ""

msgid "Avoiding usage of functions that modify indexes, columns etc on tables."
msgstr ""

msgid "Using ``pgr_extractVertices`` to create a routing topology"
msgstr ""

msgid "Restructure of the pgRouting concepts page."
msgstr ""

msgid ""
"`#2276 <https://github.com/pgRouting/pgrouting/issues/2276>`__: "
"edgeDisjointPaths issues with start_vid and combinations"
msgstr ""

msgid ""
"`#2312 <https://github.com/pgRouting/pgrouting/issues/2312>`__: "
"pgr_extractVertices error when target is not BIGINT"
msgstr ""

msgid ""
"`#2357 <https://github.com/pgRouting/pgrouting/issues/2357>`__: Apply clang-"
"tidy performance-*"
msgstr ""

msgid "pgRouting 3.3.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.3.1 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.1%22>`_ on Github."
msgstr ""

msgid ""
"`#2216 <https://github.com/pgRouting/pgrouting/issues/2216>`__: Warnings "
"when using clang"
msgstr ""

msgid ""
"`#2266 <https://github.com/pgRouting/pgrouting/issues/2266>`__: Error "
"processing restrictions"
msgstr ""

msgid "pgRouting 3.3.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.3.0 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.3.0%22>`_ on Github."
msgstr ""

msgid ""
"`#2057 <https://github.com/pgRouting/pgrouting/issues/2057>`__: trspViaEdges "
"columns in different order"
msgstr ""

msgid ""
"`#2087 <https://github.com/pgRouting/pgrouting/issues/2087>`__: "
"pgr_extractVertices to proposed"
msgstr ""

msgid ""
"`#2201 <https://github.com/pgRouting/pgrouting/issues/2201>`__: "
"pgr_depthFirstSearch to proposed"
msgstr ""

msgid ""
"`#2202 <https://github.com/pgRouting/pgrouting/issues/2202>`__: "
"pgr_sequentialVertexColoring to proposed"
msgstr ""

msgid ""
"`#2203 <https://github.com/pgRouting/pgrouting/issues/2203>`__: "
"pgr_dijkstraNear and pgr_dijkstraNearCost to proposed"
msgstr ""

msgid "Coloring"
msgstr ""

msgid "pgr_edgeColoring"
msgstr ""

msgid "Experimental promoted to Proposed"
msgstr ""

msgid "pgr_dijkstraNear"
msgstr ""

msgid "pgr_dijkstraNear(Combinations)"
msgstr ""

msgid "pgr_dijkstraNear(Many to Many)"
msgstr ""

msgid "pgr_dijkstraNear(Many to One)"
msgstr ""

msgid "pgr_dijkstraNear(One to Many)"
msgstr ""

msgid "pgr_dijkstraNearCost"
msgstr ""

msgid "pgr_dijkstraNearCost(Combinations)"
msgstr ""

msgid "pgr_dijkstraNearCost(Many to Many)"
msgstr ""

msgid "pgr_dijkstraNearCost(Many to One)"
msgstr ""

msgid "pgr_dijkstraNearCost(One to Many)"
msgstr ""

msgid "pgr_sequentialVertexColoring"
msgstr ""

msgid "pgr_extractVertices"
msgstr ""

msgid "Traversal"
msgstr ""

msgid "pgr_depthFirstSearch(Multiple vertices)"
msgstr ""

msgid "pgr_depthFirstSearch(Single vertex)"
msgstr ""

msgid "pgRouting 3.2"
msgstr ""

msgid "pgRouting 3.2.2 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.2.2 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.2.2%22>`_ on Github."
msgstr ""

msgid ""
"`#2093 <https://github.com/pgRouting/pgrouting/issues/2093>`__: Compilation "
"on Visual Studio"
msgstr ""

msgid ""
"`#2189 <https://github.com/pgRouting/pgrouting/issues/2189>`__: Build error "
"on RHEL 7"
msgstr ""

msgid "pgRouting 3.2.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.2.1 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.2.1%22>`_ on Github."
msgstr ""

msgid ""
"`#1883 <https://github.com/pgRouting/pgrouting/issues/1883>`__: "
"pgr_TSPEuclidean crashes connection on Windows"
msgstr ""

msgid "The solution is to use Boost::graph::metric_tsp_approx"
msgstr ""

msgid ""
"To not break user's code the optional parameters related to the TSP "
"Annaeling are ignored"
msgstr ""

msgid "The function with the annaeling optional parameters is deprecated"
msgstr ""

msgid "pgRouting 3.2.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.2.0 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.2.0%22>`_ on Github."
msgstr ""

msgid "Build"
msgstr ""

msgid ""
"`#1850 <https://github.com/pgRouting/pgrouting/issues/1850>`__: Change Boost "
"min version to 1.56"
msgstr ""

msgid "Removing support for Boost v1.53, v1.54 & v1.55"
msgstr ""

msgid "pgr_bellmanFord(Combinations)"
msgstr ""

msgid "pgr_binaryBreadthFirstSearch(Combinations)"
msgstr ""

msgid "pgr_bipartite"
msgstr ""

msgid "pgr_depthFirstSearch"
msgstr ""

msgid "Dijkstra Near"
msgstr ""

msgid "pgr_edwardMoore(Combinations)"
msgstr ""

msgid "pgr_isPlanar"
msgstr ""

msgid "pgr_lengauerTarjanDominatorTree"
msgstr ""

msgid "pgr_makeConnected"
msgstr ""

msgid "pgr_maxFlowMinCost(Combinations)"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost(Combinations)"
msgstr ""

msgid "Astar"
msgstr ""

msgid "pgr_aStar(Combinations)"
msgstr ""

msgid "pgr_aStarCost(Combinations)"
msgstr ""

msgid "Bidirectional Astar"
msgstr ""

msgid "pgr_bdAstar(Combinations)"
msgstr ""

msgid "pgr_bdAstarCost(Combinations)"
msgstr ""

msgid "Bidirectional Dijkstra"
msgstr ""

msgid "pgr_bdDijkstra(Combinations)"
msgstr ""

msgid "pgr_bdDijkstraCost(Combinations)"
msgstr ""

msgid "pgr_boykovKolmogorov(Combinations)"
msgstr ""

msgid "pgr_edmondsKarp(Combinations)"
msgstr ""

msgid "pgr_maxFlow(Combinations)"
msgstr ""

msgid "pgr_pushRelabel(Combinations)"
msgstr ""

msgid "pgRouting 3.1"
msgstr ""

msgid "pgRouting 3.1.4 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.1.4 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.4%22>`_ on Github."
msgstr ""

msgid "Issues fixes"
msgstr ""

msgid "pgRouting 3.1.3 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.1.3 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.3%22>`_ on Github."
msgstr ""

msgid ""
"`#1825 <https://github.com/pgRouting/pgrouting/issues/1825>`__: Boost "
"versions are not honored"
msgstr ""

msgid ""
"`#1849 <https://github.com/pgRouting/pgrouting/issues/1849>`__: Boost 1.75.0 "
"geometry \"point_xy.hpp\" build error on macOS environment"
msgstr ""

msgid ""
"`#1861 <https://github.com/pgRouting/pgrouting/issues/1861>`__: vrp "
"functions crash server"
msgstr ""

msgid "pgRouting 3.1.2 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.1.2 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.2%22>`_ on Github."
msgstr ""

msgid ""
"`#1304 <https://github.com/pgRouting/pgrouting/issues/1304>`__: FreeBSD 12 "
"64-bit crashes on pgr_vrOneDepot tests Experimental Function"
msgstr ""

msgid ""
"`#1356 <https://github.com/pgRouting/pgrouting/issues/1356>`__: tools/"
"testers/pg_prove_tests.sh fails when PostgreSQL port is not passed"
msgstr ""

msgid ""
"`#1725 <https://github.com/pgRouting/pgrouting/issues/1725>`__: Server crash "
"on pgr_pickDeliver and pgr_vrpOneDepot on openbsd"
msgstr ""

msgid ""
"`#1760 <https://github.com/pgRouting/pgrouting/issues/1760>`__: TSP server "
"crash on ubuntu 20.04 #1760"
msgstr ""

msgid ""
"`#1770 <https://github.com/pgRouting/pgrouting/issues/1770>`__: Remove "
"warnings when using clang compiler"
msgstr ""

msgid "pgRouting 3.1.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.1.1 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.1%22>`_ on Github."
msgstr ""

msgid ""
"`#1733 <https://github.com/pgRouting/pgrouting/issues/1733>`__: pgr_bdAstar "
"fails when source or target vertex does not exist in the graph"
msgstr ""

msgid ""
"`#1647 <https://github.com/pgRouting/pgrouting/issues/1647>`__: Linear "
"Contraction contracts self loops"
msgstr ""

msgid ""
"`#1640 <https://github.com/pgRouting/pgrouting/issues/1640>`__: "
"pgr_withPoints fails when points_sql is empty"
msgstr ""

msgid ""
"`#1616 <https://github.com/pgRouting/pgrouting/issues/1616>`__: Path "
"evaluation on C++ not updated before the results go back to C"
msgstr ""

msgid ""
"`#1300 <https://github.com/pgRouting/pgrouting/issues/1300>`__: "
"pgr_chinesePostman crash on test data"
msgstr ""

msgid "pgRouting 3.1.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.1.0 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.1.0%22>`_ on Github."
msgstr ""

msgid "pgr_dijkstra(combinations)"
msgstr ""

msgid "pgr_dijkstraCost(combinations)"
msgstr ""

msgid "Build changes"
msgstr ""

msgid "Minimal requirement for Sphinx: version 1.8"
msgstr ""

msgid "pgRouting 3.0"
msgstr ""

msgid "pgRouting 3.0.6 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.0.6 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.6%22>`_ on Github."
msgstr ""

msgid "pgRouting 3.0.5 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.0.5 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.5%22>`_ on Github."
msgstr ""

msgid "Backport issue fixes"
msgstr ""

msgid "pgRouting 3.0.4 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.0.4 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.4%22>`_ on Github."
msgstr ""

msgid "pgRouting 3.0.3 Release Notes"
msgstr ""

msgid "pgRouting 3.0.2 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.0.2 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.2%22>`_ on Github."
msgstr ""

msgid ""
"`#1378 <https://github.com/pgRouting/pgrouting/issues/1378>`__: Visual "
"Studio build failing"
msgstr ""

msgid "pgRouting 3.0.1 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.0.1 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.1%22>`_ on Github."
msgstr ""

msgid ""
"`#232 <https://github.com/pgRouting/pgrouting/issues/232>`__: Honor client "
"cancel requests in C /C++ code"
msgstr ""

msgid "pgRouting 3.0.0 Release Notes"
msgstr ""

msgid ""
"To see all issues & pull requests closed by this release see the `Git closed "
"milestone for 3.0.0 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%203.0.0%22>`_ on Github."
msgstr ""

msgid "Fixed Issues"
msgstr ""

msgid ""
"`#1153 <https://github.com/pgRouting/pgrouting/issues/1153>`__: Renamed "
"pgr_eucledianTSP to pgr_TSPeuclidean"
msgstr ""

msgid ""
"`#1188 <https://github.com/pgRouting/pgrouting/issues/1188>`__: Removed CGAL "
"dependency"
msgstr ""

msgid ""
"`#1002 <https://github.com/pgRouting/pgrouting/issues/1002>`__: Fixed "
"contraction issues:"
msgstr ""

msgid ""
"`#1004 <https://github.com/pgRouting/pgrouting/issues/1004>`__: Contracts "
"when forbidden vertices do not belong to graph"
msgstr ""

msgid ""
"`#1005 <https://github.com/pgRouting/pgrouting/issues/1005>`__: Intermideate "
"results eliminated"
msgstr ""

msgid ""
"`#1006 <https://github.com/pgRouting/pgrouting/issues/1006>`__: No loss of "
"information"
msgstr ""

msgid "New functions"
msgstr ""

msgid "Kruskal family"
msgstr ""

msgid "pgr_kruskal"
msgstr ""

msgid "pgr_kruskalBFS"
msgstr ""

msgid "pgr_kruskalDD"
msgstr ""

msgid "pgr_kruskalDFS"
msgstr ""

msgid "Prim family"
msgstr ""

msgid "pgr_prim"
msgstr ""

msgid "pgr_primDD"
msgstr ""

msgid "pgr_primDFS"
msgstr ""

msgid "pgr_primBFS"
msgstr ""

msgid "Proposed moved to official on pgRouting"
msgstr ""

msgid "aStar Family"
msgstr ""

msgid "pgr_aStar(one to many)"
msgstr ""

msgid "pgr_aStar(many to one)"
msgstr ""

msgid "pgr_aStar(many to many)"
msgstr ""

msgid "pgr_aStarCost(one to one)"
msgstr ""

msgid "pgr_aStarCost(one to many)"
msgstr ""

msgid "pgr_aStarCost(many to one)"
msgstr ""

msgid "pgr_aStarCost(many to many)"
msgstr ""

msgid "pgr_aStarCostMatrix(one to one)"
msgstr ""

msgid "pgr_aStarCostMatrix(one to many)"
msgstr ""

msgid "pgr_aStarCostMatrix(many to one)"
msgstr ""

msgid "pgr_aStarCostMatrix(many to many)"
msgstr ""

msgid "bdAstar Family"
msgstr ""

msgid "pgr_bdAstar(one to many)"
msgstr ""

msgid "pgr_bdAstar(many to one)"
msgstr ""

msgid "pgr_bdAstar(many to many)"
msgstr ""

msgid "pgr_bdAstarCost(one to one)"
msgstr ""

msgid "pgr_bdAstarCost(one to many)"
msgstr ""

msgid "pgr_bdAstarCost(many to one)"
msgstr ""

msgid "pgr_bdAstarCost(many to many)"
msgstr ""

msgid "pgr_bdAstarCostMatrix(one to one)"
msgstr ""

msgid "pgr_bdAstarCostMatrix(one to many)"
msgstr ""

msgid "pgr_bdAstarCostMatrix(many to one)"
msgstr ""

msgid "pgr_bdAstarCostMatrix(many to many)"
msgstr ""

msgid "bdDijkstra Family"
msgstr ""

msgid "pgr_bdDijkstra(one to many)"
msgstr ""

msgid "pgr_bdDijkstra(many to one)"
msgstr ""

msgid "pgr_bdDijkstra(many to many)"
msgstr ""

msgid "pgr_bdDijkstraCost(one to one)"
msgstr ""

msgid "pgr_bdDijkstraCost(one to many)"
msgstr ""

msgid "pgr_bdDijkstraCost(many to one)"
msgstr ""

msgid "pgr_bdDijkstraCost(many to many)"
msgstr ""

msgid "pgr_bdDijkstraCostMatrix(one to one)"
msgstr ""

msgid "pgr_bdDijkstraCostMatrix(one to many)"
msgstr ""

msgid "pgr_bdDijkstraCostMatrix(many to one)"
msgstr ""

msgid "pgr_bdDijkstraCostMatrix(many to many)"
msgstr ""

msgid "Flow Family"
msgstr ""

msgid "pgr_pushRelabel(one to one)"
msgstr ""

msgid "pgr_pushRelabel(one to many)"
msgstr ""

msgid "pgr_pushRelabel(many to one)"
msgstr ""

msgid "pgr_pushRelabel(many to many)"
msgstr ""

msgid "pgr_edmondsKarp(one to one)"
msgstr ""

msgid "pgr_edmondsKarp(one to many)"
msgstr ""

msgid "pgr_edmondsKarp(many to one)"
msgstr ""

msgid "pgr_edmondsKarp(many to many)"
msgstr ""

msgid "pgr_boykovKolmogorov (one to one)"
msgstr ""

msgid "pgr_boykovKolmogorov (one to many)"
msgstr ""

msgid "pgr_boykovKolmogorov (many to one)"
msgstr ""

msgid "pgr_boykovKolmogorov (many to many)"
msgstr ""

msgid "pgr_maxCardinalityMatching"
msgstr ""

msgid "pgr_maxFlow"
msgstr ""

msgid "pgr_edgeDisjointPaths(one to one)"
msgstr ""

msgid "pgr_edgeDisjointPaths(one to many)"
msgstr ""

msgid "pgr_edgeDisjointPaths(many to one)"
msgstr ""

msgid "pgr_edgeDisjointPaths(many to many)"
msgstr ""

msgid "Components family"
msgstr ""

msgid "pgr_strongComponents"
msgstr ""

msgid "pgr_biconnectedComponents"
msgstr ""

msgid "pgr_articulationPoints"
msgstr ""

msgid "pgr_bridges"
msgstr ""

msgid "Contraction:"
msgstr ""

msgid "Removed unnecessary column seq"
msgstr ""

msgid "Bug Fixes"
msgstr ""

msgid "pgr_maxFlowMinCost"
msgstr ""

msgid "pgr_maxFlowMinCost_Cost"
msgstr ""

msgid "pgr_turnRestrictedPath"
msgstr ""

msgid "pgr_stoerWagner"
msgstr ""

msgid "pgr_dagShortestpath"
msgstr ""

msgid "pgr_topologicalSort"
msgstr ""

msgid "pgr_transitiveClosure"
msgstr ""

msgid "VRP category"
msgstr ""

msgid "pgr_pickDeliverEuclidean"
msgstr ""

msgid "pgr_pickDeliver"
msgstr ""

msgid "Chinese Postman family"
msgstr ""

msgid "pgr_chinesePostman"
msgstr ""

msgid "pgr_chinesePostmanCost"
msgstr ""

msgid "Breadth First Search family"
msgstr ""

msgid "pgr_breadthFirstSearch"
msgstr ""

msgid "pgr_binaryBreadthFirstSearch"
msgstr ""

msgid "Bellman Ford family"
msgstr ""

msgid "pgr_bellmanFord"
msgstr ""

msgid "pgr_edwardMoore"
msgstr ""

msgid "Moved to legacy"
msgstr ""

msgid "pgr_labelGraph - Use the components family of functions instead."
msgstr ""

msgid "Max flow - functions were renamed on v2.5.0"
msgstr ""

msgid "pgr_maxFlowPushRelabel"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp"
msgstr ""

msgid "pgr_maximumcardinalitymatching"
msgstr ""

msgid "VRP"
msgstr ""

msgid "pgr_gsoc_vrppdtw"
msgstr ""

msgid "TSP old signatures"
msgstr ""

msgid "pgr_pointsAsPolygon"
msgstr ""

msgid "pgr_alphaShape old signature"
msgstr ""

msgid "pgRouting 2"
msgstr ""

msgid "Minors 2.x"
msgstr ""

msgid "pgRouting 2.6"
msgstr ""

msgid "pgRouting 2.6.3 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.6.3 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%202.6.3%22%20>`_ on Github."
msgstr ""

msgid ""
"`#1219 <https://github.com/pgRouting/pgrouting/pull/1219>`__ Implicit cast "
"for via_path integer to text"
msgstr ""

msgid ""
"`#1193 <https://github.com/pgRouting/pgrouting/pull/1193>`__ Fixed "
"pgr_pointsAsPolygon breaking when comparing strings in WHERE clause"
msgstr ""

msgid ""
"`#1185 <https://github.com/pgRouting/pgrouting/pull/1185>`__ Improve "
"FindPostgreSQL.cmake"
msgstr ""

msgid "pgRouting 2.6.2 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.6.2 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%202.6.2%22%20>`_ on Github."
msgstr ""

msgid ""
"`#1152 <https://github.com/pgRouting/pgrouting/issues/1152>`__ Fixes driving "
"distance when vertex is not part of the graph"
msgstr ""

msgid ""
"`#1098 <https://github.com/pgRouting/pgrouting/issues/1098>`__ Fixes windows "
"test"
msgstr ""

msgid ""
"`#1165 <https://github.com/pgRouting/pgrouting/issues/1165>`__ Fixes build "
"for python3 and perl5"
msgstr ""

msgid "pgRouting 2.6.1 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.6.1 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%202.6.1%22%20>`_ on Github."
msgstr ""

msgid "Fixes server crash on several functions."
msgstr ""

msgid "pgr_floydWarshall"
msgstr ""

msgid "pgr_johnson"
msgstr ""

msgid "pgr_astar"
msgstr ""

msgid "pgr_bdAstar"
msgstr ""

msgid "pgr_bdDijstra"
msgstr ""

msgid "pgr_alphashape"
msgstr ""

msgid "pgr_dijkstraCostMatrix"
msgstr ""

msgid "pgr_dijkstraCost"
msgstr ""

msgid "pgr_drivingDistance"
msgstr ""

msgid "pgr_dijkstraVia (proposed)"
msgstr ""

msgid "pgr_boykovKolmogorov (proposed)"
msgstr ""

msgid "pgr_edgeDisjointPaths (proposed)"
msgstr ""

msgid "pgr_edmondsKarp (proposed)"
msgstr ""

msgid "pgr_maxCardinalityMatch (proposed)"
msgstr ""

msgid "pgr_maxFlow (proposed)"
msgstr ""

msgid "pgr_withPoints (proposed)"
msgstr ""

msgid "pgr_withPointsCost (proposed)"
msgstr ""

msgid "pgr_withPointsKSP (proposed)"
msgstr ""

msgid "pgr_withPointsDD (proposed)"
msgstr ""

msgid "pgr_withPointsCostMatrix (proposed)"
msgstr ""

msgid "pgr_contractGraph (experimental)"
msgstr ""

msgid "pgr_pushRelabel (experimental)"
msgstr ""

msgid "pgr_vrpOneDepot (experimental)"
msgstr ""

msgid "pgr_gsoc_vrppdtw (experimental)"
msgstr ""

msgid "Fixes for deprecated functions where also applied but not tested"
msgstr ""

msgid "Removed compilation warning for g++8"
msgstr ""

msgid "Fixed a fallthrugh on Astar and bdAstar."
msgstr ""

msgid "pgRouting 2.6.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.6.0 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%202.6.0%22%20>`_ on Github."
msgstr ""

msgid "pgr_lineGraphFull"
msgstr ""

msgid ""
"Fix pgr_trsp(text,integer,double precision,integer,double precision,boolean,"
"boolean[,text])"
msgstr ""

msgid "without restrictions"
msgstr ""

msgid "calls pgr_dijkstra when both end points have a fraction IN (0,1)"
msgstr ""

msgid "calls pgr_withPoints when at least one fraction NOT IN (0,1)"
msgstr ""

msgid "with restrictions"
msgstr ""

msgid "calls original trsp code"
msgstr ""

msgid "Internal code"
msgstr ""

msgid ""
"Cleaned the internal code of trsp(text,integer,integer,boolean,boolean [, "
"text])"
msgstr ""

msgid "Removed the use of pointers"
msgstr ""

msgid "Internal code can accept BIGINT"
msgstr ""

msgid "Cleaned the internal code of withPoints"
msgstr ""

msgid "pgRouting 2.5"
msgstr ""

msgid "pgRouting 2.5.5 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.5.5 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.5%22%20>`_ on Github."
msgstr ""

msgid "Fixes driving distance when vertex is not part of the graph"
msgstr ""

msgid "Fixes windows test"
msgstr ""

msgid "Fixes build for python3 and perl5"
msgstr ""

msgid "pgRouting 2.5.4 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.5.4 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.4%22%20>`_ on Github."
msgstr ""

msgid "pgRouting 2.5.3 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.5.3 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.3%22%20>`_ on Github."
msgstr ""

msgid ""
"Fix for postgresql 11: Removed a compilation error when compiling with "
"postgreSQL"
msgstr ""

msgid "pgRouting 2.5.2 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.5.2 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.2%22%20>`_ on Github."
msgstr ""

msgid "Fix for postgresql 10.1: Removed a compiler condition"
msgstr ""

msgid "pgRouting 2.5.1 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.5.1 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%202.5.1%22%20>`_ on Github."
msgstr ""

msgid "Fixed prerequisite minimum version of: cmake"
msgstr ""

msgid "pgRouting 2.5.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.5.0 <https://github.com/pgRouting/pgrouting/issues?"
"q=milestone%3A%22Release+2.5.0%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "enhancement:"
msgstr ""

msgid "pgr_version is now on SQL language"
msgstr ""

msgid "Breaking change on:"
msgstr ""

msgid "pgr_edgeDisjointPaths:"
msgstr ""

msgid "Added path_id, cost and agg_cost columns on the result"
msgstr ""

msgid "Parameter names changed"
msgstr ""

msgid "The many version results are the union of the one to one version"
msgstr ""

msgid "New Signatures"
msgstr ""

msgid "pgr_bdAstar(one to one)"
msgstr ""

msgid "New Proposed functions"
msgstr ""

msgid "pgr_bdAstarCostMatrix"
msgstr ""

msgid "pgr_bdDijkstraCostMatrix"
msgstr ""

msgid "pgr_lineGraph"
msgstr ""

msgid "pgr_bdastar - use pgr_bdAstar instead"
msgstr ""

msgid "Renamed functions"
msgstr ""

msgid "pgr_maxFlowPushRelabel - use pgr_pushRelabel instead"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp -use pgr_edmondsKarp instead"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov - use pgr_boykovKolmogorov instead"
msgstr ""

msgid "pgr_maximumCardinalityMatching - use pgr_maxCardinalityMatch instead"
msgstr ""

msgid "Deprecated Function"
msgstr ""

msgid "pgr_pointToEdgeNode"
msgstr ""

msgid "pgRouting 2.4"
msgstr ""

msgid "pgRouting 2.4.2 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.4.2 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%202.4.2%22%20>`_ on Github."
msgstr ""

msgid "Improvement"
msgstr ""

msgid "Works for postgreSQL 10"
msgstr ""

msgid "Fixed: Unexpected error column \"cname\""
msgstr ""

msgid ""
"Replace __linux__ with __GLIBC__ for glibc-specific headers and functions"
msgstr ""

msgid "pgRouting 2.4.1 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed milestone for "
"2.4.1 <https://github.com/pgRouting/pgrouting/issues?"
"utf8=%E2%9C%93&q=milestone%3A%22Release%202.4.1%22%20>`_ on Github."
msgstr ""

msgid "Fixed compiling error on macOS"
msgstr ""

msgid "Condition error on pgr_withPoints"
msgstr ""

msgid "pgRouting 2.4.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.4.0 <https://github.com/pgRouting/pgrouting/issues?"
"q=milestone%3A%22Release+2.4.0%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "pgr_bdDijkstra"
msgstr ""

msgid "New Proposed Signatures"
msgstr ""

msgid "pgr_astar(one to many)"
msgstr ""

msgid "pgr_astar(many to one)"
msgstr ""

msgid "pgr_astar(many to many)"
msgstr ""

msgid "pgr_astarCost(one to one)"
msgstr ""

msgid "pgr_astarCost(one to many)"
msgstr ""

msgid "pgr_astarCost(many to one)"
msgstr ""

msgid "pgr_astarCost(many to many)"
msgstr ""

msgid "pgr_astarCostMatrix"
msgstr ""

msgid "pgr_bddijkstra - use pgr_bdDijkstra instead"
msgstr ""

msgid "pgr_pointsToVids"
msgstr ""

msgid "Bug fixes on proposed functions"
msgstr ""

msgid "pgr_withPointsKSP: fixed ordering"
msgstr ""

msgid "TRSP original code is used with no changes on the compilation warnings"
msgstr ""

msgid "pgRouting 2.3"
msgstr ""

msgid "pgRouting 2.3.2 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.3.2 <https://github.com/pgRouting/pgrouting/issues?"
"q=milestone%3A%22Release+2.3.2%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Fixed pgr_gsoc_vrppdtw crash when all orders fit on one truck."
msgstr ""

msgid "Fixed pgr_trsp:"
msgstr ""

msgid "Alternate code is not executed when the point is in reality a vertex"
msgstr ""

msgid "Fixed ambiguity on seq"
msgstr ""

msgid "pgRouting 2.3.1 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.3.1 <https://github.com/pgRouting/pgrouting/issues?"
"q=milestone%3A%22Release+2.3.1%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Leaks on proposed max_flow functions"
msgstr ""

msgid "Regression error on pgr_trsp"
msgstr ""

msgid "Types discrepancy on pgr_createVerticesTable"
msgstr ""

msgid "pgRouting 2.3.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.3.0 <https://github.com/pgRouting/pgrouting/issues?"
"q=milestone%3A%22Release+2.3.0%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "pgr_TSP"
msgstr ""

msgid "pgr_aStar"
msgstr ""

msgid "New Functions"
msgstr ""

msgid "pgr_eucledianTSP"
msgstr ""

msgid "pgr_withPointsCostMatrix"
msgstr ""

msgid "pgr_maxFlowPushRelabel(one to one)"
msgstr ""

msgid "pgr_maxFlowPushRelabel(one to many)"
msgstr ""

msgid "pgr_maxFlowPushRelabel(many to one)"
msgstr ""

msgid "pgr_maxFlowPushRelabel(many to many)"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp(one to one)"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp(one to many)"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp(many to one)"
msgstr ""

msgid "pgr_maxFlowEdmondsKarp(many to many)"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov (one to one)"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov (one to many)"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov (many to one)"
msgstr ""

msgid "pgr_maxFlowBoykovKolmogorov (many to many)"
msgstr ""

msgid "pgr_maximumCardinalityMatching"
msgstr ""

msgid "pgr_contractGraph"
msgstr ""

msgid "pgr_tsp - use pgr_TSP or pgr_eucledianTSP instead"
msgstr ""

msgid "pgr_astar - use pgr_aStar instead"
msgstr ""

msgid "pgr_flip_edges"
msgstr ""

msgid "pgr_vidsToDmatrix"
msgstr ""

msgid "pgr_pointsToDMatrix"
msgstr ""

msgid "pgr_textToPoints"
msgstr ""

msgid "pgRouting 2.2"
msgstr ""

msgid "pgRouting 2.2.4 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.2.4 <https://github.com/pgRouting/pgrouting/issues?"
"q=milestone%3A%22Release+2.2.4%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Bogus uses of extern \"C\""
msgstr ""

msgid "Build error on Fedora 24 + GCC 6.0"
msgstr ""

msgid "Regression error pgr_nodeNetwork"
msgstr ""

msgid "pgRouting 2.2.3 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.2.3 <https://github.com/pgRouting/pgrouting/issues?"
"q=milestone%3A%22Release+2.2.3%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Fixed compatibility issues with PostgreSQL 9.6."
msgstr ""

msgid "pgRouting 2.2.2 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.2.2 <https://github.com/pgRouting/pgrouting/issues?"
"q=milestone%3A%22Release+2.2.2%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Fixed regression error on pgr_drivingDistance"
msgstr ""

msgid "pgRouting 2.2.1 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.2.1 <https://github.com/pgRouting/pgrouting/issues?"
"q=milestone%3A2.2.1+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Server crash fix on pgr_alphaShape"
msgstr ""

msgid "Bug fix on With Points family of functions"
msgstr ""

msgid "pgRouting 2.2.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.2.0 <https://github.com/pgRouting/pgrouting/issues?"
"q=milestone%3A%22Release+2.2.0%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "Improvements"
msgstr ""

msgid "Adding a row_where and outall optional parameters"
msgstr ""

msgid "Signature fix"
msgstr ""

msgid "pgr_dijkstra -- to match what is documented"
msgstr ""

msgid "pgr_Johnson"
msgstr ""

msgid "pgr_dijkstraCost(one to one)"
msgstr ""

msgid "pgr_dijkstraCost(one to many)"
msgstr ""

msgid "pgr_dijkstraCost(many to one)"
msgstr ""

msgid "pgr_dijkstraCost(many to many)"
msgstr ""

msgid "Proposed Functionality"
msgstr ""

msgid "pgr_withPoints(one to one)"
msgstr ""

msgid "pgr_withPoints(one to many)"
msgstr ""

msgid "pgr_withPoints(many to one)"
msgstr ""

msgid "pgr_withPoints(many to many)"
msgstr ""

msgid "pgr_withPointsCost(one to one)"
msgstr ""

msgid "pgr_withPointsCost(one to many)"
msgstr ""

msgid "pgr_withPointsCost(many to one)"
msgstr ""

msgid "pgr_withPointsCost(many to many)"
msgstr ""

msgid "pgr_withPointsDD(single vertex)"
msgstr ""

msgid "pgr_withPointsDD(multiple vertices)"
msgstr ""

msgid "pgr_withPointsKSP"
msgstr ""

msgid "pgr_dijkstraVia"
msgstr ""

msgid "pgr_apspWarshall use pgr_floydWarshall instead"
msgstr ""

msgid "pgr_apspJohnson use pgr_Johnson instead"
msgstr ""

msgid "pgr_kDijkstraCost use pgr_dijkstraCost instead"
msgstr ""

msgid "pgr_kDijkstraPath use pgr_dijkstra instead"
msgstr ""

msgid "Renamed and Deprecated Function"
msgstr ""

msgid "pgr_makeDistanceMatrix renamed to _pgr_makeDistanceMatrix"
msgstr ""

msgid "pgRouting 2.1"
msgstr ""

msgid "pgRouting 2.1.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.1.0 <https://github.com/pgRouting/pgrouting/issues?"
"q=is%3Aissue+milestone%3A%22Release+2.1.0%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid "pgr_dijkstra(one to many)"
msgstr ""

msgid "pgr_dijkstra(many to one)"
msgstr ""

msgid "pgr_dijkstra(many to many)"
msgstr ""

msgid "pgr_drivingDistance(multiple vertices)"
msgstr ""

msgid "Refactored"
msgstr ""

msgid "pgr_dijkstra(one to one)"
msgstr ""

msgid "pgr_drivingDistance(single vertex)"
msgstr ""

msgid ""
"pgr_alphaShape function now can generate better (multi)polygon with holes "
"and alpha parameter."
msgstr ""

msgid ""
"Proposed functions from Steve Woodbridge, (Classified as Convenience by the "
"author.)"
msgstr ""

msgid ""
"pgr_pointToEdgeNode - convert a point geometry to a vertex_id based on "
"closest edge."
msgstr ""

msgid ""
"pgr_flipEdges - flip the edges in an array of geometries so the connect end "
"to end."
msgstr ""

msgid ""
"pgr_textToPoints - convert a string of x,y;x,y;... locations into point "
"geometries."
msgstr ""

msgid ""
"pgr_pointsToVids - convert an array of point geometries into vertex ids."
msgstr ""

msgid "pgr_pointsToDMatrix - Create a distance matrix from an array of points."
msgstr ""

msgid ""
"pgr_vidsToDMatrix - Create a distance matrix from an array of vertix_id."
msgstr ""

msgid "Added proposed functions from GSoc Projects:"
msgstr ""

msgid "pgr_vrppdtw"
msgstr ""

msgid "pgr_vrponedepot"
msgstr ""

msgid "pgr_getColumnName"
msgstr ""

msgid "pgr_getTableName"
msgstr ""

msgid "pgr_isColumnCndexed"
msgstr ""

msgid "pgr_isColumnInTable"
msgstr ""

msgid "pgr_quote_ident"
msgstr ""

msgid "pgr_versionless"
msgstr ""

msgid "pgr_startPoint"
msgstr ""

msgid "pgr_endPoint"
msgstr ""

msgid "pgr_pointToId"
msgstr ""

msgid "No longer supported"
msgstr ""

msgid "Removed the 1.x legacy functions"
msgstr ""

msgid "Some bug fixes in other functions"
msgstr ""

msgid "Refactoring Internal Code"
msgstr ""

msgid "A C and C++ library for developer was created"
msgstr ""

msgid "encapsulates postgreSQL related functions"
msgstr ""

msgid "encapsulates Boost.Graph graphs"
msgstr ""

msgid "Directed Boost.Graph"
msgstr ""

msgid "Undirected Boost.graph."
msgstr ""

msgid "allow any-integer in the id's"
msgstr ""

msgid "allow any-numerical on the cost/reverse_cost columns"
msgstr ""

msgid ""
"Instead of generating many libraries: - All functions are encapsulated in "
"one library - The library has the prefix 2-1-0"
msgstr ""

msgid "pgRouting 2.0"
msgstr ""

msgid "pgRouting 2.0.1 Release Notes"
msgstr ""

msgid "Minor bug fixes."
msgstr ""

msgid "No track of the bug fixes were kept."
msgstr ""

msgid "pgRouting 2.0.0 Release Notes"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for "
"2.0.0 <https://github.com/pgRouting/pgrouting/issues?"
"q=milestone%3A%22Release+2.0.0%22+is%3Aclosed>`_ on Github."
msgstr ""

msgid ""
"With the release of pgRouting 2.0.0 the library has abandoned backwards "
"compatibility to `pgRouting 1.0`_ releases. The main Goals for this release "
"are:"
msgstr ""

msgid "Major restructuring of pgRouting."
msgstr ""

msgid "Standardization of the function naming"
msgstr ""

msgid "Preparation of the project for future development."
msgstr ""

msgid "As a result of this effort:"
msgstr ""

msgid "pgRouting has a simplified structure"
msgstr ""

msgid "Significant new functionality has being added"
msgstr ""

msgid "Documentation has being integrated"
msgstr ""

msgid "Testing has being integrated"
msgstr ""

msgid "And made it easier for multiple developers to make contributions."
msgstr ""

msgid "Important Changes"
msgstr ""

msgid ""
"Graph Analytics - tools for detecting and fixing connection some problems in "
"a graph"
msgstr ""

msgid "A collection of useful utility functions"
msgstr ""

msgid ""
"Two new All Pairs Short Path algorithms (pgr_apspJohnson, pgr_apspWarshall)"
msgstr ""

msgid ""
"Bi-directional Dijkstra and A-star search algorithms (pgr_bdAstar, "
"pgr_bdDijkstra)"
msgstr ""

msgid "One to many nodes search (pgr_kDijkstra)"
msgstr ""

msgid "K alternate paths shortest path (pgr_ksp)"
msgstr ""

msgid ""
"New TSP solver that simplifies the code and the build process (pgr_tsp), "
"dropped \"Gaul Library\" dependency"
msgstr ""

msgid "Turn Restricted shortest path (pgr_trsp) that replaces Shooting Star"
msgstr ""

msgid "Dropped support for Shooting Star"
msgstr ""

msgid ""
"Built a test infrastructure that is run before major code changes are "
"checked in"
msgstr ""

msgid ""
"Tested and fixed most all of the outstanding bugs reported against 1.x that "
"existing in the 2.0-dev code base."
msgstr ""

msgid "Improved build process for Windows"
msgstr ""

msgid ""
"Automated testing on Linux and Windows platforms trigger by every commit"
msgstr ""

msgid "Modular library design"
msgstr ""

msgid "Compatibility with PostgreSQL 9.1 or newer"
msgstr ""

msgid "Compatibility with PostGIS 2.0 or newer"
msgstr ""

msgid "Installs as PostgreSQL EXTENSION"
msgstr ""

msgid "Return types re factored and unified"
msgstr ""

msgid "Support for table SCHEMA in function parameters"
msgstr ""

msgid "Support for ``st_`` PostGIS function prefix"
msgstr ""

msgid "Added ``pgr_`` prefix to functions and types"
msgstr ""

msgid "Better documentation: https://docs.pgrouting.org"
msgstr ""

msgid "shooting_star is discontinued"
msgstr ""

msgid "pgRouting 1"
msgstr ""

msgid "pgRouting 1.0"
msgstr ""

msgid ""
"To see the issues closed by this release see the `Git closed issues for 1.x "
"<https://github.com/pgRouting/pgrouting/issues?q=milestone%3A%22Release+1."
"x%22+is%3Aclosed>`_ on Github. The following release notes have been copied "
"from the previous ``RELEASE_NOTES`` file and are kept as a reference."
msgstr ""

msgid "Changes for release 1.05"
msgstr ""

msgid "Changes for release 1.03"
msgstr ""

msgid "Much faster topology creation"
msgstr ""

msgid "Changes for release 1.02"
msgstr ""

msgid "Shooting* bug fixes"
msgstr ""

msgid "Compilation problems solved"
msgstr ""

msgid "Changes for release 1.01"
msgstr ""

msgid "Changes for release 1.0"
msgstr ""

msgid "Core and extra functions are separated"
msgstr ""

msgid "Cmake build process"
msgstr ""

msgid "Changes for release 1.0.0b"
msgstr ""

msgid "Additional SQL file with more simple names for wrapper functions"
msgstr ""

msgid "Changes for release 1.0.0a"
msgstr ""

msgid "Shooting* shortest path algorithm for real road networks"
msgstr ""

msgid "Several SQL bugs were fixed"
msgstr ""

msgid "Changes for release 0.9.9"
msgstr ""

msgid "PostgreSQL 8.2 support"
msgstr ""

msgid ""
"Shortest path functions return empty result if they could not find any path"
msgstr ""

msgid "Changes for release 0.9.8"
msgstr ""

msgid "Renumbering scheme was added to shortest path functions"
msgstr ""

msgid "Directed shortest path functions were added"
msgstr ""

msgid "routing_postgis.sql was modified to use dijkstra in TSP search"
msgstr ""

msgid "Function Families"
msgstr ""

msgid "Sample Data"
msgstr ""

msgid ""
"The documentation provides very simple example queries based on a small "
"sample network that resembles a city. To be able to execute the mayority of "
"the examples queries, follow the instructions bellow."
msgstr ""

msgid "Main graph"
msgstr ""

msgid "A graph consists of a set of edges and a set of vertices."
msgstr ""

msgid "The following city is to be inserted into the database:"
msgstr ""

msgid ""
"Information known at this point is the geometry of the edges, cost values, "
"cpacity values, category values and some locations that are not in the graph."
msgstr ""

msgid ""
"The process to have working topology starts by inserting the edges. After "
"that everything else is calculated."
msgstr ""

msgid "Edges"
msgstr ""

msgid ""
"The database design for the documentation of pgRouting, keeps in the same "
"row 2 segments, one in the direction of the geometry and the second in the "
"oposite direction. Therfore some information has the ``reverse_`` prefix "
"which corresponds to the segment on the oposite direction of the geometry."
msgstr ""

msgid "Identifier of the starting vertex of the geometry ``geom``."
msgstr ""

msgid "Identifier of the ending vertex of the geometry ``geom``"
msgstr ""

msgid "Cost to traverse from `source` to ``target``."
msgstr ""

msgid "Cost to traverse from `target` to ``source``."
msgstr ""

msgid "Flow capacity from `source` to ``target``."
msgstr ""

msgid "Flow capacity from `target` to ``source``."
msgstr ""

msgid "``category``"
msgstr ""

msgid "``reverse_category``"
msgstr ""

msgid ":math:`x` coordinate of the starting vertex of the geometry."
msgstr ""

msgid ""
"For convinience it is saved on the table but can be calculated as "
"``ST_X(ST_StartPoint(geom))``."
msgstr ""

msgid ":math:`y` coordinate of the ending vertex of the geometry."
msgstr ""

msgid ""
"For convinience it is saved on the table but can be calculated as "
"``ST_Y(ST_EndPoint(geom))``."
msgstr ""

msgid "The geometry of the segments."
msgstr ""

msgid "Starting on PostgreSQL 12::"
msgstr ""

msgid ""
"Optionally indexes on different columns can be created. The recomendation is "
"to have"
msgstr ""

msgid "``id`` indexed."
msgstr ""

msgid ""
"``source`` and ``target`` columns indexed to speed up pgRouting queries."
msgstr ""

msgid ""
"``geom`` indexed to speed up gemetry processes that might be needed in the "
"front end."
msgstr ""

msgid "For this small example the indexes are skipped, except for ``id``"
msgstr ""

msgid "Edges data"
msgstr ""

msgid "Inserting into the database the information of the edges:"
msgstr ""

msgid ""
"Negative values on the cost, capacity and category means that the edge do "
"not exist."
msgstr ""

msgid "Vertices"
msgstr ""

msgid ""
"The vertex information is calculated based on the identifier of the edge and "
"the geometry and saved on a table. Saving all the information provided by :"
"doc:`pgr_extractVertices`:"
msgstr ""

msgid ""
"In this case the because the ``CREATE`` statement was not used, the "
"definition of an index on the table is needed."
msgstr ""

msgid "The structure of the table is:"
msgstr ""

msgid "Vertices data"
msgstr ""

msgid "The saved information of the vertices is:"
msgstr ""

msgid ""
"Here is where adding more columns to the vertices table can be done. "
"Additional columns names and types will depend on the application."
msgstr ""

msgid "The topology"
msgstr ""

msgid ""
"This queries based on the vertices data create a topology by filling the "
"``source`` and ``target`` columns in the edges table."
msgstr ""

msgid "Topology data"
msgstr ""

msgid "Points outside the graph"
msgstr ""

msgid "Support tables"
msgstr ""

msgid ""
"Many functions can be used with a combinations of ``(source, target)`` pairs "
"when wanting a route from ``source`` to ``target``."
msgstr ""

msgid ""
"For convinence of this documentations, some combinations will be stored on a "
"table:"
msgstr ""

msgid "Inserting the data:"
msgstr ""

msgid "Combinations data"
msgstr ""

msgid "Some functions accept soft restrictions about the segments."
msgstr ""

msgid "Red arrows correspond when ``cost`` > 0 in the edge table."
msgstr ""

msgid "Blue arrows correspond when ``reverse_cost`` > 0 in the edge table."
msgstr ""

msgid "Points are outside the graph."
msgstr ""

msgid "Click on the graph to enlarge."
msgstr ""

msgid "Directed graph with ``cost`` and ``reverse_cost``"
msgstr ""

msgid ""
"When working with city networks, this is recommended for point of view of "
"vehicles."
msgstr ""

msgid "Directed, with cost and reverse_cost"
msgstr ""

msgid "Undirected graph with ``cost`` and ``reverse_cost``"
msgstr ""

msgid ""
"When working with city networks, this is recommended for point of view of "
"pedestrians."
msgstr ""

msgid "Undirected, with cost and reverse cost"
msgstr ""

msgid "Directed graph with ``cost``"
msgstr ""

msgid "Directed, with cost"
msgstr ""

msgid "Undirected graph with ``cost``"
msgstr ""

msgid "Undirected, with cost"
msgstr ""

msgid "Pick & Deliver Data"
msgstr ""

msgid "Spanning Tree - Category"
msgstr ""

msgid ""
"A spanning tree of an undirected graph is a tree that includes all the "
"vertices of G with the minimum possible number of edges."
msgstr ""

msgid ""
"For a disconnected graph, there there is no single tree, but a spanning "
"forest, consisting of a spanning tree of each connected component."
msgstr ""

msgid ""
"pgRouting community support is available through the `pgRouting website "
"<https://pgrouting.org/support.html>`_, `documentation <https://docs."
"pgrouting.org>`_, tutorials, mailing lists and others. If you’re looking "
"for :ref:`commercial support <support_commercial>`, find below a list of "
"companies providing pgRouting development and consulting services."
msgstr ""

msgid "Reporting Problems"
msgstr ""

msgid ""
"Bugs are reported and managed in an `issue tracker <https://github.com/"
"pgrouting/pgrouting/issues>`_. Please follow these steps:"
msgstr ""

msgid ""
"Search the tickets to see if your problem has already been reported. If so, "
"add any extra context you might have found, or at least indicate that you "
"too are having the problem. This will help us prioritize common issues."
msgstr ""

msgid ""
"If your problem is unreported, create a `new issue <https://github.com/"
"pgRouting/pgrouting/issues/new>`__ for it."
msgstr ""

msgid ""
"In your report include explicit instructions to replicate your issue. The "
"best tickets include the exact SQL necessary to replicate a problem."
msgstr ""

msgid ""
"If you can test older versions of PostGIS for your problem, please do. On "
"your ticket, note the earliest version the problem appears."
msgstr ""

msgid ""
"For the versions where you can replicate the problem, note the operating "
"system and version of pgRouting, PostGIS and PostgreSQL."
msgstr ""

msgid ""
"It is recommended to use the following wrapper on the problem to pin point "
"the step that is causing the problem."
msgstr ""

msgid "Mailing List and GIS StackExchange"
msgstr ""

msgid ""
"There are two mailing lists for pgRouting hosted on OSGeo mailing list "
"server:"
msgstr ""

msgid ""
"User mailing list: https://lists.osgeo.org/mailman/listinfo/pgrouting-users"
msgstr ""

msgid ""
"Developer mailing list: https://discourse.osgeo.org/c/pgrouting/pgrouting-"
"dev/"
msgstr ""

msgid "Subscribe: https://discourse.osgeo.org/g/pgrouting-dev"
msgstr ""

msgid ""
"For general questions and topics about how to use pgRouting, please write to "
"the user mailing list."
msgstr ""

msgid ""
"You can also ask at `GIS StackExchange <https://gis.stackexchange.com/>`_ "
"and tag the question with ``pgrouting``. Find all questions tagged with "
"``pgrouting`` under https://gis.stackexchange.com/questions/tagged/pgrouting "
"or subscribe to the `pgRouting questions feed <https://gis.stackexchange.com/"
"feeds/tag?tagnames=pgrouting&sort=newest>`_."
msgstr ""

msgid "Commercial Support"
msgstr ""

msgid ""
"For users who require professional support, development and consulting "
"services, consider contacting any of the following organizations, which have "
"significantly contributed to the development of pgRouting:"
msgstr ""

msgid "**Company**"
msgstr ""

msgid "**Offices in**"
msgstr ""

msgid "**Website**"
msgstr ""

msgid "Germany, Japan"
msgstr ""

msgid "https://georepublic.info"
msgstr ""

msgid "United States"
msgstr ""

msgid "https://www.paragoncorporation.com"
msgstr ""

msgid "Netlab"
msgstr ""

msgid "Capranica, Italy"
msgstr ""

msgid "https://www.osgeo.org/service-providers/netlab/"
msgstr ""

msgid "Topology - Family of Functions"
msgstr ""

msgid ""
"The pgRouting's topology of a network represented with a graph in form of "
"two tables: and edge table and a vertex table."
msgstr ""

msgid ""
"Attributes associated to the tables help to indicate if the graph is "
"directed or undirected, if an edge is one way on a directed graph, and "
"depending on the final application needs, suitable topology(s) need to be "
"created."
msgstr ""

msgid ""
"pgRouting suplies some functions to create a routing topology and to analyze "
"the topology."
msgstr ""

msgid "Additional functions to create a graph:"
msgstr ""

msgid "Additional functions to analyze a graph:"
msgstr ""

msgid "Transformation - Family of functions"
msgstr ""

msgid ""
"This family of functions is used for transforming a given input graph :math:"
"`G(V,E)` into a new graph :math:`G'(V',E')`."
msgstr ""

msgid "Traversal - Family of functions"
msgstr ""

msgid "Aditionaly there are 2 categories under this family"
msgstr ""

msgid "Via - Category"
msgstr ""

msgid "This category intends to solve the general problem:"
msgstr ""

msgid ""
"Given a graph and a list of vertices, find the shortest path between :math:"
"`vertex_i` and :math:`vertex_{i+1}` for all vertices"
msgstr ""

msgid ""
"In other words, find a continuos route that visits all the vertices in the "
"order given."
msgstr ""

msgid "path"
msgstr ""

msgid "represents a section of a **route**."
msgstr ""

msgid "route"
msgstr ""

msgid "is a sequence of **paths**"
msgstr ""

msgid "**Used in:**"
msgstr ""

msgid ""
"Besides the compulsory parameters each function has, there are optional "
"parameters that exist due to the kind of function."
msgstr ""

msgid "Used in all Via functions"
msgstr ""

msgid "Depending on the function one or more inner queries are needed."
msgstr ""

msgid "withPoints - Category"
msgstr ""

msgid "When points are added to the graph."
msgstr ""

msgid ""
"The **with points** category modifies the graph on the fly by adding points "
"on edges as required by the `Points SQL`_ query."
msgstr ""

msgid ""
"The functions within this category give the ability to process between "
"arbitrary points located outside the original graph."
msgstr ""

msgid ""
"This category of functions was thought for routing vehicles, but might as "
"well work for some other application not involving vehicles."
msgstr ""

msgid ""
"When given a point identifier ``pid`` that its being mapped to an edge with "
"an identifier ``edge_id``, with a fraction from the source to the target "
"along the edge ``fraction`` and some additional information about which side "
"of the edge the point is on ``side``, then processing from arbitrary points "
"can be done on fixed networks."
msgstr ""

msgid ""
"All this functions consider as many traits from the \"real world\" as "
"possible:"
msgstr ""

msgid "Kind of graph:"
msgstr ""

msgid "**directed** graph"
msgstr ""

msgid "**undirected** graph"
msgstr ""

msgid "Arriving at the point:"
msgstr ""

msgid ""
"Compulsory arrival on the side of the segment where the point is located."
msgstr ""

msgid "On either side of the segment."
msgstr ""

msgid "Countries with:"
msgstr ""

msgid "**Right** side driving"
msgstr ""

msgid "**Left** side driving"
msgstr ""

msgid "Some points are:"
msgstr ""

msgid ""
"**Permanent**: for example the set of points of clients stored in a table in "
"the data base."
msgstr ""

msgid ""
"The graph has been modified to permanently have those points as vertices."
msgstr ""

msgid "There is a table on the database that describes the points"
msgstr ""

msgid "**Temporal**: for example points given through a web application"
msgstr ""

msgid "The numbering of the points are handled with negative sign."
msgstr ""

msgid ""
"This sign change is to avoid confusion when there is a vertex with the same "
"identifier as the point identifier."
msgstr ""

msgid "Original point identifiers are to be positive."
msgstr ""

msgid "Transformation to negative is done internally."
msgstr ""

msgid "Interpretation of the sign on the node information of the output"
msgstr ""

msgid "positive sign is a vertex of the original graph"
msgstr ""

msgid "negative sign is a point of the `Points SQL`_"
msgstr ""

msgid "About points"
msgstr ""

msgid ""
"For this section the following city (see :doc:`sampledata`) some interesing "
"points such as restaurant, supermarket, post office, etc. will be used as "
"example."
msgstr ""

msgid "The graph is **directed**"
msgstr ""

msgid "Red arrows show the ``(source, target)`` of the edge on the edge table"
msgstr ""

msgid "Blue arrows show the ``(target, source)`` of the edge on the edge table"
msgstr ""

msgid ""
"Each point location shows where it is located with relation of the edge "
"``(source, target)``"
msgstr ""

msgid "On the right for points **2** and **4**."
msgstr ""

msgid "On the left for points **1**, **3** and **5**."
msgstr ""

msgid "On both sides for point **6**."
msgstr ""

msgid ""
"The representation on the data base follows the `Points SQL`_ description, "
"and for this example:"
msgstr ""

msgid "Driving side"
msgstr ""

msgid "In the the folowwing images:"
msgstr ""

msgid "The squared vertices are the temporary vertices,"
msgstr ""

msgid "The temporary vertices are added according to the driving side,"
msgstr ""

msgid ""
"visually showing the differences on how depending on the driving side the "
"data is interpreted."
msgstr ""

msgid "Point **1** located on edge ``(6, 5)``"
msgstr ""

msgid "Point **2** located on edge ``(16, 17)``"
msgstr ""

msgid "Point **3** located on edge ``(8, 12)``"
msgstr ""

msgid "Point **4** located on edge ``(1, 3)``"
msgstr ""

msgid "Point **5** located on edge ``(10, 11)``"
msgstr ""

msgid "Point **6** located on edges ``(6, 7)`` and ``(7, 6)``"
msgstr ""

msgid "Point **1** located on edge ``(5, 6)``"
msgstr ""

msgid "Point **2** located on edge ``(17, 16)``"
msgstr ""

msgid "Point **4** located on edge ``(3, 1)``"
msgstr ""

msgid "Like having all points to be considered in both sides ``b``"
msgstr ""

msgid "Prefered usage on **undirected** graphs"
msgstr ""

msgid "On the :doc:`TRSP-family` this option is not valid"
msgstr ""

msgid "Point **1** located on edge ``(5, 6)`` and ``(6, 5)``"
msgstr ""

msgid "Point **2** located on edge ``(17, 16)``and ``16, 17``"
msgstr ""

msgid "Point **4** located on edge ``(3, 1)`` and ``(1, 3)``"
msgstr ""

msgid "Creating temporary vertices"
msgstr ""

msgid ""
"This section will demonstrate how a temporary vertex is created internally "
"on the graph."
msgstr ""

msgid "Problem"
msgstr ""

msgid "For edge:"
msgstr ""

msgid "insert point:"
msgstr ""

msgid "On a right hand side driving network"
msgstr ""

msgid "Arrival to point ``-2`` can be achived only via vertex **16**."
msgstr ""

msgid "Does not affects edge ``(17, 16)``, therefore the edge is kept."
msgstr ""

msgid "It only affects the edge ``(16, 17)``, therefore the edge is removed."
msgstr ""

msgid "Create two new edges:"
msgstr ""

msgid ""
"Edge ``(16, -2)`` with cost ``0.4`` (original cost * fraction == :math:`1 * "
"0.4`)"
msgstr ""

msgid "Edge ``(-2, 17)`` with cost ``0.6`` (the remaing cost)"
msgstr ""

msgid "The total cost of the additional edges is equal to the original cost."
msgstr ""

msgid ""
"If more points are on the same edge, the process is repeated recursevly."
msgstr ""

msgid "On a left hand side driving network"
msgstr ""

msgid "Arrival to point ``-2`` can be achived only via vertex **17**."
msgstr ""

msgid "Does not affects edge ``(16, 17)``, therefore the edge is kept."
msgstr ""

msgid "It only affects the edge ``(17, 16)``, therefore the edge is removed."
msgstr ""

msgid ""
"Work with the original edge ``(16, 17)`` as the fraction is a fraction of "
"the original:"
msgstr ""

msgid "Flip the Edges and add them to the graph:"
msgstr ""

msgid ""
"Edge ``(17, -2)`` becomes ``(-2, 16)`` with cost ``0.4`` and is added to the "
"graph."
msgstr ""

msgid ""
"Edge ``(-2, 16)`` becomes ``(17, -2)`` with cost ``0.6`` and is added to the "
"graph."
msgstr ""

msgid "When driving side does not matter"
msgstr ""

msgid "Arrival to point ``-2`` can be achived via vertices **16** or **17**."
msgstr ""

msgid ""
"Affects the edges ``(16, 17)`` and ``(17, 16)``, therefore the edges are "
"removed."
msgstr ""

msgid "Create four new edges:"
msgstr ""

msgid "Flip the Edges and add all the edges to the graph:"
msgstr ""

msgid "Edge ``(16, -2)`` is added to the graph."
msgstr ""

msgid "Edge ``(-2, 17)`` is added to the graph."
msgstr ""

msgid ""
"Edge ``(16, -2)`` becomes ``(-2, 16)`` with cost ``0.4`` and is added to the "
"graph."
msgstr ""

msgid ""
"Edge ``(-2, 17)`` becomes ``(17, -2)`` with cost ``0.6`` and is added to the "
"graph."
msgstr ""

msgid "withPoints - Family of functions"
msgstr ""

msgid ""
"This family of functions belongs to the :doc:`withPoints-category` and the "
"functions that compose them are based one way or another on dijkstra "
"algorithm."
msgstr ""

msgid "Depending on the name:"
msgstr ""

msgid "pgr_withPoints is pgr_dijkstra **with points**"
msgstr ""

msgid "pgr_withPointsCost is pgr_dijkstraCost **with points**"
msgstr ""

msgid "pgr_withPointsCostMatrix is pgr_dijkstraCostMatrix **with points**"
msgstr ""

msgid "pgr_withPointsKSP is pgr_ksp **with points**"
msgstr ""

msgid "pgr_withPointsDD is pgr_drivingDistance **with points**"
msgstr ""

msgid "pgr_withPointsvia is pgr_dijkstraVia **with points**"
msgstr ""
