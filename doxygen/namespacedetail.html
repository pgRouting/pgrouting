<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PGROUTING: detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="pgrouting-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">PGROUTING<span id="projectnumber">&#160;4.0-alpha1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacedetail.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">detail Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1distance__heuristic.html">distance_heuristic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2baf7dcacf813377d966c6c0ae369042" id="r_a2baf7dcacf813377d966c6c0ae369042"><td class="memTemplParams" colspan="2">template&lt;typename G , typename V &gt; </td></tr>
<tr class="memitem:a2baf7dcacf813377d966c6c0ae369042"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a2baf7dcacf813377d966c6c0ae369042">astar_1_to_many</a> (G &amp;graph, std::vector&lt; V &gt; &amp;predecessors, std::vector&lt; double &gt; &amp;distances, V departure, const std::set&lt; V &gt; &amp;destinations, int heuristic, double factor, double epsilon)</td></tr>
<tr class="separator:a2baf7dcacf813377d966c6c0ae369042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab79079b48e5c02dc358956ae2e9a2d" id="r_a3ab79079b48e5c02dc358956ae2e9a2d"><td class="memTemplParams" colspan="2">template&lt;class G &gt; </td></tr>
<tr class="memitem:a3ab79079b48e5c02dc358956ae2e9a2d"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="classpgrouting_1_1Path.html">pgrouting::Path</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a3ab79079b48e5c02dc358956ae2e9a2d">dijkstra</a> (G &amp;graph, int64_t start_vertex, const std::set&lt; int64_t &gt; &amp;end_vertex, bool only_cost, size_t n_goals)</td></tr>
<tr class="memdesc:a3ab79079b48e5c02dc358956ae2e9a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dijkstra 1 to many.  <br /></td></tr>
<tr class="separator:a3ab79079b48e5c02dc358956ae2e9a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade967776df1a9c25c6ce98f3ee9fd323" id="r_ade967776df1a9c25c6ce98f3ee9fd323"><td class="memTemplParams" colspan="2">template&lt;typename B_G , typename V , typename T_E &gt; </td></tr>
<tr class="memitem:ade967776df1a9c25c6ce98f3ee9fd323"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#ade967776df1a9c25c6ce98f3ee9fd323">dijkstra_1_to_many</a> (B_G &amp;graph, std::vector&lt; V &gt; &amp;predecessors, std::vector&lt; double &gt; &amp;distances, V departure, const std::set&lt; V &gt; &amp;destinations, size_t n_goals)</td></tr>
<tr class="separator:ade967776df1a9c25c6ce98f3ee9fd323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d71d319acb7190e313a946544ea41d0" id="r_a4d71d319acb7190e313a946544ea41d0"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a4d71d319acb7190e313a946544ea41d0"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="classpgrouting_1_1Path.html">pgrouting::Path</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a4d71d319acb7190e313a946544ea41d0">drivingDistance_no_equicost</a> (const G &amp;graph, const std::set&lt; int64_t &gt; &amp;roots, std::vector&lt; std::map&lt; int64_t, int64_t &gt; &gt; &amp;depths, double distance, bool details)</td></tr>
<tr class="memdesc:a4d71d319acb7190e313a946544ea41d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets results for many vertices and equi costs  <br /></td></tr>
<tr class="separator:a4d71d319acb7190e313a946544ea41d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bd1adc415a84ca2fe7634f109dad46" id="r_a94bd1adc415a84ca2fe7634f109dad46"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a94bd1adc415a84ca2fe7634f109dad46"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="classpgrouting_1_1Path.html">pgrouting::Path</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a94bd1adc415a84ca2fe7634f109dad46">drivingDistance_with_equicost</a> (G &amp;graph, const std::set&lt; int64_t &gt; &amp;roots, std::vector&lt; std::map&lt; int64_t, int64_t &gt; &gt; &amp;depths, double distance, bool details)</td></tr>
<tr class="separator:a94bd1adc415a84ca2fe7634f109dad46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec521783c7bb3980dd2757573a702cb" id="r_a6ec521783c7bb3980dd2757573a702cb"><td class="memTemplParams" colspan="2">template&lt;typename G , typename V &gt; </td></tr>
<tr class="memitem:a6ec521783c7bb3980dd2757573a702cb"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; int64_t, int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a6ec521783c7bb3980dd2757573a702cb">get_depth</a> (const G &amp;graph, V root, const std::vector&lt; double &gt; &amp;distances, std::vector&lt; V &gt; &amp;predecessors, double distance, bool details)</td></tr>
<tr class="memdesc:a6ec521783c7bb3980dd2757573a702cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets results in form of a container of paths with depth  <br /></td></tr>
<tr class="separator:a6ec521783c7bb3980dd2757573a702cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aca0f51acb1c2a4a9a7d4f6614d868c" id="r_a1aca0f51acb1c2a4a9a7d4f6614d868c"><td class="memTemplParams" colspan="2">template&lt;typename G , typename V &gt; </td></tr>
<tr class="memitem:a1aca0f51acb1c2a4a9a7d4f6614d868c"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="classpgrouting_1_1Path.html">pgrouting::Path</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a1aca0f51acb1c2a4a9a7d4f6614d868c">get_drivingDistance_with_equicost_paths</a> (const G &amp;graph, const std::set&lt; int64_t &gt; &amp;roots, std::deque&lt; std::vector&lt; V &gt; &gt; &amp;predecessors, std::vector&lt; double &gt; &amp;distances, std::deque&lt; std::vector&lt; V &gt; &gt; &amp;noDetailsPredecessors, double distance, bool details)</td></tr>
<tr class="memdesc:a1aca0f51acb1c2a4a9a7d4f6614d868c"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets results for many vertices and equi costs  <br /></td></tr>
<tr class="separator:a1aca0f51acb1c2a4a9a7d4f6614d868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07bdec8739b3e246b1d0fecabb42e7f" id="r_ae07bdec8739b3e246b1d0fecabb42e7f"><td class="memTemplParams" colspan="2">template&lt;typename G , typename V &gt; </td></tr>
<tr class="memitem:ae07bdec8739b3e246b1d0fecabb42e7f"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="classpgrouting_1_1Path.html">pgrouting::Path</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#ae07bdec8739b3e246b1d0fecabb42e7f">get_paths</a> (const G &amp;graph, const std::vector&lt; V &gt; &amp;predecessors, const std::vector&lt; double &gt; &amp;distances, V source, const std::set&lt; V &gt; &amp;targets, bool only_cost)</td></tr>
<tr class="separator:ae07bdec8739b3e246b1d0fecabb42e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbdcdbca8ac1cd86a8eea2997d1089e" id="r_aacbdcdbca8ac1cd86a8eea2997d1089e"><td class="memTemplParams" colspan="2">template&lt;typename G , typename V &gt; </td></tr>
<tr class="memitem:aacbdcdbca8ac1cd86a8eea2997d1089e"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="classpgrouting_1_1Path.html">pgrouting::Path</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#aacbdcdbca8ac1cd86a8eea2997d1089e">get_paths</a> (const G &amp;graph, const std::vector&lt; V &gt; &amp;predecessors, const std::vector&lt; double &gt; &amp;distances, V source, std::set&lt; V &gt; &amp;targets, bool only_cost)</td></tr>
<tr class="separator:aacbdcdbca8ac1cd86a8eea2997d1089e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cc91be861b8ccf8a48a5458559fa41" id="r_a88cc91be861b8ccf8a48a5458559fa41"><td class="memTemplParams" colspan="2">template&lt;typename G , typename V &gt; </td></tr>
<tr class="memitem:a88cc91be861b8ccf8a48a5458559fa41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a88cc91be861b8ccf8a48a5458559fa41">remove_details</a> (const G &amp;graph, const std::vector&lt; double &gt; &amp;distances, std::vector&lt; V &gt; &amp;predecessors)</td></tr>
<tr class="separator:a88cc91be861b8ccf8a48a5458559fa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2baf7dcacf813377d966c6c0ae369042" name="a2baf7dcacf813377d966c6c0ae369042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2baf7dcacf813377d966c6c0ae369042">&#9670;&#160;</a></span>astar_1_to_many()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool detail::astar_1_to_many </td>
          <td>(</td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>departure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>destinations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>heuristic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="astar_8hpp_source.html#l00115">115</a> of file <a class="el" href="astar_8hpp_source.html">astar.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  123</span>                        {</div>
<div class="line"><span class="lineno">  124</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> G::B_G B_G;</div>
<div class="line"><span class="lineno">  125</span>    <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  126</span>    <a class="code hl_define" href="interruption_8hpp.html#a60107ad1e320e3c1b6cd6fd03ccc23ec">CHECK_FOR_INTERRUPTS</a>();</div>
<div class="line"><span class="lineno">  127</span>    <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">  128</span>        boost::astar_search(</div>
<div class="line"><span class="lineno">  129</span>                graph.graph, departure,</div>
<div class="line"><span class="lineno">  130</span>                <a class="code hl_class" href="classdetail_1_1distance__heuristic.html">distance_heuristic&lt;B_G, V&gt;</a>(</div>
<div class="line"><span class="lineno">  131</span>                    graph.graph, destinations,</div>
<div class="line"><span class="lineno">  132</span>                    heuristic, factor * epsilon),</div>
<div class="line"><span class="lineno">  133</span>                boost::predecessor_map(&amp;predecessors[0])</div>
<div class="line"><span class="lineno">  134</span>                .weight_map(get(&amp;<a class="code hl_variable" href="classpgrouting_1_1Basic__edge.html#afd3f18d010e1d07e8e1a9d153258dd52">pgrouting::Basic_edge::cost</a>, graph.graph))</div>
<div class="line"><span class="lineno">  135</span>                .distance_map(&amp;distances[0])</div>
<div class="line"><span class="lineno">  136</span>                .visitor(<a class="code hl_class" href="classpgrouting_1_1visitors_1_1astar__many__goals__visitor.html">pgrouting::visitors::astar_many_goals_visitor&lt;V&gt;</a>(destinations)));</div>
<div class="line"><span class="lineno">  137</span>    }</div>
<div class="line"><span class="lineno">  138</span>    <span class="keywordflow">catch</span>(<a class="code hl_struct" href="structpgrouting_1_1found__goals.html">pgrouting::found_goals</a> &amp;) {</div>
<div class="line"><span class="lineno">  139</span>        found = <span class="keyword">true</span>;  <span class="comment">// Target vertex found</span></div>
<div class="line"><span class="lineno">  140</span>    }</div>
<div class="line"><span class="lineno">  141</span>    <span class="keywordflow">return</span> found;</div>
<div class="line"><span class="lineno">  142</span>}</div>
<div class="ttc" id="aclassdetail_1_1distance__heuristic_html"><div class="ttname"><a href="classdetail_1_1distance__heuristic.html">detail::distance_heuristic</a></div><div class="ttdef"><b>Definition</b> <a href="astar_8hpp_source.html#l00051">astar.hpp:51</a></div></div>
<div class="ttc" id="aclasspgrouting_1_1Basic__edge_html_afd3f18d010e1d07e8e1a9d153258dd52"><div class="ttname"><a href="classpgrouting_1_1Basic__edge.html#afd3f18d010e1d07e8e1a9d153258dd52">pgrouting::Basic_edge::cost</a></div><div class="ttdeci">double cost</div><div class="ttdef"><b>Definition</b> <a href="basic__edge_8hpp_source.html#l00047">basic_edge.hpp:47</a></div></div>
<div class="ttc" id="aclasspgrouting_1_1visitors_1_1astar__many__goals__visitor_html"><div class="ttname"><a href="classpgrouting_1_1visitors_1_1astar__many__goals__visitor.html">pgrouting::visitors::astar_many_goals_visitor</a></div><div class="ttdoc">visitor stops when all targets are found</div><div class="ttdef"><b>Definition</b> <a href="astar__visitors_8hpp_source.html#l00041">astar_visitors.hpp:41</a></div></div>
<div class="ttc" id="ainterruption_8hpp_html_a60107ad1e320e3c1b6cd6fd03ccc23ec"><div class="ttname"><a href="interruption_8hpp.html#a60107ad1e320e3c1b6cd6fd03ccc23ec">CHECK_FOR_INTERRUPTS</a></div><div class="ttdeci">#define CHECK_FOR_INTERRUPTS()</div><div class="ttdef"><b>Definition</b> <a href="interruption_8hpp_source.html#l00083">interruption.hpp:83</a></div></div>
<div class="ttc" id="astructpgrouting_1_1found__goals_html"><div class="ttname"><a href="structpgrouting_1_1found__goals.html">pgrouting::found_goals</a></div><div class="ttdoc">exception for visitor termination</div><div class="ttdef"><b>Definition</b> <a href="found__goals_8hpp_source.html#l00033">found_goals.hpp:33</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="interruption_8hpp_source.html#l00083">CHECK_FOR_INTERRUPTS</a>, and <a class="el" href="basic__edge_8hpp_source.html#l00047">pgrouting::Basic_edge::cost</a>.</p>

<p class="reference">Referenced by <a class="el" href="astar_8hpp_source.html#l00170">pgrouting::algorithms::astar()</a>.</p>

</div>
</div>
<a id="a3ab79079b48e5c02dc358956ae2e9a2d" name="a3ab79079b48e5c02dc358956ae2e9a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab79079b48e5c02dc358956ae2e9a2d">&#9670;&#160;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="classpgrouting_1_1Path.html">pgrouting::Path</a> &gt; detail::dijkstra </td>
          <td>(</td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>start_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>end_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>only_cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_goals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dijkstra 1 to many. </p>

<p class="definition">Definition at line <a class="el" href="dijkstra_8hpp_source.html#l00120">120</a> of file <a class="el" href="dijkstra_8hpp_source.html">dijkstra.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  125</span>                        {</div>
<div class="line"><span class="lineno">  126</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> G::V V;</div>
<div class="line"><span class="lineno">  127</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> G::G_T_E T_E;</div>
<div class="line"><span class="lineno">  128</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> G::B_G B_G;</div>
<div class="line"><span class="lineno">  129</span>    std::vector&lt;V&gt; predecessors(graph.num_vertices());</div>
<div class="line"><span class="lineno">  130</span>    std::vector&lt;double&gt; distances(graph.num_vertices(), std::numeric_limits&lt;double&gt;::infinity());</div>
<div class="line"><span class="lineno">  131</span> </div>
<div class="line"><span class="lineno">  132</span>    <span class="keywordflow">if</span> (!graph.has_vertex(start_vertex)) <span class="keywordflow">return</span> std::deque&lt;pgrouting::Path&gt;();</div>
<div class="line"><span class="lineno">  133</span> </div>
<div class="line"><span class="lineno">  134</span>    <span class="keyword">auto</span> departure(graph.get_V(start_vertex));</div>
<div class="line"><span class="lineno">  135</span> </div>
<div class="line"><span class="lineno">  136</span>    std::set&lt;V&gt; destinations;</div>
<div class="line"><span class="lineno">  137</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vertex : end_vertex) {</div>
<div class="line"><span class="lineno">  138</span>        <span class="keywordflow">if</span> (graph.has_vertex(vertex)) destinations.insert(graph.get_V(vertex));</div>
<div class="line"><span class="lineno">  139</span>    }</div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span>    <span class="comment">// perform the algorithm</span></div>
<div class="line"><span class="lineno">  142</span>    detail::dijkstra_1_to_many&lt;B_G, V, T_E&gt;(graph.graph, predecessors, distances, departure, destinations, n_goals);</div>
<div class="line"><span class="lineno">  143</span> </div>
<div class="line"><span class="lineno">  144</span>    <span class="comment">// get the results</span></div>
<div class="line"><span class="lineno">  145</span>    <span class="keyword">auto</span> paths = get_paths(graph,  predecessors, distances, departure, destinations, only_cost);</div>
<div class="line"><span class="lineno">  146</span> </div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">return</span> paths;</div>
<div class="line"><span class="lineno">  148</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="astar_8hpp_source.html#l00145">get_paths()</a>.</p>

</div>
</div>
<a id="ade967776df1a9c25c6ce98f3ee9fd323" name="ade967776df1a9c25c6ce98f3ee9fd323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade967776df1a9c25c6ce98f3ee9fd323">&#9670;&#160;</a></span>dijkstra_1_to_many()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B_G , typename V , typename T_E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool detail::dijkstra_1_to_many </td>
          <td>(</td>
          <td class="paramtype">B_G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>departure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>destinations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_goals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dijkstra_8hpp_source.html#l00081">81</a> of file <a class="el" href="dijkstra_8hpp_source.html">dijkstra.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   87</span>                        {</div>
<div class="line"><span class="lineno">   88</span>    <a class="code hl_define" href="interruption_8hpp.html#a60107ad1e320e3c1b6cd6fd03ccc23ec">CHECK_FOR_INTERRUPTS</a>();</div>
<div class="line"><span class="lineno">   89</span>    std::set&lt;V&gt; goals_found;</div>
<div class="line"><span class="lineno">   90</span>    <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">   91</span>        boost::dijkstra_shortest_paths(graph, departure,</div>
<div class="line"><span class="lineno">   92</span>                boost::predecessor_map(&amp;predecessors[0])</div>
<div class="line"><span class="lineno">   93</span>                .weight_map(get(&amp;T_E::cost, graph))</div>
<div class="line"><span class="lineno">   94</span>                .distance_map(&amp;distances[0])</div>
<div class="line"><span class="lineno">   95</span>                .distance_inf(std::numeric_limits&lt;double&gt;::infinity())</div>
<div class="line"><span class="lineno">   96</span>                .visitor(<a class="code hl_class" href="classpgrouting_1_1visitors_1_1dijkstra__many__goal__visitor.html">pgrouting::visitors::dijkstra_many_goal_visitor&lt;V&gt;</a>(destinations, n_goals, goals_found)));</div>
<div class="line"><span class="lineno">   97</span>    } <span class="keywordflow">catch</span>(<a class="code hl_struct" href="structpgrouting_1_1found__goals.html">pgrouting::found_goals</a> &amp;) {</div>
<div class="line"><span class="lineno">   98</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;g : destinations) {</div>
<div class="line"><span class="lineno">   99</span>            <span class="keywordflow">if</span> (goals_found.find(g) == goals_found.end()) {</div>
<div class="line"><span class="lineno">  100</span>                <span class="comment">/* goal was not found */</span></div>
<div class="line"><span class="lineno">  101</span>                predecessors[g] = g;</div>
<div class="line"><span class="lineno">  102</span>            }</div>
<div class="line"><span class="lineno">  103</span>        }</div>
<div class="line"><span class="lineno">  104</span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  105</span>    } <span class="keywordflow">catch</span> (boost::exception <span class="keyword">const</span>&amp; ex) {</div>
<div class="line"><span class="lineno">  106</span>        (void)ex;</div>
<div class="line"><span class="lineno">  107</span>        <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">  108</span>    } <span class="keywordflow">catch</span> (std::exception &amp;e) {</div>
<div class="line"><span class="lineno">  109</span>        (void)e;</div>
<div class="line"><span class="lineno">  110</span>        <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">  111</span>    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><span class="lineno">  112</span>             <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">  113</span>         }</div>
<div class="line"><span class="lineno">  114</span>         <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  115</span>     }</div>
<div class="ttc" id="aclasspgrouting_1_1visitors_1_1dijkstra__many__goal__visitor_html"><div class="ttname"><a href="classpgrouting_1_1visitors_1_1dijkstra__many__goal__visitor.html">pgrouting::visitors::dijkstra_many_goal_visitor</a></div><div class="ttdef"><b>Definition</b> <a href="dijkstra__visitors_8hpp_source.html#l00082">dijkstra_visitors.hpp:82</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="interruption_8hpp_source.html#l00083">CHECK_FOR_INTERRUPTS</a>.</p>

</div>
</div>
<a id="a4d71d319acb7190e313a946544ea41d0" name="a4d71d319acb7190e313a946544ea41d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d71d319acb7190e313a946544ea41d0">&#9670;&#160;</a></span>drivingDistance_no_equicost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="classpgrouting_1_1Path.html">pgrouting::Path</a> &gt; detail::drivingDistance_no_equicost </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; int64_t, int64_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>depths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>details</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets results for many vertices and equi costs </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph that is being worked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roots</td><td>a set of roots </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depths</td><td>a vector of map of depths </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>maximum distance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">details</td><td>flag to indicate to include points </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="drivingDist_8hpp_source.html#l00432">432</a> of file <a class="el" href="drivingDist_8hpp_source.html">drivingDist.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  436</span>                                       {</div>
<div class="line"><span class="lineno">  437</span>    <span class="keyword">using </span>Path = <a class="code hl_class" href="classpgrouting_1_1Path.html">pgrouting::Path</a>;</div>
<div class="line"><span class="lineno">  438</span>    <span class="keyword">using </span>B_G = <span class="keyword">typename</span> G::B_G;</div>
<div class="line"><span class="lineno">  439</span>    <span class="keyword">using </span>V = <span class="keyword">typename</span> G::V;</div>
<div class="line"><span class="lineno">  440</span>    <span class="keyword">using </span>T_E = <span class="keyword">typename</span> G::G_T_E;</div>
<div class="line"><span class="lineno">  441</span> </div>
<div class="line"><span class="lineno">  442</span>    std::deque&lt;Path&gt; paths;</div>
<div class="line"><span class="lineno">  443</span> </div>
<div class="line"><span class="lineno">  444</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;root : roots) {</div>
<div class="line"><span class="lineno">  445</span>        <span class="keywordflow">if</span> (graph.has_vertex(root)) {</div>
<div class="line"><span class="lineno">  446</span>            std::vector&lt;V&gt; predecessors(graph.num_vertices());</div>
<div class="line"><span class="lineno">  447</span>            std::vector&lt;double&gt; distances(graph.num_vertices(), std::numeric_limits&lt;double&gt;::infinity());</div>
<div class="line"><span class="lineno">  448</span> </div>
<div class="line"><span class="lineno">  449</span>            bg_detail::dijkstra_1_to_distance&lt;B_G, V, T_E&gt;(</div>
<div class="line"><span class="lineno">  450</span>                    graph.graph, graph.get_V(root), predecessors, distances, distance);</div>
<div class="line"><span class="lineno">  451</span> </div>
<div class="line"><span class="lineno">  452</span>            <span class="keyword">auto</span> path = Path(graph, root, distance, predecessors, distances);</div>
<div class="line"><span class="lineno">  453</span>            path.sort_by_node_agg_cost();</div>
<div class="line"><span class="lineno">  454</span>            depths.push_back(<a class="code hl_function" href="namespacedetail.html#a6ec521783c7bb3980dd2757573a702cb">detail::get_depth</a>(graph, graph.get_V(root), distances, predecessors, distance, details));</div>
<div class="line"><span class="lineno">  455</span>            <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  456</span><span class="comment">             * When details are not wanted update costs</span></div>
<div class="line"><span class="lineno">  457</span><span class="comment">             */</span></div>
<div class="line"><span class="lineno">  458</span>            <span class="keywordflow">if</span> (!details) {</div>
<div class="line"><span class="lineno">  459</span>                <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;pathstop : path) {</div>
<div class="line"><span class="lineno">  460</span>                    <span class="keyword">auto</span> node = graph.get_V(pathstop.node);</div>
<div class="line"><span class="lineno">  461</span> </div>
<div class="line"><span class="lineno">  462</span>                    <span class="comment">/* skip points */</span></div>
<div class="line"><span class="lineno">  463</span>                    <span class="keywordflow">if</span> (graph[node].<span class="keywordtype">id</span> &lt; 0) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  464</span> </div>
<div class="line"><span class="lineno">  465</span>                    pathstop.cost = distances[node] - distances[predecessors[node]];</div>
<div class="line"><span class="lineno">  466</span>                }</div>
<div class="line"><span class="lineno">  467</span>            }</div>
<div class="line"><span class="lineno">  468</span>            paths.push_back(path);</div>
<div class="line"><span class="lineno">  469</span> </div>
<div class="line"><span class="lineno">  470</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  471</span>            Path p(root, root);</div>
<div class="line"><span class="lineno">  472</span>            p.push_back({root, -1, 0, 0, root});</div>
<div class="line"><span class="lineno">  473</span>            paths.push_back(p);</div>
<div class="line"><span class="lineno">  474</span> </div>
<div class="line"><span class="lineno">  475</span>            std::map&lt;int64_t, int64_t&gt; m;</div>
<div class="line"><span class="lineno">  476</span>            m[root] = 0;</div>
<div class="line"><span class="lineno">  477</span>            depths.push_back(m);</div>
<div class="line"><span class="lineno">  478</span>        }</div>
<div class="line"><span class="lineno">  479</span>    }</div>
<div class="line"><span class="lineno">  480</span>    <span class="keywordflow">return</span> paths;</div>
<div class="line"><span class="lineno">  481</span>}</div>
<div class="ttc" id="aclasspgrouting_1_1Path_html"><div class="ttname"><a href="classpgrouting_1_1Path.html">pgrouting::Path</a></div><div class="ttdef"><b>Definition</b> <a href="path_8hpp_source.html#l00054">path.hpp:54</a></div></div>
<div class="ttc" id="anamespacedetail_html_a6ec521783c7bb3980dd2757573a702cb"><div class="ttname"><a href="namespacedetail.html#a6ec521783c7bb3980dd2757573a702cb">detail::get_depth</a></div><div class="ttdeci">std::map&lt; int64_t, int64_t &gt; get_depth(const G &amp;graph, V root, const std::vector&lt; double &gt; &amp;distances, std::vector&lt; V &gt; &amp;predecessors, double distance, bool details)</div><div class="ttdoc">gets results in form of a container of paths with depth</div><div class="ttdef"><b>Definition</b> <a href="drivingDist_8hpp_source.html#l00220">drivingDist.hpp:220</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="drivingDist_8hpp_source.html#l00220">get_depth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="drivingDist_8hpp_source.html#l00491">pgrouting::algorithm::drivingDistance()</a>.</p>

</div>
</div>
<a id="a94bd1adc415a84ca2fe7634f109dad46" name="a94bd1adc415a84ca2fe7634f109dad46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bd1adc415a84ca2fe7634f109dad46">&#9670;&#160;</a></span>drivingDistance_with_equicost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="classpgrouting_1_1Path.html">pgrouting::Path</a> &gt; detail::drivingDistance_with_equicost </td>
          <td>(</td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; int64_t, int64_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>depths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>details</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="drivingDist_8hpp_source.html#l00367">367</a> of file <a class="el" href="drivingDist_8hpp_source.html">drivingDist.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  371</span>                                       {</div>
<div class="line"><span class="lineno">  372</span>    <span class="keyword">using </span>V = <span class="keyword">typename</span> G::V;</div>
<div class="line"><span class="lineno">  373</span>    <span class="keyword">using </span>E = <span class="keyword">typename</span> G::E;</div>
<div class="line"><span class="lineno">  374</span>    <span class="keyword">using </span>T_E = <span class="keyword">typename</span> G::G_T_E;</div>
<div class="line"><span class="lineno">  375</span>    <span class="keyword">using </span>B_G = <span class="keyword">typename</span> G::B_G;</div>
<div class="line"><span class="lineno">  376</span> </div>
<div class="line"><span class="lineno">  377</span>    depths.resize(roots.size());</div>
<div class="line"><span class="lineno">  378</span>    std::vector&lt;V&gt; predecessors(graph.num_vertices());</div>
<div class="line"><span class="lineno">  379</span>    std::vector&lt;double&gt; distances(graph.num_vertices(), std::numeric_limits&lt;double&gt;::infinity());</div>
<div class="line"><span class="lineno">  380</span> </div>
<div class="line"><span class="lineno">  381</span>    std::deque&lt;std::vector&lt;V&gt;&gt; pred(roots.size());</div>
<div class="line"><span class="lineno">  382</span>    std::deque&lt;std::vector&lt;V&gt;&gt; noDetailsPredecessors(roots.size());</div>
<div class="line"><span class="lineno">  383</span> </div>
<div class="line"><span class="lineno">  384</span>    <span class="keywordtype">size_t</span> i = 0;</div>
<div class="line"><span class="lineno">  385</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;root : roots) {</div>
<div class="line"><span class="lineno">  386</span>        <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  387</span><span class="comment">         * The vertex does not exist Nothing to do</span></div>
<div class="line"><span class="lineno">  388</span><span class="comment">         */</span></div>
<div class="line"><span class="lineno">  389</span>        <span class="keywordflow">if</span> (!(graph.has_vertex(root))) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  390</span> </div>
<div class="line"><span class="lineno">  391</span>        std::iota(predecessors.begin(), predecessors.end(), 0);</div>
<div class="line"><span class="lineno">  392</span>        bg_detail::dijkstra_1_to_distance_no_init&lt;B_G, V, E, T_E&gt;(graph.graph, graph.get_V(root), predecessors,</div>
<div class="line"><span class="lineno">  393</span>                distances, distance);</div>
<div class="line"><span class="lineno">  394</span> </div>
<div class="line"><span class="lineno">  395</span>        pred[i] = predecessors;</div>
<div class="line"><span class="lineno">  396</span>        depths[i] = <a class="code hl_function" href="namespacedetail.html#a6ec521783c7bb3980dd2757573a702cb">detail::get_depth</a>(graph, graph.get_V(root), distances, predecessors, distance, details);</div>
<div class="line"><span class="lineno">  397</span>        <span class="keywordflow">if</span> (!details) {</div>
<div class="line"><span class="lineno">  398</span>            noDetailsPredecessors[i] = predecessors;</div>
<div class="line"><span class="lineno">  399</span>        }</div>
<div class="line"><span class="lineno">  400</span>        ++i;</div>
<div class="line"><span class="lineno">  401</span>    }</div>
<div class="line"><span class="lineno">  402</span> </div>
<div class="line"><span class="lineno">  403</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  404</span><span class="comment">     * predecessors of root vertices are themselves</span></div>
<div class="line"><span class="lineno">  405</span><span class="comment">     */</span></div>
<div class="line"><span class="lineno">  406</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;root : roots) {</div>
<div class="line"><span class="lineno">  407</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p : pred) {</div>
<div class="line"><span class="lineno">  408</span>            <span class="keywordflow">if</span> (!p.empty() &amp;&amp; graph.has_vertex(root)) {</div>
<div class="line"><span class="lineno">  409</span>                p[graph.get_V(root)] = graph.get_V(root);</div>
<div class="line"><span class="lineno">  410</span>            }</div>
<div class="line"><span class="lineno">  411</span>        }</div>
<div class="line"><span class="lineno">  412</span>    }</div>
<div class="line"><span class="lineno">  413</span> </div>
<div class="line"><span class="lineno">  414</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacedetail.html#a1aca0f51acb1c2a4a9a7d4f6614d868c">get_drivingDistance_with_equicost_paths</a>(</div>
<div class="line"><span class="lineno">  415</span>            graph,</div>
<div class="line"><span class="lineno">  416</span>            roots,</div>
<div class="line"><span class="lineno">  417</span>            pred,</div>
<div class="line"><span class="lineno">  418</span>            distances,</div>
<div class="line"><span class="lineno">  419</span>            noDetailsPredecessors,</div>
<div class="line"><span class="lineno">  420</span>            distance, details);</div>
<div class="line"><span class="lineno">  421</span>}</div>
<div class="ttc" id="anamespacedetail_html_a1aca0f51acb1c2a4a9a7d4f6614d868c"><div class="ttname"><a href="namespacedetail.html#a1aca0f51acb1c2a4a9a7d4f6614d868c">detail::get_drivingDistance_with_equicost_paths</a></div><div class="ttdeci">std::deque&lt; pgrouting::Path &gt; get_drivingDistance_with_equicost_paths(const G &amp;graph, const std::set&lt; int64_t &gt; &amp;roots, std::deque&lt; std::vector&lt; V &gt; &gt; &amp;predecessors, std::vector&lt; double &gt; &amp;distances, std::deque&lt; std::vector&lt; V &gt; &gt; &amp;noDetailsPredecessors, double distance, bool details)</div><div class="ttdoc">gets results for many vertices and equi costs</div><div class="ttdef"><b>Definition</b> <a href="drivingDist_8hpp_source.html#l00291">drivingDist.hpp:291</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="drivingDist_8hpp_source.html#l00220">get_depth()</a>, and <a class="el" href="drivingDist_8hpp_source.html#l00291">get_drivingDistance_with_equicost_paths()</a>.</p>

<p class="reference">Referenced by <a class="el" href="drivingDist_8hpp_source.html#l00491">pgrouting::algorithm::drivingDistance()</a>.</p>

</div>
</div>
<a id="a6ec521783c7bb3980dd2757573a702cb" name="a6ec521783c7bb3980dd2757573a702cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec521783c7bb3980dd2757573a702cb">&#9670;&#160;</a></span>get_depth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int64_t, int64_t &gt; detail::get_depth </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>details</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets results in form of a container of paths with depth </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph that is being worked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>The starting node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distances</td><td>An array of vertices <b>id</b> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">predecessors</td><td>an array of predecessors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>the max distance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">details</td><td>the max distance </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="drivingDist_8hpp_source.html#l00220">220</a> of file <a class="el" href="drivingDist_8hpp_source.html">drivingDist.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  226</span>                      {</div>
<div class="line"><span class="lineno">  227</span>    std::map&lt;int64_t, int64_t&gt; depth;</div>
<div class="line"><span class="lineno">  228</span>    <span class="keywordflow">if</span> (predecessors.empty()) <span class="keywordflow">return</span> depth;</div>
<div class="line"><span class="lineno">  229</span>    <span class="keywordflow">if</span> (predecessors.size() != distances.size()) <span class="keywordflow">return</span> depth;</div>
<div class="line"><span class="lineno">  230</span>    depth[graph[root].id] = 0;</div>
<div class="line"><span class="lineno">  231</span> </div>
<div class="line"><span class="lineno">  232</span>    std::set&lt;V&gt; vertices;</div>
<div class="line"><span class="lineno">  233</span>    vertices.insert(root);</div>
<div class="line"><span class="lineno">  234</span> </div>
<div class="line"><span class="lineno">  235</span>    <span class="keywordflow">if</span> (!details) {</div>
<div class="line"><span class="lineno">  236</span>        <a class="code hl_function" href="namespacedetail.html#a88cc91be861b8ccf8a48a5458559fa41">remove_details</a>(graph, distances, predecessors);</div>
<div class="line"><span class="lineno">  237</span>    }</div>
<div class="line"><span class="lineno">  238</span> </div>
<div class="line"><span class="lineno">  239</span>    <span class="comment">/* cycle depth max depth can be number of nodes*/</span></div>
<div class="line"><span class="lineno">  240</span>    <span class="keywordflow">for</span> (int64_t d = 1; <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(d) &lt; graph.num_vertices() ; ++d) {</div>
<div class="line"><span class="lineno">  241</span>        <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  242</span><span class="comment">         * there is no more to search for</span></div>
<div class="line"><span class="lineno">  243</span><span class="comment">         */</span></div>
<div class="line"><span class="lineno">  244</span>        <span class="keywordflow">if</span> (vertices.empty()) <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  245</span> </div>
<div class="line"><span class="lineno">  246</span>        <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  247</span><span class="comment">         * One next cycle these vertices have the next depth</span></div>
<div class="line"><span class="lineno">  248</span><span class="comment">         */</span></div>
<div class="line"><span class="lineno">  249</span>        std::set&lt;V&gt; vertices_next;</div>
<div class="line"><span class="lineno">  250</span>        std::set&lt;V&gt; point_vertices;</div>
<div class="line"><span class="lineno">  251</span> </div>
<div class="line"><span class="lineno">  252</span> </div>
<div class="line"><span class="lineno">  253</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : vertices) {</div>
<div class="line"><span class="lineno">  254</span>            <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  255</span><span class="comment">             * Cycle predecessors looking for vertices on the depth d</span></div>
<div class="line"><span class="lineno">  256</span><span class="comment">             * v -&gt; p</span></div>
<div class="line"><span class="lineno">  257</span><span class="comment">             */</span></div>
<div class="line"><span class="lineno">  258</span>            <span class="keywordflow">for</span> (V p = 0; p &lt; graph.num_vertices() ; ++p) {</div>
<div class="line"><span class="lineno">  259</span>                <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  260</span><span class="comment">                 * Sikiping unassigned predecessors</span></div>
<div class="line"><span class="lineno">  261</span><span class="comment">                 * Sikiping distances greater than the one asked for</span></div>
<div class="line"><span class="lineno">  262</span><span class="comment">                 */</span></div>
<div class="line"><span class="lineno">  263</span>                <span class="keywordflow">if</span> (predecessors[p] == p) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  264</span>                <span class="keywordflow">if</span> (!(distances[p] &lt;= distance)) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  265</span>                <span class="keywordflow">if</span> (!(predecessors[p] == v)) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  266</span> </div>
<div class="line"><span class="lineno">  267</span> </div>
<div class="line"><span class="lineno">  268</span>                <span class="comment">/* found */</span></div>
<div class="line"><span class="lineno">  269</span>                depth[graph[p].id] = d;</div>
<div class="line"><span class="lineno">  270</span>                vertices_next.insert(p);</div>
<div class="line"><span class="lineno">  271</span>            }</div>
<div class="line"><span class="lineno">  272</span>        }</div>
<div class="line"><span class="lineno">  273</span>        vertices = vertices_next;</div>
<div class="line"><span class="lineno">  274</span>    }</div>
<div class="line"><span class="lineno">  275</span>    <span class="keywordflow">return</span> depth;</div>
<div class="line"><span class="lineno">  276</span>}</div>
<div class="ttc" id="anamespacedetail_html_a88cc91be861b8ccf8a48a5458559fa41"><div class="ttname"><a href="namespacedetail.html#a88cc91be861b8ccf8a48a5458559fa41">detail::remove_details</a></div><div class="ttdeci">void remove_details(const G &amp;graph, const std::vector&lt; double &gt; &amp;distances, std::vector&lt; V &gt; &amp;predecessors)</div><div class="ttdef"><b>Definition</b> <a href="drivingDist_8hpp_source.html#l00164">drivingDist.hpp:164</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="drivingDist_8hpp_source.html#l00164">remove_details()</a>.</p>

<p class="reference">Referenced by <a class="el" href="drivingDist_8hpp_source.html#l00432">drivingDistance_no_equicost()</a>, and <a class="el" href="drivingDist_8hpp_source.html#l00367">drivingDistance_with_equicost()</a>.</p>

</div>
</div>
<a id="a1aca0f51acb1c2a4a9a7d4f6614d868c" name="a1aca0f51acb1c2a4a9a7d4f6614d868c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aca0f51acb1c2a4a9a7d4f6614d868c">&#9670;&#160;</a></span>get_drivingDistance_with_equicost_paths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="classpgrouting_1_1Path.html">pgrouting::Path</a> &gt; detail::get_drivingDistance_with_equicost_paths </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; std::vector&lt; V &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; std::vector&lt; V &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>noDetailsPredecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>details</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets results for many vertices and equi costs </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph that is being worked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roots</td><td>a set of roots </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">predecessors</td><td>an array of predecessors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noDetailsPredecessors</td><td>veritces that do not have a predecessor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distances</td><td>a map of distances </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>maximum distance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">details</td><td>flag to indicate to include points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>one predecessor per root </dd></dl>

<p class="definition">Definition at line <a class="el" href="drivingDist_8hpp_source.html#l00291">291</a> of file <a class="el" href="drivingDist_8hpp_source.html">drivingDist.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  297</span>                                       {</div>
<div class="line"><span class="lineno">  298</span>    <span class="keyword">using </span>Path = <a class="code hl_class" href="classpgrouting_1_1Path.html">pgrouting::Path</a>;</div>
<div class="line"><span class="lineno">  299</span> </div>
<div class="line"><span class="lineno">  300</span>    <a class="code hl_define" href="assert_8hpp.html#a09250239ca707f56bc1bbfdd04a635b1">pgassert</a>(roots.size() == predecessors.size());</div>
<div class="line"><span class="lineno">  301</span> </div>
<div class="line"><span class="lineno">  302</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  303</span><span class="comment">     * Creating all the result &quot;paths&quot;</span></div>
<div class="line"><span class="lineno">  304</span><span class="comment">     */</span></div>
<div class="line"><span class="lineno">  305</span>    std::deque&lt;Path&gt; paths;</div>
<div class="line"><span class="lineno">  306</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> r : roots) {</div>
<div class="line"><span class="lineno">  307</span>        paths.push_back(Path(r, r));</div>
<div class="line"><span class="lineno">  308</span>        paths.back().push_back({r, -1, 0, 0, r});</div>
<div class="line"><span class="lineno">  309</span>    }</div>
<div class="line"><span class="lineno">  310</span> </div>
<div class="line"><span class="lineno">  311</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  312</span><span class="comment">     *  Ciclying the vertices:</span></div>
<div class="line"><span class="lineno">  313</span><span class="comment">     *  To which vertex do they belong to?</span></div>
<div class="line"><span class="lineno">  314</span><span class="comment">     */</span></div>
<div class="line"><span class="lineno">  315</span>    <span class="keywordflow">for</span> (V v = 0; v &lt; distances.size(); ++v) {</div>
<div class="line"><span class="lineno">  316</span>        <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  317</span><span class="comment">         * Sikiping distances greater than the one asked for</span></div>
<div class="line"><span class="lineno">  318</span><span class="comment">         */</span></div>
<div class="line"><span class="lineno">  319</span>        <span class="keywordflow">if</span> (!(distances[v] &lt;= distance)) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  320</span> </div>
<div class="line"><span class="lineno">  321</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = roots.size(); i &gt; 0; --i) {</div>
<div class="line"><span class="lineno">  322</span>            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;predecessor = predecessors[i - 1];</div>
<div class="line"><span class="lineno">  323</span>            <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  324</span><span class="comment">             * The vertex does not exist on the graph</span></div>
<div class="line"><span class="lineno">  325</span><span class="comment">             * The predecessor = current then its unreachable to this vertex</span></div>
<div class="line"><span class="lineno">  326</span><span class="comment">             */</span></div>
<div class="line"><span class="lineno">  327</span>            <span class="keywordflow">if</span> (predecessor.empty()) <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  328</span>            <span class="keywordflow">if</span> (predecessor[v] == v) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  329</span> </div>
<div class="line"><span class="lineno">  330</span>            <span class="keyword">auto</span> u =  details? predecessor[v] : noDetailsPredecessors[i - 1][v];</div>
<div class="line"><span class="lineno">  331</span>            <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  332</span><span class="comment">             * precalculating cost to find the edge</span></div>
<div class="line"><span class="lineno">  333</span><span class="comment">             */</span></div>
<div class="line"><span class="lineno">  334</span>            <span class="keyword">auto</span> cost = distances[v] - distances[predecessor[v]];</div>
<div class="line"><span class="lineno">  335</span>            <span class="keyword">auto</span> edge_id = graph.get_edge_id(predecessor[v], v, cost);</div>
<div class="line"><span class="lineno">  336</span>            <a class="code hl_define" href="assert_8hpp.html#a09250239ca707f56bc1bbfdd04a635b1">pgassert</a>(edge_id != -1);</div>
<div class="line"><span class="lineno">  337</span>            <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  338</span><span class="comment">             * real cost is with real predecessor</span></div>
<div class="line"><span class="lineno">  339</span><span class="comment">             */</span></div>
<div class="line"><span class="lineno">  340</span>            cost = details? cost : distances[v] - distances[u];</div>
<div class="line"><span class="lineno">  341</span>                 paths[i - 1].push_back({graph[v].id, edge_id, cost, distances[v], graph[u].id});</div>
<div class="line"><span class="lineno">  342</span>                 <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  343</span>             }</div>
<div class="line"><span class="lineno">  344</span>         }</div>
<div class="line"><span class="lineno">  345</span> </div>
<div class="line"><span class="lineno">  346</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;path : paths) {</div>
<div class="line"><span class="lineno">  347</span>        path.sort_by_node_agg_cost();</div>
<div class="line"><span class="lineno">  348</span>    }</div>
<div class="line"><span class="lineno">  349</span>    <span class="keywordflow">return</span> paths;</div>
<div class="line"><span class="lineno">  350</span>}</div>
<div class="ttc" id="aassert_8hpp_html_a09250239ca707f56bc1bbfdd04a635b1"><div class="ttname"><a href="assert_8hpp.html#a09250239ca707f56bc1bbfdd04a635b1">pgassert</a></div><div class="ttdeci">#define pgassert(expr)</div><div class="ttdoc">Uses the standard assert syntax.</div><div class="ttdef"><b>Definition</b> <a href="assert_8hpp_source.html#l00096">assert.hpp:96</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="assert_8hpp_source.html#l00096">pgassert</a>.</p>

<p class="reference">Referenced by <a class="el" href="drivingDist_8hpp_source.html#l00367">drivingDistance_with_equicost()</a>.</p>

</div>
</div>
<a id="ae07bdec8739b3e246b1d0fecabb42e7f" name="ae07bdec8739b3e246b1d0fecabb42e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07bdec8739b3e246b1d0fecabb42e7f">&#9670;&#160;</a></span>get_paths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="classpgrouting_1_1Path.html">pgrouting::Path</a> &gt; detail::get_paths </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>only_cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="astar_8hpp_source.html#l00145">145</a> of file <a class="el" href="astar_8hpp_source.html">astar.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  151</span>                        {</div>
<div class="line"><span class="lineno">  152</span>    <span class="keyword">using </span>Path = <a class="code hl_class" href="classpgrouting_1_1Path.html">pgrouting::Path</a>;</div>
<div class="line"><span class="lineno">  153</span>    std::deque&lt;Path&gt; paths;</div>
<div class="line"><span class="lineno">  154</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;target : targets) {</div>
<div class="line"><span class="lineno">  155</span>        <span class="keyword">auto</span> p = Path(graph,</div>
<div class="line"><span class="lineno">  156</span>                source, target,</div>
<div class="line"><span class="lineno">  157</span>                predecessors, distances,</div>
<div class="line"><span class="lineno">  158</span>                <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">  159</span>        paths.push_back(Path(graph, p, only_cost));</div>
<div class="line"><span class="lineno">  160</span>    }</div>
<div class="line"><span class="lineno">  161</span>    <span class="keywordflow">return</span> paths;</div>
<div class="line"><span class="lineno">  162</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="astar_8hpp_source.html#l00170">pgrouting::algorithms::astar()</a>, and <a class="el" href="dijkstra_8hpp_source.html#l00120">dijkstra()</a>.</p>

</div>
</div>
<a id="aacbdcdbca8ac1cd86a8eea2997d1089e" name="aacbdcdbca8ac1cd86a8eea2997d1089e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbdcdbca8ac1cd86a8eea2997d1089e">&#9670;&#160;</a></span>get_paths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="classpgrouting_1_1Path.html">pgrouting::Path</a> &gt; detail::get_paths </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>only_cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dijkstra_8hpp_source.html#l00062">62</a> of file <a class="el" href="dijkstra_8hpp_source.html">dijkstra.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   68</span>                        {</div>
<div class="line"><span class="lineno">   69</span>    std::deque&lt;pgrouting::Path&gt; paths;</div>
<div class="line"><span class="lineno">   70</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> target : targets) {</div>
<div class="line"><span class="lineno">   71</span>        paths.push_back(<a class="code hl_class" href="classpgrouting_1_1Path.html">pgrouting::Path</a>(</div>
<div class="line"><span class="lineno">   72</span>                    graph,</div>
<div class="line"><span class="lineno">   73</span>                    source, target,</div>
<div class="line"><span class="lineno">   74</span>                    predecessors, distances,</div>
<div class="line"><span class="lineno">   75</span>                    only_cost, <span class="keyword">true</span>));</div>
<div class="line"><span class="lineno">   76</span>    }</div>
<div class="line"><span class="lineno">   77</span>    <span class="keywordflow">return</span> paths;</div>
<div class="line"><span class="lineno">   78</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a88cc91be861b8ccf8a48a5458559fa41" name="a88cc91be861b8ccf8a48a5458559fa41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cc91be861b8ccf8a48a5458559fa41">&#9670;&#160;</a></span>remove_details()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void detail::remove_details </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="drivingDist_8hpp_source.html#l00164">164</a> of file <a class="el" href="drivingDist_8hpp_source.html">drivingDist.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  166</span>                                    {</div>
<div class="line"><span class="lineno">  167</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  168</span><span class="comment">     * find all the points that are predecessors</span></div>
<div class="line"><span class="lineno">  169</span><span class="comment">     */</span></div>
<div class="line"><span class="lineno">  170</span>    std::set&lt;V&gt; node_with_predecessor_point;</div>
<div class="line"><span class="lineno">  171</span>    <a class="code hl_define" href="interruption_8hpp.html#a60107ad1e320e3c1b6cd6fd03ccc23ec">CHECK_FOR_INTERRUPTS</a>();</div>
<div class="line"><span class="lineno">  172</span>    <span class="keywordflow">for</span> (V v = 0; v &lt; predecessors.size() ; ++v) {</div>
<div class="line"><span class="lineno">  173</span>        <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  174</span><span class="comment">         * skipping unreachable nodes and or initial node</span></div>
<div class="line"><span class="lineno">  175</span><span class="comment">         * skipping predecessors that are vertices</span></div>
<div class="line"><span class="lineno">  176</span><span class="comment">         */</span></div>
<div class="line"><span class="lineno">  177</span>        <span class="keywordflow">if</span> (predecessors[v] == v) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  178</span>        <span class="keywordflow">if</span> (graph[predecessors[v]].<span class="keywordtype">id</span> &gt;= 0) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  179</span>        node_with_predecessor_point.insert(v);</div>
<div class="line"><span class="lineno">  180</span>    }</div>
<div class="line"><span class="lineno">  181</span> </div>
<div class="line"><span class="lineno">  182</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  183</span><span class="comment">     * Compact all nodes that have predecessor point</span></div>
<div class="line"><span class="lineno">  184</span><span class="comment">     */</span></div>
<div class="line"><span class="lineno">  185</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> node : node_with_predecessor_point) {</div>
<div class="line"><span class="lineno">  186</span>        <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  187</span><span class="comment">         * Cycle predecessors</span></div>
<div class="line"><span class="lineno">  188</span><span class="comment">         * u -&gt; v  cost to arrive to v is distances[v]</span></div>
<div class="line"><span class="lineno">  189</span><span class="comment">         */</span></div>
<div class="line"><span class="lineno">  190</span>        <span class="keyword">auto</span> v = node;</div>
<div class="line"><span class="lineno">  191</span>        <span class="keyword">auto</span> u = predecessors[v];</div>
<div class="line"><span class="lineno">  192</span>        <a class="code hl_define" href="assert_8hpp.html#a09250239ca707f56bc1bbfdd04a635b1">pgassert</a>(graph[u].<span class="keywordtype">id</span> &lt; 0);</div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>        <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  195</span><span class="comment">         * while u is a point and it&#39;s predecessor is not itself</span></div>
<div class="line"><span class="lineno">  196</span><span class="comment">         */</span></div>
<div class="line"><span class="lineno">  197</span>        <a class="code hl_define" href="interruption_8hpp.html#a60107ad1e320e3c1b6cd6fd03ccc23ec">CHECK_FOR_INTERRUPTS</a>();</div>
<div class="line"><span class="lineno">  198</span>        <span class="keywordflow">while</span> (graph[u].<span class="keywordtype">id</span> &lt; 0 &amp;&amp; predecessors[u] != u) {</div>
<div class="line"><span class="lineno">  199</span>            <a class="code hl_define" href="assert_8hpp.html#a09250239ca707f56bc1bbfdd04a635b1">pgassert</a>(graph[u].<span class="keywordtype">id</span> &lt; 0);</div>
<div class="line"><span class="lineno">  200</span>            <a class="code hl_define" href="assert_8hpp.html#a09250239ca707f56bc1bbfdd04a635b1">pgassert</a>(distances[v] !=  std::numeric_limits&lt;double&gt;::infinity());</div>
<div class="line"><span class="lineno">  201</span>            v = u;</div>
<div class="line"><span class="lineno">  202</span>            u = predecessors[v];</div>
<div class="line"><span class="lineno">  203</span>        }</div>
<div class="line"><span class="lineno">  204</span> </div>
<div class="line"><span class="lineno">  205</span>        <span class="comment">/* the vertex (or initial point) that is a predecessor of p */</span></div>
<div class="line"><span class="lineno">  206</span>        predecessors[node] = u;</div>
<div class="line"><span class="lineno">  207</span>    }</div>
<div class="line"><span class="lineno">  208</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="interruption_8hpp_source.html#l00083">CHECK_FOR_INTERRUPTS</a>, and <a class="el" href="assert_8hpp_source.html#l00096">pgassert</a>.</p>

<p class="reference">Referenced by <a class="el" href="drivingDist_8hpp_source.html#l00220">get_depth()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedetail.html">detail</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
