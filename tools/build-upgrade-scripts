#!/usr/bin/perl -w
use strict;
use Data::Dumper;
use Cwd qw(cwd chdir);

my $DEBUG = 0;

# this is a list of version tags for which we want to 
# generate extension upgrades scripts.
# This should only list released version tags

my %versions = (
    'pgrouting-2.0.0' => "-DWITH_DD=ON"
);

# Algorithm
# 1. checkout the target version tag
# 2. run cmake to generate the lib/pgrouting--<current-version>.sql file
# 3. read the sql and make a list og all types and function signatures
# 4. checkout the version tag
# 5. run cmake to generate the lib/pgrouting--2.0.0.sql file
# 6. read the sql and make a list of all types and function signatures
# 7. compare the lists and generate the upgrade script for these versions
# 8. loop through the rest of the old versions and generate upgrade scripts

sub Usage {
    die "Usage: build-upgrade-scripts <current_branch> [<cmake-options>]\n";
}

die "ERROR: Must be run in the pgRouting top level git directory!\n"
    unless -f "VERSION";

#my $junk = parse_signatures( "build/lib/pgrouting--2.1.0.sql" );
#exit;

my %update_commands = ();

my $current_version = shift @ARGV || Usage();
my $current_options = shift @ARGV || "";

my $current_hash = create_signatures( $current_version, $current_options );
my ($types, $funcs) = parse_signatures( $current_hash->{FILE} );
$current_hash->{funcs} = $funcs;
$current_hash->{types} = $types;

for my $old_version ( sort keys %versions ) {
    my $options = $versions{$old_version};
    my $old_hash = create_signatures( $old_version, $options );
    my ($otypes, $ofuncs) = parse_signatures( $old_hash->{FILE} );
    $old_hash->{types} = $otypes;
    $old_hash->{funcs} = $ofuncs;
    generate_upgrade_script( $current_hash, $old_hash);
}

# need to switch back to origin branch to write the files
create_signatures( $current_version, $current_options );
write_scripts();

exit 0;


sub create_signatures {
    my ($tag, $options) = @_;

    # get our current working dir
    my $dir = cwd();

    # first generate the sql file
    mysystem("git checkout $tag > /dev/null 2>&1");
    mysystem("rm -rf build");
    mysystem("mkdir -p build");
    chdir("build");
    mysystem("cmake $options .. >/dev/null 2>&1");
    chdir( $dir );

    my %result = ();

    # $VERSION will be like 'pgrouting-2.1.0-alpha1-0-g0a769f8'
    $result{PGR_VERSION_STRING} = `git describe --tags --long`;
    $result{PGR_VERSION_STRING} =~ m/(.*)-(\d+)-(\w+)$/;
    $result{PGR_TAG} = $1;
    $result{PGR_COMMITS} = $2;
    $result{PGR_HASH} = $3;

    $result{PGR_TAG} =~ m/^pgrouting-(\d+\.\d+\.\d+)-?(\w+)?$/;
    $result{VERSION} = $1;
    $result{RELEASE} = $2 || '';

    $result{BRANCH} = `git branch | grep '*' | awk '{print \$2}'`;
    $result{FILE} = "build/lib/pgrouting--$result{VERSION}.sql";

    print Data::Dumper->Dump([\%result],['result']) if $DEBUG;

    return \%result;
}

sub parse_signatures {
    my $file = shift;

    # now read and parse it
    my %sigs = ();
    open(IN, $file) || die "ERROR: '$file' does not exist!\n";
    my @data = <IN>;
    close(IN);
    my $data = join('', @data);
    # delete C style comments
    $data =~ s{
        /\*
        .*?
        \*/
    } []gsx;
    # delete sql comments
    $data =~ s/--[^\n]*\n//gs;

    # TODO extract TYPEs
    my @types = $data =~ /create\s+type\s+(\w+\s+as\s*\([^\)]+\))/igs;
    @types = sort @types;
    for (my $i=0; $i<@types; $i++) {
        $types[$i] =~ s/\bas\s*\(/\(/is;
        $types[$i] =~ s/\s+/ /gs;
        $types[$i] =~ s/\s*([,\(\)])\s*/$1/gs;
        $types[$i] =~ s/\b(\w+)\s([^,\)]+)([,\)])/$2$3/gs;
    }

    # extract functions
    my @funcs = $data =~ /create\s+or\s+replace\s+function\s+(\w+\s*\([^\)]+\))/igs;
    @funcs = sort @funcs;
    # clean up functions
    for (my $i=0; $i<@funcs; $i++) {
        $funcs[$i] =~ s/\s+/ /gs;
        $funcs[$i] =~ s/\sdefault\s[^,\)]+//ig;
        $funcs[$i] =~ s/(IN|OUT)\s(\w+)\s([^,\)]+)/$1 $3/ig;
        $funcs[$i] =~ s/\(\s+/(/g;
        $funcs[$i] =~ s/,\s+/,/g;
        $funcs[$i] = parse_function_args($funcs[$i]);
    }

    print Data::Dumper->Dump([\@types, \@funcs], ['types', 'funcs']) if $DEBUG;

    return (\@types, \@funcs);
}


sub parse_function_args {
    my $str = shift;
    $str = lc($str);
    my @parts = split /,/, $str;
    foreach my $p (@parts) {
        next if  $p =~ /\b(in|out)\s(\w+)/;
        $p =~ s/\b(\w+)\s(\w+)/$2/;
    }
    return join(',', @parts);
}


sub generate_upgrade_script {
    my ($new, $old) = @_;

    my $err = 0;

    my $n_ver = $new->{VERSION};
    my $o_ver = $old->{VERSION};

    # analyze types

    my $ntype = $new->{types};
    my $otype = $old->{types};

    # create a hash like <name> => <column_list> for new types
    my %ntype_h = ();
    for my $x (@{$ntype}) {
        $x =~ m/(\w+)(\([^\)]+\))$/;
        $ntype_h{lc($1)} = lc($2);
    }

    # check if old type exists with different column types
    for my $x (@{$otype}) {
        $x =~ m/(\w+)(\([^\)]+\))$/;
        my $name = lc($1);
        my $cols = lc($2);
        if ($ntype_h{$name}) {
            if ($ntype_h{$name} ne $cols) {
                warn "WARNING: old type '$name$cols' changed to '$name$ntype_h{$name}' !\n";
                $err = 1;
            }
            else {
                push @{$update_commands{"$o_ver=$n_ver"}{remove_type}}, $name;
            }
        }
    }


    # analyze function sigs

    my $nsig = $new->{funcs};
    my $osig = $old->{funcs};
    my %fmap = map { $_ => 1 } @{$nsig};

    for my $x (@{$osig}) {
        my $exists = $fmap{$x} || '0';
        print "$exists\t$x\n" if $DEBUG;
        if (! $exists) {
            print "ALTER EXTENSION pgrouting DROP FUNCTION $x;\n" if $DEBUG;
            print "DROP FUNCTION $x;\n" if $DEBUG;
            push @{$update_commands{"$o_ver=$n_ver"}{commands}}, "ALTER EXTENSION pgrouting DROP FUNCTION $x;\n";
            push @{$update_commands{"$o_ver=$n_ver"}{commands}}, "DROP FUNCTION $x;\n";
        }
    }

    die "ERROR: pgrouting TYPE changed! Cannot continue!\n" if $err;
}


sub write_scripts {
    for my $key (sort keys %update_commands) {

        my ($o_ver, $n_ver) = split(/=/, $key);
        open(OUT, ">build/lib/pgrouting--$o_ver--$n_ver.sql")
            || die "ERROR: failed to create 'build/lib/pgrouting-pgrouting--$o_ver--$n_ver.sql' : $!\n";
        print OUT <<EOF;
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-- pgRouting extension upgrade from $o_ver to $n_ver
-- generated by tools/build-upgrade-scripts
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-- remove functions no longer in the $n_ver extension
@{$update_commands{$key}{commands}}

-- now install the new extension
EOF

        open(IN, $current_hash->{FILE}) ||
            die "ERROR: Failed to find '" . $current_hash->{FILE} . "' : $!\n";
        my @file = <IN>;
        close(IN);

        remove_types( \@file, $update_commands{$key}{remove_type} );

        print OUT @file;
        close(OUT);
    }
}


sub remove_types {
    my ($data, $types) = @_;

    for my $type (@{$types}) {
        my $state = 1;
        for my $x (@{$data}) {
            if ($state == 1) {
                next unless $x =~ m/create\s+type\s+$type\b/i;
                $x = "-- $x";
                $state = 2
                    unless $x =~ m/create\s+type\s+$type\s+as\s*\([^\)]+\)/i;
            }
            elsif ($state == 2) {
                $x = "-- $x";
                last if $x =~ /\)\s*;/;
            }
        }
    }
}


sub mysystem {
    system(@_);
}
